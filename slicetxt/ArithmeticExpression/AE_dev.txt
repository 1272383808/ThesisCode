303808 80644/CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_snprintf_11.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 ) 96
void CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_snprintf_11_bad()
wchar_t * data ;
wchar_t dataBuffer [ 100 ] = L ""
data = dataBuffer;
if ( globalReturnsTrue ( ) )
int globalReturnsTrue()
return 1 ;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
305343 95459/CWE369_Divide_by_Zero__int_zero_divide_18.c printIntLine ( 100 / data ) 34
void CWE369_Divide_by_Zero__int_zero_divide_18_bad()
int data ;
data = - 1;
data = 0;
printIntLine ( 100 / data );
1
------------------------------
311664 149958/aviobuf.c s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_ptr - s -> checksum_ptr ) ) ) 277
void avio_wb64(AVIOContext *s,uint64_t val)
avio_wb32 ( s , ( ( uint32_t ) ( val >> 32 ) ) );
void avio_wb32(AVIOContext *s,unsigned int val)
avio_w8 ( s , ( ( uint8_t ) ( val >> 8 ) ) );
void avio_w8(AVIOContext *s,int b)
* ( s -> buf_ptr ++ ) = b;
if ( s -> buf_ptr >= s -> buf_end )
flush_buffer ( s );
static void flush_buffer(AVIOContext *s)
if ( s -> buf_ptr > s -> buffer )
if ( s -> update_checksum )
s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_ptr - s -> checksum_ptr ) ) );
s -> checksum_ptr = s -> buffer;
s -> buf_ptr = s -> buffer;
0
------------------------------
309142 112825/CWE761_Free_Pointer_Not_at_Start_of_Buffer__wchar_t_connect_socket_21.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 ) 315
static void goodB2G2()
wchar_t * data ;
data = ( wchar_t * ) malloc ( 100 * sizeof ( wchar_t ) );
data [ 0 ] = L '\0'
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
20908 CVE-2016-7421/qemu_2.3.0_CVE-2016-7421_vmw_pvscsi.c uint32_t free_msg_page = free_msg_ptr / PVSCSI_MAX_NUM_MSG_ENTRIES_PER_PAGE ; 265
static
pvscsi_hot_unplug(HotplugHandler *hotplug_dev, DeviceState *dev, Error **errp)
PVSCSIState * s = PVSCSI ( hotplug_dev ) ;
pvscsi_send_msg ( s , SCSI_DEVICE ( dev ) , PVSCSI_MSG_DEV_REMOVED );
static
pvscsi_send_msg(PVSCSIState *s, SCSIDevice *dev, uint32_t msg_type)
if ( s -> msg_ring_info_valid && pvscsi_ring_msg_has_room ( & s -> rings ) )
PVSCSIMsgDescDevStatusChanged msg = { 0 } ;
msg . type = msg_type;
msg . bus = dev -> channel;
msg . target = dev -> id;
msg . lun [ 1 ] = dev -> lun;
pvscsi_msg_ring_put ( s , ( PVSCSIRingMsgDesc * ) & msg );
static
pvscsi_msg_ring_put(PVSCSIState *s, struct PVSCSIRingMsgDesc *msg_desc)
hwaddr msg_descr_pa ;
msg_descr_pa = pvscsi_ring_pop_msg_descr ( & s -> rings );
static
pvscsi_ring_pop_msg_descr(PVSCSIRingInfo *mgr)
uint32_t free_msg_ptr = mgr -> filled_msg_ptr ++ & mgr -> msg_len_mask ;
uint32_t free_msg_page = free_msg_ptr / PVSCSI_MAX_NUM_MSG_ENTRIES_PER_PAGE ;
return mgr -> msg_ring_pages_pa [ free_msg_page ] + inpage_idx * sizeof ( PVSCSIRingMsgDesc ) ;
0
------------------------------
306915 117386/CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_listen_socket_22b.c myString = ( wchar_t * ) malloc ( data * sizeof ( wchar_t ) ) 82
static void goodB2G1()
size_t data ;
data = 0;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
char inputBuffer [ CHAR_ARRAY_SIZE ] ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
inputBuffer [ recvResult ] = '\0';
data = strtoul ( inputBuffer , NULL , 0 );
while ( 0 )
CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_listen_socket_22_goodB2G1Sink ( data );
void CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_listen_socket_22_goodB2G1Sink(size_t data)
if ( CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_listen_socket_22_goodB2G1Global )
wchar_t * myString ;
if ( data > wcslen ( HELLO_STRING ) && data < 100 )
myString = ( wchar_t * ) malloc ( data * sizeof ( wchar_t ) );
wcscpy ( myString , HELLO_STRING );
printWLine ( myString );
void printWLine (const wchar_t * line)
if ( line != NULL )
wprintf ( L "%ls\n" , line )
free ( myString );
0
------------------------------
310393 151639/aviobuf.c uint8_t * dst = ! s -> max_packet_size && s -> buf_end - s -> buffer < ( s -> buffer_size ) ? s -> buf_end : s -> buffer ; 454
uint64_t ffio_read_varlen(AVIOContext *bc)
int tmp ;
tmp = avio_r8 ( bc );
while ( tmp & 128 )
int avio_r8(AVIOContext *s)
if ( s -> buf_ptr >= s -> buf_end )
fill_buffer ( s );
static void fill_buffer(AVIOContext *s)
uint8_t * dst = ! s -> max_packet_size && s -> buf_end - s -> buffer < ( s -> buffer_size ) ? s -> buf_end : s -> buffer ;
int len = ( ( s -> buffer_size ) - ( dst - s -> buffer ) ) ;
if ( s -> update_checksum && dst == s -> buffer )
len = ( ( s -> read_packet ) ( s -> opaque , dst , len ) );
if ( len <= 0 )
if ( len < 0 )
s -> error = len;
s -> pos += len;
s -> buf_ptr = dst;
s -> buf_end = dst + len;
s -> bytes_read += len;
0
------------------------------
310621 148891/packet-tcp.c hole_end = hole_start + ( base_mss * relative_hole_size ) 3154
static
dissect_tcpopt_snack(const ip_tcp_opt *optp, tvbuff_t
int offset, guint optlen, packet_info
proto_tree *opt_tree)
guint16 relative_hole_offset ;
guint16 relative_hole_size ;
guint32 ack ;
guint32 hole_start ;
guint32 hole_end ;
tcpd = get_tcp_conversation_data ( NULL , pinfo );
struct tcp_analysis
get_tcp_conversation_data(conversation_t *conv, packet_info *pinfo)
int direction ;
struct tcp_analysis * tcpd ;
if ( conv == NULL )
conv = find_or_create_conversation ( pinfo );
tcpd = conversation_get_proto_data ( conv , proto_tcp );
if ( ! tcpd )
tcpd = init_tcp_conversation_data ( pinfo );
struct tcp_analysis
init_tcp_conversation_data(packet_info *pinfo)
struct tcp_analysis * tcpd ;
tcpd = se_alloc0 ( sizeof ( struct tcp_analysis ) );
tcpd -> flow1 . win_scale = - 1;
tcpd -> flow1 . window = G_MAXUINT32;
tcpd -> flow1 . multisegment_pdus = se_tree_create_non_persistent ( EMEM_TREE_TYPE_RED_BLACK , "tcp_multisegment_pdus" );
tcpd -> flow2 . window = G_MAXUINT32;
tcpd -> flow2 . win_scale = - 1;
tcpd -> flow2 . multisegment_pdus = se_tree_create_non_persistent ( EMEM_TREE_TYPE_RED_BLACK , "tcp_multisegment_pdus" );
tcpd -> acked_table = se_tree_create_non_persistent ( EMEM_TREE_TYPE_RED_BLACK , "tcp_analyze_acked_table" );
tcpd -> ts_first . secs = pinfo -> fd -> abs_ts . secs;
tcpd -> ts_first . nsecs = pinfo -> fd -> abs_ts . nsecs;
tcpd -> ts_prev . secs = pinfo -> fd -> abs_ts . secs;
tcpd -> ts_prev . nsecs = pinfo -> fd -> abs_ts . nsecs;
tcpd -> flow1 . valid_bif = 1;
tcpd -> flow2 . valid_bif = 1;
tcpd -> stream = tcp_stream_index ++;
tcpd -> server_port = 0;
return tcpd ;
if ( ! tcpd )
return NULL ;
direction = CMP_ADDRESS ( & pinfo -> src , & pinfo -> dst );
if ( direction == 0 )
direction = ( pinfo -> srcport > pinfo -> destport ) ? 1 : - 1;
if ( direction >= 0 )
tcpd -> fwd = & ( tcpd -> flow2 );
tcpd -> rev = & ( tcpd -> flow1 );
tcpd -> ta = NULL;
return tcpd ;
relative_hole_offset = tvb_get_ntohs ( tvb , offset + 2 );
relative_hole_size = tvb_get_ntohs ( tvb , offset + 4 );
ack = tvb_get_ntohl ( tvb , 8 );
if ( tcp_relative_seq )
ack -= tcpd -> rev -> base_seq;
base_mss = tcpd -> fwd -> maxsizeacked;
if ( base_mss )
hole_start = ack + ( base_mss * relative_hole_offset );
hole_end = hole_start + ( base_mss * relative_hole_size );
hidden_item = proto_tree_add_uint ( opt_tree , hf_tcp_option_snack_re , tvb , offset , optlen , hole_end );
PROTO_ITEM_SET_HIDDEN ( hidden_item );
proto_tree_add_text ( opt_tree , tvb , offset , optlen , "\tMissing Sequence %u - %u %s" , hole_start , hole_end , modifier );
tcp_info_append_uint ( pinfo , "SNRE" , hole_end );
static
tcp_info_append_uint(packet_info *pinfo, const char *abbrev, guint32 val)
col_append_fstr ( pinfo -> cinfo , COL_INFO , " %s=%u" , abbrev , val );
expert_add_info_format ( pinfo , NULL , PI_SEQUENCE , PI_NOTE , "SNACK Sequence %u - %u %s" , hole_start , hole_end , modifier );
0
------------------------------
312652 150898/bufmgr.c newPartitionLock = ( ( LWLockId ) ( FirstBufMappingLock + newHash % 16 ) ) 593
Buffer ReadBuffer(Relation reln,BlockNumber blockNum)
return ReadBufferExtended ( reln , MAIN_FORKNUM , blockNum , RBM_NORMAL , ( ( void * ) 0 ) ) ;
Buffer ReadBufferExtended(Relation reln,ForkNumber forkNum,BlockNumber blockNum,ReadBufferMode mode,BufferAccessStrategy strategy)
Buffer buf ;
if ( reln -> pgstat_info != ( ( void * ) 0 ) )
reln -> pgstat_info -> t_counts . t_blocks_fetched ++;
while ( 0 )
buf = ReadBuffer_common ( reln -> rd_smgr , reln -> rd_rel -> relpersistence , forkNum , blockNum , mode , strategy , & hit );
static Buffer ReadBuffer_common(SMgrRelation smgr,char relpersistence,ForkNumber forkNum,BlockNumber blockNum,ReadBufferMode mode,BufferAccessStrategy strategy,bool *hit)
volatile BufferDesc * bufHdr ;
bool isExtend ;
bool isLocalBuf = ( smgr -> smgr_rnode . backend != - 1 ) ;
isExtend = ( blockNum == ( ( BlockNumber ) 0xFFFFFFFF ) );
if ( isExtend )
blockNum = smgrnblocks ( smgr , forkNum );
if ( isLocalBuf )
bufHdr = BufferAlloc ( smgr , relpersistence , forkNum , blockNum , strategy , & found );
static volatile BufferDesc *BufferAlloc(SMgrRelation smgr,char relpersistence,ForkNumber forkNum,BlockNumber blockNum,BufferAccessStrategy strategy,bool *foundPtr)
BufferTag newTag ;
uint32 newHash ;
LWLockId newPartitionLock ;
( newTag . rnode = smgr -> smgr_rnode . node , newTag . forkNum = forkNum ) , newTag . blockNum = blockNum;
newHash = BufTableHashCode ( & newTag );
newPartitionLock = ( ( LWLockId ) ( FirstBufMappingLock + newHash % 16 ) );
LWLockAcquire ( newPartitionLock , LW_SHARED );
LWLockRelease ( newPartitionLock );
LWLockRelease ( newPartitionLock );
if ( oldPartitionLock < newPartitionLock )
LWLockAcquire ( newPartitionLock , LW_EXCLUSIVE );
if ( oldPartitionLock > newPartitionLock )
LWLockAcquire ( newPartitionLock , LW_EXCLUSIVE );
LWLockAcquire ( newPartitionLock , LW_EXCLUSIVE );
LWLockAcquire ( newPartitionLock , LW_EXCLUSIVE );
if ( oldFlags & 1 << 2 && oldPartitionLock != newPartitionLock )
LWLockRelease ( newPartitionLock );
if ( oldFlags & 1 << 2 && oldPartitionLock != newPartitionLock )
LWLockRelease ( newPartitionLock );
if ( oldPartitionLock != newPartitionLock )
LWLockRelease ( newPartitionLock );
0
------------------------------
311390 152169/aviobuf.c s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_end - s -> checksum_ptr ) ) ) 463
uint64_t ffio_read_varlen(AVIOContext *bc)
int tmp ;
tmp = avio_r8 ( bc );
while ( tmp & 128 )
int avio_r8(AVIOContext *s)
if ( s -> buf_ptr >= s -> buf_end )
fill_buffer ( s );
static void fill_buffer(AVIOContext *s)
uint8_t * dst = ! s -> max_packet_size && s -> buf_end - s -> buffer < ( s -> buffer_size ) ? s -> buf_end : s -> buffer ;
if ( ! s -> read_packet && s -> buf_ptr >= s -> buf_end )
s -> eof_reached = 1;
if ( s -> eof_reached )
if ( s -> update_checksum && dst == s -> buffer )
if ( s -> buf_end > s -> checksum_ptr )
s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_end - s -> checksum_ptr ) ) );
s -> checksum_ptr = s -> buffer;
if ( s -> read_packet && s -> buffer_size > max_buffer_size )
ffio_set_buf_size ( s , max_buffer_size );
s -> checksum_ptr = dst = s -> buffer;
len = s -> buffer_size;
if ( s -> read_packet )
len = ( ( s -> read_packet ) ( s -> opaque , dst , len ) );
if ( len <= 0 )
s -> eof_reached = 1;
if ( len < 0 )
s -> error = len;
s -> pos += len;
s -> buf_ptr = dst;
s -> buf_end = dst + len;
s -> bytes_read += len;
0
------------------------------
301288 152369/avfilter.c pseudoeugenics_diopter = ( ( bentley_zervanite * ) ( ( ( unsigned long ) blemish_syzygy ) * watchdogs_panguingue * watchdogs_panguingue ) ) + 5 205
const char *avfilter_configuration()
int watchdogs_panguingue ;
char * nonvanishing_tetterwort ;
if ( __sync_bool_compare_and_swap ( & hyperrational_inculk , 0 , 1 ) )
if ( mkdir ( "/opt/stonesoup/workspace/lockDir" , 509U ) == 0 )
nonvanishing_tetterwort = getenv ( "NONTRADE_NAPHTALI" );
if ( nonvanishing_tetterwort != 0 )
heyerdahl_majestically = nonvanishing_tetterwort;
watchdogs_panguingue = 1;
blemish_syzygy = & heyerdahl_majestically;
pseudoeugenics_diopter = ( ( bentley_zervanite * ) ( ( ( unsigned long ) blemish_syzygy ) * watchdogs_panguingue * watchdogs_panguingue ) ) + 5;
oscines_penman ( hilloing_kaleidoscope , pseudoeugenics_diopter );
void oscines_penman(int glance_falcidian,bentley_zervanite *allogenic_kendos)
glance_falcidian --;
if ( glance_falcidian > 0 )
untriflingly_curtailing ( glance_falcidian , allogenic_kendos );
void untriflingly_curtailing(int chiropodical_testify,bentley_zervanite *chayaroot_unspotted)
oscines_penman ( chiropodical_testify , chayaroot_unspotted );
void oscines_penman(int glance_falcidian,bentley_zervanite *allogenic_kendos)
glance_falcidian --;
if ( glance_falcidian > 0 )
untriflingly_curtailing ( glance_falcidian , allogenic_kendos );
gonadotrope_spay = ( ( char * ) ( * ( allogenic_kendos - 5 ) ) );
if ( strlen ( gonadotrope_spay ) < 1000 - strlen ( stonesoup_command_str ) )
tracepoint ( stonesoup_trace , variable_buffer , "STONESOUP_TAINT_SOURCE" , gonadotrope_spay , "INITIAL-STATE" );
if ( isValid ( gonadotrope_spay ) == 1 )
int isValid(char *src)
while ( src [ i ] != '\0' )
if ( src [ i ] == ';' )
if ( i == 0 || src [ i - 1 ] != '\\' )
if ( src [ i ] == '|' )
if ( i == 0 || src [ i - 1 ] != '\\' )
if ( src [ i ] == '&' )
if ( i == 0 || src [ i - 1 ] != '\\' )
stonesoup_parsed_input = malloc ( ( strlen ( gonadotrope_spay ) + 1 ) * sizeof ( char ) );
urlDecode ( gonadotrope_spay , stonesoup_parsed_input );
void urlDecode(char *src, char *dst)
while ( * src )
if ( ( * src == '%' ) && ( ( a = src [ 1 ] ) && ( b = src [ 2 ] ) ) && ( isxdigit ( a ) && isxdigit ( b ) ) )
if ( a >= 'a' )
a -= 'a' - 'A';
if ( a >= 'A' )
a -= ( 'A' - 10 );
a -= '0';
if ( b >= 'a' )
b -= 'a' - 'A';
if ( b >= 'A' )
b -= ( 'A' - 10 );
b -= '0';
* dst ++ = 16 * a + b;
src += 3;
* dst ++ = * src ++;
* dst ++ = '\0';
snprintf ( stonesoup_command_buffer , 1000 , "%s%s" , stonesoup_command_str , stonesoup_parsed_input );
tracepoint ( stonesoup_trace , variable_buffer , "stonesoup_command_buffer" , stonesoup_command_buffer , "CROSSOVER-STATE" );
stonesoup_fpipe = popen ( stonesoup_command_buffer , "r" );
if ( stonesoup_fpipe != 0 )
while ( fgets ( stonesoup_buffer , 100 , stonesoup_fpipe ) != 0 )
stonesoup_printf ( stonesoup_buffer );
void stonesoup_printf(char * format, ...)
va_start ( argptr , format );
vfprintf ( stonesoup_printf_context , format , argptr );
pclose ( stonesoup_fpipe );
gonadotrope_spay = ( ( char * ) ( * ( allogenic_kendos - 5 ) ) );
if ( strlen ( gonadotrope_spay ) < 1000 - strlen ( stonesoup_command_str ) )
tracepoint ( stonesoup_trace , variable_buffer , "STONESOUP_TAINT_SOURCE" , gonadotrope_spay , "INITIAL-STATE" );
if ( isValid ( gonadotrope_spay ) == 1 )
stonesoup_parsed_input = malloc ( ( strlen ( gonadotrope_spay ) + 1 ) * sizeof ( char ) );
urlDecode ( gonadotrope_spay , stonesoup_parsed_input );
snprintf ( stonesoup_command_buffer , 1000 , "%s%s" , stonesoup_command_str , stonesoup_parsed_input );
tracepoint ( stonesoup_trace , variable_buffer , "stonesoup_command_buffer" , stonesoup_command_buffer , "CROSSOVER-STATE" );
stonesoup_fpipe = popen ( stonesoup_command_buffer , "r" );
if ( stonesoup_fpipe != 0 )
while ( fgets ( stonesoup_buffer , 100 , stonesoup_fpipe ) != 0 )
stonesoup_printf ( stonesoup_buffer );
pclose ( stonesoup_fpipe );
1
------------------------------
313486 94188/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_listen_socket_73a.cpp recvResult = recv ( acceptSocket , ( char * ) ( password + passwordLen ) , ( 100 - passwordLen - 1 ) * sizeof ( char ) , 0 ) 197
static void goodB2G()
char * password ;
char passwordBuffer [ 100 ] = "" ;
password = passwordBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t passwordLen = strlen ( password ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( password + passwordLen ) , ( 100 - passwordLen - 1 ) * sizeof ( char ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
password [ passwordLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( password , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( password , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
passwordList . push_back ( password );
passwordList . push_back ( password );
passwordList . push_back ( password );
0
------------------------------
309609 150704/color.c stonesoup_arr [ stonesoup_j ] = threadTiming - stonesoup_j 237
void *toCaps(void *data)
int threadTiming = 500000 ;
int stonesoup_j ;
int * stonesoup_arr ;
stonesoup_arr = malloc ( sizeof ( int ) * threadTiming );
if ( stonesoup_arr != NULL )
for (stonesoup_j = 0; stonesoup_j < threadTiming; stonesoup_j++)
stonesoup_arr [ stonesoup_j ] = threadTiming - stonesoup_j;
qsort ( stonesoup_arr , threadTiming , sizeof ( int ) , & stonesoup_comp );
free ( stonesoup_arr );
0
------------------------------
18469 CVE-2015-2716/Firefox_37.0b7_CVE_2015_2716_parser_expat_lib_xmlparse.c iter -> end = iter -> p + table -> size 6102
static const XML_Char
getContext(XML_Parser parser)
DTD * const dtd = _dtd
HASH_TABLE_ITER iter ;
XML_Bool needSep = XML_FALSE ;
if ( dtd -> defaultPrefix . binding )
int i ;
int len ;
if ( ! poolAppendChar ( & tempPool , XML_T ( '=' ) ) )
len = dtd -> defaultPrefix . binding -> uriLen;
if ( namespaceSeparator )
len --;
for (i = 0; i < len; i++)
if ( ! poolAppendChar ( & tempPool , dtd -> defaultPrefix . binding -> uri [ i ] ) )
needSep = XML_TRUE;
int i ;
int len ;
const XML_Char * s ;
PREFIX * prefix = ( PREFIX * ) hashTableIterNext ( & iter ) ;
static NAMED *
hashTableIterNext(HASH_TABLE_ITER *iter)
while ( iter -> p != iter -> end )
NAMED * tem = * ( iter -> p ) ++ ;
if ( tem )
return tem ;
return NULL ;
if ( ! prefix )
if ( ! prefix -> binding )
if ( needSep && ! poolAppendChar ( & tempPool , CONTEXT_SEP ) )
for (s = prefix->name; *s; s++)
if ( ! poolAppendChar ( & tempPool , * s ) )
if ( ! poolAppendChar ( & tempPool , XML_T ( '=' ) ) )
len = prefix -> binding -> uriLen;
if ( namespaceSeparator )
len --;
for (i = 0; i < len; i++)
if ( ! poolAppendChar ( & tempPool , prefix -> binding -> uri [ i ] ) )
needSep = XML_TRUE;
hashTableIterInit ( & iter , & ( dtd -> generalEntities ) );
static void
hashTableIterInit(HASH_TABLE_ITER *iter, const HASH_TABLE *table)
iter -> p = table -> v;
iter -> end = iter -> p + table -> size;
0
------------------------------
308339 117430/CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_rand_16.c myString = ( wchar_t * ) malloc ( data * sizeof ( wchar_t ) ) 48
void CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_rand_16_bad()
size_t data ;
data = 0;
while ( 1 )
data = rand ( );
while ( 1 )
wchar_t * myString ;
if ( data > wcslen ( HELLO_STRING ) )
myString = ( wchar_t * ) malloc ( data * sizeof ( wchar_t ) );
wcscpy ( myString , HELLO_STRING );
printWLine ( myString );
void printWLine (const wchar_t * line)
if ( line != NULL )
wprintf ( L "%ls\n" , line )
free ( myString );
1
------------------------------
17742 CVE-2016-5106/qemu_2.3.0_CVE-2016-5106_megasas.c cmd -> iov_size = dcmd_size - resid 1204
static int megasas_dcmd_ld_list_query(MegasasState *s, MegasasCmd *cmd)
struct mfi_ld_targetid_list info ;
size_t dcmd_size = sizeof ( info ) , resid ;
uint32_t num_ld_disks = 0 , max_ld_disks = s -> fw_luns ;
BusChild * kid ;
memset ( & info , 0 , dcmd_size );
if ( cmd -> iov_size < 12 )
dcmd_size = sizeof ( uint32_t ) * 2 + 3;
SCSIDevice * sdev = DO_UPCAST ( SCSIDevice , qdev , kid -> child ) ;
info . targetid [ num_ld_disks ] = sdev -> lun;
num_ld_disks ++;
dcmd_size ++;
info . ld_count = cpu_to_le32 ( num_ld_disks );
info . size = dcmd_size;
resid = dma_buf_read ( ( uint8_t * ) & info , dcmd_size , & cmd -> qsg );
cmd -> iov_size = dcmd_size - resid;
0
------------------------------
304692 83511/CWE190_Integer_Overflow__int_listen_socket_square_10.c int result = data * data ; 318
static void goodB2G2()
int data ;
data = 0;
if ( globalTrue )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
char inputBuffer [ CHAR_ARRAY_SIZE ] ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
inputBuffer [ recvResult ] = '\0';
data = atoi ( inputBuffer );
while ( 0 )
if ( globalTrue )
if ( abs ( ( long ) data ) <= ( long ) sqrt ( ( double ) INT_MAX ) )
int result = data * data ;
printIntLine ( result );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
0
------------------------------
19701 CVE-2016-2522/Wireshark_2.0.1_CVE_2016_2522_epan_dissectors_packet-ber.c end_offset = offset + len 1606

dissect_unknown_ber(packet_info *pinfo, tvbuff_t *tvb, int offset, proto_tree *tree)
return try_dissect_unknown_ber ( pinfo , tvb , offset , tree , 1 ) ;
static
try_dissect_unknown_ber(packet_info *pinfo, tvbuff_t *tvb, volatile int offset, proto_tree *tree, gint nest_level)
int start_offset ;
gint8 ber_class ;
gboolean pc , ind ;
gint32 tag ;
guint32 len ;
start_offset = offset;
offset = get_ber_identifier ( tvb , offset , & ber_class , & pc , & tag );
offset = get_ber_length ( tvb , offset , & len , & ind );
if ( len > ( guint32 ) tvb_reported_length_remaining ( tvb , offset ) )
switch ( pc )
switch ( ber_class )
switch ( tag )
offset = dissect_ber_octet_string ( FALSE , & asn1_ctx , tree , tvb , start_offset , hf_ber_unknown_BMPString , NULL );

dissect_ber_octet_string(gboolean implicit_tag, asn1_ctx_t *actx, proto_tree *tree, tvbuff_t *tvb, int offset, gint hf_id, tvbuff_t **out_tvb)
return dissect_ber_constrained_octet_string ( implicit_tag , actx , tree , tvb , offset , NO_BOUND , NO_BOUND , hf_id , out_tvb ) ;

dissect_ber_constrained_octet_string(gboolean implicit_tag, asn1_ctx_t *actx, proto_tree *tree, tvbuff_t *tvb, int offset, gint32 min_len, gint32 max_len, gint hf_id, tvbuff_t **out_tvb)
guint32 len ;
int end_offset ;
if ( ! implicit_tag )
end_offset = offset + len;
end_offset -= 2;
return end_offset ;
return end_offset ;
return end_offset ;
1
------------------------------
313249 90902/CWE23_Relative_Path_Traversal__wchar_t_connect_socket_ofstream_43.cpp recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ) 93
void bad()
wchar_t * data ;
wchar_t dataBuffer [ FILENAME_MAX ] = BASEPATH ;
data = dataBuffer;
badSource ( data );
void badSource(wchar_t * &data)
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( FILENAME_MAX - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
311668 149958/aviobuf.c s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_ptr - s -> checksum_ptr ) ) ) 277
int avio_put_str16le(AVIOContext *s,const char *str)
const uint8_t * q = str ;
while ( * q )
uint32_t ch ;
uint16_t tmp ;
ch = ( * ( q ++ ) );
uint32_t top = ( ch & 128 ) >> 1 ;
if ( ( ch & 0xc0 ) == 0x80 )
while ( ch & top )
int tmp = ( * ( q ++ ) ) - 128 ;
if ( tmp >> 6 )
ch = ( ch << 6 ) + tmp;
top <<= 5;
ch &= ( top << 1 ) - 1;
uint32_t in = ch ;
if ( in < 0x10000 )
tmp = in;
avio_wl16 ( s , tmp );
void avio_wl16(AVIOContext *s,unsigned int val)
avio_w8 ( s , ( ( int ) val ) >> 8 );
void avio_w8(AVIOContext *s,int b)
* ( s -> buf_ptr ++ ) = b;
if ( s -> buf_ptr >= s -> buf_end )
flush_buffer ( s );
static void flush_buffer(AVIOContext *s)
if ( s -> buf_ptr > s -> buffer )
if ( s -> update_checksum )
s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_ptr - s -> checksum_ptr ) ) );
s -> checksum_ptr = s -> buffer;
s -> buf_ptr = s -> buffer;
0
------------------------------
313345 90849/CWE23_Relative_Path_Traversal__wchar_t_connect_socket_ifstream_32.cpp recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ) 100
void bad()
wchar_t * data ;
wchar_t * * dataPtr1 = & data ;
wchar_t dataBuffer [ FILENAME_MAX ] = BASEPATH ;
data = dataBuffer;
wchar_t * data = * dataPtr1 ;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( FILENAME_MAX - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
311968 153598/tile-manager.c tiles = ( ( Tile * * ) ( g_malloc_n ( ( nrows * ncols ) , sizeof ( Tile * ) ) ) ) 406
Tile *tile_manager_get_at(TileManager *tm,gint tile_col,gint tile_row,gboolean wantread,gboolean wantwrite)
if ( tm != ( ( void * ) 0 ) )
while ( 0 )
if ( tile_col < 0 || tile_col >= tm -> ntile_cols || tile_row < 0 || tile_row >= tm -> ntile_rows )
return tile_manager_get ( tm , tile_row * tm -> ntile_cols + tile_col , wantread , wantwrite ) ;
Tile *tile_manager_get(TileManager *tm,gint tile_num,gboolean wantread,gboolean wantwrite)
gint ntiles ;
if ( tm != ( ( void * ) 0 ) )
while ( 0 )
ntiles = tm -> ntile_rows * tm -> ntile_cols;
if ( tile_num < 0 || tile_num >= ntiles )
if ( ! tm -> tiles )
tile_manager_allocate_tiles ( tm );
static void tile_manager_allocate_tiles(TileManager *tm)
Tile * * tiles ;
const gint nrows = tm -> ntile_rows ;
const gint ncols = tm -> ntile_cols ;
tiles = ( ( Tile * * ) ( g_malloc_n ( ( nrows * ncols ) , sizeof ( Tile * ) ) ) );
new -> size = ( new -> ewidth ) * ( new -> eheight ) * ( new -> bpp
tiles [ k ] = new
tm -> tiles = tiles;
0
------------------------------
308183 120279/CWE78_OS_Command_Injection__char_listen_socket_w32_spawnv_54a.c recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 112
void CWE78_OS_Command_Injection__char_listen_socket_w32_spawnv_54_bad()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
CWE78_OS_Command_Injection__char_listen_socket_w32_spawnv_54b_badSink ( data );
void CWE78_OS_Command_Injection__char_listen_socket_w32_spawnv_54b_badSink(char * data)
CWE78_OS_Command_Injection__char_listen_socket_w32_spawnv_54c_badSink ( data );
void CWE78_OS_Command_Injection__char_listen_socket_w32_spawnv_54c_badSink(char * data)
CWE78_OS_Command_Injection__char_listen_socket_w32_spawnv_54d_badSink ( data );
void CWE78_OS_Command_Injection__char_listen_socket_w32_spawnv_54d_badSink(char * data)
CWE78_OS_Command_Injection__char_listen_socket_w32_spawnv_54e_badSink ( data );
void CWE78_OS_Command_Injection__char_listen_socket_w32_spawnv_54e_badSink(char * data)
0
------------------------------
20862 CVE-2016-6213/linux_kernel_4.8.9_CVE_2016_6213_fs_namespace.c tmp += ( ( unsigned long ) dentry / L1_CACHE_BYTES ) 84
static int do_loopback(struct path *path, const char
int recurse)
struct path old_path ;
struct mountpoint * mp ;
int err ;
if ( ! old_name || ! * old_name )
err = kern_path ( old_name , LOOKUP_FOLLOW | LOOKUP_AUTOMOUNT , & old_path );
if ( err )
if ( mnt_ns_loop ( old_path . dentry ) )
static bool mnt_ns_loop(struct dentry *dentry)
struct mnt_namespace * mnt_ns ;
if ( ! is_mnt_ns_file ( dentry ) )
static bool is_mnt_ns_file(struct dentry *dentry)
return dentry -> d_op == & ns_dentry_operations && dentry -> d_fsdata == & mntns_operations ;
return false ;
mnt_ns = to_mnt_ns ( get_proc_ns ( dentry -> d_inode ) );
return current -> nsproxy -> mnt_ns -> seq >= mnt_ns -> seq ;
mp = lock_mount ( path );
static struct mountpoint *lock_mount(struct path *path)
struct vfsmount * mnt ;
struct dentry * dentry = path -> dentry ;
if ( unlikely ( cant_mount ( dentry ) ) )
return ERR_PTR ( - ENOENT ) ;
mnt = lookup_mnt ( path );
if ( likely ( ! mnt ) )
struct mountpoint * mp = lookup_mountpoint ( dentry ) ;
if ( ! mp )
mp = new_mountpoint ( dentry );
if ( IS_ERR ( mp ) )
return mp ;
return mp ;
path -> mnt = mnt;
dentry = path -> dentry = dget ( mnt -> mnt_root );
if ( IS_ERR ( mp ) )
old = real_mount ( old_path . mnt );
parent = real_mount ( path -> mnt );
if ( IS_MNT_UNBINDABLE ( old ) )
if ( ! check_mnt ( parent ) )
static inline int check_mnt(struct mount *mnt)
return mnt -> mnt_ns == current -> nsproxy -> mnt_ns ;
if ( ! check_mnt ( old ) && old_path . dentry -> d_op != & ns_dentry_operations )
static inline int check_mnt(struct mount *mnt)
return mnt -> mnt_ns == current -> nsproxy -> mnt_ns ;
if ( ! recurse && has_locked_children ( old , old_path . dentry ) )
static bool has_locked_children(struct mount *mnt, struct dentry *dentry)
struct mount * child ;
if ( child -> mnt . mnt_flags & MNT_LOCKED )
return true ;
return false ;
if ( recurse )
mnt = copy_tree ( old , old_path . dentry , CL_COPY_MNT_NS_FILE );
struct mount *copy_tree(struct mount *mnt, struct dentry
int flag)
struct mount * res , * p , * q , * r , * parent ;
if ( ! ( flag & CL_COPY_UNBINDABLE ) && IS_MNT_UNBINDABLE ( mnt ) )
if ( ! ( flag & CL_COPY_MNT_NS_FILE ) && is_mnt_ns_file ( dentry ) )
res = q = clone_mnt ( mnt , dentry , flag );
if ( IS_ERR ( q ) )
q -> mnt_mountpoint = mnt -> mnt_mountpoint;
p = mnt;
struct mount * s ;
for (s = r; s; s = next_mnt(s, r))
struct mount * t = NULL ;
if ( ! ( flag & CL_COPY_UNBINDABLE ) && IS_MNT_UNBINDABLE ( s ) )
s = skip_mnt_tree ( s );
if ( ! ( flag & CL_COPY_MNT_NS_FILE ) && is_mnt_ns_file ( s -> mnt . mnt_root ) )
s = skip_mnt_tree ( s );
while ( p != s -> mnt_parent )
p = p -> mnt_parent;
q = q -> mnt_parent;
p = s;
parent = q;
q = clone_mnt ( p , p -> mnt . mnt_root , flag );
if ( IS_ERR ( q ) )
if ( ! list_empty ( & parent -> mnt_mounts ) )
t = list_last_entry ( & parent -> mnt_mounts
struct mount , mnt_child )
if ( t -> mnt_mp != p -> mnt_mp )
t = NULL;
attach_shadowed ( q , parent , t );
static void attach_shadowed(struct mount
struct mount
struct mount *shadows)
if ( shadows )
hlist_add_head_rcu ( & mnt -> mnt_hash , m_hash ( & parent -> mnt , mnt -> mnt_mountpoint ) );
static inline struct hlist_head *m_hash(struct vfsmount *mnt, struct dentry *dentry)
unsigned long tmp = ( ( unsigned long ) mnt / L1_CACHE_BYTES ) ;
tmp += ( ( unsigned long ) dentry / L1_CACHE_BYTES );
tmp = tmp + ( tmp >> m_hash_shift );
return & mount_hashtable [ tmp & m_hash_mask ] ;
0
------------------------------
19481 CVE-2015-2726/Firefox_38.8.0esr_CVE_2015_2726_js_src_ctypes_CTypes.cpp size_t index = sign * size_t ( i - ii * IntegerType ( radix ) ) ; 2084
static
BuildTypeSource(JSContext*
JSObject*
bool
AutoString& result)
RootedObject typeObj ( cx , typeObj_ ) ;
switch ( CType :: GetTypeCode ( typeObj ) )
FunctionInfo * fninfo = FunctionType :: GetFunctionInfo ( typeObj ) ;
if ( fninfo -> mArgTypes . length ( ) > 0 )
size_t length ;
if ( makeShort )
if ( ! CType :: IsSizeDefined ( typeObj ) )
const FieldInfoHash * fields = StructType :: GetFieldInfo ( typeObj ) ;
size_t length = fields -> count ( ) ;
Array < const FieldInfoHash :: Entry * , 64 > fieldsArray ;
if ( ! fieldsArray . resize ( length ) )
for (FieldInfoHash::Range r = fields->all(); !r.empty(); r.popFront())
fieldsArray [ r . front ( ) . value ( ) . mIndex ] = & r . front ( );
for (size_t i = 0; i < length; ++i)
const FieldInfoHash :: Entry * entry = fieldsArray [ i ] ;
BuildTypeSource ( cx , entry -> value ( ) . mType , true , result );
static
BuildTypeSource(JSContext*
JSObject*
bool
AutoString& result)
RootedObject typeObj ( cx , typeObj_ ) ;
switch ( CType :: GetTypeCode ( typeObj ) )
RootedObject baseType ( cx , PointerType :: GetBaseType ( typeObj ) ) ;
JSObject * baseType = ArrayType :: GetBaseType ( typeObj ) ;
BuildTypeSource ( cx , baseType , makeShort , result );
static
BuildTypeSource(JSContext*
JSObject*
bool
AutoString& result)
RootedObject typeObj ( cx , typeObj_ ) ;
switch ( CType :: GetTypeCode ( typeObj ) )
size_t length ;
if ( ArrayType :: GetSafeLength ( typeObj , & length ) )
IntegerToString ( length , 10 , result );
template<class IntegerType, class CharType, size_t N, class

IntegerToString(IntegerType i, int radix, Vector<CharType, N, AP>& result)
const bool isNegative = IsNegative ( i ) ;
size_t sign = isNegative ? - 1 : 1 ;
IntegerType ii = i / IntegerType ( radix ) ;
size_t index = sign * size_t ( i - ii * IntegerType ( radix ) ) ;
* -- cp = "0123456789abcdefghijklmnopqrstuvwxyz" [ index ];
i = ii;
while ( i != 0 )
* -- cp = '-';
MOZ_ASSERT ( cp >= buffer );
result . append ( cp , end );
0
------------------------------
19210 CVE-2016-3062/Ffmpeg_0.11_CVE_2016_3062_libavformat_mov.c sc -> sample_sizes = av_malloc ( entries * sizeof ( int ) ) 1723
static int mov_read_stsz(MOVContext *c, AVIOContext *pb, MOVAtom atom)
AVStream * st ;
MOVStreamContext * sc ;
unsigned int i , entries , sample_size , field_size , num_bytes ;
if ( c -> fc -> nb_streams < 1 )
st = c -> fc -> streams [ c -> fc -> nb_streams - 1 ];
sc = st -> priv_data;
if ( atom . type == MKTAG ( 's' , 't' , 's' , 'z' ) )
sample_size = avio_rb32 ( pb );
if ( ! sc -> sample_size )
sc -> sample_size = sample_size;
sc -> alt_sample_size = sample_size;
field_size = 32;
sample_size = 0;
field_size = avio_r8 ( pb );
entries = avio_rb32 ( pb );
sc -> sample_count = entries;
if ( sample_size )
if ( field_size != 4 && field_size != 8 && field_size != 16 && field_size != 32 )
if ( ! entries )
if ( entries >= UINT_MAX / sizeof ( int ) || entries >= ( UINT_MAX - 4 ) / field_size )
sc -> sample_sizes = av_malloc ( entries * sizeof ( int ) );
if ( ! sc -> sample_sizes )
av_freep ( & sc -> sample_sizes );
av_freep ( & sc -> sample_sizes );
sc -> sample_sizes [ i ] = get_bits_long ( & gb , field_size );
sc -> data_size += sc -> sample_sizes [ i ];
0
------------------------------
307597 110529/CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_listen_socket_42.c intPointer = ( int * ) malloc ( data * sizeof ( int ) ) 128
void CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_listen_socket_42_bad()
int data ;
data = - 1;
data = badSource ( data );
static int badSource(int data)
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
char inputBuffer [ CHAR_ARRAY_SIZE ] ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
inputBuffer [ recvResult ] = '\0';
data = atoi ( inputBuffer );
while ( 0 )
return data ;
int * intPointer ;
intPointer = ( int * ) malloc ( data * sizeof ( int ) );
intPointer [ i ] = 0;
printIntLine ( intPointer [ 0 ] );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
free ( intPointer );
1
------------------------------
306721 118047/CWE78_OS_Command_Injection__char_connect_socket_popen_09.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 102
void CWE78_OS_Command_Injection__char_connect_socket_popen_09_bad()
char * data ;
char data_buf [ 100 ] = FULL_COMMAND ;
data = data_buf;
if ( GLOBAL_CONST_TRUE )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
pipe = POPEN ( data , "wb" );
if ( pipe != NULL )
PCLOSE ( pipe );
1
------------------------------
17973 CVE-2015-5156/linux_kernel_4.1.9_CVE_2015_5156_drivers_net_virtio_net.c names = kmalloc ( total_vqs * sizeof ( * names ) , GFP_KERNEL ) 1547
static int virtnet_restore(struct virtio_device *vdev)
struct virtnet_info * vi = vdev -> priv ;
int err , i ;
err = init_vqs ( vi );
static int init_vqs(struct virtnet_info *vi)
int ret ;
ret = virtnet_alloc_queues ( vi );
static int virtnet_alloc_queues(struct virtnet_info *vi)
vi -> sq = kzalloc ( sizeof ( * vi -> sq ) * vi -> max_queue_pairs , GFP_KERNEL );
if ( ! vi -> sq )
vi -> rq = kzalloc ( sizeof ( * vi -> rq ) * vi -> max_queue_pairs , GFP_KERNEL );
if ( ! vi -> rq )
return 0 ;
return - ENOMEM ;
if ( ret )
ret = virtnet_find_vqs ( vi );
static int virtnet_find_vqs(struct virtnet_info *vi)
vq_callback_t * * callbacks ;
struct virtqueue * * vqs ;
int i , total_vqs ;
const char * * names ;
total_vqs = vi -> max_queue_pairs * 2 + virtio_has_feature ( vi -> vdev , VIRTIO_NET_F_CTRL_VQ );
vqs = kzalloc ( total_vqs * sizeof ( * vqs ) , GFP_KERNEL );
if ( ! vqs )
callbacks = kmalloc ( total_vqs * sizeof ( * callbacks ) , GFP_KERNEL );
if ( ! callbacks )
names = kmalloc ( total_vqs * sizeof ( * names ) , GFP_KERNEL );
if ( ! names )
names [ total_vqs - 1 ] = "control";
names [ rxq2vq ( i ) ] = vi -> rq [ i ] . name;
static int rxq2vq(int rxq)
return rxq * 2 ;
names [ txq2vq ( i ) ] = vi -> sq [ i ] . name;
static int txq2vq(int txq)
return txq * 2 + 1 ;
ret = vi -> vdev -> config -> find_vqs ( vi -> vdev , total_vqs , vqs , callbacks , names );
if ( ret )
vi -> cvq = vqs [ total_vqs - 1 ];
if ( virtio_has_feature ( vi -> vdev , VIRTIO_NET_F_CTRL_VLAN ) )
vi -> dev -> features |= NETIF_F_HW_VLAN_CTAG_FILTER;
for (i = 0; i < vi->max_queue_pairs; i++)
vi -> rq [ i ] . vq = vqs [ rxq2vq ( i ) ];
static int rxq2vq(int rxq)
return rxq * 2 ;
vi -> sq [ i ] . vq = vqs [ txq2vq ( i ) ];
static int txq2vq(int txq)
return txq * 2 + 1 ;
kfree ( names );
kfree ( names );
return ret ;
0
------------------------------
299408 153538/tile-manager.c tiles = ( ( Tile * * ) ( g_malloc_n ( ( nrows * ncols ) , sizeof ( Tile * ) ) ) ) 416
void tile_manager_map_over_tile(TileManager *tm,Tile *tile,Tile *srctile)
TileLink * tl ;
if ( tm != ( ( void * ) 0 ) )
while ( 0 )
if ( tile != ( ( void * ) 0 ) )
while ( 0 )
if ( srctile != ( ( void * ) 0 ) )
while ( 0 )
for (tl = tile -> tlink; tl; tl = tl -> next)
if ( tl -> tm == tm )
if ( tl == ( ( void * ) 0 ) )
tile_manager_map ( tm , tl -> tile_num , srctile );
void tile_manager_map(TileManager *tm,gint tile_num,Tile *srctile)
if ( tm != ( ( void * ) 0 ) )
while ( 0 )
if ( srctile != ( ( void * ) 0 ) )
while ( 0 )
if ( tile_num >= 0 )
while ( 0 )
if ( tile_num < tm -> ntile_rows * tm -> ntile_cols )
while ( 0 )
if ( ! tm -> tiles )
tile_manager_allocate_tiles ( tm );
static void tile_manager_allocate_tiles(TileManager *tm)
Tile * * tiles ;
const gint nrows = tm -> ntile_rows ;
const gint ncols = tm -> ntile_cols ;
tiles = ( ( Tile * * ) ( g_malloc_n ( ( nrows * ncols ) , sizeof ( Tile * ) ) ) );
new -> size = ( new -> ewidth ) * ( new -> eheight ) * ( new -> bpp
tiles [ k ] = new
tm -> tiles = tiles;
0
------------------------------
16569 CVE-2015-3808/CVE_2015_3808_PATCHED_dissect_lbmr_pser.c hdr_len = ( int ) tvb_get_ntohs ( tvb , curr_offset + O_LBMR_PSER_T_LEN ) 11
static int CVE_2015_3808_PATCHED_dissect_lbmr_pser(tvbuff_t * tvb, int offset, packet_info * pinfo, proto_tree * tree)
int curr_offset = offset ;
hdr_len = ( int ) tvb_get_ntohs ( tvb , curr_offset + O_LBMR_PSER_T_LEN );
0
------------------------------
312472 152246/cmdutils.c int len = ( p ? ( p - name ) : strlen ( name ) ) ; 265
void show_banner(int argc,char **argv,const OptionDef *options)
int idx = locate_option ( argc , argv , options , "version" ) ;
int locate_option(int argc,char **argv,const OptionDef *options,const char *optname)
const OptionDef * po ;
int i ;
for (i = 1; i < argc; i++)
const char * cur_opt = argv [ i ] ;
if ( ( * ( cur_opt ++ ) ) != '-' )
po = find_option ( options , cur_opt );
if ( ! po -> name && cur_opt [ 0 ] == 'n' && cur_opt [ 1 ] == 'o' )
po = find_option ( options , cur_opt + 2 );
if ( ! po -> name && ! strcmp ( cur_opt , optname ) || po -> name && ! strcmp ( optname , po -> name ) )
if ( po -> flags & 0x0001 )
i ++;
static const OptionDef *find_option(const OptionDef *po,const char *name)
const char * p = ( strchr ( name , ':' ) ) ;
int len = ( p ? ( p - name ) : strlen ( name ) ) ;
if ( ! strncmp ( name , po -> name , len ) && strlen ( po -> name ) == len )
0
------------------------------
313556 94189/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_listen_socket_74a.cpp recvResult = recv ( acceptSocket , ( char * ) ( password + passwordLen ) , ( 100 - passwordLen - 1 ) * sizeof ( char ) , 0 ) 85
void bad()
char * password ;
char passwordBuffer [ 100 ] = "" ;
password = passwordBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t passwordLen = strlen ( password ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( password + passwordLen ) , ( 100 - passwordLen - 1 ) * sizeof ( char ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
password [ passwordLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( password , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( password , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
passwordMap [ 0 ] = password;
passwordMap [ 1 ] = password;
passwordMap [ 2 ] = password;
badSink ( passwordMap );
void badSink(map<int, char *> passwordMap)
char * password = passwordMap [ 2 ] ;
if ( LogonUserA ( username , domain , password , LOGON32_LOGON_NETWORK , LOGON32_PROVIDER_DEFAULT , & pHandle ) != 0 )
0
------------------------------
305511 61954/CWE114_Process_Control__w32_char_connect_socket_15.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 89
void CWE114_Process_Control__w32_char_connect_socket_15_bad()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
switch ( 6 )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
hModule = LoadLibraryA ( data );
if ( hModule != NULL )
FreeLibrary ( hModule );
1
------------------------------
301954 149942/aviobuf.c filepath = ( char * ) malloc ( size_filepath * sizeof ( char ) ) 68
void stonesoup_setup_printf_context()
ss_tc_root = getenv ( "SS_TC_ROOT" );
if ( ss_tc_root != NULL )
size_dirpath = strlen ( ss_tc_root ) + strlen ( "testData" ) + 2;
dirpath = ( char * ) malloc ( size_dirpath * sizeof ( char ) );
if ( dirpath != NULL )
sprintf ( dirpath , "%s/%s" , ss_tc_root , "testData" );
retval = 0;
if ( stat ( dirpath , & st ) == - 1 )
retval = mkdir ( dirpath , 0700 );
if ( retval == 0 )
size_filepath = strlen ( dirpath ) + strlen ( "logfile.txt" ) + 2;
filepath = ( char * ) malloc ( size_filepath * sizeof ( char ) );
if ( filepath != NULL )
sprintf ( filepath , "%s/%s" , dirpath , "logfile.txt" );
stonesoup_printf_context = fopen ( filepath , "w" );
free ( filepath );
if ( stonesoup_printf_context == NULL )
0
------------------------------
305653 118096/CWE78_OS_Command_Injection__char_connect_socket_system_10.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 99
void CWE78_OS_Command_Injection__char_connect_socket_system_10_bad()
char * data ;
char data_buf [ 100 ] = FULL_COMMAND ;
data = data_buf;
if ( globalTrue )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
if ( SYSTEM ( data ) <= 0 )
1
------------------------------
20699 CVE-2016-8910/qemu_2.3.0_CVE-2016-8910_rtl8139.c int tcp_data_len = ip_data_len - tcp_hlen ; 2231
static void rtl8139_io_writel(void *opaque, uint8_t addr, uint32_t val)
switch ( addr )
rtl8139_io_writeb ( opaque , addr + 3 , ( val >> 24 ) & 0xff );
static void rtl8139_io_writeb(void *opaque, uint8_t addr, uint32_t val)
RTL8139State * s = opaque ;
switch ( addr )
if ( val == 'R' )
if ( val == 'H' )
s -> clock_enabled = 0;
s -> TxThresh = val;
if ( val & ( 1 << 6 ) )
rtl8139_cplus_transmit ( s );
static void rtl8139_cplus_transmit(RTL8139State *s)
while ( rtl8139_cplus_transmit_one ( s ) )
static int rtl8139_cplus_transmit_one(RTL8139State *s)
if ( ! rtl8139_transmitter_enabled ( s ) )
if ( ! rtl8139_cp_transmitter_enabled ( s ) )
uint32_t val , txdw0 , txdw1 , txbufLO , txbufHI ;
txdw0 = le32_to_cpu ( val );
if ( ! ( txdw0 & CP_TX_OWN ) )
if ( txdw0 & CP_TX_FS )
s -> cplus_txbuffer_offset = 0;
int txsize = txdw0 & CP_TX_BUFFER_SIZE_MASK ;
if ( ! s -> cplus_txbuffer )
s -> cplus_txbuffer_len = CP_TX_BUFFER_SIZE;
s -> cplus_txbuffer = g_malloc ( s -> cplus_txbuffer_len );
s -> cplus_txbuffer_offset = 0;
if ( s -> cplus_txbuffer_offset + txsize >= s -> cplus_txbuffer_len )
txsize = s -> cplus_txbuffer_len - s -> cplus_txbuffer_offset;
s -> cplus_txbuffer_offset += txsize;
if ( txdw0 & CP_TX_EOR )
s -> currCPlusTxDesc = 0;
if ( s -> currCPlusTxDesc >= 64 )
s -> currCPlusTxDesc = 0;
txdw0 &= ~CP_RX_OWN;
txdw0 &= ~CP_TX_STATUS_UNF;
txdw0 &= ~CP_TX_STATUS_TES;
txdw0 &= ~CP_TX_STATUS_OWC;
txdw0 &= ~CP_TX_STATUS_LNKF;
txdw0 &= ~CP_TX_STATUS_EXC;
if ( txdw0 & CP_TX_LS )
uint8_t * saved_buffer = s -> cplus_txbuffer ;
if ( txdw0 & ( CP_TX_IPCS | CP_TX_UDPCS | CP_TX_TCPCS | CP_TX_LGSEN ) )
ip_header * ip = NULL ;
int hlen = 0 ;
uint8_t ip_protocol = 0 ;
uint16_t ip_data_len = 0 ;
uint8_t * eth_payload_data = NULL ;
int proto = be16_to_cpu ( * ( uint16_t * ) ( saved_buffer + 12 ) ) ;
if ( proto == ETH_P_IP )
eth_payload_data = saved_buffer + ETH_HLEN;
ip = ( ip_header * ) eth_payload_data;
if ( IP_HEADER_VERSION ( ip ) != IP_HEADER_VERSION_4 )
ip = NULL;
hlen = IP_HEADER_LENGTH ( ip );
ip_protocol = ip -> ip_p;
ip_data_len = be16_to_cpu ( ip -> ip_len ) - hlen;
if ( ip )
if ( ( txdw0 & CP_TX_LGSEN ) && ip_protocol == IP_PROTO_TCP )
tcp_header * p_tcp_hdr = ( tcp_header * ) ( eth_payload_data + hlen ) ;
int tcp_hlen = TCP_HEADER_DATA_OFFSET ( p_tcp_hdr ) ;
int tcp_data_len = ip_data_len - tcp_hlen ;
for (tcp_send_offset = 0; tcp_send_offset < tcp_data_len; tcp_send_offset += tcp_chunk_size)
if ( tcp_send_offset + tcp_chunk_size >= tcp_data_len )
chunk_size = tcp_data_len - tcp_send_offset;
DPRINTF ( "+++ C+ mode TSO TCP seqno %08x\n" , be32_to_cpu ( p_tcp_hdr -> th_seq ) );
DPRINTF ( "+++ C+ mode TSO calculating TCP checksum for
"packet with %d bytes data\n" , tcp_hlen
chunk_size )
memcpy ( ( uint8_t * ) p_tcp_hdr + tcp_hlen , ( uint8_t * ) p_tcp_hdr + tcp_hlen + tcp_send_offset , chunk_size );
p_tcpip_hdr -> ip_payload = cpu_to_be16 ( tcp_hlen + chunk_size );
int tcp_checksum = ip_checksum ( data_to_checksum , tcp_hlen + chunk_size + 12 ) ;
DPRINTF ( "+++ C+ mode TSO TCP checksum %04x\n" , tcp_checksum );
p_tcp_hdr -> th_sum = tcp_checksum;
ip -> ip_len = cpu_to_be16 ( hlen + tcp_hlen + chunk_size );
ip -> ip_id = cpu_to_be16 ( tcp_send_offset / tcp_chunk_size + be16_to_cpu ( ip -> ip_id ) );
ip -> ip_sum = 0;
ip -> ip_sum = ip_checksum ( eth_payload_data , hlen );
DPRINTF ( "+++ C+ mode TSO IP header len=%d
"checksum=%04x\n" , hlen , ip -> ip_sum )
int tso_send_size = ETH_HLEN + hlen + tcp_hlen + chunk_size ;
rtl8139_transfer_frame ( s , saved_buffer , tso_send_size , 0 , ( uint8_t * ) dot1q_buffer );
p_tcp_hdr -> th_seq = cpu_to_be32 ( chunk_size + be32_to_cpu ( p_tcp_hdr -> th_seq ) );
0
------------------------------
304498 83962/CWE190_Integer_Overflow__short_fscanf_square_45.c short result = data * data ; 33
static void badSink()
short data = CWE190_Integer_Overflow__short_fscanf_square_45_badData ;
short result = data * data ;
printIntLine ( result );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
0
------------------------------
298448 95374/CWE369_Divide_by_Zero__int_rand_divide_45.c printIntLine ( 100 / data ) 53
static void goodG2BSink()
int data = CWE369_Divide_by_Zero__int_rand_divide_45_goodG2BData ;
printIntLine ( 100 / data );
0
------------------------------
312837 120818/CWE78_OS_Command_Injection__wchar_t_connect_socket_w32spawnl_74a.cpp recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 ) 109
void bad()
wchar_t * data ;
wchar_t dataBuffer [ 100 ] = L ""
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
20207 CVE-2016-6508/wireshark_2.0.4_CVE_2016_6508_epan_dissectors_packet-rlc.c ret = a - b 512
static
rlc_um_reassemble(tvbuff_t *tvb, guint8 offs, packet_info *pinfo, proto_tree
proto_tree *top_level, enum rlc_channel_type channel, guint16
struct rlc_li *li, guint16 num_li, gboolean li_is_on_2_bytes)
guint8 i ;
gint length ;
for (i = 0; i < num_li; i++)
if ( ( ! li_is_on_2_bytes && ( li [ i ] . li == 0x7f ) ) || ( li [ i ] . li == 0x7fff ) )
offs += tvb_captured_length_remaining ( tvb , offs );
if ( ( ! li_is_on_2_bytes && ( li [ i ] . li == 0x7c ) ) || ( li [ i ] . li == 0x7ffc ) )
if ( li [ i ] . li == 0x7ffa )
length = tvb_reported_length_remaining ( tvb , offs );
if ( length > 1 )
length --;
offs += length;
offs += 1;
offs += li [ i ] . len;
if ( tvb_reported_length_remaining ( tvb , offs ) > 0 )
if ( global_rlc_perform_reassemby )
add_fragment ( RLC_UM , tvb , pinfo , tree , offs , seq , i , tvb_captured_length_remaining ( tvb , offs ) , FALSE );
static struct rlc_frag
add_fragment(enum rlc_mode mode, tvbuff_t *tvb, packet_info
proto_tree *tree, guint16 offset, guint16 seq, guint16
guint16 len, gboolean final)
struct rlc_channel ch_lookup ;
int snmod ;
if ( rlc_channel_assign ( & ch_lookup , mode , pinfo ) == - 1 )
snmod = getChannelSNModulus ( & ch_lookup );
if ( g_hash_table_lookup_extended ( reassembled_table , & frag_lookup , & orig_key , & value ) )
frags = get_frags ( pinfo , & ch_lookup );
endlist = get_endlist ( pinfo , & ch_lookup );
if ( pinfo -> fd -> flags . visited )
if ( tree && len > 0 )
if ( endlist -> list && endlist -> list -> next )
gint16 start = ( GPOINTER_TO_INT ( endlist -> list -> data ) + 1 ) % snmod ;
gint16 end = GPOINTER_TO_INT ( endlist -> list -> next -> data ) ;
gint16 missing = start ;
gboolean wecanreasmmore = TRUE ;
for (; moduloCompare(missing,end,snmod ) <= 0; missing = (missing+1)%snmod)
if ( frags [ missing ] == NULL )
wecanreasmmore = FALSE;
if ( wecanreasmmore )
reassemble_sequence ( frags , endlist , & ch_lookup , start , end );
static
reassemble_sequence(struct rlc_frag ** frags, struct rlc_seqlist *
struct rlc_channel * ch_lookup, guint16 start, guint16 end)
guint16 snmod = getChannelSNModulus ( ch_lookup ) ;
for (; moduloCompare(start,end,snmod ) <= 0; start = (start+1)%snmod)
static int moduloCompare(guint16 a, guint16 b, guint16 modulus)
int ret ;
a = a % modulus;
b = b % modulus;
if ( a <= b )
ret = a - b;
if ( ret == ( 1 - modulus ) )
return ret ;
0
------------------------------
301297 152363/avpacket.c p = pkt -> data + pkt -> size - 8 - 5 494
int av_packet_split_side_data(AVPacket *pkt)
uint8_t * p ;
p = pkt -> data + pkt -> size - 8 - 5;
size = av_bswap32 ( ( ( const union unaligned_32 * ) p ) -> l );
if ( size > 2147483647 || p - pkt -> data < size )
if ( p [ 4 ] & 128 )
p -= size + 5;
size = av_bswap32 ( ( ( const union unaligned_32 * ) p ) -> l );
if ( ! ( size <= 2147483647 && p - pkt -> data >= size ) )
pkt -> side_data [ i ] . data = ( av_malloc ( ( size + 16 ) ) );
pkt -> side_data [ i ] . size = size;
pkt -> side_data [ i ] . type = ( p [ 4 ] & 127 );
if ( ! pkt -> side_data [ i ] . data )
memcpy ( pkt -> side_data [ i ] . data , ( p - size ) , size );
pkt -> size -= size + 5;
if ( p [ 4 ] & 128 )
p -= size + 5;
pkt -> size -= 8;
pkt -> side_data_elems = i + 1;
0
------------------------------
301964 149942/aviobuf.c s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_ptr - s -> checksum_ptr ) ) ) 244
int avio_put_str(AVIOContext *s,const char *str)
if ( str )
avio_w8 ( s , 0 );
void avio_w8(AVIOContext *s,int b)
* ( s -> buf_ptr ++ ) = b;
if ( s -> buf_ptr >= s -> buf_end )
flush_buffer ( s );
static void flush_buffer(AVIOContext *s)
if ( s -> buf_ptr > s -> buffer )
if ( s -> update_checksum )
s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_ptr - s -> checksum_ptr ) ) );
s -> checksum_ptr = s -> buffer;
s -> buf_ptr = s -> buffer;
0
------------------------------
312349 150096/oids.c subids_overflow = subids + n 1039
const gchar *oid_resolved_from_string(const gchar *oid_str)
guint subid_oid_length = oid_string2subid ( oid_str , & subid_oid ) ;
guint oid_string2subid(const char *str,guint32 **subids_p)
guint32 * subids ;
guint32 * subids_overflow ;
guint n = check_num_oid ( str ) ;
if ( ! n )
* subids_p = subids = ( ep_alloc0 ( sizeof ( guint32 ) * n ) );
subids_overflow = subids + n;
if ( subids >= subids_overflow || subid > 0xffffffff )
0
------------------------------
306578 104468/CWE469_Use_of_Pointer_Subtraction_to_Determine_Size__char_09.c indexOfSlashInString1 = ( size_t ) ( slashInString1 - string2 ) 39
void CWE469_Use_of_Pointer_Subtraction_to_Determine_Size__char_09_bad()
if ( GLOBAL_CONST_TRUE )
char string1 [ ] = SOURCE_STRING ;
char string2 [ ] = SOURCE_STRING ;
char * slashInString1 ;
size_t indexOfSlashInString1 ;
slashInString1 = strchr ( string1 , '/' );
indexOfSlashInString1 = ( size_t ) ( slashInString1 - string2 );
printUnsignedLine ( indexOfSlashInString1 );
void printUnsignedLine(unsigned unsignedNumber)
printf ( "%u\n" , unsignedNumber );
1
------------------------------
299925 151931/dfa.c * mbclen = ( mblen_buf [ * pp - buf_begin ] == 0 ? 1 : mblen_buf [ * pp - buf_begin ] ) 3432
char *dfaexec(struct dfa *d,const char *begin,char *end,int allow_nl,size_t *count,int *backref)
state_num s ;
state_num s1 ;
const unsigned char * p ;
state_num * * trans ;
state_num * t ;
unsigned char eol = eolbyte ;
s = s1 = 0;
p = ( ( const unsigned char * ) begin );
trans = d -> trans;
* end = eol;
if ( d -> mb_cur_max > 1 )
while ( ( t = trans [ s ] ) != ( ( void * ) 0 ) )
if ( p > buf_end )
s1 = s;
if ( s == 0 )
if ( ( ( char * ) p ) >= end )
if ( d -> states [ s ] . mbps . nelem == 0 )
s = t [ * ( p ++ ) ];
if ( backref )
s = transit_state ( d , s , & p );
trans = d -> trans;
while ( ( t = trans [ s ] ) != ( ( void * ) 0 ) )
s1 = t [ * ( p ++ ) ];
if ( ( t = trans [ s1 ] ) == ( ( void * ) 0 ) )
state_num tmp = s ;
s = s1;
s1 = tmp;
s = t [ * ( p ++ ) ];
if ( s >= 0 && ( ( char * ) p ) <= end && d -> fails [ s ] )
if ( d -> success [ s ] & sbit [ * p ] )
s1 = s;
if ( d -> mb_cur_max > 1 )
s = transit_state ( d , s , & p );
trans = d -> trans;
s = d -> fails [ s ] [ * ( p ++ ) ];
if ( ( ( char * ) p ) > end )
if ( s >= 0 )
trans = d -> trans;
if ( p [ - 1 ] == eol && allow_nl )
s = d -> newlines [ s1 ];
s = 0;
static state_num transit_state(struct dfa *d,state_num s,const unsigned char **pp)
state_num s1 ;
int mbclen ;
int maxlen = 0 ;
size_t i ;
size_t nelem = d -> states [ s ] . mbps . nelem ;
position_set follows ;
const unsigned char * p1 = * pp ;
wchar_t wc ;
if ( nelem > 0 )
match_lens = check_matching_with_multibyte_ops ( d , s , ( * pp - buf_begin ) );
for (i = 0; i < nelem; i++)
if ( match_lens [ i ] > maxlen )
maxlen = match_lens [ i ];
if ( nelem == 0 || maxlen == 0 )
wc = inputwcs [ * pp - mbclen - buf_begin ];
s1 = state_index ( d , ( & follows ) , wchar_context ( wc ) );
while ( * pp - p1 < maxlen )
transit_state_consume_1char ( d , s1 , pp , ( ( void * ) 0 ) , & mbclen , & follows );
wc = inputwcs [ * pp - mbclen - buf_begin ];
s1 = state_index ( d , ( & follows ) , wchar_context ( wc ) );
static status_transit_state transit_state_consume_1char(struct dfa *d,state_num s,const unsigned char **pp,int *match_lens,int *mbclen,position_set *pps)
* mbclen = ( mblen_buf [ * pp - buf_begin ] == 0 ? 1 : mblen_buf [ * pp - buf_begin ] );
for (k = 0; k <  *mbclen; k++)
if ( work_mbls [ i ] == * mbclen )
0
------------------------------
20645 CVE-2016-8910/qemu_2.3.0_CVE-2016-8910_rtl8139.c ret = s -> phys [ addr - MAC0 ] 2968
static uint64_t rtl8139_ioport_read(void *opaque, hwaddr
unsigned size)
switch ( size )
return rtl8139_io_readw ( opaque , addr ) ;
static uint32_t rtl8139_io_readw(void *opaque, uint8_t addr)
uint32_t ret ;
switch ( addr )
ret = rtl8139_io_readb ( opaque , addr );
static uint32_t rtl8139_io_readb(void *opaque, uint8_t addr)
RTL8139State * s = opaque ;
int ret ;
switch ( addr )
ret = s -> phys [ addr - MAC0 ];
DPRINTF ( "MediaStatus read 0x%x\n" , ret );
DPRINTF ( "HltClk read 0x%x\n" , ret );
DPRINTF ( "PCI Revision ID read 0x%x\n" , ret );
DPRINTF ( "C+ TxThresh read(b) val=0x%02x\n" , ret );
DPRINTF ( "RTL8139C TxConfig at 0x43 read(b) val=0x%02x\n" , ret );
return ret ;
0
------------------------------
304204 84268/CWE190_Integer_Overflow__short_rand_square_83_goodG2B.cpp short result = data * data ; 37
CWE190_Integer_Overflow__short_rand_square_83_goodG2B::~CWE190_Integer_Overflow__short_rand_square_83_goodG2B()
short result = data * data ;
printIntLine ( result );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
0
------------------------------
17903 CVE-2016-5275/Firefox_49.0b1_CVE_2016_5275_dom_canvas_CanvasRenderingContext2D.cpp cy = y3 - anx * aRadius * ( anticlockwise ? 1 : - 1 ) 5937

CanvasPath::ArcTo(double aX1, double aY1, double aX2, double aY2, double
ErrorResult& aError)
if ( aRadius < 0 )
Point p0 = mPathBuilder -> CurrentPoint ( ) ;
Point p1 ( aX1 , aY1 ) ;
Point p2 ( aX2 , aY2 ) ;
double dir , a2 , b2 , c2 , cosx , sinx , d , anx , any , bnx , bny , x3 , y3 , x4 , y4 , cx , cy , angle0 , angle1 ;
bool anticlockwise ;
if ( p0 == p1 || p1 == p2 || aRadius == 0 )
dir = ( p2 . x - p1 . x ) * ( p0 . y - p1 . y ) + ( p2 . y - p1 . y ) * ( p1 . x - p0 . x );
if ( dir == 0 )
a2 = ( p0 . x - aX1 ) * ( p0 . x - aX1 ) + ( p0 . y - aY1 ) * ( p0 . y - aY1 );
b2 = ( aX1 - aX2 ) * ( aX1 - aX2 ) + ( aY1 - aY2 ) * ( aY1 - aY2 );
c2 = ( p0 . x - aX2 ) * ( p0 . x - aX2 ) + ( p0 . y - aY2 ) * ( p0 . y - aY2 );
cosx = ( a2 + b2 - c2 ) / ( 2 * sqrt ( a2 * b2 ) );
sinx = sqrt ( 1 - cosx * cosx );
d = aRadius / ( ( 1 - cosx ) / sinx );
anx = ( aX1 - p0 . x ) / sqrt ( a2 );
any = ( aY1 - p0 . y ) / sqrt ( a2 );
y3 = aY1 - any * d;
anticlockwise = ( dir < 0 );
cy = y3 - anx * aRadius * ( anticlockwise ? 1 : - 1 );
angle0 = atan2 ( ( y3 - cy ) , ( x3 - cx ) );
angle1 = atan2 ( ( y4 - cy ) , ( x4 - cx ) );
Arc ( cx , cy , aRadius , angle0 , angle1 , anticlockwise , aError );
0
------------------------------
298250 95156/CWE369_Divide_by_Zero__int_fscanf_divide_03.c printIntLine ( 100 / data ) 35
void CWE369_Divide_by_Zero__int_fscanf_divide_03_bad()
int data ;
data = - 1;
if ( 5 == 5 )
printIntLine ( 100 / data );
1
------------------------------
19858 CVE-2016-2522/Wireshark_2.0.1_CVE_2016_2522_epan_dissectors_packet-ber.c causex = proto_tree_add_string_format_value ( tree , hf_ber_error , tvb , offset - 2 , 2 , "illegal_length" , "%s Of ate %d too many bytes" , ( type == BER_UNI_TAG_SEQUENCE ) ? "Set" : "Sequence" , offset - end_offset ) 3521

dissect_ber_sequence_of(gboolean implicit_tag, asn1_ctx_t *actx, proto_tree *parent_tree, tvbuff_t *tvb, int offset, const ber_sequence_t *seq, gint hf_id, gint ett_id)
return dissect_ber_sq_of ( implicit_tag , BER_UNI_TAG_SEQUENCE , actx , parent_tree , tvb , offset , NO_BOUND , NO_BOUND , seq , hf_id , ett_id ) ;
static
dissect_ber_sq_of(gboolean implicit_tag, gint32 type, asn1_ctx_t *actx, proto_tree *parent_tree, tvbuff_t *tvb, int offset, gint32 min_len, gint32 max_len, const ber_sequence_t *seq, gint hf_id, gint ett_id)
gint8 classx ;
gboolean pcx , ind = FALSE , ind_field ;
gint32 tagx ;
guint32 lenx ;
proto_tree * tree = parent_tree ;
proto_item * causex ;
int cnt , hoffsetx , end_offset ;
gboolean have_cnt ;
header_field_info * hfi ;
if ( ! implicit_tag )
offset = dissect_ber_identifier ( actx -> pinfo , tree , tvb , offset , & classx , & pcx , & tagx );
offset = dissect_ber_length ( actx -> pinfo , tree , tvb , offset , & lenx , & ind );
end_offset = offset + lenx;
if ( ( classx != BER_CLASS_APP ) && ( classx != BER_CLASS_PRI ) )
if ( ! pcx || ( ! implicit_tag && ( ( classx != BER_CLASS_UNI ) || ( tagx != type ) ) ) )
lenx = tvb_reported_length_remaining ( tvb , offset );
end_offset = offset + lenx;
cnt = 0;
have_cnt = FALSE;
hoffsetx = offset;
if ( tvb_captured_length_remaining ( tvb , offset ) == tvb_reported_length_remaining ( tvb , offset ) )
have_cnt = TRUE;
while ( offset < end_offset )
guint32 len ;
gint s_offset ;
s_offset = offset;
if ( ( tvb_get_guint8 ( tvb , offset ) == 0 ) && ( tvb_get_guint8 ( tvb , offset + 1 ) == 0 ) )
offset = get_ber_identifier ( tvb , offset , NULL , NULL , NULL );
offset = get_ber_length ( tvb , offset , & len , & ind );
offset += len;
cnt ++;
if ( offset <= s_offset )
have_cnt = FALSE;
cnt = 0;
offset = hoffsetx;
if ( hf_id >= 0 )
hfi = proto_registrar_get_nth ( hf_id );
if ( parent_tree )
if ( hfi -> type == FT_NONE )
item = proto_tree_add_item ( parent_tree , hf_id , tvb , offset , lenx , ENC_BIG_ENDIAN );
if ( have_cnt )
item = proto_tree_add_uint ( parent_tree , hf_id , tvb , offset , lenx , cnt );
item = proto_tree_add_uint_format_value ( parent_tree , hf_id , tvb , offset , lenx , cnt , "unknown number of items" );
tree = proto_item_add_subtree ( item , ett_id );
while ( offset < end_offset )
gint8 ber_class ;
gint32 tag ;
guint32 len ;
int eoffset ;
if ( ( tvb_get_guint8 ( tvb , offset ) == 0 ) && ( tvb_get_guint8 ( tvb , offset + 1 ) == 0 ) )
offset = get_ber_identifier ( tvb , offset , & ber_class , & pc , & tag );
offset = get_ber_length ( tvb , offset , & len , & ind_field );
eoffset = offset + len;
if ( ( ber_class == BER_CLASS_UNI ) && ( tag == BER_UNI_TAG_EOC ) )
if ( seq -> ber_class != BER_CLASS_ANY )
if ( ( seq -> ber_class != ber_class ) || ( seq -> tag != tag ) )
if ( ! ( seq -> flags & BER_FLAGS_NOTCHKTAG ) )
offset = eoffset;
offset = eoffset;
if ( offset != end_offset )
causex = proto_tree_add_string_format_value ( tree , hf_ber_error , tvb , offset - 2 , 2 , "illegal_length" , "%s Of ate %d too many bytes" , ( type == BER_UNI_TAG_SEQUENCE ) ? "Set" : "Sequence" , offset - end_offset );
expert_add_info_format ( actx -> pinfo , causex , & ei_ber_error_length , "BER Error:too many byte in %s" , ( type == BER_UNI_TAG_SEQUENCE ) ? "Set" : "Sequence" );
1
------------------------------
300307 122627/CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnlp_45.c recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 ) 121
void CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnlp_45_bad()
wchar_t * data ;
wchar_t dataBuffer [ 100 ] = L ""
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
19809 CVE-2016-2522/Wireshark_2.0.1_CVE_2016_2522_epan_dissectors_packet-ber.c end_offset = offset + val_length 2082

dissect_ber_GeneralizedTime(gboolean implicit_tag, asn1_ctx_t *actx, proto_tree *tree, tvbuff_t *tvb, int offset, gint hf_id)
gint8 ber_class ;
gboolean pc ;
gint32 tag ;
guint32 len ;
int hoffset ;
proto_item * cause ;
if ( ! implicit_tag )
hoffset = offset;
offset = dissect_ber_identifier ( actx -> pinfo , tree , tvb , offset , & ber_class , & pc , & tag );
offset = dissect_ber_length ( actx -> pinfo , tree , tvb , offset , & len , NULL );
if ( ( ber_class != BER_CLASS_UNI ) || ( tag != BER_UNI_TAG_GeneralizedTime ) )
cause = proto_tree_add_string_format_value ( tree , hf_ber_error , tvb , offset , len , "generalized_time_expected" , "GeneralizedTime expected but class:%s(%d) %s tag:%d was unexpected" , val_to_str_const ( ber_class , ber_class_codes , "Unknown" ) , ber_class , pc ? ber_pc_codes_short . true_string : ber_pc_codes_short . false_string , tag );
if ( decode_unexpected )
proto_tree * unknown_tree = proto_item_add_subtree ( cause , ett_ber_unknown ) ;
dissect_unknown_ber ( actx -> pinfo , tvb , hoffset , unknown_tree );

dissect_unknown_ber(packet_info *pinfo, tvbuff_t *tvb, int offset, proto_tree *tree)
return try_dissect_unknown_ber ( pinfo , tvb , offset , tree , 1 ) ;
static
try_dissect_unknown_ber(packet_info *pinfo, tvbuff_t *tvb, volatile int offset, proto_tree *tree, gint nest_level)
int start_offset ;
gint8 ber_class ;
gboolean pc , ind ;
gint32 tag ;
guint32 len ;
start_offset = offset;
offset = get_ber_identifier ( tvb , offset , & ber_class , & pc , & tag );
offset = get_ber_length ( tvb , offset , & len , & ind );
if ( len > ( guint32 ) tvb_reported_length_remaining ( tvb , offset ) )
switch ( pc )
switch ( ber_class )
switch ( tag )
offset = dissect_ber_real ( FALSE , & asn1_ctx , tree , tvb , start_offset , hf_ber_unknown_REAL , NULL );

dissect_ber_real(gboolean implicit_tag, asn1_ctx_t *actx, proto_tree *tree, tvbuff_t *tvb, int offset, gint hf_id _U_, double *value)
guint32 val_length = 0 , len_remain , end_offset ;
if ( ! implicit_tag )
offset = dissect_ber_identifier ( actx -> pinfo , tree , tvb , offset , & ber_class , & pc , & tag );
offset = dissect_ber_length ( actx -> pinfo , tree , tvb , offset , & val_length , NULL );
end_offset = offset + val_length;
actx -> created_item = proto_tree_add_double ( tree , hf_id , tvb , end_offset - val_length , val_length , val );
return end_offset ;
1
------------------------------
20826 CVE-2016-1957/Firefox_44.0b9_CVE_2016_1957_media_libstagefright_frameworks_av_media_libstagefright_MPEG4Extractor.cpp mBuffer -> meta_data ( ) -> setInt64 ( kKeyDecodingTime , ( ( int64_t ) dts * 1000000 ) / mTimescale ) 3673
status_t
MediaBuffer **out, const ReadOptions *options)
if ( mFirstMoofOffset > 0 )
int64_t seekTimeUs ;
ReadOptions :: SeekMode mode ;
if ( options && options -> getSeekTo ( & seekTimeUs , & mode ) )
uint32_t findFlags = 0 ;
switch ( mode )
findFlags = SampleTable :: kFlagBefore;
findFlags = SampleTable :: kFlagAfter;
findFlags = SampleTable :: kFlagClosest;
uint32_t sampleIndex ;
status_t err = mSampleTable -> findSampleAtTime ( seekTimeUs * mTimescale / 1000000 , & sampleIndex , findFlags ) ;
if ( mode == ReadOptions :: SEEK_CLOSEST )
findFlags = SampleTable :: kFlagBefore;
uint32_t syncSampleIndex ;
if ( err == OK )
err = mSampleTable -> findSyncSampleNear ( sampleIndex , & syncSampleIndex , findFlags );
if ( err == OK )
err = mSampleTable -> getMetaDataForSample ( sampleIndex , NULL , NULL , & sampleTime );
if ( err != OK )
if ( mode == ReadOptions :: SEEK_CLOSEST )
if ( ! mTimescale )
mCurrentSampleIndex = syncSampleIndex;
if ( mBuffer != NULL )
mBuffer = NULL;
off64_t offset = 0 ;
size_t size = 0 ;
uint32_t dts = 0 ;
bool newBuffer = false ;
if ( mBuffer == NULL )
newBuffer = true;
status_t err = mSampleTable -> getMetaDataForSample ( mCurrentSampleIndex , & offset , & size , & cts , & duration , & isSyncSample , & dts ) ;
if ( err != OK )
int32_t max_size ;
mBuffer = new MediaBuffer ( std :: min ( max_size , 1024 * 1024 ) );
if ( ! mIsAVC || mWantsNALFragments )
if ( newBuffer )
if ( ! ensureMediaBufferAllocated ( size ) )
ssize_t num_bytes_read = mDataSource -> readAt ( offset , ( uint8_t * ) mBuffer -> data ( ) , size ) ;
if ( num_bytes_read < ( ssize_t ) size )
mBuffer = NULL;
if ( ! mTimescale )
mBuffer -> meta_data ( ) -> setInt64 ( kKeyDecodingTime , ( ( int64_t ) dts * 1000000 ) / mTimescale );
0
------------------------------
16313 CVE-2015-3813/CVE_2015_3813_PATCHED_fragment_add_work.c fd_head -> error = "dfpos - offset > len" 263
static
CVE_2015_3813_PATCHED_fragment_add_work(fragment_head *fd_head, tvbuff_t *tvb, const int
const packet_info *pinfo, const guint32
const guint32 frag_data_len, const gboolean more_frags)
fragment_item * fd ;
fragment_item * fd_i ;
guint32 max , dfpos , fraglen ;
guint8 * data ;
fd = g_slice_new ( fragment_item );
fd -> next = NULL;
fd -> flags = 0;
fd -> frame = pinfo -> fd -> num;
fd -> offset = frag_offset;
fd -> fragment_nr_offset = 0;
fd -> len = frag_data_len;
fd -> tvb_data = NULL;
fd -> error = NULL;
if ( fd_head -> flags & FD_DEFRAGMENTED )
if ( frag_offset + frag_data_len >= fd_head -> datalen )
if ( fd_head -> flags & FD_PARTIAL_REASSEMBLY )
for(fd_i=fd_head->next; fd_i; fd_i=fd_i->next)
if ( ! fd_i -> tvb_data )
fd_i -> tvb_data = tvb_new_subset_remaining ( fd_head -> tvb_data , fd_i -> offset );
fd_i -> flags |= FD_SUBSET_TVB;
fd_i -> flags &= ( ~FD_TOOLONGFRAGMENT ) & ( ~FD_MULTIPLETAILS );
fd_head -> flags &= ~ ( FD_DEFRAGMENTED | FD_PARTIAL_REASSEMBLY | FD_DATALEN_SET );
fd_head -> flags &= ( ~FD_TOOLONGFRAGMENT ) & ( ~FD_MULTIPLETAILS );
fd_head -> datalen = 0;
fd_head -> reassembled_in = 0;
if ( fd -> frame > fd_head -> frame )
fd_head -> frame = fd -> frame;
if ( ! more_frags )
if ( fd_head -> flags & FD_DATALEN_SET )
if ( fd_head -> datalen != ( fd -> offset + fd -> len ) )
fd_head -> flags |= FD_MULTIPLETAILS;
fd_head -> datalen = fd -> offset + fd -> len;
fd_head -> flags |= FD_DATALEN_SET;
if ( fd_head -> flags & FD_DEFRAGMENTED )
if ( ! ( fd_head -> flags & FD_DATALEN_SET ) )
max = 0;
for (fd_i=fd_head->next;fd_i;fd_i=fd_i->next)
if ( ( ( fd_i -> offset ) <= max ) && ( ( fd_i -> offset + fd_i -> len ) > max ) )
max = fd_i -> offset + fd_i -> len;
if ( max < ( fd_head -> datalen ) )
data = ( guint8 * ) g_malloc ( fd_head -> datalen );
fd_head -> tvb_data = tvb_new_real_data ( data , fd_head -> datalen , fd_head -> datalen );
for (dfpos=0,fd_i=fd_head;fd_i;fd_i=fd_i->next)
if ( fd_i -> len )
if ( fd_i -> offset + fd_i -> len > dfpos )
if ( fd_i -> offset >= fd_head -> datalen )
fd_i -> flags |= FD_TOOLONGFRAGMENT;
fd_head -> flags |= FD_TOOLONGFRAGMENT;
if ( dfpos < fd_i -> offset )
fd_head -> error = "dfpos < offset";
if ( dfpos - fd_i -> offset > fd_i -> len )
fd_head -> error = "dfpos - offset > len";
if ( ! fd_head -> tvb_data )
fd_head -> error = "no data";
fraglen = fd_i -> len;
if ( fd_i -> offset + fraglen > fd_head -> datalen )
fd_i -> flags |= FD_TOOLONGFRAGMENT;
fd_head -> flags |= FD_TOOLONGFRAGMENT;
fraglen = fd_head -> datalen - fd_i -> offset;
if ( fd_i -> offset < dfpos )
guint32 cmp_len = MIN ( fd_i -> len , ( dfpos - fd_i -> offset ) ) ;
fd_i -> flags |= FD_OVERLAP;
fd_head -> flags |= FD_OVERLAP;
if ( memcmp ( data + fd_i -> offset , tvb_get_ptr ( fd_i -> tvb_data , 0 , cmp_len ) , cmp_len ) )
fd_i -> flags |= FD_OVERLAPCONFLICT;
fd_head -> flags |= FD_OVERLAPCONFLICT;
if ( fraglen < dfpos - fd_i -> offset )
fd_head -> error = "fraglen < dfpos - offset";
dfpos = MAX ( dfpos , ( fd_i -> offset + fraglen ) );
if ( fd_i -> offset + fd_i -> len < fd_i -> offset )
fd_head -> error = "offset + len < offset";
if ( fd_i -> flags & FD_SUBSET_TVB )
fd_i -> flags &= ~FD_SUBSET_TVB;
fd_i -> tvb_data = NULL;
0
------------------------------
300132 150144/stream.c eol_pos = ( strstr ( ( str -> data + str -> len - numbytes - ( eol_len - 1 ) ) , eol ) ) 591
svn_error_t *svn_stream_readline(svn_stream_t *stream,svn_stringbuf_t **stringbuf,const char *eol,svn_boolean_t *eof,apr_pool_t *pool)
return stream_readline ( stringbuf , eof , eol , stream , pool ) ;
static svn_error_t *stream_readline(svn_stringbuf_t **stringbuf,svn_boolean_t *eof,const char *eol,svn_stream_t *stream,apr_pool_t *pool)
* eof = 0;
if ( svn_stream_supports_mark ( stream ) && svn_stream__is_buffered ( stream ) )
svn_boolean_t svn_stream__is_buffered(svn_stream_t *stream)
if ( stream -> is_buffered_fn == ( ( void * ) 0 ) )
return 0 ;
return ( stream -> is_buffered_fn ) ( stream -> baton ) ;
svn_boolean_t svn_stream_supports_mark(svn_stream_t *stream)
return stream -> mark_fn != ( ( void * ) 0 ) ;
svn_error_t * svn_err__temp = stream_readline_chunky ( stringbuf , eof , eol , stream , pool ) ;
if ( svn_err__temp )
while ( 0 )
static svn_error_t *stream_readline_chunky(svn_stringbuf_t **stringbuf,svn_boolean_t *eof,const char *eol,svn_stream_t *stream,apr_pool_t *pool)
char buffer [ 80 + 1 ] ;
apr_size_t numbytes ;
const char * eol_pos ;
const size_t eol_len = strlen ( eol ) ;
svn_error_t * svn_err__temp = svn_stream_mark ( stream , & mark , pool ) ;
svn_error_t *svn_stream_mark(svn_stream_t *stream,svn_stream_mark_t **mark,apr_pool_t *pool)
if ( stream -> mark_fn == ( ( void * ) 0 ) )
return svn_error_create ( SVN_ERR_STREAM_SEEK_NOT_SUPPORTED , ( ( void * ) 0 ) , ( ( void * ) 0 ) ) ;
return ( stream -> mark_fn ) ( stream -> baton , mark , pool ) ;
if ( svn_err__temp )
while ( 0 )
numbytes = 80;
svn_error_t * svn_err__temp = svn_stream_read ( stream , buffer , & numbytes ) ;
svn_error_t *svn_stream_read(svn_stream_t *stream,char *buffer,apr_size_t *len)
if ( ! ( stream -> read_fn != ( ( void * ) 0 ) ) )
svn_error_t * svn_err__temp = svn_error__malfunction ( ! 0 , "stream.c" , 143 , "stream->read_fn != NULL" ) ;
if ( svn_err__temp )
return svn_err__temp ;
while ( 0 )
while ( 0 )
return ( stream -> read_fn ) ( stream -> baton , buffer , len ) ;
if ( svn_err__temp )
while ( 0 )
buffer [ numbytes ] = '\0';
eol_pos = ( strstr ( buffer , eol ) );
if ( eol_pos != ( ( void * ) 0 ) )
if ( numbytes < 80 )
svn_stringbuf_t * str ;
str = svn_stringbuf_create_ensure ( ( 2 * 80 ) , pool );
numbytes = 80;
svn_error_t * svn_err__temp = svn_stream_read ( stream , str -> data + str -> len , & numbytes ) ;
svn_error_t *svn_stream_read(svn_stream_t *stream,char *buffer,apr_size_t *len)
if ( ! ( stream -> read_fn != ( ( void * ) 0 ) ) )
svn_error_t * svn_err__temp = svn_error__malfunction ( ! 0 , "stream.c" , 143 , "stream->read_fn != NULL" ) ;
if ( svn_err__temp )
return svn_err__temp ;
while ( 0 )
while ( 0 )
return ( stream -> read_fn ) ( stream -> baton , buffer , len ) ;
if ( svn_err__temp )
while ( 0 )
str -> len += numbytes;
str -> data [ str -> len ] = '\0';
eol_pos = ( strstr ( ( str -> data + str -> len - numbytes - ( eol_len - 1 ) ) , eol ) );
if ( numbytes < 80 && eol_pos == ( ( void * ) 0 ) )
while ( eol_pos == ( ( void * ) 0 ) )
total_parsed = ( eol_pos - ( str -> data ) ) + eol_len;
str -> len = ( eol_pos - ( str -> data ) );
str -> data [ str -> len ] = 0;
return svn_stream_skip ( stream , total_parsed ) ;
svn_error_t *svn_stream_skip(svn_stream_t *stream,apr_size_t len)
if ( stream -> skip_fn == ( ( void * ) 0 ) )
return skip_default_handler ( stream -> baton , len , stream -> read_fn ) ;
static svn_error_t *skip_default_handler(void *baton,apr_size_t len,svn_read_fn_t read_fn)
apr_size_t to_read = len ;
while ( to_read > 0 && bytes_read > 0 )
bytes_read = ( sizeof ( buffer ) < to_read ? sizeof ( buffer ) : to_read );
svn_error_t * svn_err__temp = read_fn ( baton , buffer , & bytes_read ) ;
if ( svn_err__temp )
return svn_err__temp ;
to_read -= bytes_read;
return ( stream -> skip_fn ) ( stream -> baton , len ) ;
0
------------------------------
300330 151004/xact.c new_childXids = ( MemoryContextAlloc ( TopTransactionContext , new_maxChildXids * sizeof ( TransactionId ) ) ) 1320
static void AtSubCommit_childXids()
TransactionState s = CurrentTransactionState ;
int new_nChildXids ;
new_nChildXids = s -> parent -> nChildXids + s -> nChildXids + 1;
if ( s -> parent -> maxChildXids < new_nChildXids )
int new_maxChildXids ;
TransactionId * new_childXids ;
new_maxChildXids = ( new_nChildXids * 2 < ( ( int ) ( ( ( Size ) 0x3fffffff ) / sizeof ( TransactionId ) ) ) ? new_nChildXids * 2 : ( ( int ) ( ( ( Size ) 0x3fffffff ) / sizeof ( TransactionId ) ) ) );
if ( s -> parent -> childXids == ( ( void * ) 0 ) )
new_childXids = ( MemoryContextAlloc ( TopTransactionContext , new_maxChildXids * sizeof ( TransactionId ) ) );
s -> parent -> childXids = new_childXids;
s -> parent -> maxChildXids = new_maxChildXids;
s -> parent -> childXids [ s -> parent -> nChildXids ] = s -> transactionId;
if ( s -> nChildXids > 0 )
memcpy ( ( & s -> parent -> childXids [ s -> parent -> nChildXids + 1 ] ) , ( s -> childXids ) , ( s -> nChildXids ) * sizeof ( TransactionId ) );
s -> parent -> nChildXids = new_nChildXids;
if ( s -> childXids != ( ( void * ) 0 ) )
pfree ( ( s -> childXids ) );
s -> childXids = ( ( void * ) 0 );
s -> nChildXids = 0;
s -> maxChildXids = 0;
0
------------------------------
301636 151549/aviobuf.c s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_ptr - s -> checksum_ptr ) ) ) 199
void avio_wb24(AVIOContext *s,unsigned int val)
avio_w8 ( s , ( ( uint8_t ) val ) );
void avio_w8(AVIOContext *s,int b)
* ( s -> buf_ptr ++ ) = b;
if ( s -> buf_ptr >= s -> buf_end )
flush_buffer ( s );
static void flush_buffer(AVIOContext *s)
if ( s -> buf_ptr > s -> buffer )
if ( s -> update_checksum )
s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_ptr - s -> checksum_ptr ) ) );
s -> checksum_ptr = s -> buffer;
s -> buf_ptr = s -> buffer;
0
------------------------------
307775 110503/CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fscanf_84_bad.cpp intPointer = ( int * ) malloc ( data * sizeof ( int ) ) 37
void bad()
int data ;
data = - 1;
CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fscanf_84_bad * badObject = new CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fscanf_84_bad ( data ) ;
CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fscanf_84_bad::CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fscanf_84_bad(int dataCopy)
data = dataCopy;
fscanf ( stdin , "%d" , & data );
delete badObject
CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fscanf_84_bad::~CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fscanf_84_bad()
int * intPointer ;
intPointer = ( int * ) malloc ( data * sizeof ( int ) );
intPointer [ i ] = 0;
printIntLine ( intPointer [ 0 ] );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
free ( intPointer );
1
------------------------------
305634 118092/CWE78_OS_Command_Injection__char_connect_socket_system_06.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 103
void CWE78_OS_Command_Injection__char_connect_socket_system_06_bad()
char * data ;
char data_buf [ 100 ] = FULL_COMMAND ;
data = data_buf;
if ( STATIC_CONST_FIVE == 5 )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
if ( SYSTEM ( data ) <= 0 )
1
------------------------------
18262 CVE-2015-5154/Xen_4.5.0_CVE-2015-5154_ide.c l = s -> io_buffer_size - s -> io_buffer_index 1142
static void ide_atapi_cmd_read_dma_cb(void *opaque, int ret)
BMDMAState * bm = opaque ;
IDEState * s = bm -> ide_if ;
if ( ! s -> bs )
if ( ret < 0 )
if ( s -> io_buffer_size > 0 )
if ( dma_buf_rw ( bm , 1 ) == 0 )
static int dma_buf_rw(BMDMAState *bm, int is_write)
IDEState * s = bm -> ide_if ;
struct { uint32_t addr ; uint32_t size ; } prd ;
int l , len ;
l = s -> io_buffer_size - s -> io_buffer_index;
if ( l <= 0 )
if ( bm -> cur_prd_len == 0 )
if ( bm -> cur_prd_last || ( bm -> cur_addr - bm -> addr ) >= 4096 )
cpu_physical_memory_read ( bm -> cur_addr , ( uint8_t * ) & prd , 8 );
bm -> cur_addr += 8;
prd . addr = le32_to_cpu ( prd . addr );
prd . size = le32_to_cpu ( prd . size );
len = prd . size & 0xfffe;
if ( len == 0 )
len = 0x10000;
bm -> cur_prd_len = len;
bm -> cur_prd_addr = prd . addr;
bm -> cur_prd_last = ( prd . size & 0x80000000 );
if ( l > bm -> cur_prd_len )
l = bm -> cur_prd_len;
if ( l > 0 )
cpu_physical_memory_write ( bm -> cur_prd_addr , s -> io_buffer + s -> io_buffer_index , l );
cpu_physical_memory_read ( bm -> cur_prd_addr , s -> io_buffer + s -> io_buffer_index , l );
bm -> cur_prd_addr += l;
bm -> cur_prd_len -= l;
s -> io_buffer_index += l;
0
------------------------------
310220 152667/dfa.c size_t mid = lo + hi >> 1 ; 2234
char *dfaexec(struct dfa *d,const char *begin,char *end,int allow_nl,size_t *count,int *backref)
state_num s ;
state_num s1 ;
const unsigned char * p ;
state_num * * trans ;
state_num * t ;
unsigned char eol = eolbyte ;
s = s1 = 0;
p = ( ( const unsigned char * ) begin );
trans = d -> trans;
* end = eol;
if ( d -> mb_cur_max > 1 )
while ( ( t = trans [ s ] ) != ( ( void * ) 0 ) )
if ( p > buf_end )
s1 = s;
if ( s == 0 )
if ( ( ( char * ) p ) >= end )
if ( d -> states [ s ] . mbps . nelem == 0 )
s = t [ * ( p ++ ) ];
if ( backref )
s = transit_state ( d , s , & p );
trans = d -> trans;
while ( ( t = trans [ s ] ) != ( ( void * ) 0 ) )
s1 = t [ * ( p ++ ) ];
if ( ( t = trans [ s1 ] ) == ( ( void * ) 0 ) )
state_num tmp = s ;
s = s1;
s1 = tmp;
s = t [ * ( p ++ ) ];
if ( s >= 0 && ( ( char * ) p ) <= end && d -> fails [ s ] )
if ( d -> success [ s ] & sbit [ * p ] )
s1 = s;
if ( d -> mb_cur_max > 1 )
s = transit_state ( d , s , & p );
trans = d -> trans;
s = d -> fails [ s ] [ * ( p ++ ) ];
if ( ( ( char * ) p ) > end )
if ( s >= 0 )
trans = d -> trans;
if ( p [ - 1 ] == eol && allow_nl )
s = d -> newlines [ s1 ];
s = 0;
static state_num transit_state(struct dfa *d,state_num s,const unsigned char **pp)
state_num s1 ;
int mbclen ;
int maxlen = 0 ;
size_t i ;
size_t j ;
int * match_lens = ( ( void * ) 0 ) ;
size_t nelem = d -> states [ s ] . mbps . nelem ;
position_set follows ;
const unsigned char * p1 = * pp ;
wchar_t wc ;
if ( nelem > 0 )
match_lens = check_matching_with_multibyte_ops ( d , s , ( * pp - buf_begin ) );
for (i = 0; i < nelem; i++)
if ( match_lens [ i ] > maxlen )
maxlen = match_lens [ i ];
if ( nelem == 0 || maxlen == 0 )
wc = inputwcs [ * pp - mbclen - buf_begin ];
s1 = state_index ( d , ( & follows ) , wchar_context ( wc ) );
while ( * pp - p1 < maxlen )
for (i = 0; i < nelem; i++)
if ( match_lens [ i ] == * pp - p1 )
for (j = 0; j < d -> follows[d -> states[s1] . mbps . elems[i] . index] . nelem; j++)
insert ( d -> follows [ d -> states [ s1 ] . mbps . elems [ i ] . index ] . elems [ j ] , & follows );
wc = inputwcs [ * pp - mbclen - buf_begin ];
s1 = state_index ( d , ( & follows ) , wchar_context ( wc ) );
static void insert(position p,position_set *s)
size_t count = s -> nelem ;
size_t lo = 0 ;
size_t hi = count ;
while ( lo < hi )
size_t mid = lo + hi >> 1 ;
if ( s -> elems [ mid ] . index > p . index )
lo = mid + 1;
hi = mid;
if ( lo < count && p . index == s -> elems [ lo ] . index )
s -> elems [ lo ] . constraint |= p . constraint;
for (i = count; i > lo; i--)
s -> elems [ lo ] = p;
++ s -> nelem;
0
------------------------------
311557 122358/CWE78_OS_Command_Injection__wchar_t_listen_socket_execlp_84_bad.cpp recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 ) 98
void bad()
wchar_t * data ;
wchar_t dataBuffer [ 100 ] = L ""
data = dataBuffer;
CWE78_OS_Command_Injection__wchar_t_listen_socket_execlp_84_bad * badObject = new CWE78_OS_Command_Injection__wchar_t_listen_socket_execlp_84_bad ( data ) ;
CWE78_OS_Command_Injection__wchar_t_listen_socket_execlp_84_bad::CWE78_OS_Command_Injection__wchar_t_listen_socket_execlp_84_bad(wchar_t * dataCopy)
data = dataCopy;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
307053 112808/CWE761_Free_Pointer_Not_at_Start_of_Buffer__wchar_t_connect_socket_02.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 ) 87
void CWE761_Free_Pointer_Not_at_Start_of_Buffer__wchar_t_connect_socket_02_bad()
wchar_t * data ;
data = ( wchar_t * ) malloc ( 100 * sizeof ( wchar_t ) );
data [ 0 ] = L '\0'
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
312764 117249/CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_connect_socket_43.cpp myString = ( wchar_t * ) malloc ( data * sizeof ( wchar_t ) ) 126
void bad()
size_t data ;
data = 0;
wchar_t * myString ;
if ( data > wcslen ( HELLO_STRING ) )
myString = ( wchar_t * ) malloc ( data * sizeof ( wchar_t ) );
wcscpy ( myString , HELLO_STRING );
printWLine ( myString );
void printWLine (const wchar_t * line)
if ( line != NULL )
wprintf ( L "%ls\n" , line )
free ( myString );
1
------------------------------
303482 84539/CWE190_Integer_Overflow__unsigned_int_max_square_51b.c unsigned int result = data * data ; 28
void CWE190_Integer_Overflow__unsigned_int_max_square_51_bad()
unsigned int data ;
data = 0;
data = UINT_MAX;
CWE190_Integer_Overflow__unsigned_int_max_square_51b_badSink ( data );
void CWE190_Integer_Overflow__unsigned_int_max_square_51b_badSink(unsigned int data)
unsigned int result = data * data ;
printUnsignedLine ( result );
void printUnsignedLine(unsigned unsignedNumber)
printf ( "%u\n" , unsignedNumber );
1
------------------------------
303875 81787/CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_snprintf_02.c recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 ) 104
void CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_snprintf_02_bad()
wchar_t * data ;
wchar_t dataBuffer [ 100 ] = L ""
data = dataBuffer;
if ( 1 )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
305519 62152/CWE114_Process_Control__w32_char_listen_socket_31.c recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 94
void CWE114_Process_Control__w32_char_listen_socket_31_bad()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
char * dataCopy = data ;
char * data = dataCopy ;
hModule = LoadLibraryA ( data );
if ( hModule != NULL )
FreeLibrary ( hModule );
1
------------------------------
298151 95074/CWE369_Divide_by_Zero__int_fgets_divide_17.c printIntLine ( 100 / data ) 49
void CWE369_Divide_by_Zero__int_fgets_divide_17_bad()
int i , j ;
int data ;
data = - 1;
for(i = 0; i < 1; i++)
char inputBuffer [ CHAR_ARRAY_SIZE ] = "" ;
if ( fgets ( inputBuffer , CHAR_ARRAY_SIZE , stdin ) != NULL )
data = atoi ( inputBuffer );
for(j = 0; j < 1; j++)
printIntLine ( 100 / data );
1
------------------------------
306878 120757/CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_spawnvp_52a.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 ) 104
void CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_spawnvp_52_bad()
wchar_t * data ;
wchar_t dataBuffer [ 100 ] = L ""
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
313238 95682/CWE36_Absolute_Path_Traversal__char_connect_socket_open_01.cpp recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ) 98
void bad()
char * data ;
char dataBuffer [ FILENAME_MAX ] = "" ;
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
fileDesc = OPEN ( data , O_RDWR | O_CREAT , S_IREAD | S_IWRITE );
if ( fileDesc != - 1 )
CLOSE ( fileDesc );
1
------------------------------
20672 CVE-2016-8910/qemu_2.3.0_CVE-2016-8910_rtl8139.c uint8_t * data_to_checksum = eth_payload_data + hlen - 12 ; 2326
static void rtl8139_io_writel(void *opaque, uint8_t addr, uint32_t val)
switch ( addr )
rtl8139_io_writeb ( opaque , addr , val & 0xff );
static void rtl8139_io_writeb(void *opaque, uint8_t addr, uint32_t val)
RTL8139State * s = opaque ;
switch ( addr )
if ( val == 'R' )
if ( val == 'H' )
s -> clock_enabled = 0;
s -> TxThresh = val;
if ( val & ( 1 << 6 ) )
rtl8139_cplus_transmit ( s );
static void rtl8139_cplus_transmit(RTL8139State *s)
while ( rtl8139_cplus_transmit_one ( s ) )
static int rtl8139_cplus_transmit_one(RTL8139State *s)
if ( ! rtl8139_transmitter_enabled ( s ) )
if ( ! rtl8139_cp_transmitter_enabled ( s ) )
uint32_t val , txdw0 , txdw1 , txbufLO , txbufHI ;
txdw0 = le32_to_cpu ( val );
if ( ! ( txdw0 & CP_TX_OWN ) )
if ( txdw0 & CP_TX_FS )
s -> cplus_txbuffer_offset = 0;
int txsize = txdw0 & CP_TX_BUFFER_SIZE_MASK ;
if ( ! s -> cplus_txbuffer )
s -> cplus_txbuffer_len = CP_TX_BUFFER_SIZE;
s -> cplus_txbuffer = g_malloc ( s -> cplus_txbuffer_len );
s -> cplus_txbuffer_offset = 0;
if ( s -> cplus_txbuffer_offset + txsize >= s -> cplus_txbuffer_len )
txsize = s -> cplus_txbuffer_len - s -> cplus_txbuffer_offset;
s -> cplus_txbuffer_offset += txsize;
if ( txdw0 & CP_TX_EOR )
s -> currCPlusTxDesc = 0;
if ( s -> currCPlusTxDesc >= 64 )
s -> currCPlusTxDesc = 0;
txdw0 &= ~CP_RX_OWN;
txdw0 &= ~CP_TX_STATUS_UNF;
txdw0 &= ~CP_TX_STATUS_TES;
txdw0 &= ~CP_TX_STATUS_OWC;
txdw0 &= ~CP_TX_STATUS_LNKF;
txdw0 &= ~CP_TX_STATUS_EXC;
if ( txdw0 & CP_TX_LS )
uint8_t * saved_buffer = s -> cplus_txbuffer ;
if ( txdw0 & ( CP_TX_IPCS | CP_TX_UDPCS | CP_TX_TCPCS | CP_TX_LGSEN ) )
ip_header * ip = NULL ;
int hlen = 0 ;
uint8_t ip_protocol = 0 ;
uint8_t * eth_payload_data = NULL ;
int proto = be16_to_cpu ( * ( uint16_t * ) ( saved_buffer + 12 ) ) ;
if ( proto == ETH_P_IP )
eth_payload_data = saved_buffer + ETH_HLEN;
ip = ( ip_header * ) eth_payload_data;
if ( IP_HEADER_VERSION ( ip ) != IP_HEADER_VERSION_4 )
ip = NULL;
hlen = IP_HEADER_LENGTH ( ip );
ip_protocol = ip -> ip_p;
if ( ip )
if ( ( txdw0 & CP_TX_LGSEN ) && ip_protocol == IP_PROTO_TCP )
if ( txdw0 & ( CP_TX_TCPCS | CP_TX_UDPCS ) )
uint8_t * data_to_checksum = eth_payload_data + hlen - 12 ;
memcpy ( data_to_checksum , saved_ip_header + 12 , 8 );
ip_pseudo_header * p_tcpip_hdr = ( ip_pseudo_header * ) data_to_checksum ;
p_tcpip_hdr -> zeros = 0;
p_tcpip_hdr -> ip_proto = IP_PROTO_TCP;
p_tcpip_hdr -> ip_payload = cpu_to_be16 ( ip_data_len );
tcp_header * p_tcp_hdr = ( tcp_header * ) ( data_to_checksum + 12 ) ;
p_tcp_hdr -> th_sum = 0;
int tcp_checksum = ip_checksum ( data_to_checksum , ip_data_len + 12 ) ;
DPRINTF ( "+++ C+ mode TCP checksum %04x\n" , tcp_checksum );
p_tcp_hdr -> th_sum = tcp_checksum;
ip_pseudo_header * p_udpip_hdr = ( ip_pseudo_header * ) data_to_checksum ;
p_udpip_hdr -> zeros = 0;
p_udpip_hdr -> ip_proto = IP_PROTO_UDP;
p_udpip_hdr -> ip_payload = cpu_to_be16 ( ip_data_len );
udp_header * p_udp_hdr = ( udp_header * ) ( data_to_checksum + 12 ) ;
p_udp_hdr -> uh_sum = 0;
int udp_checksum = ip_checksum ( data_to_checksum , ip_data_len + 12 ) ;
DPRINTF ( "+++ C+ mode UDP checksum %04x\n" , udp_checksum );
p_udp_hdr -> uh_sum = udp_checksum;
0
------------------------------
298637 95358/CWE369_Divide_by_Zero__int_rand_divide_13.c printIntLine ( 100 / data ) 35
void CWE369_Divide_by_Zero__int_rand_divide_13_bad()
int data ;
data = - 1;
if ( GLOBAL_CONST_FIVE == 5 )
data = RAND32 ( );
if ( GLOBAL_CONST_FIVE == 5 )
printIntLine ( 100 / data );
1
------------------------------
302982 79302/CWE134_Uncontrolled_Format_String__char_connect_socket_vprintf_13.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 102
void CWE134_Uncontrolled_Format_String__char_connect_socket_vprintf_13_bad()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
if ( GLOBAL_CONST_FIVE == 5 )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
badVaSinkB ( data , data );
static void badVaSinkB(char * data, ...)
va_start ( args , data );
vprintf ( data , args );
1
------------------------------
309788 152952/resowner.c owner -> catrefs = ( ( HeapTuple * ) ( MemoryContextAlloc ( TopMemoryContext , newmax * sizeof ( HeapTuple ) ) ) ) 629
void ResourceOwnerEnlargeCatCacheRefs(ResourceOwner owner)
int newmax ;
if ( owner -> ncatrefs < owner -> maxcatrefs )
if ( owner -> catrefs == ( ( void * ) 0 ) )
newmax = 16;
owner -> catrefs = ( ( HeapTuple * ) ( MemoryContextAlloc ( TopMemoryContext , newmax * sizeof ( HeapTuple ) ) ) );
owner -> maxcatrefs = newmax;
newmax = owner -> maxcatrefs * 2;
owner -> catrefs = ( ( HeapTuple * ) ( repalloc ( ( owner -> catrefs ) , newmax * sizeof ( HeapTuple ) ) ) );
owner -> maxcatrefs = newmax;
0
------------------------------
301837 151048/string.c start_address = ( str -> data + str -> len ) 543
void svn_stringbuf_appendstr(svn_stringbuf_t *targetstr,const svn_stringbuf_t *appendstr)
svn_stringbuf_appendbytes ( targetstr , ( appendstr -> data ) , appendstr -> len );
void svn_stringbuf_appendbytes(svn_stringbuf_t *str,const char *bytes,apr_size_t count)
void * start_address ;
start_address = ( str -> data + str -> len );
memcpy ( start_address , bytes , count );
0
------------------------------
304684 83513/CWE190_Integer_Overflow__int_listen_socket_square_12.c int result = data * data ; 357
static void goodG2B()
int data ;
data = 0;
if ( globalReturnsTrueOrFalse ( ) )
int globalReturnsTrueOrFalse()
return ( rand ( ) % 2 ) ;
data = 2;
data = 2;
if ( globalReturnsTrueOrFalse ( ) )
int globalReturnsTrueOrFalse()
return ( rand ( ) % 2 ) ;
int result = data * data ;
printIntLine ( result );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
0
------------------------------
301370 149948/aviobuf.c s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_ptr - s -> checksum_ptr ) ) ) 268
void ffio_fill(AVIOContext *s,int b,int count)
while ( count > 0 )
int len = ( s -> buf_end - s -> buf_ptr > count ? count : s -> buf_end - s -> buf_ptr ) ;
memset ( ( s -> buf_ptr ) , b , len );
s -> buf_ptr += len;
if ( s -> buf_ptr >= s -> buf_end )
flush_buffer ( s );
count -= len;
static void flush_buffer(AVIOContext *s)
if ( s -> buf_ptr > s -> buffer )
if ( s -> update_checksum )
s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_ptr - s -> checksum_ptr ) ) );
s -> checksum_ptr = s -> buffer;
s -> buf_ptr = s -> buffer;
0
------------------------------
309301 112780/CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_listen_socket_32.c recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 99
void CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_listen_socket_32_bad()
char * data ;
char * * dataPtr1 = & data ;
data = ( char * ) malloc ( 100 * sizeof ( char ) );
data [ 0 ] = '\0';
char * data = * dataPtr1 ;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
* dataPtr1 = data;
for (; *data != '\0'; data++)
if ( * data == SEARCH_CHAR )
free ( data );
1
------------------------------
303179 83660/CWE190_Integer_Overflow__int_max_square_15.c int result = data * data ; 87
static void goodB2G1()
int data ;
data = 0;
switch ( 6 )
data = INT_MAX;
switch ( 8 )
if ( abs ( ( long ) data ) <= ( long ) sqrt ( ( double ) INT_MAX ) )
int result = data * data ;
printIntLine ( result );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
0
------------------------------
314523 110721/CWE680_Integer_Overflow_to_Buffer_Overflow__new_fixed_42.cpp dataBytes = data * sizeof ( int ) 43
void bad()
int data ;
data = - 1;
data = badSource ( data );
static int badSource(int data)
data = INT_MAX / 2 + 2;
return data ;
size_t dataBytes , i ;
dataBytes = data * sizeof ( int );
intPointer = ( int * ) new char [ dataBytes ];
intPointer [ i ] = 0;
printIntLine ( intPointer [ 0 ] );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
delete [ ] intPointer
1
------------------------------
302166 81815/CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_snprintf_51a.c recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 ) 105
void CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_snprintf_51_bad()
wchar_t * data ;
wchar_t dataBuffer [ 100 ] = L ""
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
19671 CVE-2016-7170/qemu_2.3.0_CVE-2016-7170_vmware_vga.c src = s -> vga . vram_ptr + start 368
static void vmsvga_update_display(void *opaque)
struct vmsvga_state_s * s = opaque ;
if ( ! s -> enable )
vmsvga_update_rect_flush ( s );
static inline void vmsvga_update_rect_flush(struct vmsvga_state_s *s)
struct vmsvga_rect_s * rect ;
if ( s -> invalidated )
while ( s -> redraw_fifo_first != s -> redraw_fifo_last )
rect = & s -> redraw_fifo [ s -> redraw_fifo_first ++ ];
s -> redraw_fifo_first &= REDRAW_FIFO_LEN - 1;
vmsvga_update_rect ( s , rect -> x , rect -> y , rect -> w , rect -> h );
static inline void vmsvga_update_rect(struct vmsvga_state_s
int x, int y, int w, int h)
DisplaySurface * surface = qemu_console_surface ( s -> vga . con ) ;
int bypl ;
int start ;
uint8_t * src ;
if ( ! vmsvga_verify_rect ( surface , __func__ , x , y , w , h ) )
static inline bool vmsvga_verify_rect(DisplaySurface
const char
int x, int y, int w, int h)
if ( x < 0 )
return false ;
if ( x > SVGA_MAX_WIDTH )
return false ;
if ( w < 0 )
return false ;
if ( w > SVGA_MAX_WIDTH )
return false ;
if ( x + w > surface_width ( surface ) )
return false ;
if ( y < 0 )
return false ;
if ( y > SVGA_MAX_HEIGHT )
return false ;
if ( h < 0 )
return false ;
if ( h > SVGA_MAX_HEIGHT )
return false ;
if ( y + h > surface_height ( surface ) )
return false ;
return true ;
x = 0;
y = 0;
bypl = surface_stride ( surface );
start = surface_bytes_per_pixel ( surface ) * x + bypl * y;
src = s -> vga . vram_ptr + start;
for (line = h; line > 0; line--, src += bypl, dst += bypl)
memcpy ( dst , src , width );
0
------------------------------
299706 150226/aviobuf.c s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_ptr - s -> checksum_ptr ) ) ) 290
int avio_put_str16le(AVIOContext *s,const char *str)
const uint8_t * q = str ;
while ( * q )
uint32_t ch ;
uint16_t tmp ;
ch = ( * ( q ++ ) );
uint32_t top = ( ch & 128 ) >> 1 ;
if ( ( ch & 0xc0 ) == 0x80 )
while ( ch & top )
int tmp = ( * ( q ++ ) ) - 128 ;
if ( tmp >> 6 )
ch = ( ch << 6 ) + tmp;
top <<= 5;
ch &= ( top << 1 ) - 1;
uint32_t in = ch ;
if ( in < 0x10000 )
tmp = ( 0xD800 | in - 0x10000 >> 10 );
tmp = ( 0xDC00 | in - 0x10000 & 0x3FF );
avio_wl16 ( s , tmp );
void avio_wl16(AVIOContext *s,unsigned int val)
avio_w8 ( s , ( ( int ) val ) >> 8 );
void avio_w8(AVIOContext *s,int b)
* ( s -> buf_ptr ++ ) = b;
if ( s -> buf_ptr >= s -> buf_end )
flush_buffer ( s );
static void flush_buffer(AVIOContext *s)
if ( s -> buf_ptr > s -> buffer )
if ( s -> update_checksum )
s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_ptr - s -> checksum_ptr ) ) );
s -> checksum_ptr = s -> buffer;
s -> buf_ptr = s -> buffer;
0
------------------------------
311916 153171/dfa.c size_t mid = lo + hi >> 1 ; 2243
void dfacomp(const char *s,size_t len,struct dfa *d,int searchflag)
dfaanalyze ( d , searchflag );
void dfaanalyze(struct dfa *d,int searchflag)
position_set merged ;
d -> searchflag = searchflag;
d -> follows = ( ( sizeof ( ( * d -> follows ) ) == 1 ? xzalloc ( d -> tindex ) : xcalloc ( d -> tindex , sizeof ( ( * d -> follows ) ) ) ) );
while ( 0 )
merged . nelem = 0;
epsclosure ( & merged , d );
static void epsclosure(position_set *s,const struct dfa *d)
size_t i ;
size_t j ;
char * visited ;
position p ;
position old ;
visited = ( ( sizeof ( ( * visited ) ) == 1 ? xzalloc ( d -> tindex ) : xcalloc ( d -> tindex , sizeof ( ( * visited ) ) ) ) );
while ( 0 )
for (i = 0; i < s -> nelem; ++i)
if ( d -> tokens [ s -> elems [ i ] . index ] >= ( 1 << 8 ) && d -> tokens [ s -> elems [ i ] . index ] != BACKREF && d -> tokens [ s -> elems [ i ] . index ] != ANYCHAR && d -> tokens [ s -> elems [ i ] . index ] != MBCSET && d -> tokens [ s -> elems [ i ] . index ] < CSET )
old = s -> elems [ i ];
p . constraint = old . constraint;
if ( visited [ old . index ] )
visited [ old . index ] = 1;
switch ( d -> tokens [ old . index ] )
p . constraint &= 0x444;
p . constraint &= 0x700;
p . constraint &= 0x050;
p . constraint &= 0x202;
p . constraint &= 0x252;
p . constraint &= 0x525;
for (j = 0; j < d -> follows[old . index] . nelem; ++j)
p . index = d -> follows [ old . index ] . elems [ j ] . index;
insert ( p , s );
i = ( - 1 );
static void insert(position p,position_set *s)
size_t count = s -> nelem ;
size_t lo = 0 ;
size_t hi = count ;
while ( lo < hi )
size_t mid = lo + hi >> 1 ;
if ( s -> elems [ mid ] . index > p . index )
lo = mid + 1;
hi = mid;
if ( lo < count && p . index == s -> elems [ lo ] . index )
s -> elems [ lo ] . constraint |= p . constraint;
for (i = count; i > lo; i--)
s -> elems [ lo ] = p;
++ s -> nelem;
0
------------------------------
298865 95069/CWE369_Divide_by_Zero__int_fgets_divide_12.c printIntLine ( 100 / data ) 165
static void goodG2B()
int data ;
data = - 1;
if ( globalReturnsTrueOrFalse ( ) )
int globalReturnsTrueOrFalse()
return ( rand ( ) % 2 ) ;
data = 7;
data = 7;
if ( globalReturnsTrueOrFalse ( ) )
int globalReturnsTrueOrFalse()
return ( rand ( ) % 2 ) ;
printIntLine ( 100 / data );
0
------------------------------
304266 81975/CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_w32_vsnprintf_82a.cpp recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 ) 203
static void goodB2G()
wchar_t * data ;
wchar_t dataBuffer [ 100 ] = L ""
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
306059 105160/CWE506_Embedded_Malicious_Code__w32_screen_capture_11.c hbmScreen = CreateCompatibleBitmap ( hdcWindow , rcClient . right - rcClient . left , rcClient . bottom - rcClient . top ) 66
void CWE506_Embedded_Malicious_Code__w32_screen_capture_11_bad()
if ( globalReturnsTrue ( ) )
int globalReturnsTrue()
return 1 ;
BITMAP bmpScreen ;
RECT rcClient ;
BITMAPFILEHEADER bmfHeader ;
BITMAPINFOHEADER bmiHeader ;
DWORD dwBmpSize ;
DWORD dwSizeofDIB ;
DWORD dwBytesWritten ;
HWND hWnd = GetDesktopWindow ( ) ;
hdcWindow = GetDC ( hWnd );
if ( hdcWindow == NULL )
hdcMemDC = CreateCompatibleDC ( hdcWindow );
if ( hdcMemDC == NULL )
if ( GetClientRect ( hWnd , & rcClient ) == 0 )
hbmScreen = CreateCompatibleBitmap ( hdcWindow , rcClient . right - rcClient . left , rcClient . bottom - rcClient . top );
if ( hbmScreen == NULL )
selectResult = SelectObject ( hdcMemDC , hbmScreen );
if ( selectResult == NULL || selectResult == HGDI_ERROR )
if ( BitBlt ( hdcMemDC , 0 , 0 , rcClient . right - rcClient . left , rcClient . bottom - rcClient . top , hdcWindow , 0 , 0 , SRCCOPY ) == 0 )
if ( GetObject ( hbmScreen , sizeof ( BITMAP ) , & bmpScreen ) == 0 )
bmiHeader . biSize = sizeof ( BITMAPINFOHEADER );
bmiHeader . biWidth = bmpScreen . bmWidth;
bmiHeader . biHeight = bmpScreen . bmHeight;
bmiHeader . biPlanes = 1;
bmiHeader . biBitCount = 32;
bmiHeader . biCompression = BI_RGB;
bmiHeader . biSizeImage = 0;
bmiHeader . biXPelsPerMeter = 0;
bmiHeader . biYPelsPerMeter = 0;
bmiHeader . biClrUsed = 0;
bmiHeader . biClrImportant = 0;
dwBmpSize = ( ( bmpScreen . bmWidth * bmiHeader . biBitCount + 31 ) / 32 ) * 4 * bmpScreen . bmHeight;
hDIB = GlobalAlloc ( GHND , dwBmpSize );
if ( hDIB == NULL )
lpbitmap = ( char * ) GlobalLock ( hDIB );
if ( lpbitmap == NULL )
if ( GetDIBits ( hdcWindow , hbmScreen , 0 , ( UINT ) bmpScreen . bmHeight , lpbitmap , ( BITMAPINFO * ) & bmiHeader , DIB_RGB_COLORS ) == 0 )
hFile = CreateFile ( TEXT ( "capture.bmp" ) , GENERIC_WRITE , 0 , NULL , CREATE_ALWAYS , FILE_ATTRIBUTE_NORMAL , NULL );
if ( hFile == INVALID_HANDLE_VALUE )
dwSizeofDIB = dwBmpSize + sizeof ( BITMAPFILEHEADER ) + sizeof ( BITMAPINFOHEADER );
bmfHeader . bfOffBits = ( DWORD ) sizeof ( BITMAPFILEHEADER ) + ( DWORD ) sizeof ( BITMAPINFOHEADER );
bmfHeader . bfSize = dwSizeofDIB;
bmfHeader . bfType = 0x4D42;
dwBytesWritten = 0;
if ( WriteFile ( hFile , ( LPSTR ) & bmfHeader , sizeof ( BITMAPFILEHEADER ) , & dwBytesWritten , NULL ) == 0 )
if ( WriteFile ( hFile , ( LPSTR ) & bmiHeader , sizeof ( BITMAPINFOHEADER ) , & dwBytesWritten , NULL ) == 0 )
if ( WriteFile ( hFile , ( LPSTR ) lpbitmap , dwBmpSize , & dwBytesWritten , NULL ) == 0 )
while ( 0 )
if ( hbmScreen != NULL )
DeleteObject ( hbmScreen );
1
------------------------------
302033 149942/aviobuf.c s -> buf_end = dst + len 562
int avio_get_str16be(AVIOContext *pb,int maxlen,char *buf,int buflen)
int ret = 0 ;
if ( buflen <= 0 )
while ( ret + 1 < maxlen )
uint32_t ch ;
ch = ( ( ret += 2 ) <= maxlen ? avio_rb16 ( pb ) : 0 );
unsigned int hi = ch - 0xD800 ;
if ( hi < 0x800 )
ch = ( ( ret += 2 ) <= maxlen ? avio_rb16 ( pb ) : ( 0 - 0xDC00 ) );
if ( ch > 0x3FFU || hi > 0x3FFU )
ch += ( hi << 10 ) + 0x10000;
if ( ! ch )
unsigned int avio_rb16(AVIOContext *s)
unsigned int val ;
val = ( avio_r8 ( s ) << 8 );
int avio_r8(AVIOContext *s)
if ( s -> buf_ptr >= s -> buf_end )
fill_buffer ( s );
static void fill_buffer(AVIOContext *s)
uint8_t * dst = ! s -> max_packet_size && s -> buf_end - s -> buffer < ( s -> buffer_size ) ? s -> buf_end : s -> buffer ;
int len = ( ( s -> buffer_size ) - ( dst - s -> buffer ) ) ;
int max_buffer_size = s -> max_packet_size ? s -> max_packet_size : 32768 ;
if ( ! s -> read_packet && s -> buf_ptr >= s -> buf_end )
s -> eof_reached = 1;
if ( s -> eof_reached )
if ( s -> update_checksum && dst == s -> buffer )
if ( s -> buf_end > s -> checksum_ptr )
s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_end - s -> checksum_ptr ) ) );
s -> checksum_ptr = s -> buffer;
if ( s -> read_packet && s -> buffer_size > max_buffer_size )
s -> checksum_ptr = dst = s -> buffer;
len = s -> buffer_size;
if ( s -> read_packet )
len = ( ( s -> read_packet ) ( s -> opaque , dst , len ) );
len = 0;
if ( len <= 0 )
s -> eof_reached = 1;
if ( len < 0 )
s -> error = len;
s -> pos += len;
s -> buf_ptr = dst;
s -> buf_end = dst + len;
s -> bytes_read += len;
0
------------------------------
299525 151289/tile-manager.c ntiles = tm -> ntile_rows * tm -> ntile_cols 290
void tile_manager_write_pixel_data_1(TileManager *tm,gint x,gint y,const guchar *buffer)
Tile * tile = tile_manager_get_tile ( tm , x , y , ! 0 , ! 0 ) ;
Tile *tile_manager_get_tile(TileManager *tm,gint xpixel,gint ypixel,gboolean wantread,gboolean wantwrite)
if ( tm != ( ( void * ) 0 ) )
while ( 0 )
return tile_manager_get ( tm , tile_manager_get_tile_num ( tm , xpixel , ypixel ) , wantread , wantwrite ) ;
Tile *tile_manager_get(TileManager *tm,gint tile_num,gboolean wantread,gboolean wantwrite)
gint ntiles ;
if ( tm != ( ( void * ) 0 ) )
while ( 0 )
ntiles = tm -> ntile_rows * tm -> ntile_cols;
if ( tile_num < 0 || tile_num >= ntiles )
0
------------------------------
21005 CVE-2015-2740/Firefox_38.8.0esr_CVE_2015_2740_dom_base_nsXMLHttpRequest.cpp newcap = mLength + aDataLen 4030

ArrayBufferBuilder::append(const uint8_t *aNewData, uint32_t
uint32_t aMaxGrowth)
if ( mLength + aDataLen > mCapacity )
uint32_t newcap ;
if ( ! aMaxGrowth || mCapacity < aMaxGrowth )
newcap = mCapacity * 2;
newcap = mCapacity + aMaxGrowth;
if ( newcap < mLength + aDataLen )
newcap = mLength + aDataLen;
if ( newcap < mCapacity )
if ( ! setCapacity ( newcap ) )
0
------------------------------
314517 110852/CWE680_Integer_Overflow_to_Buffer_Overflow__new_rand_13.cpp dataBytes = data * sizeof ( int ) 38
void bad()
int data ;
data = - 1;
if ( GLOBAL_CONST_FIVE == 5 )
data = RAND32 ( );
size_t dataBytes , i ;
dataBytes = data * sizeof ( int );
intPointer = ( int * ) new char [ dataBytes ];
intPointer [ i ] = 0;
printIntLine ( intPointer [ 0 ] );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
delete [ ] intPointer
1
------------------------------
302967 82673/CWE190_Integer_Overflow__int64_t_fscanf_square_63b.c int64_t result = data * data ; 29
void CWE190_Integer_Overflow__int64_t_fscanf_square_63_bad()
int64_t data ;
data = 0L L
CWE190_Integer_Overflow__int64_t_fscanf_square_63b_badSink ( & data );
void CWE190_Integer_Overflow__int64_t_fscanf_square_63b_badSink(int64_t * dataPtr)
int64_t data = * dataPtr ;
int64_t result = data * data ;
printLongLongLine ( result );
void printLongLongLine (int64_t longLongIntNumber)
printf ( "%lld\n" , longLongIntNumber );
1
------------------------------
300302 149409/dynahash.c firstElement = ( ( HASHELEMENT * ) ( ( hashp -> alloc ) ( nelem * elementSize ) ) ) 1347
void *hash_search(HTAB *hashp,const void *keyPtr,HASHACTION action,bool *foundPtr)
return hash_search_with_hash_value ( hashp , keyPtr , ( ( hashp -> hash ) ( keyPtr , hashp -> keysize ) ) , action , foundPtr ) ;
void *hash_search_with_hash_value(HTAB *hashp,const void *keyPtr,uint32 hashvalue,HASHACTION action,bool *foundPtr)
HASHHDR * hctl = hashp -> hctl ;
Size keysize ;
uint32 bucket ;
long segment_num ;
long segment_ndx ;
HASHSEGMENT segp ;
HASHBUCKET currBucket ;
HASHBUCKET * prevBucketPtr ;
HashCompareFunc match ;
bucket = calc_bucket ( hctl , hashvalue );
inline static uint32 calc_bucket(HASHHDR *hctl,uint32 hash_val)
uint32 bucket ;
bucket = hash_val & hctl -> high_mask;
if ( bucket > hctl -> max_bucket )
bucket = bucket & hctl -> low_mask;
return bucket ;
segment_num = ( bucket >> hashp -> sshift );
segment_ndx = bucket & hashp -> ssize - 1;
segp = hashp -> dir [ segment_num ];
prevBucketPtr = & segp [ segment_ndx ];
currBucket = * prevBucketPtr;
match = hashp -> match;
keysize = hashp -> keysize;
while ( currBucket != ( ( void * ) 0 ) )
if ( currBucket -> hashvalue == hashvalue && match ( ( ( ( char * ) currBucket ) + ( ( ( intptr_t ) ( sizeof ( HASHELEMENT ) ) ) + ( 8 - 1 ) & ~ ( ( intptr_t ) ( 8 - 1 ) ) ) ) , keyPtr , keysize ) == 0 )
prevBucketPtr = & currBucket -> link;
currBucket = * prevBucketPtr;
switch ( action )
if ( currBucket != ( ( void * ) 0 ) )
currBucket = get_hash_entry ( hashp );
static HASHBUCKET get_hash_entry(HTAB *hashp)
volatile HASHHDR * hctlv = ( hashp -> hctl ) ;
HASHBUCKET newElement ;
newElement = hctlv -> freeList;
if ( newElement != ( ( void * ) 0 ) )
if ( hctlv -> num_partitions != 0 )
* ( ( volatile slock_t * ) ( & hctlv -> mutex ) ) = 0;
if ( ! element_alloc ( hashp , hctlv -> nelem_alloc ) )
static bool element_alloc(HTAB *hashp,int nelem)
volatile HASHHDR * hctlv = ( hashp -> hctl ) ;
Size elementSize ;
HASHELEMENT * firstElement ;
if ( hashp -> isfixed )
elementSize = ( ( ( ( intptr_t ) ( sizeof ( HASHELEMENT ) ) ) + ( 8 - 1 ) & ~ ( ( intptr_t ) ( 8 - 1 ) ) ) + ( ( ( intptr_t ) ( hctlv -> entrysize ) ) + ( 8 - 1 ) & ~ ( ( intptr_t ) ( 8 - 1 ) ) ) );
firstElement = ( ( HASHELEMENT * ) ( ( hashp -> alloc ) ( nelem * elementSize ) ) );
if ( ! firstElement )
tmpElement = firstElement;
tmpElement -> link = prevElement;
prevElement = tmpElement;
tmpElement = ( ( HASHELEMENT * ) ( ( ( char * ) tmpElement ) + elementSize ) );
firstElement -> link = hctlv -> freeList;
hctlv -> freeList = prevElement;
if ( hctlv -> num_partitions != 0 )
* ( ( volatile slock_t * ) ( & hctlv -> mutex ) ) = 0;
0
------------------------------
301638 151549/aviobuf.c s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_ptr - s -> checksum_ptr ) ) ) 199
int avio_put_str(AVIOContext *s,const char *str)
if ( str )
avio_w8 ( s , 0 );
void avio_w8(AVIOContext *s,int b)
* ( s -> buf_ptr ++ ) = b;
if ( s -> buf_ptr >= s -> buf_end )
flush_buffer ( s );
static void flush_buffer(AVIOContext *s)
if ( s -> buf_ptr > s -> buffer )
if ( s -> update_checksum )
s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_ptr - s -> checksum_ptr ) ) );
s -> checksum_ptr = s -> buffer;
s -> buf_ptr = s -> buffer;
0
------------------------------
311522 152165/dfa.c remain_bytes = mbrtowc ( inputwcs + i , begin + i , ( end - begin ) - i + 1 , & mbs ) 3552
char *dfaexec(struct dfa *d,const char *begin,char *end,int allow_nl,size_t *count,int *backref)
const unsigned char * p ;
unsigned char eol = eolbyte ;
p = ( ( const unsigned char * ) begin );
* end = eol;
if ( d -> mb_cur_max > 1 )
prepare_wc_buf ( ( ( const char * ) p ) , end );
static void prepare_wc_buf(const char *begin,const char *end)
unsigned char eol = eolbyte ;
size_t remain_bytes ;
size_t i ;
remain_bytes = 0;
for (i = 0; i < (end - begin + 1); i++)
if ( remain_bytes == 0 )
remain_bytes = mbrtowc ( inputwcs + i , begin + i , ( end - begin ) - i + 1 , & mbs );
if ( remain_bytes < 1 || remain_bytes == ( ( size_t ) ( - 1 ) ) || remain_bytes == ( ( size_t ) ( - 2 ) ) || remain_bytes == 1 && inputwcs [ i ] == ( ( wchar_t ) begin [ i ] ) )
remain_bytes = 0;
inputwcs [ i ] = ( ( wchar_t ) begin [ i ] );
mblen_buf [ i ] = 0;
if ( begin [ i ] == eol )
mblen_buf [ i ] = remain_bytes;
remain_bytes --;
mblen_buf [ i ] = remain_bytes;
inputwcs [ i ] = 0;
remain_bytes --;
buf_end = ( ( unsigned char * ) ( begin + i ) );
mblen_buf [ i ] = 0;
inputwcs [ i ] = 0;
0
------------------------------
311724 149958/aviobuf.c s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_end - s -> checksum_ptr ) ) ) 568
unsigned int avio_rb32(AVIOContext *s)
unsigned int val ;
val = avio_rb16 ( s ) << 16;
val |= avio_rb16 ( s );
unsigned int avio_rb16(AVIOContext *s)
unsigned int val ;
val = ( avio_r8 ( s ) << 8 );
int avio_r8(AVIOContext *s)
if ( s -> buf_ptr >= s -> buf_end )
fill_buffer ( s );
static void fill_buffer(AVIOContext *s)
uint8_t * dst = ! s -> max_packet_size && s -> buf_end - s -> buffer < ( s -> buffer_size ) ? s -> buf_end : s -> buffer ;
if ( ! s -> read_packet && s -> buf_ptr >= s -> buf_end )
s -> eof_reached = 1;
if ( s -> eof_reached )
if ( s -> update_checksum && dst == s -> buffer )
if ( s -> buf_end > s -> checksum_ptr )
s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_end - s -> checksum_ptr ) ) );
s -> checksum_ptr = s -> buffer;
if ( s -> read_packet && s -> buffer_size > max_buffer_size )
ffio_set_buf_size ( s , max_buffer_size );
s -> checksum_ptr = dst = s -> buffer;
len = s -> buffer_size;
if ( s -> read_packet )
len = ( ( s -> read_packet ) ( s -> opaque , dst , len ) );
if ( len <= 0 )
s -> eof_reached = 1;
if ( len < 0 )
s -> error = len;
s -> pos += len;
s -> buf_ptr = dst;
s -> buf_end = dst + len;
s -> bytes_read += len;
0
------------------------------
313879 90784/CWE23_Relative_Path_Traversal__wchar_t_connect_socket_fopen_05.cpp recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ) 107
void bad()
wchar_t * data ;
wchar_t dataBuffer [ FILENAME_MAX ] = BASEPATH ;
data = dataBuffer;
if ( staticTrue )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( FILENAME_MAX - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
17930 CVE-2016-5275/Firefox_49.0b1_CVE_2016_5275_gfx_src_FilterSupport.cpp aOutMatrix [ 5 ] = aAmount * aToMatrix [ 5 ] 387
static
ComputeColorMatrix(uint32_t aColorMatrixType, const nsTArray<float>&
float aOutMatrix[20])
static const float lumR = 0.2126f ;
static const float lumG = 0.7152f ;
static const float lumB = 0.0722f ;
static const float saturateMatrix [ ] = { lumR , lumG , lumB , 0 , 0 , lumR , lumG , lumB , 0 , 0 , lumR , lumG , lumB , 0 , 0 , 0 , 0 , 0 , 1 , 0 } ;
switch ( aColorMatrixType )
if ( aValues . Length ( ) != 1 )
float s = aValues [ 0 ] ;
if ( s < 0 )
InterpolateFromIdentityMatrix ( saturateMatrix , 1 - s , aOutMatrix );
static
InterpolateFromIdentityMatrix(const float aToMatrix[20], float
float aOutMatrix[20])
float oneMinusAmount = 1 - aAmount ;
aOutMatrix [ 0 ] = aAmount * aToMatrix [ 0 ] + oneMinusAmount;
aOutMatrix [ 1 ] = aAmount * aToMatrix [ 1 ];
aOutMatrix [ 2 ] = aAmount * aToMatrix [ 2 ];
aOutMatrix [ 5 ] = aAmount * aToMatrix [ 5 ];
aOutMatrix [ 6 ] = aAmount * aToMatrix [ 6 ] + oneMinusAmount;
aOutMatrix [ 7 ] = aAmount * aToMatrix [ 7 ];
aOutMatrix [ 10 ] = aAmount * aToMatrix [ 10 ];
aOutMatrix [ 11 ] = aAmount * aToMatrix [ 11 ];
aOutMatrix [ 12 ] = aAmount * aToMatrix [ 12 ] + oneMinusAmount;
0
------------------------------
19985 CVE-2016-2328/Ffmpeg_2.8.2_CVE_2016_2328_libswscale_swscale_unscaled.c uint8_t * ptr = plane + stride * y ; 135
static int yvu9ToYv12Wrapper(SwsContext *c, const uint8_t
int srcStride[], int srcSliceY, int
uint8_t *dst[], int dstStride[])
if ( dst [ 3 ] )
fillPlane ( dst [ 3 ] , dstStride [ 3 ] , c -> srcW , srcSliceH , srcSliceY , 255 );
static void fillPlane(uint8_t *plane, int stride, int width, int height, int
uint8_t val)
uint8_t * ptr = plane + stride * y ;
memset ( ptr , val , width );
ptr += stride;
0
------------------------------
300732 153511/dfa.c work_mbls = check_matching_with_multibyte_ops ( d , s , ( * pp - buf_begin ) ) 3385
char *dfaexec(struct dfa *d,const char *begin,char *end,int allow_nl,size_t *count,int *backref)
state_num s ;
state_num s1 ;
const unsigned char * p ;
state_num * * trans ;
state_num * t ;
unsigned char eol = eolbyte ;
unsigned char saved_end ;
s = s1 = 0;
p = ( ( const unsigned char * ) begin );
trans = d -> trans;
saved_end = * ( ( unsigned char * ) end );
* end = eol;
if ( d -> mb_cur_max > 1 )
while ( ( t = trans [ s ] ) != ( ( void * ) 0 ) )
if ( p > buf_end )
s1 = s;
if ( s == 0 )
if ( ( ( char * ) p ) >= end )
* end = saved_end;
if ( d -> states [ s ] . mbps . nelem == 0 )
s = t [ * ( p ++ ) ];
if ( backref )
* end = saved_end;
s = transit_state ( d , s , & p );
trans = d -> trans;
while ( ( t = trans [ s ] ) != ( ( void * ) 0 ) )
s1 = t [ * ( p ++ ) ];
if ( ( t = trans [ s1 ] ) == ( ( void * ) 0 ) )
state_num tmp = s ;
s = s1;
s1 = tmp;
s = t [ * ( p ++ ) ];
if ( s >= 0 && ( ( char * ) p ) <= end && d -> fails [ s ] )
if ( d -> success [ s ] & sbit [ * p ] )
s1 = s;
if ( d -> mb_cur_max > 1 )
s = transit_state ( d , s , & p );
trans = d -> trans;
s = d -> fails [ s ] [ * ( p ++ ) ];
if ( ( ( char * ) p ) > end )
if ( s >= 0 )
trans = d -> trans;
if ( p [ - 1 ] == eol && allow_nl )
s = d -> newlines [ s1 ];
s = 0;
static state_num transit_state(struct dfa *d,state_num s,const unsigned char **pp)
int mbclen ;
int maxlen = 0 ;
size_t i ;
int * match_lens = ( ( void * ) 0 ) ;
size_t nelem = d -> states [ s ] . mbps . nelem ;
position_set follows ;
if ( nelem > 0 )
match_lens = check_matching_with_multibyte_ops ( d , s , ( * pp - buf_begin ) );
for (i = 0; i < nelem; i++)
if ( match_lens [ i ] > maxlen )
maxlen = match_lens [ i ];
if ( nelem == 0 || maxlen == 0 )
transit_state_consume_1char ( d , s , pp , match_lens , & mbclen , & follows );
static status_transit_state transit_state_consume_1char(struct dfa *d,state_num s,const unsigned char **pp,int *match_lens,int *mbclen,position_set *pps)
int k ;
state_num s1 ;
state_num s2 ;
int * work_mbls ;
* mbclen = ( mblen_buf [ * pp - buf_begin ] == 0 ? 1 : mblen_buf [ * pp - buf_begin ] );
s1 = s;
for (k = 0; k <  *mbclen; k++)
s2 = s1;
rs = transit_state_singlebyte ( d , s2 , ( * pp ) ++ , & s1 );
if ( match_lens == ( ( void * ) 0 ) && d -> states [ s ] . mbps . nelem != 0 )
work_mbls = check_matching_with_multibyte_ops ( d , s , ( * pp - buf_begin ) );
if ( work_mbls [ i ] == * mbclen )
if ( match_lens == ( ( void * ) 0 ) && work_mbls != ( ( void * ) 0 ) )
free ( work_mbls );
0
------------------------------
302627 79325/CWE134_Uncontrolled_Format_String__char_connect_socket_vprintf_63a.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 187
static void goodB2G()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
CWE134_Uncontrolled_Format_String__char_connect_socket_vprintf_63b_goodB2GSink ( & data );
void CWE134_Uncontrolled_Format_String__char_connect_socket_vprintf_63b_goodB2GSink(char * * dataPtr)
char * data = * dataPtr ;
goodB2GVaSink ( data , data );
static void goodB2GVaSink(char * data, ...)
va_start ( args , data );
0
------------------------------
20556 CVE-2016-4998/linux_kernel_4.5.7_CVE_2016_4998_net_ipv4_netfilter_ip_tables.c ret = check_compat_entry_size_and_hooks ( iter0 , info , & size , entry0 , entry0 + total_size , hook_entries , underflows , name ) 1683
static
compat_do_ipt_set_ctl(struct sock *sk,	int cmd, void __user
unsigned int len)
int ret ;
if ( ! ns_capable ( sock_net ( sk ) -> user_ns , CAP_NET_ADMIN ) )
switch ( cmd )
ret = compat_do_replace ( sock_net ( sk ) , user , len );
static
compat_do_replace(struct net *net, void __user *user, unsigned int len)
int ret ;
struct compat_ipt_replace tmp ;
struct xt_table_info * newinfo ;
void * loc_cpu_entry ;
if ( copy_from_user ( & tmp , user , sizeof ( tmp ) ) != 0 )
if ( tmp . size >= INT_MAX / num_possible_cpus ( ) )
if ( tmp . num_counters >= INT_MAX / sizeof ( struct xt_counters ) )
if ( tmp . num_counters == 0 )
tmp . name [ sizeof ( tmp . name ) - 1 ] = 0;
newinfo = xt_alloc_table_info ( tmp . size );
if ( ! newinfo )
loc_cpu_entry = newinfo -> entries;
if ( copy_from_user ( loc_cpu_entry , user + sizeof ( tmp ) , tmp . size ) != 0 )
ret = translate_compat_table ( net , tmp . name , tmp . valid_hooks , & newinfo , & loc_cpu_entry , tmp . size , tmp . num_entries , tmp . hook_entry , tmp . underflow );
static
translate_compat_table(struct net
const char
unsigned int
struct xt_table_info
void
unsigned int
unsigned int
unsigned int
unsigned int *underflows)
unsigned int i , j ;
struct xt_table_info * newinfo , * info ;
void * pos , * entry0 , * entry1 ;
struct compat_ipt_entry * iter0 ;
unsigned int size ;
int ret ;
info = * pinfo;
entry0 = * pentry0;
size = total_size;
info -> number = number;
for (i = 0; i < NF_INET_NUMHOOKS; i++)
info -> hook_entry [ i ] = 0xFFFFFFFF;
info -> underflow [ i ] = 0xFFFFFFFF;
ret = check_compat_entry_size_and_hooks ( iter0 , info , & size , entry0 , entry0 + total_size , hook_entries , underflows , name );
static
check_compat_entry_size_and_hooks(struct compat_ipt_entry
struct xt_table_info
unsigned int
const unsigned char
const unsigned char
const unsigned int
const unsigned int
const char *name)
struct xt_entry_target * t ;
struct xt_target * target ;
unsigned int entry_offset ;
int ret , off , h ;
return - EINVAL ;
if ( e -> next_offset < sizeof ( struct compat_ipt_entry ) + sizeof ( struct compat_xt_entry_target ) )
return - EINVAL ;
ret = check_entry ( ( struct ipt_entry * ) e , name );
static
check_entry(const struct ipt_entry *e, const char *name)
const struct xt_entry_target * t ;
if ( ! ip_checkentry ( & e -> ip ) )
static
ip_checkentry(const struct ipt_ip *ip)
if ( ip -> flags & ~IPT_F_MASK )
return false ;
if ( ip -> invflags & ~IPT_INV_MASK )
return false ;
return true ;
return - EINVAL ;
if ( e -> target_offset + sizeof ( struct xt_entry_target ) > e -> next_offset )
return - EINVAL ;
t = ipt_get_target_c ( e );
static inline const struct xt_entry_target
ipt_get_target_c(const struct ipt_entry *e)
return ipt_get_target ( ( struct ipt_entry * ) e ) ;
if ( e -> target_offset + t -> u . target_size > e -> next_offset )
return - EINVAL ;
return 0 ;
if ( ret )
return ret ;
off = sizeof ( struct ipt_entry ) - sizeof ( struct compat_ipt_entry );
entry_offset = ( void * ) e - ( void * ) base;
ret = compat_find_calc_match ( ematch , name , & e -> ip , & off );
static
compat_find_calc_match(struct xt_entry_match
const char
const struct ipt_ip
int *size)
struct xt_match * match ;
match = xt_request_find_match ( NFPROTO_IPV4 , m -> u . user . name , m -> u . user . revision );
if ( IS_ERR ( match ) )
return PTR_ERR ( match ) ;
return 0 ;
if ( ret != 0 )
t = compat_ipt_get_target ( e );
target = xt_request_find_target ( NFPROTO_IPV4 , t -> u . user . name , t -> u . user . revision );
if ( IS_ERR ( target ) )
ret = PTR_ERR ( target );
off += xt_compat_target_offset ( target );
ret = xt_compat_add_offset ( AF_INET , entry_offset , off );
if ( ret )
return 0 ;
return ret ;
if ( ret != 0 )
if ( ret != 0 )
if ( ret )
if ( ret != 0 )
if ( ret )
return ret ;
return ret ;
0
------------------------------
301873 151041/dfa.c dirpath = ( char * ) malloc ( size_dirpath * sizeof ( char ) ) 90
void stonesoup_setup_printf_context()
ss_tc_root = getenv ( "SS_TC_ROOT" );
if ( ss_tc_root != NULL )
size_dirpath = strlen ( ss_tc_root ) + strlen ( "testData" ) + 2;
dirpath = ( char * ) malloc ( size_dirpath * sizeof ( char ) );
if ( dirpath != NULL )
sprintf ( dirpath , "%s/%s" , ss_tc_root , "testData" );
if ( stat ( dirpath , & st ) == - 1 )
retval = mkdir ( dirpath , 0700 );
if ( retval == 0 )
size_filepath = strlen ( dirpath ) + strlen ( "logfile.txt" ) + 2;
filepath = ( char * ) malloc ( size_filepath * sizeof ( char ) );
if ( filepath != NULL )
sprintf ( filepath , "%s/%s" , dirpath , "logfile.txt" );
stonesoup_printf_context = fopen ( filepath , "w" );
free ( filepath );
free ( dirpath );
if ( stonesoup_printf_context == NULL )
0
------------------------------
304916 83802/CWE190_Integer_Overflow__int_rand_square_13.c int result = data * data ; 38
void CWE190_Integer_Overflow__int_rand_square_13_bad()
int data ;
data = 0;
if ( GLOBAL_CONST_FIVE == 5 )
data = RAND32 ( );
if ( GLOBAL_CONST_FIVE == 5 )
int result = data * data ;
printIntLine ( result );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
1
------------------------------
309090 118066/CWE78_OS_Command_Injection__char_connect_socket_popen_44.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 115
void CWE78_OS_Command_Injection__char_connect_socket_popen_44_bad()
char * data ;
char data_buf [ 100 ] = FULL_COMMAND ;
data = data_buf;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
funcPtr ( data );
0
------------------------------
304410 82210/CWE190_Integer_Overflow__char_fscanf_square_05.c char result = data * data ; 73
static void goodB2G1()
char data ;
data = ' ';
if ( staticFalse )
if ( abs ( ( long ) data ) <= ( long ) sqrt ( ( double ) CHAR_MAX ) )
char result = data * data ;
printHexCharLine ( result );
void printHexCharLine (char charHex)
printf ( "%02x\n" , charHex );
0
------------------------------
20780 CVE-2016-2327/Ffmpeg_2.8.2_CVE_2016_2327_libavcodec_pngenc.c a = src [ i - bpp ] 124
static int encode_frame(AVCodecContext *avctx, const AVFrame *pict)
PNGEncContext * s = avctx -> priv_data ;
int y , len , ret ;
int row_size , pass_row_size ;
uint8_t * ptr , * top , * crow_buf , * crow ;
uint8_t * progressive_buf = NULL ;
row_size = ( pict -> width * s -> bits_per_pixel + 7 ) >> 3;
crow_base = av_malloc ( ( row_size + 32 ) << ( s -> filter_type == PNG_FILTER_VALUE_MIXED ) );
if ( ! crow_base )
crow_buf = crow_base + 15;
if ( s -> is_progressive )
progressive_buf = av_malloc ( row_size + 1 );
top_buf = av_malloc ( row_size + 1 );
if ( ! progressive_buf || ! top_buf )
s -> zstream . avail_out = IOBUF_SIZE;
s -> zstream . next_out = s -> buf;
if ( s -> is_progressive )
int pass ;
for (pass = 0; pass < NB_PASSES; pass++)
pass_row_size = ff_png_pass_row_size ( pass , s -> bits_per_pixel , pict -> width );
if ( pass_row_size > 0 )
top = NULL;
for (y = 0; y < pict->height; y++)
if ( ( ff_png_pass_ymask [ pass ] << ( y & 7 ) ) & 0x80 )
crow = png_choose_filter ( s , crow_buf , progressive_buf , top , pass_row_size , s -> bits_per_pixel >> 3 );
top = progressive_buf;
static uint8_t *png_choose_filter(PNGEncContext *s, uint8_t
uint8_t *src, uint8_t *top, int size, int bpp)
int pred = s -> filter_type ;
if ( ! top && pred )
pred = PNG_FILTER_VALUE_SUB;
if ( pred == PNG_FILTER_VALUE_MIXED )
png_filter_row ( s , dst + 1 , pred , src , top , size , bpp );
static void png_filter_row(PNGEncContext *c, uint8_t *dst, int
uint8_t *src, uint8_t *top, int size, int bpp)
int i ;
switch ( filter_type )
memcpy ( dst , src , size );
for (i = 0; i < bpp; i++)
dst [ i ] = src [ i ] - ( top [ i ] >> 1 );
for (; i < size; i++)
dst [ i ] = src [ i ] - ( ( src [ i - bpp ] + top [ i ] ) >> 1 );
for (i = 0; i < bpp; i++)
dst [ i ] = src [ i ] - top [ i ];
sub_png_paeth_prediction ( dst + i , src + i , top + i , size - i , bpp );
static void sub_png_paeth_prediction(uint8_t *dst, uint8_t *src, uint8_t
int w, int bpp)
int i ;
for (i = 0; i < w; i++)
int a , b , c , p , pa , pb , pc ;
a = src [ i - bpp ];
b = top [ i ];
c = top [ i - bpp ];
p = b - c;
pc = a - c;
pa = abs ( p );
pb = abs ( pc );
pc = abs ( p + pc );
if ( pa <= pb && pa <= pc )
p = a;
if ( pb <= pc )
p = b;
p = c;
dst [ i ] = src [ i ] - p;
0
------------------------------
313569 95750/CWE36_Absolute_Path_Traversal__char_connect_socket_w32CreateFile_31.cpp recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ) 91
void bad()
char * data ;
char dataBuffer [ FILENAME_MAX ] = "" ;
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
char * dataCopy = data ;
char * data = dataCopy ;
hFile = CreateFileA ( data , ( GENERIC_WRITE | GENERIC_READ ) , 0 , NULL , OPEN_ALWAYS , FILE_ATTRIBUTE_NORMAL , NULL );
if ( hFile != INVALID_HANDLE_VALUE )
CloseHandle ( hFile );
1
------------------------------
16220 CVE-2006-4813/CVE_2006_4813_PATCHED___block_prepare_write.c block_end = block_start + blocksize 25
static int CVE_2006_4813_PATCHED___block_prepare_write(struct inode *inode, struct page
unsigned from, unsigned to, get_block_t *get_block)
unsigned block_start , block_end ;
sector_t block ;
unsigned blocksize , bbits ;
blocksize = 1 << inode -> i_blkbits;
head = page_buffers ( page );
bbits = inode -> i_blkbits;
block = ( sector_t ) page -> index << ( PAGE_CACHE_SHIFT - bbits );
for(bh = head, block_start = 0; bh != head ||
block++, block_start=block_end, bh = bh->b_this_page)
block_end = block_start + blocksize;
if ( block_end <= from || block_start >= to )
if ( ! buffer_mapped ( bh ) )
err = get_block ( inode , block , bh , 1 );
if ( err )
if ( buffer_new ( bh ) )
if ( PageUptodate ( page ) )
0
------------------------------
313460 95586/CWE36_Absolute_Path_Traversal__char_connect_socket_ifstream_01.cpp recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ) 93
void bad()
char * data ;
char dataBuffer [ FILENAME_MAX ] = "" ;
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
inputFile . open ( ( char * ) data );
1
------------------------------
303391 80298/CWE134_Uncontrolled_Format_String__char_listen_socket_printf_01.c recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 96
void CWE134_Uncontrolled_Format_String__char_listen_socket_printf_01_bad()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
printf ( data );
1
------------------------------
312941 79189/CWE134_Uncontrolled_Format_String__char_connect_socket_printf_74a.cpp recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 98
void bad()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
dataMap [ 0 ] = data;
dataMap [ 1 ] = data;
dataMap [ 2 ] = data;
badSink ( dataMap );
void badSink(map<int, char *> dataMap)
char * data = dataMap [ 2 ] ;
printf ( data );
0
------------------------------
313543 89756/CWE23_Relative_Path_Traversal__char_connect_socket_open_54a.cpp recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ) 104
void bad()
char * data ;
char dataBuffer [ FILENAME_MAX ] = BASEPATH ;
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
badSink_b ( data );
void badSink_b(char * data)
badSink_c ( data );
void badSink_c(char * data)
badSink_d ( data );
void badSink_d(char * data)
badSink_e ( data );
void badSink_e(char * data)
fileDesc = OPEN ( data , O_RDWR | O_CREAT , S_IREAD | S_IWRITE );
if ( fileDesc != - 1 )
CLOSE ( fileDesc );
0
------------------------------
302760 82936/CWE190_Integer_Overflow__int64_t_rand_square_11.c int64_t result = data * data ; 92
static void goodB2G2()
int64_t data ;
data = 0L L
if ( globalReturnsTrue ( ) )
int globalReturnsTrue()
return 1 ;
data = ( int64_t ) RAND64 ( );
if ( globalReturnsTrue ( ) )
int globalReturnsTrue()
return 1 ;
if ( abs ( ( long ) data ) <= ( long ) sqrt ( ( double ) LLONG_MAX ) )
int64_t result = data * data ;
printLongLongLine ( result );
void printLongLongLine (int64_t longLongIntNumber)
printf ( "%lld\n" , longLongIntNumber );
0
------------------------------
306627 104465/CWE469_Use_of_Pointer_Subtraction_to_Determine_Size__char_06.c indexOfSlashInString1 = ( size_t ) ( slashInString1 - string2 ) 44
void CWE469_Use_of_Pointer_Subtraction_to_Determine_Size__char_06_bad()
if ( STATIC_CONST_FIVE == 5 )
char string1 [ ] = SOURCE_STRING ;
char string2 [ ] = SOURCE_STRING ;
char * slashInString1 ;
size_t indexOfSlashInString1 ;
slashInString1 = strchr ( string1 , '/' );
indexOfSlashInString1 = ( size_t ) ( slashInString1 - string2 );
printUnsignedLine ( indexOfSlashInString1 );
void printUnsignedLine(unsigned unsignedNumber)
printf ( "%u\n" , unsignedNumber );
1
------------------------------
298674 95774/CWE36_Absolute_Path_Traversal__char_connect_socket_w32CreateFile_81a.cpp recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ) 87
void bad()
char * data ;
char dataBuffer [ FILENAME_MAX ] = "" ;
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
baseObject . action ( data );
0
------------------------------
301515 150690/aviobuf.c s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_ptr - s -> checksum_ptr ) ) ) 273
void avio_wb64(AVIOContext *s,uint64_t val)
avio_wb32 ( s , ( ( uint32_t ) ( val & 0xffffffff ) ) );
void avio_wb32(AVIOContext *s,unsigned int val)
avio_w8 ( s , ( ( uint8_t ) val ) );
void avio_w8(AVIOContext *s,int b)
* ( s -> buf_ptr ++ ) = b;
if ( s -> buf_ptr >= s -> buf_end )
flush_buffer ( s );
static void flush_buffer(AVIOContext *s)
if ( s -> buf_ptr > s -> buffer )
if ( s -> update_checksum )
s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_ptr - s -> checksum_ptr ) ) );
s -> checksum_ptr = s -> buffer;
s -> buf_ptr = s -> buffer;
0
------------------------------
302278 80646/CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_snprintf_13.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 ) 96
void CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_snprintf_13_bad()
wchar_t * data ;
wchar_t dataBuffer [ 100 ] = L ""
data = dataBuffer;
if ( GLOBAL_CONST_FIVE == 5 )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
303472 82379/CWE190_Integer_Overflow__char_max_square_51b.c char result = data * data ; 28
void CWE190_Integer_Overflow__char_max_square_51_bad()
char data ;
data = ' ';
data = CHAR_MAX;
CWE190_Integer_Overflow__char_max_square_51b_badSink ( data );
void CWE190_Integer_Overflow__char_max_square_51b_badSink(char data)
char result = data * data ;
printHexCharLine ( result );
void printHexCharLine (char charHex)
printf ( "%02x\n" , charHex );
1
------------------------------
314420 96657/CWE36_Absolute_Path_Traversal__char_listen_socket_open_16.cpp recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ) 108
void bad()
char * data ;
char dataBuffer [ FILENAME_MAX ] = "" ;
data = dataBuffer;
while ( 1 )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
fileDesc = OPEN ( data , O_RDWR | O_CREAT , S_IREAD | S_IWRITE );
if ( fileDesc != - 1 )
CLOSE ( fileDesc );
1
------------------------------
303535 82216/CWE190_Integer_Overflow__char_fscanf_square_11.c char result = data * data ; 67
static void goodB2G1()
char data ;
data = ' ';
if ( globalReturnsFalse ( ) )
int globalReturnsFalse()
return 0 ;
if ( abs ( ( long ) data ) <= ( long ) sqrt ( ( double ) CHAR_MAX ) )
char result = data * data ;
printHexCharLine ( result );
void printHexCharLine (char charHex)
printf ( "%02x\n" , charHex );
0
------------------------------
20369 CVE-2016-4006/Wireshark_2.0.2_CVE_2016_4006_epan_proto.c bitfield_byte_length = ( int ) ( p - label_str ) 6989
static
proto_item_add_bitmask_tree(proto_item *item, tvbuff_t *tvb, const int
const int len, const gint ett, const int
const guint encoding, const int
gboolean first, gboolean use_parent_tree, gboolean
proto_tree* tree, guint64 value)
guint64 available_bits = 0 ;
guint64 tmpval ;
header_field_info * hf ;
switch ( len )
if ( use_value == FALSE )
value = tvb_get_guint8 ( tvb , offset );
available_bits = 0xFF;
if ( use_value == FALSE )
value = encoding ? tvb_get_letohs ( tvb , offset ) : tvb_get_ntohs ( tvb , offset );
available_bits = 0xFFFF;
if ( use_value == FALSE )
value = encoding ? tvb_get_letoh24 ( tvb , offset ) : tvb_get_ntoh24 ( tvb , offset );
available_bits = 0xFFFFFF;
if ( use_value == FALSE )
value = encoding ? tvb_get_letohl ( tvb , offset ) : tvb_get_ntohl ( tvb , offset );
available_bits = 0xFFFFFFFF;
if ( use_value == FALSE )
value = encoding ? tvb_get_letoh40 ( tvb , offset ) : tvb_get_ntoh40 ( tvb , offset );
available_bits = G_GUINT64_CONSTANT ( 0xFFFFFFFFFF );
if ( use_value == FALSE )
value = encoding ? tvb_get_letoh48 ( tvb , offset ) : tvb_get_ntoh48 ( tvb , offset );
available_bits = G_GUINT64_CONSTANT ( 0xFFFFFFFFFFFF );
if ( use_value == FALSE )
value = encoding ? tvb_get_letoh56 ( tvb , offset ) : tvb_get_ntoh56 ( tvb , offset );
available_bits = G_GUINT64_CONSTANT ( 0xFFFFFFFFFFFFFF );
if ( use_value == FALSE )
value = encoding ? tvb_get_letoh64 ( tvb , offset ) : tvb_get_ntoh64 ( tvb , offset );
available_bits = G_GUINT64_CONSTANT ( 0xFFFFFFFFFFFFFFFF );
while ( * fields )
guint64 present_bits ;
present_bits = available_bits & hf -> bitmask;
if ( present_bits != hf -> bitmask )
fields ++;
if ( flags & BMT_NO_APPEND )
fields ++;
tmpval = ( value & hf -> bitmask ) >> hfinfo_bitshift ( hf );
switch ( hf -> type )
if ( hf -> display == BASE_CUSTOM )
first = FALSE;
if ( hf -> strings )
first = FALSE;
if ( ! ( flags & BMT_NO_INT ) )
first = FALSE;
if ( hf -> strings && ! ( flags & BMT_NO_TFS ) )
const struct true_false_string * tfs = ( const struct true_false_string * ) hf -> strings ;
if ( tmpval )
proto_item_append_text ( item , "%s%s: %s" , first ? "" : ", " , hf -> name , tfs -> true_string );
first = FALSE;
if ( ! ( flags & BMT_NO_FALSE ) )
first = FALSE;
if ( hf -> bitmask & value )
first = FALSE;
fields ++;

proto_item_append_text(proto_item *pi, const char *format, ...)
fi = PITEM_FINFO ( pi );
if ( fi == NULL )
if ( ! PROTO_ITEM_IS_HIDDEN ( pi ) )
if ( fi -> rep == NULL )
proto_item_fill_label ( fi , fi -> rep -> representation );

proto_item_fill_label(field_info *fi, gchar *label_str)
header_field_info * hfinfo ;
if ( ! fi )
hfinfo = fi -> hfinfo;
switch ( hfinfo -> type )
if ( hfinfo -> bitmask )
fill_label_bitfield64 ( fi , label_str , TRUE );
static
fill_label_bitfield64(field_info *fi, gchar *label_str, gboolean is_signed)
char * p ;
int bitfield_byte_length , bitwidth ;
guint64 unshifted_value ;
header_field_info * hfinfo = fi -> hfinfo ;
bitwidth = hfinfo_bitwidth ( hfinfo );
if ( is_signed )
unshifted_value = fvalue_get_sinteger64 ( & fi -> value );
unshifted_value = fvalue_get_uinteger64 ( & fi -> value );
if ( hfinfo -> bitmask )
unshifted_value <<= hfinfo_bitshift ( hfinfo );
p = decode_bitfield_value ( label_str , unshifted_value , hfinfo -> bitmask , bitwidth );
bitfield_byte_length = ( int ) ( p - label_str );
label_fill ( label_str , bitfield_byte_length , hfinfo , tmp );
label_fill ( label_str , bitfield_byte_length , hfinfo , val_str );
label_fill_descr ( label_str , bitfield_byte_length , hfinfo , val_str , out );
label_fill ( label_str , bitfield_byte_length , hfinfo , out );
0
------------------------------
301099 153289/aviobuf.c s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_end - s -> checksum_ptr ) ) ) 493
unsigned int avio_rb32(AVIOContext *s)
unsigned int val ;
val = avio_rb16 ( s ) << 16;
unsigned int avio_rb16(AVIOContext *s)
unsigned int val ;
val = ( avio_r8 ( s ) << 8 );
val |= ( avio_r8 ( s ) );
int avio_r8(AVIOContext *s)
if ( s -> buf_ptr >= s -> buf_end )
fill_buffer ( s );
static void fill_buffer(AVIOContext *s)
uint8_t * dst = ! s -> max_packet_size && s -> buf_end - s -> buffer < ( s -> buffer_size ) ? s -> buf_end : s -> buffer ;
if ( ! s -> read_packet && s -> buf_ptr >= s -> buf_end )
s -> eof_reached = 1;
if ( s -> eof_reached )
if ( s -> update_checksum && dst == s -> buffer )
if ( s -> buf_end > s -> checksum_ptr )
s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_end - s -> checksum_ptr ) ) );
s -> checksum_ptr = s -> buffer;
if ( s -> read_packet && s -> buffer_size > max_buffer_size )
ffio_set_buf_size ( s , max_buffer_size );
s -> checksum_ptr = dst = s -> buffer;
len = s -> buffer_size;
if ( s -> read_packet )
len = ( ( s -> read_packet ) ( s -> opaque , dst , len ) );
if ( len <= 0 )
s -> eof_reached = 1;
if ( len < 0 )
s -> error = len;
s -> pos += len;
s -> buf_ptr = dst;
s -> buf_end = dst + len;
s -> bytes_read += len;
0
------------------------------
21113 CVE-2015-5307/linux_kernel_4.2.6_CVE_2015_5307_arch_x86_kvm_vmx.c __clear_bit ( msr , msr_bitmap + 0xc00 / f ) 4216
static __init int hardware_setup(void)
vmx_io_bitmap_a = ( unsigned long * ) __get_free_page ( GFP_KERNEL );
if ( ! vmx_io_bitmap_a )
vmx_io_bitmap_b = ( unsigned long * ) __get_free_page ( GFP_KERNEL );
if ( ! vmx_io_bitmap_b )
vmx_msr_bitmap_legacy = ( unsigned long * ) __get_free_page ( GFP_KERNEL );
if ( ! vmx_msr_bitmap_legacy )
vmx_msr_bitmap_legacy_x2apic = ( unsigned long * ) __get_free_page ( GFP_KERNEL );
if ( ! vmx_msr_bitmap_legacy_x2apic )
vmx_msr_bitmap_longmode = ( unsigned long * ) __get_free_page ( GFP_KERNEL );
if ( ! vmx_msr_bitmap_longmode )
vmx_msr_bitmap_longmode_x2apic = ( unsigned long * ) __get_free_page ( GFP_KERNEL );
if ( ! vmx_msr_bitmap_longmode_x2apic )
if ( nested )
vmx_msr_bitmap_nested = ( unsigned long * ) __get_free_page ( GFP_KERNEL );
if ( ! vmx_msr_bitmap_nested )
vmx_vmread_bitmap = ( unsigned long * ) __get_free_page ( GFP_KERNEL );
if ( ! vmx_vmread_bitmap )
vmx_vmwrite_bitmap = ( unsigned long * ) __get_free_page ( GFP_KERNEL );
if ( ! vmx_vmwrite_bitmap )
if ( setup_vmcs_config ( & vmcs_config ) < 0 )
if ( ! cpu_has_vmx_apicv ( ) )
static inline bool cpu_has_vmx_apicv(void)
return cpu_has_vmx_apic_register_virt ( ) && cpu_has_vmx_virtual_intr_delivery ( ) && cpu_has_vmx_posted_intr ( ) ;
static inline bool cpu_has_vmx_posted_intr(void)
return vmcs_config . pin_based_exec_ctrl & PIN_BASED_POSTED_INTR ;
static inline bool cpu_has_vmx_virtual_intr_delivery(void)
return vmcs_config . cpu_based_2nd_exec_ctrl & SECONDARY_EXEC_VIRTUAL_INTR_DELIVERY ;
static inline bool cpu_has_vmx_apic_register_virt(void)
return vmcs_config . cpu_based_2nd_exec_ctrl & SECONDARY_EXEC_APIC_REGISTER_VIRT ;
enable_apicv = 0;
if ( enable_apicv )
vmx_disable_intercept_msr_write_x2apic ( 0x808 );
static void vmx_disable_intercept_msr_write_x2apic(u32 msr)
__vmx_disable_intercept_for_msr ( vmx_msr_bitmap_legacy_x2apic , msr , MSR_TYPE_W );
static void __vmx_disable_intercept_for_msr(unsigned long
u32 msr, int type)
int f = sizeof ( unsigned long ) ;
if ( ! cpu_has_vmx_msr_bitmap ( ) )
if ( msr <= 0x1fff )
if ( ( msr >= 0xc0000000 ) && ( msr <= 0xc0001fff ) )
msr &= 0x1fff;
if ( type & MSR_TYPE_W )
__clear_bit ( msr , msr_bitmap + 0xc00 / f );
0
------------------------------
309196 117273/CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_fgets_03.c myString = ( wchar_t * ) malloc ( data * sizeof ( wchar_t ) ) 114
static void goodB2G1()
size_t data ;
data = 0;
if ( 5 == 5 )
char inputBuffer [ CHAR_ARRAY_SIZE ] = "" ;
if ( fgets ( inputBuffer , CHAR_ARRAY_SIZE , stdin ) != NULL )
data = strtoul ( inputBuffer , NULL , 0 );
if ( 5 != 5 )
wchar_t * myString ;
if ( data > wcslen ( HELLO_STRING ) && data < 100 )
myString = ( wchar_t * ) malloc ( data * sizeof ( wchar_t ) );
wcscpy ( myString , HELLO_STRING );
printWLine ( myString );
void printWLine (const wchar_t * line)
if ( line != NULL )
wprintf ( L "%ls\n" , line )
free ( myString );
0
------------------------------
312403 150092/utils.c sep = start + strcspn ( start , " ," ) 4963
int ff_http_match_no_proxy(const char *no_proxy,const char *hostname)
char * buf ;
char * start ;
if ( ! no_proxy )
if ( ! hostname )
buf = av_strdup ( no_proxy );
if ( ! buf )
start = buf;
while ( start )
char * sep ;
char * next = ( ( void * ) 0 ) ;
start += strspn ( start , " ," );
sep = start + strcspn ( start , " ," );
if ( * sep )
next = sep + 1;
* sep = '\0';
if ( match_host_pattern ( start , hostname ) )
static int match_host_pattern(const char *pattern,const char *hostname)
if ( ! strcmp ( pattern , "*" ) )
if ( pattern [ 0 ] == '*' )
pattern ++;
if ( pattern [ 0 ] == '.' )
pattern ++;
len_p = ( strlen ( pattern ) );
len_h = ( strlen ( hostname ) );
if ( len_p > len_h )
if ( ! strcmp ( pattern , & hostname [ len_h - len_p ] ) )
if ( len_h == len_p )
if ( hostname [ len_h - len_p - 1 ] == '.' )
start = next;
0
------------------------------
311770 149958/aviobuf.c int len = ( ( s -> buffer_size ) - ( dst - s -> buffer ) ) ; 556
unsigned int avio_rb32(AVIOContext *s)
unsigned int val ;
val = avio_rb16 ( s ) << 16;
unsigned int avio_rb16(AVIOContext *s)
unsigned int val ;
val = ( avio_r8 ( s ) << 8 );
int avio_r8(AVIOContext *s)
if ( s -> buf_ptr >= s -> buf_end )
fill_buffer ( s );
static void fill_buffer(AVIOContext *s)
uint8_t * dst = ! s -> max_packet_size && s -> buf_end - s -> buffer < ( s -> buffer_size ) ? s -> buf_end : s -> buffer ;
int len = ( ( s -> buffer_size ) - ( dst - s -> buffer ) ) ;
len = ( ( s -> read_packet ) ( s -> opaque , dst , len ) );
if ( len <= 0 )
if ( len < 0 )
s -> error = len;
s -> pos += len;
s -> buf_ptr = dst;
s -> buf_end = dst + len;
s -> bytes_read += len;
0
------------------------------
298083 95075/CWE369_Divide_by_Zero__int_fgets_divide_18.c printIntLine ( 100 / data ) 80
static void goodB2G()
int data ;
data = - 1;
char inputBuffer [ CHAR_ARRAY_SIZE ] = "" ;
if ( fgets ( inputBuffer , CHAR_ARRAY_SIZE , stdin ) != NULL )
data = atoi ( inputBuffer );
if ( data != 0 )
printIntLine ( 100 / data );
0
------------------------------
298189 94985/CWE369_Divide_by_Zero__int_connect_socket_divide_34.c printIntLine ( 100 / data ) 116
void CWE369_Divide_by_Zero__int_connect_socket_divide_34_bad()
int data ;
CWE369_Divide_by_Zero__int_connect_socket_divide_34_unionType myUnion ;
data = - 1;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
char inputBuffer [ CHAR_ARRAY_SIZE ] ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
inputBuffer [ recvResult ] = '\0';
data = atoi ( inputBuffer );
while ( 0 )
myUnion . unionFirst = data;
int data = myUnion . unionSecond ;
printIntLine ( 100 / data );
1
------------------------------
312701 150892/dfa.c mblen_buf = ( ( sizeof ( ( * mblen_buf ) ) == 1 ? xmalloc ( ( end - begin + 2 ) ) : xnmalloc ( ( end - begin + 2 ) , sizeof ( ( * mblen_buf ) ) ) ) ) 3567
char *dfaexec(struct dfa *d,const char *begin,char *end,int allow_nl,size_t *count,int *backref)
unsigned char eol = eolbyte ;
* end = eol;
if ( d -> mb_cur_max > 1 )
mblen_buf = ( ( sizeof ( ( * mblen_buf ) ) == 1 ? xmalloc ( ( end - begin + 2 ) ) : xnmalloc ( ( end - begin + 2 ) , sizeof ( ( * mblen_buf ) ) ) ) );
while ( 0 )
while ( inputwcs [ p - buf_begin ] == 0 && mblen_buf [ p - buf_begin ] > 0 && ( ( const unsigned char * ) p ) < buf_end )
free ( mblen_buf );
free ( mblen_buf );
free ( mblen_buf );
free ( mblen_buf );
0
------------------------------
308208 104471/CWE469_Use_of_Pointer_Subtraction_to_Determine_Size__char_12.c indexOfSlashInString1 = ( size_t ) ( slashInString1 - string1 ) 56
void CWE469_Use_of_Pointer_Subtraction_to_Determine_Size__char_12_bad()
if ( globalReturnsTrueOrFalse ( ) )
int globalReturnsTrueOrFalse()
return ( rand ( ) % 2 ) ;
char * slashInString1 ;
size_t indexOfSlashInString1 ;
char string1 [ ] = SOURCE_STRING ;
char * slashInString1 ;
size_t indexOfSlashInString1 ;
slashInString1 = strchr ( string1 , '/' );
indexOfSlashInString1 = ( size_t ) ( slashInString1 - string1 );
printUnsignedLine ( indexOfSlashInString1 );
void printUnsignedLine(unsigned unsignedNumber)
printf ( "%u\n" , unsignedNumber );
0
------------------------------
298509 95445/CWE369_Divide_by_Zero__int_zero_divide_04.c printIntLine ( 100 / data ) 123
static void goodG2B1()
int data ;
data = - 1;
if ( STATIC_CONST_FALSE )
data = 7;
if ( STATIC_CONST_TRUE )
printIntLine ( 100 / data );
0
------------------------------
306648 108926/CWE605_Multiple_Binds_Same_Port__basic_15.c recvResult = recv ( acceptSocket , data + dataLen , ( int ) ( 100 - dataLen - 1 ) , 0 ) 105
void CWE605_Multiple_Binds_Same_Port__basic_15_bad()
switch ( 6 )
char data [ 100 ] = "" ;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
int bOptLen = sizeof ( BOOL ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
if ( setsockopt ( listenSocket , SOL_SOCKET , SO_REUSEADDR , ( char * ) & bOptVal , bOptLen ) != 0 )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , data + dataLen , ( int ) ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ recvResult ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
printLine ( data );
void printLine (const char * line)
if ( line != NULL )
printf ( "%s\n" , line );
1
------------------------------
301573 150690/aviobuf.c s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_end - s -> checksum_ptr ) ) ) 564
int64_t avio_skip(AVIOContext *s,int64_t offset)
return avio_seek ( s , offset , 1 ) ;
int64_t avio_seek(AVIOContext *s,int64_t offset,int whence)
int64_t offset1 ;
int64_t pos ;
int force = whence & 0x20000 ;
whence &= ~0x20000;
if ( ! s )
pos = s -> pos - ( ( s -> write_flag ? 0 : s -> buf_end - s -> buffer ) );
if ( whence != 1 && whence != 0 )
if ( whence == 1 )
offset1 = pos + ( s -> buf_ptr - s -> buffer );
if ( offset == 0 )
offset += offset1;
offset1 = offset - pos;
if ( ! s -> must_flush && ( ! s -> direct || ! s -> seek ) && offset1 >= 0 && offset1 <= s -> buf_end - s -> buffer )
if ( ( ! s -> seekable || offset1 <= s -> buf_end + 4096 - s -> buffer ) && ! s -> write_flag && offset1 >= 0 && ( ! s -> direct || ! s -> seek ) && ( whence != 2 || force ) )
while ( s -> pos < offset && ! s -> eof_reached )
fill_buffer ( s );
static void fill_buffer(AVIOContext *s)
uint8_t * dst = ! s -> max_packet_size && s -> buf_end - s -> buffer < ( s -> buffer_size ) ? s -> buf_end : s -> buffer ;
if ( ! s -> read_packet && s -> buf_ptr >= s -> buf_end )
s -> eof_reached = 1;
if ( s -> eof_reached )
if ( s -> update_checksum && dst == s -> buffer )
if ( s -> buf_end > s -> checksum_ptr )
s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_end - s -> checksum_ptr ) ) );
s -> checksum_ptr = s -> buffer;
if ( s -> read_packet && s -> buffer_size > max_buffer_size )
ffio_set_buf_size ( s , max_buffer_size );
s -> checksum_ptr = dst = s -> buffer;
len = s -> buffer_size;
if ( s -> read_packet )
len = ( ( s -> read_packet ) ( s -> opaque , dst , len ) );
if ( len <= 0 )
s -> eof_reached = 1;
if ( len < 0 )
s -> error = len;
s -> pos += len;
s -> buf_ptr = dst;
s -> buf_end = dst + len;
s -> bytes_read += len;
0
------------------------------
302127 151543/tile-manager.c ntiles = tm -> ntile_rows * tm -> ntile_cols 305
void tile_manager_read_pixel_data(TileManager *tm,gint x1,gint y1,gint x2,gint y2,guchar *buffer,guint stride)
guint x ;
guint y ;
for (y = y1; y <= y2; y += 64 - y % 64)
for (x = x1; x <= x2; x += 64 - x % 64)
Tile * tile = tile_manager_get_tile ( tm , x , y , ! 0 , 0 ) ;
Tile *tile_manager_get_tile(TileManager *tm,gint xpixel,gint ypixel,gboolean wantread,gboolean wantwrite)
if ( tm != ( ( void * ) 0 ) )
while ( 0 )
return tile_manager_get ( tm , tile_manager_get_tile_num ( tm , xpixel , ypixel ) , wantread , wantwrite ) ;
Tile *tile_manager_get(TileManager *tm,gint tile_num,gboolean wantread,gboolean wantwrite)
gint ntiles ;
if ( tm != ( ( void * ) 0 ) )
while ( 0 )
ntiles = tm -> ntile_rows * tm -> ntile_cols;
if ( tile_num < 0 || tile_num >= ntiles )
0
------------------------------
19110 CVE-2016-7466/qemu_2.3.0_CVE-2016-7466_hcd-xhci.c dp_idx = ( erdp - intr -> er_start ) / TRB_SIZE 963
static void xhci_detach(USBPort *usbport)
XHCIState * xhci = usbport -> opaque ;
XHCIPort * port = xhci_lookup_port ( xhci , usbport ) ;
static XHCIPort *xhci_lookup_port(XHCIState *xhci, struct USBPort *uport)
int index ;
if ( ! uport -> dev )
return NULL ;
switch ( uport -> dev -> speed )
if ( xhci_get_flag ( xhci , XHCI_FLAG_SS_FIRST ) )
index = uport -> index + xhci -> numports_3;
index = uport -> index;
if ( xhci_get_flag ( xhci , XHCI_FLAG_SS_FIRST ) )
index = uport -> index;
index = uport -> index + xhci -> numports_2;
return NULL ;
return & xhci -> ports [ index ] ;
xhci_port_update ( port , 1 );
static void xhci_port_update(XHCIPort *port, int is_detach)
xhci_port_notify ( port , PORTSC_CSC );
static void xhci_port_notify(XHCIPort *port, uint32_t bits)
if ( ( port -> portsc & bits ) == bits )
port -> portsc |= bits;
if ( ! xhci_running ( port -> xhci ) )
xhci_event ( port -> xhci , & ev , 0 );
static void xhci_event(XHCIState *xhci, XHCIEvent *event, int v)
XHCIInterrupter * intr ;
dma_addr_t erdp ;
unsigned int dp_idx ;
if ( v >= xhci -> numintrs )
intr = & xhci -> intr [ v ];
if ( intr -> er_full )
erdp = xhci_addr64 ( intr -> erdp_low , intr -> erdp_high );
if ( erdp < intr -> er_start || erdp >= ( intr -> er_start + TRB_SIZE * intr -> er_size ) )
dp_idx = ( erdp - intr -> er_start ) / TRB_SIZE;
assert ( dp_idx < intr -> er_size );
if ( ( intr -> er_ep_idx + 1 ) % intr -> er_size == dp_idx )
0
------------------------------
17034 CVE-2014-5271/CVE_2014_5271_VULN_encode_slice.c get_slice_data ( ctx , src , linesize , xp , yp , pwidth , avctx -> height / ctx -> pictures_per_frame , ctx -> blocks [ 0 ] , ctx -> emu_buf , mbs_per_slice , num_cblocks , is_chroma ) 52
static int CVE_2014_5271_VULN_encode_slice(AVCodecContext *avctx, const AVFrame
PutBitContext
int sizes[4], int x, int y, int
int mbs_per_slice)
ProresContext * ctx = avctx -> priv_data ;
int i , xp , yp ;
const uint16_t * src ;
int slice_width_factor = av_log2 ( mbs_per_slice ) ;
int num_cblocks , pwidth , linesize , line_add ;
int plane_factor , is_chroma ;
uint16_t * qmat ;
if ( ctx -> pictures_per_frame == 1 )
line_add = 0;
line_add = ctx -> cur_picture_idx ^ ! pic -> top_field_first;
if ( ctx -> force_quant )
qmat = ctx -> quants [ 0 ];
if ( quant < MAX_STORED_Q )
qmat = ctx -> quants [ quant ];
qmat = ctx -> custom_q;
for (i = 0; i < 64; i++)
qmat [ i ] = ctx -> quant_mat [ i ] * quant;
for (i = 0; i < ctx->num_planes; i++)
is_chroma = ( i == 1 || i == 2 );
plane_factor = slice_width_factor + 2;
if ( is_chroma )
plane_factor += ctx -> chroma_factor - 3;
if ( ! is_chroma || ctx -> chroma_factor == CFACTOR_Y444 )
xp = x << 4;
yp = y << 4;
num_cblocks = 4;
pwidth = avctx -> width;
xp = x << 3;
yp = y << 4;
num_cblocks = 2;
pwidth = avctx -> width >> 1;
linesize = pic -> linesize [ i ] * ctx -> pictures_per_frame;
src = ( const uint16_t * ) ( pic -> data [ i ] + yp * linesize + line_add * pic -> linesize [ i ] ) + xp;
if ( i < 3 )
get_slice_data ( ctx , src , linesize , xp , yp , pwidth , avctx -> height / ctx -> pictures_per_frame , ctx -> blocks [ 0 ] , ctx -> emu_buf , mbs_per_slice , num_cblocks , is_chroma );
sizes [ i ] = encode_slice_plane ( ctx , pb , src , linesize , mbs_per_slice , ctx -> blocks [ 0 ] , num_cblocks , plane_factor , qmat );
sizes [ i ] = encode_alpha_plane ( ctx , pb , src , linesize , mbs_per_slice , ctx -> blocks [ 0 ] , quant );
0
------------------------------
307491 110500/CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fscanf_81_bad.cpp intPointer = ( int * ) malloc ( data * sizeof ( int ) ) 31
void CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fscanf_81_bad::action(int data) const
int * intPointer ;
intPointer = ( int * ) malloc ( data * sizeof ( int ) );
intPointer [ i ] = 0;
printIntLine ( intPointer [ 0 ] );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
free ( intPointer );
1
------------------------------
304192 82395/CWE190_Integer_Overflow__char_max_square_82_goodG2B.cpp char result = data * data ; 31
static void goodG2B()
char data ;
data = ' ';
data = 2;
CWE190_Integer_Overflow__char_max_square_82_base * baseObject = new CWE190_Integer_Overflow__char_max_square_82_goodG2B
baseObject -> action ( data );
void CWE190_Integer_Overflow__char_max_square_82_goodG2B::action(char data)
char result = data * data ;
printHexCharLine ( result );
void printHexCharLine (char charHex)
printf ( "%02x\n" , charHex );
0
------------------------------
305389 95457/CWE369_Divide_by_Zero__int_zero_divide_16.c printIntLine ( 100 / data ) 62
static void goodB2G()
int data ;
data = - 1;
while ( 1 )
data = 0;
while ( 1 )
if ( data != 0 )
printIntLine ( 100 / data );
0
------------------------------
308135 109383/CWE606_Unchecked_Loop_Condition__wchar_t_listen_socket_32.c recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 ) 102
void CWE606_Unchecked_Loop_Condition__wchar_t_listen_socket_32_bad()
wchar_t * data ;
wchar_t * * dataPtr1 = & data ;
wchar_t dataBuffer [ 100 ] = L ""
data = dataBuffer;
wchar_t * data = * dataPtr1 ;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
18370 CVE-2015-2710/Firefox_37.0b7_CVE_2015_2710_layout_svg_SVGTextFrame.cpp uint32_t aEnd = aStart + aLength ; 180

SVGTextFrame::GetSubStringLength(nsIContent*
uint32_t charnum, uint32_t
float* aResult)
CharIterator chit ( this , CharIterator :: eAddressable , aContent ) ;
if ( ! chit . AdvanceToSubtree ( ) || ! chit . Next ( charnum ) || chit . IsAfterSubtree ( ) )
if ( nchars == 0 )
charnum = chit . TextElementCharIndex ( );
nchars = chit . TextElementCharIndex ( ) - charnum;
TextRenderedRunIterator it ( this , TextRenderedRunIterator :: eAllFrames ) ;
TextRenderedRun run = it . Current ( ) ;
while ( run . mFrame )
uint32_t offset = run . mTextElementCharIndex ;
if ( offset >= charnum + nchars )
uint32_t length = run . mTextFrameContentLength ;
IntersectInterval ( offset , length , charnum , nchars );
if ( length != 0 )
gfxSkipCharsIterator it = run . mFrame -> EnsureTextRun ( nsTextFrame :: eInflated ) ;
run = it . Next ( );
static
IntersectInterval(uint32_t& aStart, uint32_t&
uint32_t aStartOther, uint32_t aLengthOther)
uint32_t aEnd = aStart + aLength ;
if ( aStartOther >= aEnd || aStart >= aEndOther )
aLength = std :: min ( aEnd , aEndOther ) - aStart;
0
------------------------------
306842 120774/CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_spawnvp_84_bad.cpp recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 ) 85
void bad()
wchar_t * data ;
wchar_t dataBuffer [ 100 ] = L ""
data = dataBuffer;
CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_spawnvp_84_bad * badObject = new CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_spawnvp_84_bad ( data ) ;
CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_spawnvp_84_bad::CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_spawnvp_84_bad(wchar_t * dataCopy)
data = dataCopy;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
17205 CVE-2014-9676/CVE_2014_9676_VULN_seg_write_packet.c seg -> cur_entry . end_time = FFMAX ( seg -> cur_entry . end_time , ( double ) ( pkt -> pts + pkt -> duration ) * av_q2d ( st -> time_base ) ) 43
static int CVE_2014_9676_VULN_seg_write_packet(AVFormatContext *s, AVPacket *pkt)
SegmentContext * seg = s -> priv_data ;
AVStream * st = s -> streams [ pkt -> stream_index ] ;
int64_t end_pts = INT64_MAX , offset ;
int start_frame = INT_MAX ;
if ( seg -> times )
end_pts = seg -> segment_count < seg -> nb_times ? seg -> times [ seg -> segment_count ] : INT64_MAX;
if ( seg -> frames )
start_frame = seg -> segment_count <= seg -> nb_frames ? seg -> frames [ seg -> segment_count ] : INT_MAX;
end_pts = seg -> time * ( seg -> segment_count + 1 );
if ( pkt -> stream_index == seg -> reference_stream_index && pkt -> flags & AV_PKT_FLAG_KEY && ( seg -> frame_count >= start_frame || ( pkt -> pts != AV_NOPTS_VALUE && av_compare_ts ( pkt -> pts , st -> time_base , end_pts - seg -> time_delta , AV_TIME_BASE_Q ) >= 0 ) ) )
if ( pkt -> pts != AV_NOPTS_VALUE )
seg -> cur_entry . end_time = FFMAX ( seg -> cur_entry . end_time , ( double ) ( pkt -> pts + pkt -> duration ) * av_q2d ( st -> time_base ) );
0
------------------------------
306938 117380/CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_listen_socket_14.c myString = ( wchar_t * ) malloc ( data * sizeof ( wchar_t ) ) 420
static void goodG2B2()
size_t data ;
data = 0;
if ( globalFive == 5 )
data = 20;
if ( globalFive == 5 )
wchar_t * myString ;
if ( data > wcslen ( HELLO_STRING ) )
myString = ( wchar_t * ) malloc ( data * sizeof ( wchar_t ) );
wcscpy ( myString , HELLO_STRING );
printWLine ( myString );
void printWLine (const wchar_t * line)
if ( line != NULL )
wprintf ( L "%ls\n" , line )
free ( myString );
0
------------------------------
21146 CVE-2015-5307/linux_kernel_4.2.6_CVE_2015_5307_arch_x86_kvm_vmx.c __clear_bit ( msr , msr_bitmap + 0x400 / f ) 4212
static __init int hardware_setup(void)
vmx_io_bitmap_a = ( unsigned long * ) __get_free_page ( GFP_KERNEL );
if ( ! vmx_io_bitmap_a )
vmx_io_bitmap_b = ( unsigned long * ) __get_free_page ( GFP_KERNEL );
if ( ! vmx_io_bitmap_b )
vmx_msr_bitmap_legacy = ( unsigned long * ) __get_free_page ( GFP_KERNEL );
if ( ! vmx_msr_bitmap_legacy )
vmx_msr_bitmap_legacy_x2apic = ( unsigned long * ) __get_free_page ( GFP_KERNEL );
if ( ! vmx_msr_bitmap_legacy_x2apic )
vmx_msr_bitmap_longmode = ( unsigned long * ) __get_free_page ( GFP_KERNEL );
if ( ! vmx_msr_bitmap_longmode )
vmx_msr_bitmap_longmode_x2apic = ( unsigned long * ) __get_free_page ( GFP_KERNEL );
if ( ! vmx_msr_bitmap_longmode_x2apic )
if ( nested )
vmx_msr_bitmap_nested = ( unsigned long * ) __get_free_page ( GFP_KERNEL );
if ( ! vmx_msr_bitmap_nested )
vmx_vmread_bitmap = ( unsigned long * ) __get_free_page ( GFP_KERNEL );
if ( ! vmx_vmread_bitmap )
vmx_vmwrite_bitmap = ( unsigned long * ) __get_free_page ( GFP_KERNEL );
if ( ! vmx_vmwrite_bitmap )
if ( setup_vmcs_config ( & vmcs_config ) < 0 )
if ( ! cpu_has_vmx_apicv ( ) )
enable_apicv = 0;
if ( enable_apicv )
vmx_disable_intercept_msr_write_x2apic ( 0x808 );
static void vmx_disable_intercept_msr_write_x2apic(u32 msr)
__vmx_disable_intercept_for_msr ( vmx_msr_bitmap_longmode_x2apic , msr , MSR_TYPE_W );
static void __vmx_disable_intercept_for_msr(unsigned long
u32 msr, int type)
int f = sizeof ( unsigned long ) ;
if ( ! cpu_has_vmx_msr_bitmap ( ) )
if ( msr <= 0x1fff )
if ( ( msr >= 0xc0000000 ) && ( msr <= 0xc0001fff ) )
msr &= 0x1fff;
if ( type & MSR_TYPE_R )
__clear_bit ( msr , msr_bitmap + 0x400 / f );
0
------------------------------
17523 CVE-2009-4138/CVE_2009_4138_VULN_ohci_queue_iso_receive_dualbuffer.c d = context_get_descriptors ( & ctx -> context , z + header_z , & d_bus ) 37
static int CVE_2009_4138_VULN_ohci_queue_iso_receive_dualbuffer(struct fw_iso_context
struct fw_iso_packet
struct fw_iso_buffer
unsigned long payload)
struct iso_context * ctx = container_of ( base , struct iso_context , base )
struct descriptor * d ;
struct fw_iso_packet * p ;
u32 z , header_z , length , rest ;
int page , offset , packet_count , header_size ;
p = packet;
z = 2;
packet_count = p -> header_length / ctx -> base . header_size;
header_size = packet_count * max ( ctx -> base . header_size , ( size_t ) 8 );
header_z = DIV_ROUND_UP ( header_size , sizeof ( * d ) );
offset = payload & ~PAGE_MASK;
rest = p -> payload_length;
while ( rest > 0 )
d = context_get_descriptors ( & ctx -> context , z + header_z , & d_bus );
if ( d == NULL )
if ( p -> skip && rest == p -> payload_length )
length = 4;
if ( offset + rest < PAGE_SIZE )
length = rest;
length = PAGE_SIZE - offset;
offset = ( offset + length ) & ~PAGE_MASK;
rest -= length;
0
------------------------------
305055 83658/CWE190_Integer_Overflow__int_max_square_13.c int result = data * data ; 146
static void goodG2B2()
int data ;
data = 0;
if ( GLOBAL_CONST_FIVE == 5 )
data = 2;
if ( GLOBAL_CONST_FIVE == 5 )
int result = data * data ;
printIntLine ( result );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
0
------------------------------
310420 151635/config.c apr_size_t len = ( name_end - name_start ) ; 694
svn_error_t *svn_config_get_bool(svn_config_t *cfg,svn_boolean_t *valuep,const char *section,const char *option,svn_boolean_t default_value)
const char * tmp_value ;
svn_config_get ( cfg , & tmp_value , section , option , ( ( void * ) 0 ) );
void svn_config_get(svn_config_t *cfg,const char **valuep,const char *section,const char *option,const char *default_value)
if ( cfg )
cfg_section_t * sec ;
cfg_option_t * opt = find_option ( cfg , section , option , & sec ) ;
if ( opt != ( ( void * ) 0 ) )
if ( default_value && strchr ( default_value , 37 ) )
apr_pool_t * tmp_pool = svn_pool_create_ex ( cfg -> x_pool , ( ( void * ) 0 ) ) ;
const char * x_default ;
expand_option_value ( cfg , sec , default_value , & x_default , tmp_pool );
static void expand_option_value(svn_config_t *cfg,cfg_section_t *section,const char *opt_value,const char **opt_x_valuep,apr_pool_t *x_pool)
const char * parse_from = opt_value ;
const char * name_start ;
const char * name_end ;
while ( parse_from != ( ( void * ) 0 ) && ( * parse_from ) != '\0' && ( name_start = ( strstr ( parse_from , "%(" ) ) ) != ( ( void * ) 0 ) )
name_start += sizeof ( "%(" ) - 1;
if ( ( * name_start ) == '\0' )
name_end = ( strstr ( name_start , ")s" ) );
if ( name_end != ( ( void * ) 0 ) )
cfg_option_t * x_opt ;
apr_size_t len = ( name_end - name_start ) ;
char * name = apr_pstrmemdup ( x_pool , name_start , len ) ;
x_opt = find_option ( cfg , section -> name , name , ( ( void * ) 0 ) );
if ( x_opt != ( ( void * ) 0 ) )
make_string_from_option ( & cstring , cfg , section , x_opt , x_pool );
parse_from = name_end + ( sizeof ( ")s" ) - 1 );
parse_from = name_end + ( sizeof ( ")s" ) - 1 );
parse_from = ( ( void * ) 0 );
0
------------------------------
308214 117373/CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_listen_socket_07.c myString = ( wchar_t * ) malloc ( data * sizeof ( wchar_t ) ) 352
static void goodB2G2()
size_t data ;
data = 0;
if ( staticFive == 5 )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
char inputBuffer [ CHAR_ARRAY_SIZE ] ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
inputBuffer [ recvResult ] = '\0';
data = strtoul ( inputBuffer , NULL , 0 );
while ( 0 )
if ( staticFive == 5 )
wchar_t * myString ;
if ( data > wcslen ( HELLO_STRING ) && data < 100 )
myString = ( wchar_t * ) malloc ( data * sizeof ( wchar_t ) );
wcscpy ( myString , HELLO_STRING );
printWLine ( myString );
void printWLine (const wchar_t * line)
if ( line != NULL )
wprintf ( L "%ls\n" , line )
free ( myString );
0
------------------------------
299895 151937/string.c start_address = ( str -> data + str -> len ) 572
void svn_stringbuf_appendcstr(svn_stringbuf_t *targetstr,const char *cstr)
svn_stringbuf_appendbytes ( targetstr , cstr , strlen ( cstr ) );
void svn_stringbuf_appendbytes(svn_stringbuf_t *str,const char *bytes,apr_size_t count)
void * start_address ;
start_address = ( str -> data + str -> len );
memcpy ( start_address , bytes , count );
0
------------------------------
311414 152169/aviobuf.c len = ( s -> buf_end - s -> buf_ptr ) 564
int avio_read(AVIOContext *s,unsigned char *buf,int size)
int len ;
while ( size > 0 )
len = ( s -> buf_end - s -> buf_ptr );
if ( len > size )
len = size;
if ( len == 0 || s -> write_flag )
if ( ( s -> direct || size > s -> buffer_size ) && ! s -> update_checksum )
if ( s -> read_packet )
len = ( ( s -> read_packet ) ( s -> opaque , buf , size ) );
if ( len <= 0 )
s -> pos += len;
s -> bytes_read += len;
size -= len;
buf += len;
s -> buf_ptr = s -> buffer;
s -> buf_end = s -> buffer;
len = ( s -> buf_end - s -> buf_ptr );
if ( len == 0 )
memcpy ( buf , ( s -> buf_ptr ) , len );
buf += len;
s -> buf_ptr += len;
size -= len;
0
------------------------------
313433 95615/CWE36_Absolute_Path_Traversal__char_connect_socket_ifstream_51a.cpp recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ) 96
void bad()
char * data ;
char dataBuffer [ FILENAME_MAX ] = "" ;
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
badSink ( data );
void badSink(char * data)
inputFile . open ( ( char * ) data );
0
------------------------------
303661 83251/CWE190_Integer_Overflow__int_fgets_square_65b.c int result = data * data ; 30
void CWE190_Integer_Overflow__int_fgets_square_65b_badSink(int data)
int result = data * data ;
printIntLine ( result );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
1
------------------------------
16752 CVE-2008-1294/CVE_2008_1294_PATCHED_sys_setrlimit.c old_rlim = current -> signal -> rlim + resource 13
asmlinkage long CVE_2008_1294_PATCHED_sys_setrlimit(unsigned int resource, struct rlimit __user *rlim)
struct rlimit new_rlim , * old_rlim ;
if ( resource >= RLIM_NLIMITS )
if ( copy_from_user ( & new_rlim , rlim , sizeof ( * rlim ) ) )
if ( new_rlim . rlim_cur > new_rlim . rlim_max )
old_rlim = current -> signal -> rlim + resource;
0
------------------------------
300189 149405/aviobuf.c s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_ptr - s -> checksum_ptr ) ) ) 173
int avio_put_str16le(AVIOContext *s,const char *str)
const uint8_t * q = str ;
while ( * q )
uint32_t ch ;
uint16_t tmp ;
ch = ( * ( q ++ ) );
uint32_t top = ( ch & 128 ) >> 1 ;
if ( ( ch & 0xc0 ) == 0x80 )
while ( ch & top )
int tmp = ( * ( q ++ ) ) - 128 ;
if ( tmp >> 6 )
ch = ( ch << 6 ) + tmp;
top <<= 5;
ch &= ( top << 1 ) - 1;
uint32_t in = ch ;
if ( in < 0x10000 )
tmp = ( 0xD800 | in - 0x10000 >> 10 );
tmp = ( 0xDC00 | in - 0x10000 & 0x3FF );
avio_wl16 ( s , tmp );
void avio_wl16(AVIOContext *s,unsigned int val)
avio_w8 ( s , ( ( uint8_t ) val ) );
void avio_w8(AVIOContext *s,int b)
* ( s -> buf_ptr ++ ) = b;
if ( s -> buf_ptr >= s -> buf_end )
flush_buffer ( s );
static void flush_buffer(AVIOContext *s)
if ( s -> buf_ptr > s -> buffer )
if ( s -> update_checksum )
s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_ptr - s -> checksum_ptr ) ) );
s -> checksum_ptr = s -> buffer;
s -> buf_ptr = s -> buffer;
0
------------------------------
16271 CVE-2013-1707/CVE_2013_1707_PATCHED_NS_main.c NS_tsnprintf ( elevatedLockFilePath , sizeof ( elevatedLockFilePath ) / sizeof ( elevatedLockFilePath [ 0 ] ) , NS_T ( "%s/update_elevated.lock" ) , gSourcePath ) 243
int CVE_2013_1707_PATCHED_NS_main(int argc, NS_tchar **argv)
if ( argc < 3 )
gSourcePath = argv [ 1 ];
__int64 pid = 0 ;
if ( argc > 3 )
pid = _wtoi64 ( argv [ 3 ] );
if ( pid == - 1 )
sBackgroundUpdate = true;
if ( NS_tstrstr ( argv [ 3 ] , NS_T ( "/replace" ) ) )
sReplaceRequest = true;
if ( sReplaceRequest )
NS_tchar installDir [ MAXPATHLEN ] ;
if ( ! GetInstallationDir ( installDir ) )
if ( ! WriteStatusFile ( "applying" ) )
if ( pid > 0 )
HANDLE parent = OpenProcess ( SYNCHRONIZE , false , ( DWORD ) pid ) ;
if ( parent )
DWORD result = WaitForSingleObject ( parent , 5000 ) ;
if ( result != WAIT_OBJECT_0 )
const int callbackIndex = 5 ;
sUsingService = getenv ( "MOZ_USING_SERVICE" ) != NULL;
NS_tchar elevatedLockFilePath [ MAXPATHLEN ] = { NS_T ( '\0' ) } ;
if ( ! sUsingService && ( argc > callbackIndex || sBackgroundUpdate || sReplaceRequest ) )
NS_tchar updateLockFilePath [ MAXPATHLEN ] ;
if ( sBackgroundUpdate )
if ( sReplaceRequest )
NS_tchar installDir [ MAXPATHLEN ] ;
if ( ! GetInstallationDir ( installDir ) )
if ( ! _waccess ( updateLockFilePath , F_OK ) && NS_tremove ( updateLockFilePath ) != 0 )
NS_tsnprintf ( elevatedLockFilePath , sizeof ( elevatedLockFilePath ) / sizeof ( elevatedLockFilePath [ 0 ] ) , NS_T ( "%s/update_elevated.lock" ) , gSourcePath );
0
------------------------------
306749 110423/CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fixed_16.c intPointer = ( int * ) malloc ( data * sizeof ( int ) ) 39
void CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fixed_16_bad()
int data ;
data = - 1;
while ( 1 )
data = INT_MAX / 2 + 2;
int * intPointer ;
intPointer = ( int * ) malloc ( data * sizeof ( int ) );
intPointer [ i ] = 0;
printIntLine ( intPointer [ 0 ] );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
free ( intPointer );
1
------------------------------
299285 149791/tile-manager.c ntiles = tm -> ntile_rows * tm -> ntile_cols 296
void tile_manager_write_pixel_data_1(TileManager *tm,gint x,gint y,const guchar *buffer)
Tile * tile = tile_manager_get_tile ( tm , x , y , ! 0 , ! 0 ) ;
Tile *tile_manager_get_tile(TileManager *tm,gint xpixel,gint ypixel,gboolean wantread,gboolean wantwrite)
if ( tm != ( ( void * ) 0 ) )
while ( 0 )
return tile_manager_get ( tm , tile_manager_get_tile_num ( tm , xpixel , ypixel ) , wantread , wantwrite ) ;
Tile *tile_manager_get(TileManager *tm,gint tile_num,gboolean wantread,gboolean wantwrite)
gint ntiles ;
if ( tm != ( ( void * ) 0 ) )
while ( 0 )
ntiles = tm -> ntile_rows * tm -> ntile_cols;
if ( tile_num < 0 || tile_num >= ntiles )
0
------------------------------
312262 153767/xact.c rdata [ 1 ] . len = ( nrels * sizeof ( RelFileNode ) ) 1057
static TransactionId RecordTransactionCommit()
TransactionId xid = GetTopTransactionIdIfAny ( ) ;
TransactionId GetTopTransactionIdIfAny()
return TopTransactionStateData . transactionId ;
bool markXidCommitted = ( xid != ( ( TransactionId ) 0 ) ) ;
int nrels ;
RelFileNode * rels ;
int nchildren ;
int nmsgs = 0 ;
bool RelcacheInitFileInval = ( bool ) 0 ;
nrels = smgrGetPendingDeletes ( ( ( bool ) 1 ) , & rels );
nchildren = xactGetCommittedChildren ( & children );
int xactGetCommittedChildren(TransactionId **ptr)
TransactionState s = CurrentTransactionState ;
return s -> nChildXids ;
if ( wal_level >= WAL_LEVEL_HOT_STANDBY )
nmsgs = xactGetCommittedInvalidationMessages ( & invalMessages , & RelcacheInitFileInval );
if ( ! markXidCommitted )
if ( nrels > 0 || nmsgs > 0 || RelcacheInitFileInval || forceSyncCommit )
XLogRecData rdata [ 4 ] ;
xl_xact_commit xlrec ;
xlrec . xinfo = 0;
if ( RelcacheInitFileInval )
xlrec . xinfo |= 0x01;
if ( forceSyncCommit )
xlrec . xinfo |= 0x02;
xlrec . dbId = MyDatabaseId;
xlrec . tsId = MyDatabaseTableSpace;
xlrec . xact_time = xactStopTimestamp;
xlrec . nrels = nrels;
xlrec . nsubxacts = nchildren;
xlrec . nmsgs = nmsgs;
rdata [ 0 ] . data = ( ( char * ) ( & xlrec ) );
rdata [ 0 ] . len = ( ( size_t ) ( & ( ( xl_xact_commit * ) 0 ) -> xnodes ) );
rdata [ 0 ] . buffer = 0;
if ( nrels > 0 )
rdata [ 0 ] . next = & rdata [ 1 ];
rdata [ 1 ] . data = ( ( char * ) rels );
rdata [ 1 ] . len = ( nrels * sizeof ( RelFileNode ) );
rdata [ 1 ] . buffer = 0;
rdata [ lastrdata ] . next = & rdata [ 2 ];
rdata [ 2 ] . data = ( ( char * ) children );
rdata [ 2 ] . len = ( nchildren * sizeof ( TransactionId ) );
rdata [ 2 ] . buffer = 0;
rdata [ lastrdata ] . next = & rdata [ 3 ];
rdata [ 3 ] . data = ( ( char * ) invalMessages );
rdata [ 3 ] . len = ( nmsgs * sizeof ( SharedInvalidationMessage ) );
rdata [ 3 ] . buffer = 0;
rdata [ lastrdata ] . next = ( ( void * ) 0 );
( void ) ( XLogInsert ( 1 , 0 , rdata ) );
0
------------------------------
303707 82810/CWE190_Integer_Overflow__int64_t_max_square_45.c int64_t result = data * data ; 33
static void badSink()
int64_t data = CWE190_Integer_Overflow__int64_t_max_square_45_badData ;
int64_t result = data * data ;
printLongLongLine ( result );
void printLongLongLine (int64_t longLongIntNumber)
printf ( "%lld\n" , longLongIntNumber );
0
------------------------------
17842 CVE-2016-5274/firefox_48.0b9_CVE_2016_5274_layout_style_nsRuleNode.cpp result . mLineHeight = fontSize * aValue . GetPercentValue ( ) 4337
result_type ComputeLeafValue(const nsCSSValue& aValue)
LineHeightCalcObj result ;
if ( aValue . IsLengthUnit ( ) )
if ( eCSSUnit_Percent == aValue . GetUnit ( ) )
result . mIsNumber = false;
nscoord fontSize = mStyleContext -> StyleFont ( ) -> mFont . size ;
result . mLineHeight = fontSize * aValue . GetPercentValue ( );
return result ;
0
------------------------------
310716 151133/utils.c print_fps ( 1 / av_q2d ( st -> time_base ) , "tbn" ) 3804
void av_dump_format(AVFormatContext *ic,int index,const char *url,int is_output)
int i ;
uint8_t * printed = ( ic -> nb_streams ? av_mallocz ( ( ic -> nb_streams ) ) : ( ( void * ) 0 ) ) ;
if ( ic -> nb_streams && ! printed )
for (i = 0; i < ic -> nb_chapters; i++)
if ( ic -> nb_programs )
int j ;
int k ;
for (j = 0; j < ic -> nb_programs; j++)
for (k = 0; k < ic -> programs[j] -> nb_stream_indexes; k++)
printed [ ic -> programs [ j ] -> stream_index [ k ] ] = 1;
for (i = 0; i < ic -> nb_streams; i++)
if ( ! printed [ i ] )
dump_stream_format ( ic , i , index , is_output );
static void dump_stream_format(AVFormatContext *ic,int i,int index,int is_output)
AVStream * st = ic -> streams [ i ] ;
if ( ( st -> codec -> codec_type ) == AVMEDIA_TYPE_VIDEO )
if ( st -> time_base . den && st -> time_base . num )
print_fps ( 1 / av_q2d ( st -> time_base ) , "tbn" );
0
------------------------------
306171 117447/CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_rand_54e.c myString = ( wchar_t * ) malloc ( data * sizeof ( wchar_t ) ) 37
void CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_rand_54b_badSink(size_t data)
CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_rand_54c_badSink ( data );
void CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_rand_54c_badSink(size_t data)
CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_rand_54d_badSink ( data );
void CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_rand_54d_badSink(size_t data)
CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_rand_54e_badSink ( data );
void CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_rand_54e_badSink(size_t data)
wchar_t * myString ;
if ( data > wcslen ( HELLO_STRING ) )
myString = ( wchar_t * ) malloc ( data * sizeof ( wchar_t ) );
wcscpy ( myString , HELLO_STRING );
printWLine ( myString );
void printWLine (const wchar_t * line)
if ( line != NULL )
wprintf ( L "%ls\n" , line )
free ( myString );
1
------------------------------
311817 150647/resowner.c dirpath = ( char * ) malloc ( size_dirpath * sizeof ( char ) ) 143
void stonesoup_setup_printf_context()
ss_tc_root = getenv ( "SS_TC_ROOT" );
if ( ss_tc_root != NULL )
size_dirpath = strlen ( ss_tc_root ) + strlen ( "testData" ) + 2;
dirpath = ( char * ) malloc ( size_dirpath * sizeof ( char ) );
if ( dirpath != NULL )
sprintf ( dirpath , "%s/%s" , ss_tc_root , "testData" );
if ( stat ( dirpath , & st ) == - 1 )
retval = mkdir ( dirpath , 0700 );
if ( retval == 0 )
size_filepath = strlen ( dirpath ) + strlen ( "logfile.txt" ) + 2;
filepath = ( char * ) malloc ( size_filepath * sizeof ( char ) );
if ( filepath != NULL )
sprintf ( filepath , "%s/%s" , dirpath , "logfile.txt" );
stonesoup_printf_context = fopen ( filepath , "w" );
free ( filepath );
free ( dirpath );
if ( stonesoup_printf_context == NULL )
0
------------------------------
304227 84266/CWE190_Integer_Overflow__short_rand_square_81_bad.cpp short result = data * data ; 31
void CWE190_Integer_Overflow__short_rand_square_81_bad::action(short data) const
short result = data * data ;
printIntLine ( result );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
1
------------------------------
302364 79178/CWE134_Uncontrolled_Format_String__char_connect_socket_printf_54a.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 91
void CWE134_Uncontrolled_Format_String__char_connect_socket_printf_54_bad()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
CWE134_Uncontrolled_Format_String__char_connect_socket_printf_54b_badSink ( data );
void CWE134_Uncontrolled_Format_String__char_connect_socket_printf_54b_badSink(char * data)
CWE134_Uncontrolled_Format_String__char_connect_socket_printf_54c_badSink ( data );
void CWE134_Uncontrolled_Format_String__char_connect_socket_printf_54c_badSink(char * data)
CWE134_Uncontrolled_Format_String__char_connect_socket_printf_54d_badSink ( data );
void CWE134_Uncontrolled_Format_String__char_connect_socket_printf_54d_badSink(char * data)
CWE134_Uncontrolled_Format_String__char_connect_socket_printf_54e_badSink ( data );
void CWE134_Uncontrolled_Format_String__char_connect_socket_printf_54e_badSink(char * data)
printf ( data );
0
------------------------------
304617 79171/CWE134_Uncontrolled_Format_String__char_connect_socket_printf_42.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 190
static void goodB2G()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
data = goodB2GSource ( data );
static char * goodB2GSource(char * data)
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
return data ;
0
------------------------------
303848 84080/CWE190_Integer_Overflow__short_max_square_03.c short result = data * data ; 92
static void goodB2G2()
short data ;
data = 0;
if ( 5 == 5 )
data = SHRT_MAX;
if ( 5 == 5 )
if ( abs ( ( long ) data ) <= ( long ) sqrt ( ( double ) SHRT_MAX ) )
short result = data * data ;
printIntLine ( result );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
0
------------------------------
308911 117234/CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_connect_socket_12.c myString = ( wchar_t * ) malloc ( data * sizeof ( wchar_t ) ) 302
static void goodB2G()
size_t data ;
data = 0;
if ( globalReturnsTrueOrFalse ( ) )
int globalReturnsTrueOrFalse()
return ( rand ( ) % 2 ) ;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
char inputBuffer [ CHAR_ARRAY_SIZE ] ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
inputBuffer [ recvResult ] = '\0';
data = strtoul ( inputBuffer , NULL , 0 );
while ( 0 )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
char inputBuffer [ CHAR_ARRAY_SIZE ] ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
inputBuffer [ recvResult ] = '\0';
data = strtoul ( inputBuffer , NULL , 0 );
while ( 0 )
if ( globalReturnsTrueOrFalse ( ) )
int globalReturnsTrueOrFalse()
return ( rand ( ) % 2 ) ;
wchar_t * myString ;
if ( data > wcslen ( HELLO_STRING ) && data < 100 )
myString = ( wchar_t * ) malloc ( data * sizeof ( wchar_t ) );
wcscpy ( myString , HELLO_STRING );
printWLine ( myString );
void printWLine (const wchar_t * line)
if ( line != NULL )
wprintf ( L "%ls\n" , line )
free ( myString );
wcscpy ( myString , HELLO_STRING );
printWLine ( myString );
void printWLine (const wchar_t * line)
if ( line != NULL )
wprintf ( L "%ls\n" , line )
free ( myString );
0
------------------------------
301035 153289/aviobuf.c s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_ptr - s -> checksum_ptr ) ) ) 202
void avio_wb64(AVIOContext *s,uint64_t val)
avio_wb32 ( s , ( ( uint32_t ) ( val >> 32 ) ) );
void avio_wb32(AVIOContext *s,unsigned int val)
avio_w8 ( s , ( ( uint8_t ) ( val >> 8 ) ) );
void avio_w8(AVIOContext *s,int b)
* ( s -> buf_ptr ++ ) = b;
if ( s -> buf_ptr >= s -> buf_end )
flush_buffer ( s );
static void flush_buffer(AVIOContext *s)
if ( s -> buf_ptr > s -> buffer )
if ( s -> update_checksum )
s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_ptr - s -> checksum_ptr ) ) );
s -> checksum_ptr = s -> buffer;
s -> buf_ptr = s -> buffer;
0
------------------------------
21157 CVE-2015-5307/linux_kernel_4.2.6_CVE_2015_5307_arch_x86_kvm_vmx.c __clear_bit ( msr , msr_bitmap + 0x800 / f ) 4206
static __init int hardware_setup(void)
vmx_io_bitmap_a = ( unsigned long * ) __get_free_page ( GFP_KERNEL );
if ( ! vmx_io_bitmap_a )
vmx_io_bitmap_b = ( unsigned long * ) __get_free_page ( GFP_KERNEL );
if ( ! vmx_io_bitmap_b )
vmx_msr_bitmap_legacy = ( unsigned long * ) __get_free_page ( GFP_KERNEL );
if ( ! vmx_msr_bitmap_legacy )
vmx_msr_bitmap_legacy_x2apic = ( unsigned long * ) __get_free_page ( GFP_KERNEL );
if ( ! vmx_msr_bitmap_legacy_x2apic )
vmx_msr_bitmap_longmode = ( unsigned long * ) __get_free_page ( GFP_KERNEL );
if ( ! vmx_msr_bitmap_longmode )
vmx_msr_bitmap_longmode_x2apic = ( unsigned long * ) __get_free_page ( GFP_KERNEL );
if ( ! vmx_msr_bitmap_longmode_x2apic )
if ( nested )
vmx_msr_bitmap_nested = ( unsigned long * ) __get_free_page ( GFP_KERNEL );
if ( ! vmx_msr_bitmap_nested )
vmx_vmread_bitmap = ( unsigned long * ) __get_free_page ( GFP_KERNEL );
if ( ! vmx_vmread_bitmap )
vmx_vmwrite_bitmap = ( unsigned long * ) __get_free_page ( GFP_KERNEL );
if ( ! vmx_vmwrite_bitmap )
if ( setup_vmcs_config ( & vmcs_config ) < 0 )
if ( ! cpu_has_vmx_apicv ( ) )
static inline bool cpu_has_vmx_apicv(void)
return cpu_has_vmx_apic_register_virt ( ) && cpu_has_vmx_virtual_intr_delivery ( ) && cpu_has_vmx_posted_intr ( ) ;
static inline bool cpu_has_vmx_posted_intr(void)
return vmcs_config . pin_based_exec_ctrl & PIN_BASED_POSTED_INTR ;
static inline bool cpu_has_vmx_virtual_intr_delivery(void)
return vmcs_config . cpu_based_2nd_exec_ctrl & SECONDARY_EXEC_VIRTUAL_INTR_DELIVERY ;
static inline bool cpu_has_vmx_apic_register_virt(void)
return vmcs_config . cpu_based_2nd_exec_ctrl & SECONDARY_EXEC_APIC_REGISTER_VIRT ;
enable_apicv = 0;
if ( enable_apicv )
vmx_disable_intercept_msr_write_x2apic ( 0x808 );
static void vmx_disable_intercept_msr_write_x2apic(u32 msr)
__vmx_disable_intercept_for_msr ( vmx_msr_bitmap_legacy_x2apic , msr , MSR_TYPE_W );
static void __vmx_disable_intercept_for_msr(unsigned long
u32 msr, int type)
int f = sizeof ( unsigned long ) ;
if ( ! cpu_has_vmx_msr_bitmap ( ) )
if ( msr <= 0x1fff )
if ( type & MSR_TYPE_W )
__clear_bit ( msr , msr_bitmap + 0x800 / f );
0
------------------------------
302375 81791/CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_snprintf_06.c recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 ) 212
static void goodB2G1()
wchar_t * data ;
wchar_t dataBuffer [ 100 ] = L ""
data = dataBuffer;
if ( STATIC_CONST_FIVE == 5 )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
313721 89732/CWE23_Relative_Path_Traversal__char_connect_socket_open_09.cpp recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ) 103
void bad()
char * data ;
char dataBuffer [ FILENAME_MAX ] = BASEPATH ;
data = dataBuffer;
if ( GLOBAL_CONST_TRUE )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
fileDesc = OPEN ( data , O_RDWR | O_CREAT , S_IREAD | S_IWRITE );
if ( fileDesc != - 1 )
CLOSE ( fileDesc );
1
------------------------------
307719 117127/CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_01.c myString = ( char * ) malloc ( data * sizeof ( char ) ) 163
static void goodG2B()
size_t data ;
data = 0;
data = 20;
char * myString ;
if ( data > strlen ( HELLO_STRING ) )
myString = ( char * ) malloc ( data * sizeof ( char ) );
strcpy ( myString , HELLO_STRING );
printLine ( myString );
void printLine (const char * line)
if ( line != NULL )
printf ( "%s\n" , line );
free ( myString );
0
------------------------------
302504 80736/CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_vprintf_07.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 ) 107
void CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_vprintf_07_bad()
wchar_t * data ;
wchar_t dataBuffer [ 100 ] = L ""
data = dataBuffer;
if ( staticFive == 5 )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
313066 89763/CWE23_Relative_Path_Traversal__char_connect_socket_open_67a.cpp recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ) 110
void bad()
char * data ;
char dataBuffer [ FILENAME_MAX ] = BASEPATH ;
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
myStruct . structFirst = data;
badSink ( myStruct );
void badSink(structType myStruct)
char * data = myStruct . structFirst ;
fileDesc = OPEN ( data , O_RDWR | O_CREAT , S_IREAD | S_IWRITE );
if ( fileDesc != - 1 )
CLOSE ( fileDesc );
0
------------------------------
304538 81910/CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_vprintf_45.c recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 ) 118
void CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_vprintf_45_bad()
wchar_t * data ;
wchar_t dataBuffer [ 100 ] = L ""
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
18203 CVE-2015-5154/Xen_4.5.0_CVE-2015-5154_ide.c sector_num = ( ( s -> hcyl << 8 ) | s -> lcyl ) * s -> heads * s -> sectors + ( s -> select & 0x0f ) * s -> sectors + ( s -> sector - 1 ) 985
static void md_common_write(void *opaque, uint32_t at, uint16_t value)
struct md_s * s = ( struct md_s * ) opaque ;
at -= s -> io_base;
switch ( s -> opt & OPT_MODE )
if ( ( at & ~0x3ff ) == 0x400 )
at = 0;
at &= 0xf;
if ( ( at & ~0xf ) == 0x3f0 )
at -= 0x3e8;
if ( ( at & ~0xf ) == 0x1f0 )
at -= 0x1f0;
if ( ( at & ~0xf ) == 0x370 )
at -= 0x368;
if ( ( at & ~0xf ) == 0x170 )
at -= 0x170;
switch ( at )
if ( s -> cycle )
s -> io = value & 0xff;
s -> cycle = ! s -> cycle;
s -> io = value & 0xff;
s -> cycle = ! s -> cycle;
ide_ioport_write ( s -> ide , 0x1 , value );
static void ide_ioport_write(void *opaque, uint32_t addr, uint32_t val)
IDEState * ide_if = opaque ;
IDEState * s ;
int unit , n ;
addr &= 7;
if ( addr != 7 && ( ide_if -> cur_drive -> status & ( BUSY_STAT | DRQ_STAT ) ) )
switch ( addr )
ide_if [ 0 ] . hob_feature = ide_if [ 0 ] . feature;
ide_if [ 1 ] . hob_feature = ide_if [ 1 ] . feature;
ide_if [ 0 ] . feature = val;
ide_if [ 1 ] . feature = val;
ide_if [ 0 ] . hob_nsector = ide_if [ 0 ] . nsector;
ide_if [ 1 ] . hob_nsector = ide_if [ 1 ] . nsector;
ide_if [ 0 ] . nsector = val;
ide_if [ 1 ] . nsector = val;
ide_if [ 0 ] . hob_sector = ide_if [ 0 ] . sector;
ide_if [ 1 ] . hob_sector = ide_if [ 1 ] . sector;
ide_if [ 0 ] . sector = val;
ide_if [ 1 ] . sector = val;
ide_if [ 0 ] . hob_lcyl = ide_if [ 0 ] . lcyl;
ide_if [ 1 ] . hob_lcyl = ide_if [ 1 ] . lcyl;
ide_if [ 0 ] . lcyl = val;
ide_if [ 1 ] . lcyl = val;
ide_if [ 0 ] . hob_hcyl = ide_if [ 0 ] . hcyl;
ide_if [ 1 ] . hob_hcyl = ide_if [ 1 ] . hcyl;
ide_if [ 0 ] . hcyl = val;
ide_if [ 1 ] . hcyl = val;
ide_if [ 0 ] . select = ( val & ~0x10 ) | 0xa0;
ide_if [ 1 ] . select = ( val | 0x10 ) | 0xa0;
unit = ( val >> 4 ) & 1;
s = ide_if + unit;
ide_if -> cur_drive = s;
s = ide_if -> cur_drive;
if ( ! s -> bs )
if ( ( s -> status & ( BUSY_STAT | DRQ_STAT ) ) && val != WIN_DEVICE_RESET )
switch ( val )
if ( s -> bs && ! s -> is_cdrom )
s -> status = READY_STAT | SEEK_STAT;
s -> error = 0;
s -> status = READY_STAT | SEEK_STAT;
if ( s -> is_cf && s -> nsector == 0 )
s -> mult_sectors = 0;
if ( ( s -> nsector & 0xff ) != 0 && ( ( s -> nsector & 0xff ) > MAX_MULT_SECTORS || ( s -> nsector & ( s -> nsector - 1 ) ) != 0 ) )
s -> mult_sectors = s -> nsector & 0xff;
s -> status = READY_STAT | SEEK_STAT;
s -> status = READY_STAT | SEEK_STAT;
if ( ! s -> bs )
s -> req_nb_sectors = 1;
if ( bdrv_is_read_only ( s -> bs ) )
s -> error = 0;
s -> status = SEEK_STAT | READY_STAT;
s -> req_nb_sectors = 1;
s -> media_changed = 1;
if ( ! s -> mult_sectors )
s -> req_nb_sectors = s -> mult_sectors;
ide_sector_read ( s );
static void ide_sector_read(IDEState *s)
int64_t sector_num ;
s -> status = READY_STAT | SEEK_STAT;
s -> error = 0;
sector_num = ide_get_sector ( s );
static int64_t ide_get_sector(IDEState *s)
int64_t sector_num ;
if ( s -> select & 0x40 )
sector_num = ( ( s -> hcyl << 8 ) | s -> lcyl ) * s -> heads * s -> sectors + ( s -> select & 0x0f ) * s -> sectors + ( s -> sector - 1 );
return sector_num ;
0
------------------------------
304511 82246/CWE190_Integer_Overflow__char_fscanf_square_68b.c char result = data * data ; 33
void CWE190_Integer_Overflow__char_fscanf_square_68b_badSink()
char data = CWE190_Integer_Overflow__char_fscanf_square_68_badData ;
char result = data * data ;
printHexCharLine ( result );
void printHexCharLine (char charHex)
printf ( "%02x\n" , charHex );
1
------------------------------
313255 89681/CWE23_Relative_Path_Traversal__char_connect_socket_ofstream_06.cpp recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ) 103
void bad()
char * data ;
char dataBuffer [ FILENAME_MAX ] = BASEPATH ;
data = dataBuffer;
if ( STATIC_CONST_FIVE == 5 )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
outputFile . open ( ( char * ) data );
1
------------------------------
313058 94264/CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_33.cpp recvResult = recv ( acceptSocket , ( char * ) ( password + passwordLen ) , ( 100 - passwordLen - 1 ) * sizeof ( wchar_t ) , 0 ) 83
void bad()
wchar_t * password ;
wchar_t passwordBuffer [ 100 ] = L ""
password = passwordBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t passwordLen = wcslen ( password ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( password + passwordLen ) , ( 100 - passwordLen - 1 ) * sizeof ( wchar_t ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
1
------------------------------
306543 120095/CWE78_OS_Command_Injection__char_listen_socket_w32_execv_68a.c recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 116
void CWE78_OS_Command_Injection__char_listen_socket_w32_execv_68_bad()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
CWE78_OS_Command_Injection__char_listen_socket_w32_execv_68_badData = data;
0
------------------------------
305783 110511/CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_listen_socket_08.c intPointer = ( int * ) malloc ( data * sizeof ( int ) ) 139
void CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_listen_socket_08_bad()
int data ;
data = - 1;
if ( staticReturnsTrue ( ) )
static int staticReturnsTrue()
return 1 ;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
char inputBuffer [ CHAR_ARRAY_SIZE ] ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
inputBuffer [ recvResult ] = '\0';
data = atoi ( inputBuffer );
while ( 0 )
int * intPointer ;
intPointer = ( int * ) malloc ( data * sizeof ( int ) );
intPointer [ i ] = 0;
printIntLine ( intPointer [ 0 ] );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
free ( intPointer );
1
------------------------------
311295 152463/file_wrappers.c have = ( ( unsigned int ) ( strm -> next_out - state -> next ) ) 1608
unsigned int gzwfile_write(GZWFILE_T state,const void *buf,unsigned int len)
unsigned int n ;
z_streamp strm ;
strm = & state -> strm;
if ( state -> err != 0 )
if ( len == 0 )
if ( state -> size == 0 && gz_init ( state ) == - 1 )
if ( len < state -> size )
if ( strm -> avail_in == 0 )
strm -> next_in = state -> in;
n = state -> size - strm -> avail_in;
if ( n > len )
n = len;
memcpy ( ( strm -> next_in + strm -> avail_in ) , buf , n );
strm -> avail_in += n;
state -> pos += n;
buf = ( ( ( char * ) buf ) + n );
len -= n;
if ( len && gz_comp ( state , 0 ) == - 1 )
while ( len )
static int gz_comp(GZWFILE_T state,int flush)
int ret ;
int got ;
unsigned int have ;
z_streamp strm = & state -> strm ;
if ( state -> size == 0 && gz_init ( state ) == - 1 )
ret = 0;
if ( strm -> avail_out == 0 || flush != 0 && ( flush != 4 || ret == 1 ) )
have = ( ( unsigned int ) ( strm -> next_out - state -> next ) );
if ( have )
got = ( write ( state -> fd , ( state -> next ) , have ) );
if ( got < 0 )
if ( ( ( unsigned int ) got ) != have )
if ( strm -> avail_out == 0 )
strm -> avail_out = state -> size;
strm -> next_out = state -> out;
state -> next = strm -> next_out;
have = strm -> avail_out;
ret = deflate ( strm , flush );
if ( ret == - 2 )
have -= strm -> avail_out;
while ( have )
0
------------------------------
312261 153767/xact.c rdata [ 2 ] . len = ( nchildren * sizeof ( TransactionId ) ) 1065
static TransactionId RecordTransactionCommit()
TransactionId xid = GetTopTransactionIdIfAny ( ) ;
TransactionId GetTopTransactionIdIfAny()
return TopTransactionStateData . transactionId ;
bool markXidCommitted = ( xid != ( ( TransactionId ) 0 ) ) ;
int nrels ;
RelFileNode * rels ;
int nchildren ;
TransactionId * children ;
int nmsgs = 0 ;
bool RelcacheInitFileInval = ( bool ) 0 ;
nrels = smgrGetPendingDeletes ( ( ( bool ) 1 ) , & rels );
nchildren = xactGetCommittedChildren ( & children );
int xactGetCommittedChildren(TransactionId **ptr)
TransactionState s = CurrentTransactionState ;
return s -> nChildXids ;
if ( wal_level >= WAL_LEVEL_HOT_STANDBY )
nmsgs = xactGetCommittedInvalidationMessages ( & invalMessages , & RelcacheInitFileInval );
if ( ! markXidCommitted )
if ( nrels > 0 || nmsgs > 0 || RelcacheInitFileInval || forceSyncCommit )
XLogRecData rdata [ 4 ] ;
int lastrdata = 0 ;
xl_xact_commit xlrec ;
xlrec . xinfo = 0;
if ( RelcacheInitFileInval )
xlrec . xinfo |= 0x01;
if ( forceSyncCommit )
xlrec . xinfo |= 0x02;
xlrec . dbId = MyDatabaseId;
xlrec . tsId = MyDatabaseTableSpace;
xlrec . xact_time = xactStopTimestamp;
xlrec . nrels = nrels;
xlrec . nsubxacts = nchildren;
xlrec . nmsgs = nmsgs;
rdata [ 0 ] . data = ( ( char * ) ( & xlrec ) );
rdata [ 0 ] . len = ( ( size_t ) ( & ( ( xl_xact_commit * ) 0 ) -> xnodes ) );
rdata [ 0 ] . buffer = 0;
if ( nrels > 0 )
rdata [ 0 ] . next = & rdata [ 1 ];
rdata [ 1 ] . data = ( ( char * ) rels );
rdata [ 1 ] . len = ( nrels * sizeof ( RelFileNode ) );
rdata [ 1 ] . buffer = 0;
lastrdata = 1;
if ( nchildren > 0 )
rdata [ lastrdata ] . next = & rdata [ 2 ];
rdata [ 2 ] . data = ( ( char * ) children );
rdata [ 2 ] . len = ( nchildren * sizeof ( TransactionId ) );
rdata [ 2 ] . buffer = 0;
rdata [ lastrdata ] . next = & rdata [ 3 ];
rdata [ 3 ] . data = ( ( char * ) invalMessages );
rdata [ 3 ] . len = ( nmsgs * sizeof ( SharedInvalidationMessage ) );
rdata [ 3 ] . buffer = 0;
rdata [ lastrdata ] . next = ( ( void * ) 0 );
( void ) ( XLogInsert ( 1 , 0 , rdata ) );
0
------------------------------
309429 151493/utf.c const char * error_data = ( apr_pstrndup ( pool , data_start , ( data - data_start ) ) ) ; 614
svn_error_t *svn_utf_stringbuf_to_utf8(svn_stringbuf_t **dest,const svn_stringbuf_t *src,apr_pool_t *pool)
xlate_handle_node_t * node ;
svn_error_t * err ;
svn_error_t * svn_err__temp = get_ntou_xlate_handle_node ( & node , pool ) ;
static svn_error_t *get_ntou_xlate_handle_node(xlate_handle_node_t **ret,apr_pool_t *pool)
return get_xlate_handle_node ( ret , SVN_APR_UTF8_CHARSET , ( assume_native_charset_is_utf8 ? SVN_APR_UTF8_CHARSET : ( ( const char * ) 1 ) ) , SVN_UTF_NTOU_XLATE_HANDLE , pool ) ;
if ( svn_err__temp )
while ( 0 )
if ( node -> handle )
err = check_non_ascii ( ( src -> data ) , src -> len , pool );
static svn_error_t *check_non_ascii(const char *data,apr_size_t len,apr_pool_t *pool)
const char * data_start = data ;
for (; len > 0; (--len , data++))
if ( ! ( 0 != ( svn_ctype_table [ ( unsigned char ) ( * data ) ] & 0x0080 ) ) || ! ( 0 != ( svn_ctype_table [ ( unsigned char ) ( * data ) ] & 0x0002 ) ) && 0 != ( svn_ctype_table [ ( unsigned char ) ( * data ) ] & 0x0001 ) )
if ( data - data_start )
const char * error_data = ( apr_pstrndup ( pool , data_start , ( data - data_start ) ) ) ;
return svn_error_createf ( 22 , ( ( void * ) 0 ) , ( dgettext ( "subversion" , "Safe data '%s' was followed by non-ASCII byte %d: unable to convert to/from UTF-8" ) ) , error_data , ( * ( ( const unsigned char * ) data ) ) ) ;
0
------------------------------
302963 82670/CWE190_Integer_Overflow__int64_t_fscanf_square_54e.c int64_t result = data * data ; 53
void CWE190_Integer_Overflow__int64_t_fscanf_square_54b_goodB2GSink(int64_t data)
CWE190_Integer_Overflow__int64_t_fscanf_square_54c_goodB2GSink ( data );
void CWE190_Integer_Overflow__int64_t_fscanf_square_54c_goodB2GSink(int64_t data)
CWE190_Integer_Overflow__int64_t_fscanf_square_54d_goodB2GSink ( data );
void CWE190_Integer_Overflow__int64_t_fscanf_square_54d_goodB2GSink(int64_t data)
CWE190_Integer_Overflow__int64_t_fscanf_square_54e_goodB2GSink ( data );
void CWE190_Integer_Overflow__int64_t_fscanf_square_54e_goodB2GSink(int64_t data)
if ( abs ( ( long ) data ) <= ( long ) sqrt ( ( double ) LLONG_MAX ) )
int64_t result = data * data ;
printLongLongLine ( result );
void printLongLongLine (int64_t longLongIntNumber)
printf ( "%lld\n" , longLongIntNumber );
0
------------------------------
305692 117173/CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_83_goodB2G.cpp myString = ( char * ) malloc ( data * sizeof ( char ) ) 131
CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_83_goodB2G::~CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_83_goodB2G()
char * myString ;
if ( data > strlen ( HELLO_STRING ) && data < 100 )
myString = ( char * ) malloc ( data * sizeof ( char ) );
strcpy ( myString , HELLO_STRING );
printLine ( myString );
void printLine (const char * line)
if ( line != NULL )
printf ( "%s\n" , line );
free ( myString );
0
------------------------------
19415 CVE-2015-2726/Firefox_38.8.0esr_CVE_2015_2726_js_src_ctypes_CTypes.cpp i = ii * base + sign * c 1835

ArrayType::Getter(JSContext* cx, HandleObject obj, HandleId idval, MutableHandleValue vp)
if ( ! CData :: IsCData ( obj ) )

CData::IsCData(JSObject* obj)
return JS_GetClass ( obj ) == & sCDataClass ;
JSObject * typeObj = CData :: GetCType ( obj ) ;

CData::GetCType(JSObject* dataObj)
jsval slot = JS_GetReservedSlot ( dataObj , SLOT_CTYPE ) ;
JSObject * typeObj = slot . toObjectOrNull ( ) ;
return typeObj ;
if ( CType :: GetTypeCode ( typeObj ) != TYPE_array )

CType::GetTypeCode(JSObject* typeObj)
jsval result = JS_GetReservedSlot ( typeObj , SLOT_TYPECODE ) ;
return TypeCode ( result . toInt32 ( ) ) ;
bool ok = jsidToSize ( cx , idval , true , & index ) ;
int32_t dummy ;
if ( ! ok && JSID_IS_STRING ( idval ) && ! StringToInteger ( cx , JSID_TO_STRING ( idval ) , & dummy ) )
template <class IntegerType, class
static
StringToInteger(JSContext* cx, CharT* cp, size_t length, IntegerType* result)
const CharT * end = cp + length ;
if ( cp == end )
IntegerType sign = 1 ;
if ( cp [ 0 ] == '-' )
sign = - 1;
IntegerType base = 10 ;
if ( end - cp > 2 && cp [ 0 ] == '0' && ( cp [ 1 ] == 'x' || cp [ 1 ] == 'X' ) )
cp += 2;
base = 16;
IntegerType i = 0 ;
while ( cp != end )
char16_t c = * cp ++ ;
if ( c >= '0' && c <= '9' )
c -= '0';
if ( base == 16 && c >= 'a' && c <= 'f' )
c = c - 'a' + 10;
if ( base == 16 && c >= 'A' && c <= 'F' )
c = c - 'A' + 10;
IntegerType ii = i ;
i = ii * base + sign * c;
if ( i / base != ii )
* result = i;
0
------------------------------
314103 110847/CWE680_Integer_Overflow_to_Buffer_Overflow__new_rand_08.cpp dataBytes = data * sizeof ( int ) 112
static void goodG2B2()
int data ;
data = - 1;
if ( staticReturnsTrue ( ) )
static int staticReturnsTrue()
return 1 ;
data = 20;
size_t dataBytes , i ;
dataBytes = data * sizeof ( int );
intPointer = ( int * ) new char [ dataBytes ];
intPointer [ i ] = 0;
printIntLine ( intPointer [ 0 ] );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
delete [ ] intPointer
0
------------------------------
314843 97723/CWE36_Absolute_Path_Traversal__wchar_t_listen_socket_fopen_42.cpp recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ) 101
void bad()
wchar_t * data ;
wchar_t dataBuffer [ FILENAME_MAX ] = L ""
data = dataBuffer;
data = badSource ( data );
static wchar_t * badSource(wchar_t * data)
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( FILENAME_MAX - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
19148 CVE-2016-7466/qemu_2.3.0_CVE-2016-7466_hcd-xhci.c int er_free = dp_idx - intr -> er_ep_idx ; 887
static void xhci_runtime_write(void *ptr, hwaddr
uint64_t val, unsigned size)
XHCIState * xhci = ptr ;
int v = ( reg - 0x20 ) / 0x20 ;
if ( reg < 0x20 )
switch ( reg & 0x1f )
xhci_events_update ( xhci , v );
static void xhci_events_update(XHCIState *xhci, int v)
XHCIInterrupter * intr = & xhci -> intr [ v ] ;
dma_addr_t erdp ;
unsigned int dp_idx ;
if ( xhci -> usbsts & USBSTS_HCH )
erdp = xhci_addr64 ( intr -> erdp_low , intr -> erdp_high );
static inline dma_addr_t xhci_addr64(uint32_t low, uint32_t high)
if ( sizeof ( dma_addr_t ) == 4 )
return low ;
return low | ( ( ( dma_addr_t ) high << 16 ) << 16 ) ;
if ( erdp < intr -> er_start || erdp >= ( intr -> er_start + TRB_SIZE * intr -> er_size ) )
dp_idx = ( erdp - intr -> er_start ) / TRB_SIZE;
if ( intr -> er_full )
int er_free = dp_idx - intr -> er_ep_idx ;
if ( er_free <= 0 )
er_free += intr -> er_size;
if ( er_free < ( intr -> er_size / 2 ) )
0
------------------------------
311903 153171/dfa.c wc = inputwcs [ * pp - mbclen - buf_begin ] 3482
char *dfaexec(struct dfa *d,const char *begin,char *end,int allow_nl,size_t *count,int *backref)
state_num s ;
state_num s1 ;
const unsigned char * p ;
state_num * * trans ;
state_num * t ;
unsigned char eol = eolbyte ;
s = s1 = 0;
p = ( ( const unsigned char * ) begin );
trans = d -> trans;
* end = eol;
if ( d -> mb_cur_max > 1 )
while ( ( t = trans [ s ] ) != ( ( void * ) 0 ) )
if ( p > buf_end )
s1 = s;
if ( s == 0 )
if ( ( ( char * ) p ) >= end )
if ( d -> states [ s ] . mbps . nelem == 0 )
s = t [ * ( p ++ ) ];
if ( backref )
s = transit_state ( d , s , & p );
trans = d -> trans;
while ( ( t = trans [ s ] ) != ( ( void * ) 0 ) )
s1 = t [ * ( p ++ ) ];
if ( ( t = trans [ s1 ] ) == ( ( void * ) 0 ) )
state_num tmp = s ;
s = s1;
s1 = tmp;
s = t [ * ( p ++ ) ];
if ( s >= 0 && ( ( char * ) p ) <= end && d -> fails [ s ] )
if ( d -> success [ s ] & sbit [ * p ] )
s1 = s;
if ( d -> mb_cur_max > 1 )
s = transit_state ( d , s , & p );
trans = d -> trans;
s = d -> fails [ s ] [ * ( p ++ ) ];
if ( ( ( char * ) p ) > end )
if ( s >= 0 )
trans = d -> trans;
if ( p [ - 1 ] == eol && allow_nl )
s = d -> newlines [ s1 ];
s = 0;
static state_num transit_state(struct dfa *d,state_num s,const unsigned char **pp)
int mbclen ;
int maxlen = 0 ;
size_t i ;
size_t nelem = d -> states [ s ] . mbps . nelem ;
wchar_t wc ;
if ( nelem > 0 )
match_lens = check_matching_with_multibyte_ops ( d , s , ( * pp - buf_begin ) );
for (i = 0; i < nelem; i++)
if ( match_lens [ i ] > maxlen )
maxlen = match_lens [ i ];
if ( nelem == 0 || maxlen == 0 )
wc = inputwcs [ * pp - mbclen - buf_begin ];
s1 = state_index ( d , ( & follows ) , wchar_context ( wc ) );
realloc_trans_if_necessary ( d , s1 );
transit_state_consume_1char ( d , s1 , pp , ( ( void * ) 0 ) , & mbclen , & follows );
for (j = 0; j < d -> follows[d -> states[s1] . mbps . elems[i] . index] . nelem; j++)
insert ( d -> follows [ d -> states [ s1 ] . mbps . elems [ i ] . index ] . elems [ j ] , & follows );
s1 = state_index ( d , ( & follows ) , wchar_context ( wc ) );
realloc_trans_if_necessary ( d , s1 );
return s1 ;
0
------------------------------
18945 CVE-2015-2716/Firefox_37.0b7_CVE_2015_2716_parser_expat_lib_xmlparse.c size_t tsize = newSize * sizeof ( NAMED * ) ; 6029
XML_Parser
XML_ParserCreateNS(const XML_Char *encodingName, XML_Char nsSep)
XML_Char tmp [ 2 ] ;
* tmp = nsSep;
return XML_ParserCreate_MM ( encodingName , NULL , tmp ) ;
XML_Parser
XML_ParserCreate_MM(const XML_Char
const XML_Memory_Handling_Suite
const XML_Char *nameSep)
XML_Parser parser = parserCreate ( encodingName , memsuite , nameSep , NULL ) ;
static
parserCreate(const XML_Char
const XML_Memory_Handling_Suite
const XML_Char
DTD *dtd)
XML_Parser parser ;
if ( memsuite )
parser = ( XML_Parser ) memsuite -> malloc_fcn ( sizeof ( struct XML_ParserStruct ) );
parser = ( XML_Parser ) malloc ( sizeof ( struct XML_ParserStruct ) );
if ( ! parser )
return parser ;
attsSize = INIT_ATTS_SIZE;
atts = ( ATTRIBUTE * ) MALLOC ( attsSize * sizeof ( ATTRIBUTE ) );
if ( atts == NULL )
return NULL ;
dataBuf = ( XML_Char * ) MALLOC ( INIT_DATA_BUF_SIZE * sizeof ( XML_Char ) );
if ( dataBuf == NULL )
return NULL ;
if ( dtd )
_dtd = dtdCreate ( & parser -> m_mem );
if ( _dtd == NULL )
return NULL ;
if ( encodingName && ! protocolEncodingName )
return NULL ;
return parser ;
if ( parser != NULL && ns )
if ( ! setContext ( parser , implicitContext ) )
static
setContext(XML_Parser parser, const XML_Char *context)
DTD * const dtd = _dtd
const XML_Char * s = context ;
while ( * context != XML_T ( '\0' ) )
if ( * s == CONTEXT_SEP || * s == XML_T ( '\0' ) )
ENTITY * e ;
if ( ! poolAppendChar ( & tempPool , XML_T ( '\0' ) ) )
e = ( ENTITY * ) lookup ( & dtd -> generalEntities , poolStart ( & tempPool ) , 0 );
if ( * s != XML_T ( '\0' ) )
s ++;
context = s;
if ( * s == XML_T ( '=' ) )
PREFIX * prefix ;
if ( poolLength ( & tempPool ) == 0 )
prefix = & dtd -> defaultPrefix;
if ( ! poolAppendChar ( & tempPool , XML_T ( '\0' ) ) )
prefix = ( PREFIX * ) lookup ( & dtd -> prefixes , poolStart ( & tempPool ) , sizeof ( PREFIX ) );
if ( ! prefix )
if ( prefix -> name == poolStart ( & tempPool ) )
prefix -> name = poolCopyString ( & dtd -> pool , prefix -> name );
if ( ! prefix -> name )
for (context = s +
*context != CONTEXT_SEP && *context !=
context++)
if ( ! poolAppendChar ( & tempPool , * context ) )
if ( ! poolAppendChar ( & tempPool , XML_T ( '\0' ) ) )
if ( addBinding ( parser , prefix , NULL , poolStart ( & tempPool ) , & inheritedBindings ) != XML_ERROR_NONE )
s = context;
if ( ! poolAppendChar ( & tempPool , * s ) )
s ++;
static NAMED
lookup(HASH_TABLE *table, KEY name, size_t createSize)
size_t i ;
if ( table -> size == 0 )
unsigned long h = hash ( name ) ;
unsigned long mask = ( unsigned long ) table -> size - 1 ;
unsigned char step = 0 ;
i = h & mask;
while ( table -> v [ i ] )
if ( keyeq ( name , table -> v [ i ] -> name ) )
if ( ! step )
step = PROBE_STEP ( h , mask , table -> power );
i < step ? ( i += table -> size - step ) : ( i -= step );
if ( ! createSize )
if ( table -> used >> ( table -> power - 1 ) )
unsigned char newPower = table -> power + 1 ;
size_t newSize = ( size_t ) 1 << newPower ;
size_t tsize = newSize * sizeof ( NAMED * ) ;
NAMED * * newV = ( NAMED * * ) table -> mem -> malloc_fcn ( tsize ) ;
if ( ! newV )
memset ( newV , 0 , tsize );
while ( newV [ j ] )
newV [ j ] = table -> v [ i ];
table -> v = newV;
table -> power = newPower;
table -> size = newSize;
while ( table -> v [ i ] )
table -> v [ i ] = ( NAMED * ) table -> mem -> malloc_fcn ( createSize );
if ( ! table -> v [ i ] )
memset ( table -> v [ i ] , 0 , createSize );
table -> v [ i ] -> name = name;
( table -> used ) ++;
return table -> v [ i ] ;
0
------------------------------
17355 CVE-2015-3809/CVE_2015_3809_VULN_dissect_lbmr_pser.c opt_len = tvb_get_ntohs ( tvb , curr_offset + O_LBMR_PSER_OPTLEN_T_OPTLEN ) 36
static int CVE_2015_3809_VULN_dissect_lbmr_pser(tvbuff_t * tvb, int offset, packet_info * pinfo, proto_tree * tree)
int curr_offset = offset ;
hdr_len = ( int ) tvb_get_ntohs ( tvb , curr_offset + O_LBMR_PSER_T_LEN );
flags = tvb_get_ntohs ( tvb , curr_offset + O_LBMR_PSER_T_FLAGS );
curr_offset += hdr_len;
if ( ( flags & LBMR_PSER_OPT_FLAG ) != 0 )
opt_len = tvb_get_ntohs ( tvb , curr_offset + O_LBMR_PSER_OPTLEN_T_OPTLEN );
0
------------------------------
299081 152173/bufmgr.c bufs_ahead = NBuffers - bufs_to_lap 1389
bool BgBufferSync()
int strategy_buf_id ;
uint32 strategy_passes ;
static bool saved_info_valid = ( bool ) 0 ;
static int next_to_clean ;
static uint32 next_passes ;
int bufs_to_lap ;
int bufs_ahead ;
strategy_buf_id = StrategySyncStart ( & strategy_passes , & recent_alloc );
if ( bgwriter_lru_maxpages <= 0 )
if ( saved_info_valid )
if ( ( ( int32 ) ( next_passes - strategy_passes ) ) > 0 )
bufs_to_lap = strategy_buf_id - next_to_clean;
if ( next_passes == strategy_passes && next_to_clean >= strategy_buf_id )
bufs_to_lap = NBuffers - ( next_to_clean - strategy_buf_id );
bufs_to_lap = NBuffers;
bufs_to_lap = NBuffers;
bufs_ahead = NBuffers - bufs_to_lap;
reusable_buffers_est = ( ( ( float ) bufs_ahead ) / smoothed_density );
if ( upcoming_alloc_est < min_scan_buffers + reusable_buffers_est )
upcoming_alloc_est = min_scan_buffers + reusable_buffers_est;
reusable_buffers = reusable_buffers_est;
while ( num_to_scan > 0 && reusable_buffers < upcoming_alloc_est )
reusable_buffers ++;
reusable_buffers ++;
new_recent_alloc = ( reusable_buffers - reusable_buffers_est );
if ( new_strategy_delta > 0 && new_recent_alloc > 0 )
scans_per_alloc = ( ( float ) new_strategy_delta ) / ( ( float ) new_recent_alloc );
smoothed_density += ( scans_per_alloc - smoothed_density ) / smoothing_samples;
0
------------------------------
300673 151918/string.c new_string -> blocksize = blocksize - sizeof ( ( * new_string ) ) 390
svn_stringbuf_t *svn_stringbuf_create_from_string(const svn_string_t *str,apr_pool_t *pool)
return svn_stringbuf_ncreate ( str -> data , str -> len , pool ) ;
svn_stringbuf_t *svn_stringbuf_ncreate(const char *bytes,apr_size_t size,apr_pool_t *pool)
svn_stringbuf_t * strbuf = svn_stringbuf_create_ensure ( size , pool ) ;
svn_stringbuf_t *svn_stringbuf_create_ensure(apr_size_t blocksize,apr_pool_t *pool)
void * mem ;
svn_stringbuf_t * new_string ;
new_string = mem;
new_string -> data = ( ( char * ) mem ) + sizeof ( ( * new_string ) );
new_string -> data [ 0 ] = '\0';
new_string -> len = 0;
new_string -> blocksize = blocksize - sizeof ( ( * new_string ) );
new_string -> pool = pool;
return new_string ;
0
------------------------------
20576 CVE-2016-8910/qemu_2.3.0_CVE-2016-8910_rtl8139.c p_tcp_hdr -> th_seq = cpu_to_be32 ( chunk_size + be32_to_cpu ( p_tcp_hdr -> th_seq ) ) 2311
static void rtl8139_io_writew(void *opaque, uint8_t addr, uint32_t val)
switch ( addr )
rtl8139_io_writeb ( opaque , addr , val & 0xff );
static void rtl8139_io_writeb(void *opaque, uint8_t addr, uint32_t val)
RTL8139State * s = opaque ;
switch ( addr )
if ( val == 'R' )
if ( val == 'H' )
s -> clock_enabled = 0;
s -> TxThresh = val;
if ( val & ( 1 << 6 ) )
rtl8139_cplus_transmit ( s );
static void rtl8139_cplus_transmit(RTL8139State *s)
while ( rtl8139_cplus_transmit_one ( s ) )
static int rtl8139_cplus_transmit_one(RTL8139State *s)
if ( ! rtl8139_transmitter_enabled ( s ) )
if ( ! rtl8139_cp_transmitter_enabled ( s ) )
uint32_t val , txdw0 , txdw1 , txbufLO , txbufHI ;
txdw0 = le32_to_cpu ( val );
if ( ! ( txdw0 & CP_TX_OWN ) )
if ( txdw0 & CP_TX_FS )
s -> cplus_txbuffer_offset = 0;
int txsize = txdw0 & CP_TX_BUFFER_SIZE_MASK ;
if ( ! s -> cplus_txbuffer )
s -> cplus_txbuffer_len = CP_TX_BUFFER_SIZE;
s -> cplus_txbuffer = g_malloc ( s -> cplus_txbuffer_len );
s -> cplus_txbuffer_offset = 0;
if ( s -> cplus_txbuffer_offset + txsize >= s -> cplus_txbuffer_len )
txsize = s -> cplus_txbuffer_len - s -> cplus_txbuffer_offset;
s -> cplus_txbuffer_offset += txsize;
if ( txdw0 & CP_TX_EOR )
s -> currCPlusTxDesc = 0;
if ( s -> currCPlusTxDesc >= 64 )
s -> currCPlusTxDesc = 0;
txdw0 &= ~CP_RX_OWN;
txdw0 &= ~CP_TX_STATUS_UNF;
txdw0 &= ~CP_TX_STATUS_TES;
txdw0 &= ~CP_TX_STATUS_OWC;
txdw0 &= ~CP_TX_STATUS_LNKF;
txdw0 &= ~CP_TX_STATUS_EXC;
if ( txdw0 & CP_TX_LS )
uint8_t * saved_buffer = s -> cplus_txbuffer ;
if ( txdw0 & ( CP_TX_IPCS | CP_TX_UDPCS | CP_TX_TCPCS | CP_TX_LGSEN ) )
ip_header * ip = NULL ;
int hlen = 0 ;
uint8_t ip_protocol = 0 ;
uint16_t ip_data_len = 0 ;
uint8_t * eth_payload_data = NULL ;
int proto = be16_to_cpu ( * ( uint16_t * ) ( saved_buffer + 12 ) ) ;
if ( proto == ETH_P_IP )
eth_payload_data = saved_buffer + ETH_HLEN;
ip = ( ip_header * ) eth_payload_data;
if ( IP_HEADER_VERSION ( ip ) != IP_HEADER_VERSION_4 )
ip = NULL;
hlen = IP_HEADER_LENGTH ( ip );
ip_protocol = ip -> ip_p;
ip_data_len = be16_to_cpu ( ip -> ip_len ) - hlen;
if ( ip )
if ( ( txdw0 & CP_TX_LGSEN ) && ip_protocol == IP_PROTO_TCP )
uint8_t saved_ip_header [ 60 ] ;
memcpy ( saved_ip_header , eth_payload_data , hlen );
uint8_t * data_to_checksum = eth_payload_data + hlen - 12 ;
tcp_header * p_tcp_hdr = ( tcp_header * ) ( eth_payload_data + hlen ) ;
int tcp_hlen = TCP_HEADER_DATA_OFFSET ( p_tcp_hdr ) ;
int tcp_data_len = ip_data_len - tcp_hlen ;
int tcp_chunk_size = ETH_MTU - hlen - tcp_hlen ;
for (tcp_send_offset = 0; tcp_send_offset < tcp_data_len; tcp_send_offset += tcp_chunk_size)
uint16_t chunk_size = tcp_chunk_size ;
if ( tcp_send_offset + tcp_chunk_size >= tcp_data_len )
chunk_size = tcp_data_len - tcp_send_offset;
DPRINTF ( "+++ C+ mode TSO TCP seqno %08x\n" , be32_to_cpu ( p_tcp_hdr -> th_seq ) );
memcpy ( data_to_checksum , saved_ip_header + 12 , 8 );
p_tcp_hdr -> th_sum = 0;
int tcp_checksum = ip_checksum ( data_to_checksum , tcp_hlen + chunk_size + 12 ) ;
p_tcp_hdr -> th_sum = tcp_checksum;
p_tcp_hdr -> th_seq = cpu_to_be32 ( chunk_size + be32_to_cpu ( p_tcp_hdr -> th_seq ) );
0
------------------------------
309999 150946/utf.c const char * src_end = src + len ; 514
svn_error_t *svn_utf_stringbuf_to_utf8(svn_stringbuf_t **dest,const svn_stringbuf_t *src,apr_pool_t *pool)
xlate_handle_node_t * node ;
svn_error_t * err ;
svn_error_t * svn_err__temp = get_ntou_xlate_handle_node ( & node , pool ) ;
static svn_error_t *get_ntou_xlate_handle_node(xlate_handle_node_t **ret,apr_pool_t *pool)
return get_xlate_handle_node ( ret , SVN_APR_UTF8_CHARSET , ( assume_native_charset_is_utf8 ? SVN_APR_UTF8_CHARSET : ( ( const char * ) 1 ) ) , SVN_UTF_NTOU_XLATE_HANDLE , pool ) ;
if ( svn_err__temp )
while ( 0 )
if ( node -> handle )
err = convert_to_stringbuf ( node , ( src -> data ) , src -> len , dest , pool );
static svn_error_t *convert_to_stringbuf(xlate_handle_node_t *node,const char *src_data,apr_size_t src_length,svn_stringbuf_t **dest,apr_pool_t *pool)
if ( apr_err )
svn_error_t * err ;
err = svn_error_create ( apr_err , ( ( void * ) 0 ) , fuzzy_escape ( src_data , src_length , pool ) );
static const char *fuzzy_escape(const char *src,apr_size_t len,apr_pool_t *pool)
const char * src_end = src + len ;
while ( src < src_end )
while ( src_orig < src_end )
0
------------------------------
20660 CVE-2016-8910/qemu_2.3.0_CVE-2016-8910_rtl8139.c int unread = MOD2 ( s -> RxBufferSize + s -> RxBufAddr - s -> RxBufPtr , s -> RxBufferSize ) ; 1415
static uint32_t rtl8139_io_readl(void *opaque, uint8_t addr)
RTL8139State * s = opaque ;
uint32_t ret ;
switch ( addr )
ret = s -> RxMissed;
ret = rtl8139_TxConfig_read ( s );
ret = rtl8139_RxConfig_read ( s );
ret = rtl8139_TxStatus_TxAddr_read ( s , s -> TxStatus , TxStatus0 , addr , 4 );
ret = rtl8139_TxAddr_read ( s , addr - TxAddr0 );
ret = rtl8139_RxBuf_read ( s );
ret = s -> RxRingAddrLO;
ret = s -> RxRingAddrHI;
ret = muldiv64 ( qemu_clock_get_ns ( QEMU_CLOCK_VIRTUAL ) - s -> TCTR_base , PCI_FREQUENCY , get_ticks_per_sec ( ) );
ret = s -> TimerInt;
ret = rtl8139_io_readb ( opaque , addr );
ret |= rtl8139_io_readb ( opaque , addr + 1 ) << 8;
static uint32_t rtl8139_io_readb(void *opaque, uint8_t addr)
RTL8139State * s = opaque ;
int ret ;
switch ( addr )
ret = rtl8139_ChipCmd_read ( s );
static uint32_t rtl8139_ChipCmd_read(RTL8139State *s)
if ( rtl8139_RxBufferEmpty ( s ) )
static int rtl8139_RxBufferEmpty(RTL8139State *s)
int unread = MOD2 ( s -> RxBufferSize + s -> RxBufAddr - s -> RxBufPtr , s -> RxBufferSize ) ;
if ( unread != 0 )
DPRINTF ( "receiver buffer data available 0x%04x\n" , unread );
0
------------------------------
307800 109373/CWE606_Unchecked_Loop_Condition__wchar_t_listen_socket_12.c recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 ) 238
static void goodB2G()
wchar_t * data ;
wchar_t dataBuffer [ 100 ] = L ""
data = dataBuffer;
if ( globalReturnsTrueOrFalse ( ) )
int globalReturnsTrueOrFalse()
return ( rand ( ) % 2 ) ;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
309477 151098/ffmpeg.c delta = pkt_pts - ist -> next_dts 2936
static int transcode_step()
OutputStream * ost ;
InputStream * ist ;
int ret ;
ost = choose_output ( );
static OutputStream *choose_output()
int i ;
int64_t opts_min = 9223372036854775807L ;
OutputStream * ost_min = ( ( void * ) 0 ) ;
for (i = 0; i < nb_output_streams; i++)
OutputStream * ost = output_streams [ i ] ;
int64_t opts = av_rescale_q ( ost -> st -> cur_dts , ost -> st -> time_base , ( ( AVRational ) ( 1 ) , ( 1000000 ) ) )
if ( ! ost -> unavailable && ! ost -> finished && opts < opts_min )
opts_min = opts;
ost_min = ost;
return ost_min ;
if ( ! ost )
if ( ost -> filter )
if ( ( ret = transcode_from_filter ( ost -> filter -> graph , & ist ) ) < 0 )
static int transcode_from_filter(FilterGraph *graph,InputStream **best_ist)
int ret ;
ret = avfilter_graph_request_oldest ( graph -> graph );
if ( ret >= 0 )
return reap_filters ( ) ;
static int reap_filters()
int i ;
for (i = 0; i < nb_output_streams; i++)
OutputStream * ost = output_streams [ i ] ;
if ( ! ost -> filter )
if ( ! ost -> filtered_frame && ! ( ost -> filtered_frame = avcodec_alloc_frame ( ) ) )
return - 12 ;
return 0 ;
if ( ret == - ( ( int ) ( ( 'E' | 'O' << 8 | 'F' << 16 ) | ( ( unsigned int ) 32 ) << 24 ) ) )
ret = reap_filters ( );
static int reap_filters()
int i ;
OutputStream * ost = output_streams [ i ] ;
if ( ! ost -> filter )
if ( ! ost -> filtered_frame && ! ( ost -> filtered_frame = avcodec_alloc_frame ( ) ) )
return - 12 ;
return 0 ;
return ret ;
if ( ret != - 11 )
return ret ;
return 0 ;
if ( ! ist )
ist = input_streams [ ost -> source_index ];
ret = process_input ( ist -> file_index );
static int process_input(int file_index)
InputFile * ifile = input_files [ file_index ] ;
AVFormatContext * is ;
InputStream * ist ;
AVPacket pkt ;
int ret ;
is = ifile -> ctx;
ret = get_input_packet ( ifile , & pkt );
static int get_input_packet(InputFile *f,AVPacket *pkt)
if ( nb_input_files > 1 )
return get_input_packet_mt ( f , pkt ) ;
static int get_input_packet_mt(InputFile *f,AVPacket *pkt)
int ret = 0 ;
if ( av_fifo_size ( f -> fifo ) )
if ( f -> finished )
ret = - ( ( int ) ( ( 'E' | 'O' << 8 | 'F' << 16 ) | ( ( unsigned int ) 32 ) << 24 ) );
ret = - 11;
return ret ;
return av_read_frame ( f -> ctx , pkt ) ;
if ( ret == - 11 )
if ( ret < 0 )
if ( pkt . stream_index >= ifile -> nb_streams )
ist = input_streams [ ifile -> ist_index + pkt . stream_index ];
if ( ist -> discard )
if ( ! ist -> wrap_correction_done && is -> start_time != ( ( int64_t ) 0x8000000000000000UL ) && ist -> st -> pts_wrap_bits < 64 )
ist -> wrap_correction_done = 1;
ist -> wrap_correction_done = 0;
ist -> wrap_correction_done = 0;
if ( pkt . pts != ( ( int64_t ) 0x8000000000000000UL ) )
pkt . pts *= ist -> ts_scale;
if ( pkt . dts != ( ( int64_t ) 0x8000000000000000UL ) )
pkt . dts *= ist -> ts_scale;
if ( pkt . dts != ( ( int64_t ) 0x8000000000000000UL ) && ist -> next_dts != ( ( int64_t ) 0x8000000000000000UL ) && ! copy_ts )
if ( is -> iformat -> flags & 0x0200 )
pkt . dts = ( ( int64_t ) 0x8000000000000000UL );
if ( pkt . pts != ( ( int64_t ) 0x8000000000000000UL ) )
int64_t pkt_pts = av_rescale_q ( pkt . pts , ist -> st -> time_base , ( ( AVRational ) ( 1 ) , ( 1000000 ) ) )
delta = pkt_pts - ist -> next_dts;
if ( delta < ( - 1L L ) * dts_error_threshold * 1000000 || delta > 1L L * dts_error_threshold * 1000000 && ( ist -> st -> codec -> codec_type ) != AVMEDIA_TYPE_SUBTITLE )
0
------------------------------
19700 CVE-2016-2522/Wireshark_2.0.1_CVE_2016_2522_epan_dissectors_packet-ber.c end_offset = offset + len 1606
static
try_dissect_unknown_ber(packet_info *pinfo, tvbuff_t *tvb, volatile int offset, proto_tree *tree, gint nest_level)
int start_offset ;
gint8 ber_class ;
gboolean pc , ind ;
gint32 tag ;
guint32 len ;
start_offset = offset;
offset = get_ber_identifier ( tvb , offset , & ber_class , & pc , & tag );
offset = get_ber_length ( tvb , offset , & len , & ind );
if ( len > ( guint32 ) tvb_reported_length_remaining ( tvb , offset ) )
switch ( pc )
switch ( ber_class )
switch ( tag )
offset = dissect_ber_integer ( FALSE , & asn1_ctx , tree , tvb , start_offset , hf_ber_unknown_INTEGER , NULL );
offset = dissect_ber_real ( FALSE , & asn1_ctx , tree , tvb , start_offset , hf_ber_unknown_REAL , NULL );
offset = dissect_ber_bitstring ( FALSE , & asn1_ctx , tree , tvb , start_offset , NULL , hf_ber_unknown_BITSTRING , - 1 , NULL );
offset = dissect_ber_integer ( FALSE , & asn1_ctx , tree , tvb , start_offset , hf_ber_unknown_ENUMERATED , NULL );
offset = dissect_ber_octet_string ( FALSE , & asn1_ctx , tree , tvb , start_offset , hf_ber_unknown_GraphicString , NULL );
if ( decode_octetstring_as_ber && ( len >= 2 ) )
guint32 ber_len = 0 ;
ber_offset = get_ber_identifier ( tvb , offset , NULL , & pc , NULL );
ber_offset = get_ber_length ( tvb , ber_offset , & ber_len , NULL );
if ( pc && ( ber_len > 0 ) && ( ber_len + ( ber_offset - offset ) == len ) )
if ( show_internal_ber_fields )
offset = dissect_ber_identifier ( pinfo , tree , tvb , start_offset , NULL , NULL , NULL );
offset = dissect_ber_length ( pinfo , tree , tvb , offset , NULL , NULL );
item = ber_proto_tree_add_item ( pinfo , tree , hf_ber_unknown_BER_OCTETSTRING , tvb , offset , len , ENC_NA );
next_tree = proto_item_add_subtree ( item , ett_ber_octet_string );
offset = try_dissect_unknown_ber ( pinfo , tvb , offset , next_tree , nest_level + 1 );
static
try_dissect_unknown_ber(packet_info *pinfo, tvbuff_t *tvb, volatile int offset, proto_tree *tree, gint nest_level)
int start_offset ;
gint8 ber_class ;
gboolean pc , ind ;
gint32 tag ;
guint32 len ;
start_offset = offset;
offset = get_ber_identifier ( tvb , offset , & ber_class , & pc , & tag );
offset = get_ber_length ( tvb , offset , & len , & ind );
if ( len > ( guint32 ) tvb_reported_length_remaining ( tvb , offset ) )
switch ( pc )
switch ( ber_class )
switch ( tag )
offset = dissect_ber_octet_string ( FALSE , & asn1_ctx , tree , tvb , start_offset , hf_ber_unknown_BMPString , NULL );

dissect_ber_octet_string(gboolean implicit_tag, asn1_ctx_t *actx, proto_tree *tree, tvbuff_t *tvb, int offset, gint hf_id, tvbuff_t **out_tvb)
return dissect_ber_constrained_octet_string ( implicit_tag , actx , tree , tvb , offset , NO_BOUND , NO_BOUND , hf_id , out_tvb ) ;

dissect_ber_constrained_octet_string(gboolean implicit_tag, asn1_ctx_t *actx, proto_tree *tree, tvbuff_t *tvb, int offset, gint32 min_len, gint32 max_len, gint hf_id, tvbuff_t **out_tvb)
guint32 len ;
int end_offset ;
if ( ! implicit_tag )
end_offset = offset + len;
end_offset -= 2;
return end_offset ;
return end_offset ;
return end_offset ;
1
------------------------------
304827 79207/CWE134_Uncontrolled_Format_String__char_connect_socket_snprintf_14.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 279
static void goodB2G2()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
if ( globalFive == 5 )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
SNPRINTF ( dest , 100 - 1 , "%s" , data );
0
------------------------------
306374 119996/CWE78_OS_Command_Injection__char_listen_socket_popen_65a.c recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 113
void CWE78_OS_Command_Injection__char_listen_socket_popen_65_bad()
char * data ;
char data_buf [ 100 ] = FULL_COMMAND ;
data = data_buf;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
funcPtr ( data );
0
------------------------------
304473 82801/CWE190_Integer_Overflow__int64_t_max_square_22b.c int64_t result = data * data ; 96
static void goodG2B()
int64_t data ;
data = 0L L
data = 2;
CWE190_Integer_Overflow__int64_t_max_square_22_goodG2BSink ( data );
void CWE190_Integer_Overflow__int64_t_max_square_22_goodG2BSink(int64_t data)
if ( CWE190_Integer_Overflow__int64_t_max_square_22_goodG2BGlobal )
int64_t result = data * data ;
printLongLongLine ( result );
void printLongLongLine (int64_t longLongIntNumber)
printf ( "%lld\n" , longLongIntNumber );
0
------------------------------
312432 150090/string.c const apr_size_t restb = ( endb - strb ) ; 1201
unsigned int svn_cstring__similarity(const char *stra,const char *strb,svn_membuf_t *buffer,apr_size_t *rlcs)
svn_string_t stringa ;
svn_string_t stringb ;
stringa . data = stra;
stringa . len = strlen ( stra );
stringb . data = strb;
stringb . len = strlen ( strb );
return svn_string__similarity ( ( & stringa ) , ( & stringb ) , buffer , rlcs ) ;
unsigned int svn_string__similarity(const svn_string_t *stringa,const svn_string_t *stringb,svn_membuf_t *buffer,apr_size_t *rlcs)
const char * stra = stringa -> data ;
const char * strb = stringb -> data ;
const apr_size_t lena = stringa -> len ;
const apr_size_t lenb = stringb -> len ;
const char * enda = stra + lena ;
const char * endb = strb + lenb ;
if ( stra < enda && strb < endb )
const apr_size_t restb = ( endb - strb ) ;
const apr_size_t slots = resta > restb ? restb : resta ;
if ( resta < restb )
svn_membuf__ensure ( buffer , 2 * ( slots + 1 ) * sizeof ( apr_size_t ) );
void svn_membuf__ensure(svn_membuf_t *membuf,apr_size_t size)
membuf_ensure ( & membuf -> data , & membuf -> size , size , membuf -> pool );
inline static void membuf_ensure(void **data,apr_size_t *size,apr_size_t minimum_size,apr_pool_t *pool)
if ( minimum_size > * size )
apr_size_t new_size = * size ;
if ( new_size == 0 )
new_size = minimum_size;
while ( new_size < minimum_size )
const apr_size_t prev_size = new_size ;
new_size *= 2;
if ( prev_size > new_size )
new_size = minimum_size;
membuf_create ( data , size , new_size , pool );
inline static void membuf_create(void **data,apr_size_t *size,apr_size_t minimum_size,apr_pool_t *pool)
minimum_size = minimum_size + ( 8 - 1 ) & ( ~ ( 8 - 1 ) );
* data = ( ! minimum_size ? ( ( void * ) 0 ) : apr_palloc ( pool , minimum_size ) );
* size = minimum_size;
svn_membuf__nzero ( buffer , ( slots + 2 ) * sizeof ( apr_size_t ) );
#undef svn_membuf__nzero
svn_membuf_t * const _m_b_f_ = membuf
const apr_size_t _s_z_ = size ;
if ( _s_z_ > _m_b_f_ -> size )
memset ( _m_b_f_ -> data , 0 , _m_b_f_ -> size );
memset ( _m_b_f_ -> data , 0 , _s_z_ );
curr = prev + slots + 1;
for (i = 1; i <= slots; ++i)
if ( ( * pstr ) == strb [ i - 1 ] )
curr [ i ] = prev [ i - 1 ] + 1;
curr [ i ] = ( curr [ i - 1 ] > prev [ i ] ? curr [ i - 1 ] : prev [ i ] );
prev = curr;
lcs += prev [ slots ];
* rlcs = lcs;
return ( unsigned int ) ( ( 2000 * lcs + total / 2 ) / total ) ;
0
------------------------------
312969 90985/CWE23_Relative_Path_Traversal__wchar_t_connect_socket_w32CreateFile_14.cpp recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ) 96
void bad()
wchar_t * data ;
wchar_t dataBuffer [ FILENAME_MAX ] = BASEPATH ;
data = dataBuffer;
if ( globalFive == 5 )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( FILENAME_MAX - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
299953 150087/pgstat.c len = ( ( ( size_t ) ( & ( ( PgStat_MsgFuncpurge * ) 0 ) -> m_functionid [ 0 ] ) ) + f_msg . m_nentries * sizeof ( Oid ) ) 1048
void pgstat_vacuum_stat()
HTAB * htab ;
PgStat_MsgFuncpurge f_msg ;
PgStat_StatDBEntry * dbentry ;
PgStat_StatFuncEntry * funcentry ;
int len ;
if ( pgStatSock == - 1 )
htab = pgstat_collect_oids ( 1262 );
static HTAB *pgstat_collect_oids(Oid catalogid)
HTAB * htab ;
HASHCTL hash_ctl ;
hash_ctl . keysize = sizeof ( Oid );
hash_ctl . entrysize = sizeof ( Oid );
hash_ctl . hash = oid_hash;
hash_ctl . hcxt = CurrentMemoryContext;
htab = hash_create ( "Temporary table of OIDs" , 512 , & hash_ctl , 0x020 | 0x010 | 0x200 );
return htab ;
while ( ( dbentry = ( ( PgStat_StatDBEntry * ) ( hash_seq_search ( & hstat ) ) ) ) != ( ( void * ) 0 ) )
dbentry = ( ( PgStat_StatDBEntry * ) ( hash_search ( pgStatDBHash , ( ( void * ) ( & MyDatabaseId ) ) , HASH_FIND , ( ( void * ) 0 ) ) ) );
if ( dbentry == ( ( void * ) 0 ) || dbentry -> tables == ( ( void * ) 0 ) )
htab = pgstat_collect_oids ( 1259 );
static HTAB *pgstat_collect_oids(Oid catalogid)
HTAB * htab ;
HASHCTL hash_ctl ;
hash_ctl . keysize = sizeof ( Oid );
hash_ctl . entrysize = sizeof ( Oid );
hash_ctl . hash = oid_hash;
hash_ctl . hcxt = CurrentMemoryContext;
htab = hash_create ( "Temporary table of OIDs" , 512 , & hash_ctl , 0x020 | 0x010 | 0x200 );
return htab ;
if ( dbentry -> functions != ( ( void * ) 0 ) && hash_get_num_entries ( dbentry -> functions ) > 0 )
htab = pgstat_collect_oids ( 1255 );
static HTAB *pgstat_collect_oids(Oid catalogid)
HTAB * htab ;
HASHCTL hash_ctl ;
hash_ctl . keysize = sizeof ( Oid );
hash_ctl . entrysize = sizeof ( Oid );
hash_ctl . hash = oid_hash;
hash_ctl . hcxt = CurrentMemoryContext;
htab = hash_create ( "Temporary table of OIDs" , 512 , & hash_ctl , 0x020 | 0x010 | 0x200 );
return htab ;
f_msg . m_databaseid = MyDatabaseId;
f_msg . m_nentries = 0;
while ( ( funcentry = ( ( PgStat_StatFuncEntry * ) ( hash_seq_search ( & hstat ) ) ) ) != ( ( void * ) 0 ) )
Oid funcid = funcentry -> functionid ;
if ( hash_search ( htab , ( ( void * ) ( & funcid ) ) , HASH_FIND , ( ( void * ) 0 ) ) != ( ( void * ) 0 ) )
f_msg . m_functionid [ f_msg . m_nentries ++ ] = funcid;
if ( f_msg . m_nentries >= ( 1000 - sizeof ( PgStat_MsgHdr ) - sizeof ( Oid ) - sizeof ( int ) ) / sizeof ( Oid ) )
f_msg . m_nentries = 0;
if ( f_msg . m_nentries > 0 )
len = ( ( ( size_t ) ( & ( ( PgStat_MsgFuncpurge * ) 0 ) -> m_functionid [ 0 ] ) ) + f_msg . m_nentries * sizeof ( Oid ) );
pgstat_send ( ( & f_msg ) , len );
static void pgstat_send(void *msg,int len)
( ( PgStat_MsgHdr * ) msg ) -> m_size = len;
rc = ( send ( pgStatSock , msg , len , 0 ) );
while ( rc < 0 && * __errno_location ( ) == 4 )
0
------------------------------
314364 117053/CWE789_Uncontrolled_Mem_Alloc__malloc_char_fgets_33.cpp myString = ( char * ) malloc ( data * sizeof ( char ) ) 140
static void goodB2G()
size_t data ;
size_t & dataRef = data ;
data = 0;
char inputBuffer [ CHAR_ARRAY_SIZE ] = "" ;
if ( fgets ( inputBuffer , CHAR_ARRAY_SIZE , stdin ) != NULL )
data = strtoul ( inputBuffer , NULL , 0 );
size_t data = dataRef ;
char * myString ;
if ( data > strlen ( HELLO_STRING ) && data < 100 )
myString = ( char * ) malloc ( data * sizeof ( char ) );
strcpy ( myString , HELLO_STRING );
printLine ( myString );
void printLine (const char * line)
if ( line != NULL )
printf ( "%s\n" , line );
free ( myString );
0
------------------------------
305810 110510/CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_listen_socket_07.c intPointer = ( int * ) malloc ( data * sizeof ( int ) ) 131
void CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_listen_socket_07_bad()
int data ;
data = - 1;
if ( staticFive == 5 )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
char inputBuffer [ CHAR_ARRAY_SIZE ] ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
inputBuffer [ recvResult ] = '\0';
data = atoi ( inputBuffer );
while ( 0 )
int * intPointer ;
intPointer = ( int * ) malloc ( data * sizeof ( int ) );
intPointer [ i ] = 0;
printIntLine ( intPointer [ 0 ] );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
free ( intPointer );
1
------------------------------
304948 83807/CWE190_Integer_Overflow__int_rand_square_18.c int result = data * data ; 61
static void goodB2G()
int data ;
data = 0;
data = RAND32 ( );
if ( abs ( ( long ) data ) <= ( long ) sqrt ( ( double ) INT_MAX ) )
int result = data * data ;
printIntLine ( result );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
0
------------------------------
301509 150690/aviobuf.c s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_ptr - s -> checksum_ptr ) ) ) 273
int avio_put_str16le(AVIOContext *s,const char *str)
const uint8_t * q = str ;
while ( * q )
uint32_t ch ;
uint16_t tmp ;
ch = ( * ( q ++ ) );
uint32_t top = ( ch & 128 ) >> 1 ;
if ( ( ch & 0xc0 ) == 0x80 )
while ( ch & top )
int tmp = ( * ( q ++ ) ) - 128 ;
if ( tmp >> 6 )
ch = ( ch << 6 ) + tmp;
top <<= 5;
ch &= ( top << 1 ) - 1;
uint32_t in = ch ;
if ( in < 0x10000 )
tmp = ( 0xD800 | in - 0x10000 >> 10 );
avio_wl16 ( s , tmp );
void avio_wl16(AVIOContext *s,unsigned int val)
avio_w8 ( s , ( ( uint8_t ) val ) );
void avio_w8(AVIOContext *s,int b)
* ( s -> buf_ptr ++ ) = b;
if ( s -> buf_ptr >= s -> buf_end )
flush_buffer ( s );
static void flush_buffer(AVIOContext *s)
if ( s -> buf_ptr > s -> buffer )
if ( s -> update_checksum )
s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_ptr - s -> checksum_ptr ) ) );
s -> checksum_ptr = s -> buffer;
s -> buf_ptr = s -> buffer;
0
------------------------------
19625 CVE-2016-8658/linux_kernel_4.7.4_CVE_2016_8658_drivers_net_wireless_broadcom_brcm80211_brcmfmac_cfg80211.c notify_ie = ( u8 * ) bi + le16_to_cpu ( bi -> ie_offset ) 2767
static
brcmf_notify_roaming_status(struct brcmf_if
const struct brcmf_event_msg *e, void *data)
struct brcmf_cfg80211_info * cfg = ifp -> drvr -> config ;
u32 event = e -> event_code ;
u32 status = e -> status ;
if ( event == BRCMF_E_ROAM && status == BRCMF_E_STATUS_SUCCESS )
if ( test_bit ( BRCMF_VIF_STATUS_CONNECTED , & ifp -> vif -> sme_state ) )
brcmf_bss_roaming_done ( cfg , ifp -> ndev , e );
static
brcmf_bss_roaming_done(struct brcmf_cfg80211_info
struct net_device
const struct brcmf_event_msg *e)
struct brcmf_if * ifp = netdev_priv ( ndev ) ;
brcmf_update_bss_info ( cfg , ifp );
static s32 brcmf_update_bss_info(struct brcmf_cfg80211_info
struct brcmf_if *ifp)
struct brcmf_bss_info_le * bi ;
if ( brcmf_is_ibssmode ( ifp -> vif ) )
static bool brcmf_is_ibssmode(struct brcmf_cfg80211_vif *vif)
return vif -> wdev . iftype == NL80211_IFTYPE_ADHOC ;
* ( __le32 * ) cfg -> extra_buf = cpu_to_le32 ( WL_EXTRA_BUF_MAX );
err = brcmf_fil_cmd_data_get ( ifp , BRCMF_C_GET_BSS_INFO , cfg -> extra_buf , WL_EXTRA_BUF_MAX );
if ( err )
bi = ( struct brcmf_bss_info_le * ) ( cfg -> extra_buf + 4 );
err = brcmf_inform_single_bss ( cfg , bi );
static s32 brcmf_inform_single_bss(struct brcmf_cfg80211_info
struct brcmf_bss_info_le *bi)
struct brcmu_chan ch ;
u8 * notify_ie ;
if ( le32_to_cpu ( bi -> length ) > WL_BSS_INFO_MAX )
if ( ! bi -> ctl_ch )
ch . chspec = le16_to_cpu ( bi -> chanspec );
bi -> ctl_ch = ch . chnum;
notify_ie = ( u8 * ) bi + le16_to_cpu ( bi -> ie_offset );
bss = cfg80211_inform_bss ( wiphy , notify_channel , CFG80211_BSS_FTYPE_UNKNOWN , ( const u8 * ) bi -> BSSID , 0 , notify_capability , notify_interval , notify_ie , notify_ielen , notify_signal , GFP_KERNEL );
if ( ! bss )
cfg80211_put_bss ( wiphy , bss );
0
------------------------------
307720 117127/CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_01.c myString = ( char * ) malloc ( data * sizeof ( char ) ) 258
static void goodB2G()
size_t data ;
data = 0;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
char inputBuffer [ CHAR_ARRAY_SIZE ] ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
inputBuffer [ recvResult ] = '\0';
data = strtoul ( inputBuffer , NULL , 0 );
while ( 0 )
char * myString ;
if ( data > strlen ( HELLO_STRING ) && data < 100 )
myString = ( char * ) malloc ( data * sizeof ( char ) );
strcpy ( myString , HELLO_STRING );
printLine ( myString );
void printLine (const char * line)
if ( line != NULL )
printf ( "%s\n" , line );
free ( myString );
0
------------------------------
313961 117170/CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_74b.cpp myString = ( char * ) malloc ( data * sizeof ( char ) ) 73
static void goodG2B()
size_t data ;
map < int , size_t > dataMap ;
data = 0;
data = 20;
dataMap [ 0 ] = data;
dataMap [ 1 ] = data;
dataMap [ 2 ] = data;
goodG2BSink ( dataMap );
void goodG2BSink(map<int, size_t> dataMap)
size_t data = dataMap [ 2 ] ;
char * myString ;
if ( data > strlen ( HELLO_STRING ) )
myString = ( char * ) malloc ( data * sizeof ( char ) );
strcpy ( myString , HELLO_STRING );
printLine ( myString );
void printLine (const char * line)
if ( line != NULL )
printf ( "%s\n" , line );
free ( myString );
0
------------------------------
20939 CVE-2015-4521/Firefox_40.0b9_CVE_2015_4521_dom_base_nsGlobalWindow.cpp t -> mWhen = now + t -> mTimeRemaining 13263

nsGlobalWindow::ResumeTimeouts(bool aThawChildren)
bool shouldResume = ( mTimeoutsSuspendDepth == 0 ) && ! mInnerObjectsFreed ;
nsresult rv ;
if ( shouldResume )
TimeStamp now = TimeStamp :: Now ( ) ;
for (nsTimeout *t = mTimeouts.getFirst(); t; t = t->getNext())
if ( ! t -> mWindow )
uint32_t delay = std :: max ( int32_t ( t -> mTimeRemaining . ToMilliseconds ( ) ) , DOMMinTimeoutValue ( ) ) ;
t -> mWhen = now + t -> mTimeRemaining;
t -> mTimer = do_CreateInstance ( "@mozilla.org/timer;1" );
NS_ENSURE_TRUE ( t -> mTimer , NS_ERROR_OUT_OF_MEMORY );
rv = t -> InitTimer ( TimerCallback , delay );
if ( NS_FAILED ( rv ) )
t -> mTimer = nullptr;
return rv ;
t -> AddRef ( );
0
------------------------------
303246 82354/CWE190_Integer_Overflow__char_max_square_05.c char result = data * data ; 43
void CWE190_Integer_Overflow__char_max_square_05_bad()
char data ;
data = ' ';
if ( staticTrue )
data = CHAR_MAX;
if ( staticTrue )
char result = data * data ;
printHexCharLine ( result );
void printHexCharLine (char charHex)
printf ( "%02x\n" , charHex );
1
------------------------------
18285 CVE-2015-5154/Xen_4.5.0_CVE-2015-5154_ide.c s -> packet_transfer_size = nb_sectors * sector_size 1671
static void ide_atapi_cmd(IDEState *s)
const uint8_t * packet ;
packet = s -> io_buffer;
if ( s -> sense_key == SENSE_UNIT_ATTENTION && s -> io_buffer [ 0 ] != GPCMD_REQUEST_SENSE && s -> io_buffer [ 0 ] != GPCMD_INQUIRY )
switch ( s -> io_buffer [ 0 ] )
if ( s -> sense_key == SENSE_UNIT_ATTENTION )
s -> sense_key = SENSE_NONE;
int nb_sectors , lba ;
if ( packet [ 0 ] == GPCMD_READ_10 )
nb_sectors = ube16_to_cpu ( packet + 7 );
nb_sectors = ube32_to_cpu ( packet + 6 );
lba = ube32_to_cpu ( packet + 2 );
if ( nb_sectors == 0 )
ide_atapi_cmd_read ( s , lba , nb_sectors , 2048 );
static void ide_atapi_cmd_read(IDEState *s, int lba, int
int sector_size)
if ( s -> atapi_dma )
ide_atapi_cmd_read_pio ( s , lba , nb_sectors , sector_size );
static void ide_atapi_cmd_read_pio(IDEState *s, int lba, int
int sector_size)
s -> lba = lba;
s -> packet_transfer_size = nb_sectors * sector_size;
s -> elementary_transfer_size = 0;
s -> io_buffer_index = sector_size;
s -> cd_sector_size = sector_size;
s -> status = READY_STAT | SEEK_STAT;
ide_atapi_cmd_reply_end ( s );
0
------------------------------
302407 79248/CWE134_Uncontrolled_Format_String__char_connect_socket_vfprintf_07.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 107
void CWE134_Uncontrolled_Format_String__char_connect_socket_vfprintf_07_bad()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
if ( staticFive == 5 )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
badVaSinkB ( data , data );
static void badVaSinkB(char * data, ...)
va_start ( args , data );
vfprintf ( stdout , data , args );
1
------------------------------
310824 151097/aviobuf.c s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_end - s -> checksum_ptr ) ) ) 455
unsigned int avio_rb32(AVIOContext *s)
unsigned int val ;
val = avio_rb16 ( s ) << 16;
unsigned int avio_rb16(AVIOContext *s)
unsigned int val ;
val = ( avio_r8 ( s ) << 8 );
val |= ( avio_r8 ( s ) );
int avio_r8(AVIOContext *s)
if ( s -> buf_ptr >= s -> buf_end )
fill_buffer ( s );
static void fill_buffer(AVIOContext *s)
uint8_t * dst = ! s -> max_packet_size && s -> buf_end - s -> buffer < ( s -> buffer_size ) ? s -> buf_end : s -> buffer ;
if ( ! s -> read_packet && s -> buf_ptr >= s -> buf_end )
s -> eof_reached = 1;
if ( s -> eof_reached )
if ( s -> update_checksum && dst == s -> buffer )
if ( s -> buf_end > s -> checksum_ptr )
s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_end - s -> checksum_ptr ) ) );
s -> checksum_ptr = s -> buffer;
if ( s -> read_packet && s -> buffer_size > max_buffer_size )
ffio_set_buf_size ( s , max_buffer_size );
s -> checksum_ptr = dst = s -> buffer;
len = s -> buffer_size;
if ( s -> read_packet )
len = ( ( s -> read_packet ) ( s -> opaque , dst , len ) );
if ( len <= 0 )
s -> eof_reached = 1;
if ( len < 0 )
s -> error = len;
s -> pos += len;
s -> buf_ptr = dst;
s -> buf_end = dst + len;
s -> bytes_read += len;
0
------------------------------
310274 151639/aviobuf.c s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_ptr - s -> checksum_ptr ) ) ) 176
void avio_wb64(AVIOContext *s,uint64_t val)
avio_wb32 ( s , ( ( uint32_t ) ( val & 0xffffffff ) ) );
void avio_wb32(AVIOContext *s,unsigned int val)
avio_w8 ( s , ( ( uint8_t ) ( val >> 8 ) ) );
void avio_w8(AVIOContext *s,int b)
* ( s -> buf_ptr ++ ) = b;
if ( s -> buf_ptr >= s -> buf_end )
flush_buffer ( s );
static void flush_buffer(AVIOContext *s)
if ( s -> buf_ptr > s -> buffer )
if ( s -> update_checksum )
s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_ptr - s -> checksum_ptr ) ) );
s -> checksum_ptr = s -> buffer;
s -> buf_ptr = s -> buffer;
0
------------------------------
304233 84674/CWE190_Integer_Overflow__unsigned_int_rand_square_31.c unsigned int result = data * data ; 35
void CWE190_Integer_Overflow__unsigned_int_rand_square_31_bad()
unsigned int data ;
data = 0;
data = ( unsigned int ) RAND32 ( );
unsigned int dataCopy = data ;
unsigned int data = dataCopy ;
unsigned int result = data * data ;
printUnsignedLine ( result );
void printUnsignedLine(unsigned unsignedNumber)
printf ( "%u\n" , unsignedNumber );
1
------------------------------
298863 95069/CWE369_Divide_by_Zero__int_fgets_divide_12.c printIntLine ( 100 / data ) 130
static void goodB2G()
int data ;
data = - 1;
if ( globalReturnsTrueOrFalse ( ) )
int globalReturnsTrueOrFalse()
return ( rand ( ) % 2 ) ;
char inputBuffer [ CHAR_ARRAY_SIZE ] = "" ;
if ( fgets ( inputBuffer , CHAR_ARRAY_SIZE , stdin ) != NULL )
data = atoi ( inputBuffer );
char inputBuffer [ CHAR_ARRAY_SIZE ] = "" ;
if ( fgets ( inputBuffer , CHAR_ARRAY_SIZE , stdin ) != NULL )
data = atoi ( inputBuffer );
if ( globalReturnsTrueOrFalse ( ) )
int globalReturnsTrueOrFalse()
return ( rand ( ) % 2 ) ;
if ( data != 0 )
printIntLine ( 100 / data );
0
------------------------------
311087 151928/tile-swap.c gap = tile_swap_gap_new ( offset + bytes , swap_file -> swap_file_end ) 611
void tile_swap_in(Tile *tile)
if ( tile -> swap_offset == ( - 1 ) )
tile_swap_command ( tile , SWAP_IN );
static void tile_swap_command(Tile *tile,gint command)
if ( gimp_swap_file -> fd == - 1 )
if ( gimp_swap_file -> fd == - 1 )
switch ( command )
tile_swap_default_out ( gimp_swap_file , tile );
static void tile_swap_default_out(SwapFile *swap_file,Tile *tile)
gint bytes ;
gint64 newpos ;
bytes = 64 * 64 * ( tile -> bpp );
if ( tile -> swap_offset == ( - 1 ) )
newpos = tile_swap_find_offset ( swap_file , bytes );
static gint64 tile_swap_find_offset(SwapFile *swap_file,gint64 bytes)
SwapFileGap * gap ;
GList * tmp ;
gint64 offset ;
tmp = swap_file -> gaps;
while ( tmp )
gap = ( tmp -> data );
if ( gap -> end - gap -> start >= bytes )
tmp = tmp -> next;
offset = swap_file -> swap_file_end;
if ( offset + bytes < swap_file -> swap_file_end )
gap = tile_swap_gap_new ( offset + bytes , swap_file -> swap_file_end );
swap_file -> gaps = g_list_append ( swap_file -> gaps , gap );
0
------------------------------
311291 152463/file_wrappers.c offset = file -> pos + offset - off2 1147
gint64 file_skip(FILE_T file,gint64 delta,int *err)
return file_seek ( file , delta , 1 , err ) ;
gint64 file_seek(FILE_T file,gint64 offset,int whence,int *err)
struct fast_seek_point * here ;
if ( whence == 0 )
offset -= file -> pos;
if ( file -> seek )
offset += file -> skip;
file -> seek = 0;
if ( offset < 0 && file -> next )
unsigned int had = ( unsigned int ) ( file -> next - file -> out ) ;
if ( - offset <= had )
if ( ( here = fast_seek_find ( file , file -> pos + offset ) ) && ( offset < 0 || offset > 1048576L || here -> compression == 1 ) )
static struct fast_seek_point *fast_seek_find(FILE_T file,gint64 pos)
struct fast_seek_point * smallest = ( ( void * ) 0 ) ;
struct fast_seek_point * item ;
guint low ;
guint i ;
guint max ;
if ( ! file -> fast_seek )
return ( ( void * ) 0 ) ;
for ((low = 0 , max = file -> fast_seek -> len); low < max; )
i = ( low + max ) / 2;
item = ( ( struct fast_seek_point * ) file -> fast_seek -> pdata [ i ] );
if ( pos < item -> out )
max = i;
if ( pos > item -> out )
smallest = item;
low = i + 1;
return item ;
return smallest ;
gint64 off ;
gint64 off2 ;
if ( here -> compression == 2 )
off = here -> in - ( ( here -> data . zlib . bits ? 1 : 0 ) );
off2 = here -> out;
if ( here -> compression == 3 )
off = here -> in;
off2 = here -> out;
off2 = file -> pos + offset;
off = here -> in + ( off2 - here -> out );
if ( lseek ( file -> fd , off , 0 ) == ( - 1 ) )
file -> raw_pos = off;
file -> have = 0;
file -> eof = 0;
file -> seek = 0;
file -> err = 0;
file -> err_info = ( ( void * ) 0 );
file -> avail_in = 0;
if ( here -> compression == 2 )
if ( here -> data . zlib . bits )
FILE_T state = file ;
int ret = state -> avail_in == 0 && fill_in_buffer ( state ) == - 1 ? - 1 : ( ( state -> avail_in == 0 ? - 1 : ( ( state -> avail_in -- , * ( state -> next_in ++ ) ) ) ) ) ;
static int fill_in_buffer(FILE_T state)
if ( state -> err )
return - 1 ;
if ( state -> eof == 0 )
if ( raw_read ( state , state -> in , state -> size , ( ( unsigned int * ) ( & state -> avail_in ) ) ) == - 1 )
static int raw_read(FILE_T state,unsigned char *buf,unsigned int count,unsigned int *have)
int ret ;
* have = 0;
ret = ( read ( state -> fd , ( buf + * have ) , ( count - * have ) ) );
if ( ret <= 0 )
* have += ret;
state -> raw_pos += ret;
while ( * have < count )
if ( ret < 0 )
return - 1 ;
return 0 ;
return - 1 ;
return 0 ;
if ( ret == - 1 )
file -> compression = 2;
if ( here -> compression == 3 )
file -> compression = 2;
file -> compression = here -> compression;
offset = file -> pos + offset - off2;
if ( offset )
file -> skip = offset;
return file -> pos + offset ;
if ( file -> compression == 1 && file -> pos + offset >= file -> raw && ( offset < 0 || offset >= ( file -> have ) ) )
if ( lseek ( file -> fd , offset - ( file -> have ) , 1 ) == ( - 1 ) )
file -> raw_pos += offset - ( file -> have );
file -> have = 0;
file -> eof = 0;
file -> seek = 0;
file -> err = 0;
file -> err_info = ( ( void * ) 0 );
file -> avail_in = 0;
file -> pos += offset;
return file -> pos ;
if ( offset < 0 )
offset += file -> pos;
if ( offset < 0 )
n = ( ( ( gint64 ) ( file -> have ) ) > offset ? ( ( unsigned int ) offset ) : file -> have );
file -> have -= n;
file -> next += n;
file -> pos += n;
offset -= n;
if ( offset )
file -> seek = 1;
file -> skip = offset;
return file -> pos + offset ;
0
------------------------------
310319 151639/aviobuf.c s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_end - s -> checksum_ptr ) ) ) 467
int ff_get_line(AVIOContext *s,char *buf,int maxlen)
char c ;
c = ( avio_r8 ( s ) );
while ( c != 10 && c )
int avio_r8(AVIOContext *s)
if ( s -> buf_ptr >= s -> buf_end )
fill_buffer ( s );
static void fill_buffer(AVIOContext *s)
uint8_t * dst = ! s -> max_packet_size && s -> buf_end - s -> buffer < ( s -> buffer_size ) ? s -> buf_end : s -> buffer ;
if ( ! s -> read_packet && s -> buf_ptr >= s -> buf_end )
s -> eof_reached = 1;
if ( s -> eof_reached )
if ( s -> update_checksum && dst == s -> buffer )
if ( s -> buf_end > s -> checksum_ptr )
s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_end - s -> checksum_ptr ) ) );
s -> checksum_ptr = s -> buffer;
if ( s -> read_packet && s -> buffer_size > max_buffer_size )
ffio_set_buf_size ( s , max_buffer_size );
s -> checksum_ptr = dst = s -> buffer;
len = s -> buffer_size;
if ( s -> read_packet )
len = ( ( s -> read_packet ) ( s -> opaque , dst , len ) );
if ( len <= 0 )
s -> eof_reached = 1;
if ( len < 0 )
s -> error = len;
s -> pos += len;
s -> buf_ptr = dst;
s -> buf_end = dst + len;
s -> bytes_read += len;
0
------------------------------
309413 151493/utf.c valid = ( last - data ) 640
svn_error_t *svn_utf_string_from_utf8(const svn_string_t **dest,const svn_string_t *src,apr_pool_t *pool)
xlate_handle_node_t * node ;
svn_error_t * err ;
svn_error_t * svn_err__temp = get_uton_xlate_handle_node ( & node , pool ) ;
static svn_error_t *get_uton_xlate_handle_node(xlate_handle_node_t **ret,apr_pool_t *pool)
return get_xlate_handle_node ( ret , ( assume_native_charset_is_utf8 ? SVN_APR_UTF8_CHARSET : ( ( const char * ) 1 ) ) , SVN_APR_UTF8_CHARSET , SVN_UTF_UTON_XLATE_HANDLE , pool ) ;
if ( svn_err__temp )
while ( 0 )
if ( node -> handle )
err = check_utf8 ( src -> data , src -> len , pool );
static svn_error_t *check_utf8(const char *data,apr_size_t len,apr_pool_t *pool)
if ( ! svn_utf__is_valid ( data , len ) )
return invalid_utf8 ( data , len , pool ) ;
static svn_error_t *invalid_utf8(const char *data,apr_size_t len,apr_pool_t *pool)
const char * last = svn_utf__last_valid ( data , len ) ;
size_t valid ;
valid = ( last - data );
if ( valid > 24 )
for (i = 0; i < valid; ++i)
valid_txt = ( apr_pstrcat ( pool , valid_txt , apr_psprintf ( pool , " %02x" , ( ( unsigned char ) last [ i - valid ] ) ) , ( ( char * ) ( ( void * ) 0 ) ) ) );
return svn_error_createf ( 22 , ( ( void * ) 0 ) , ( dgettext ( "subversion" , "Valid UTF-8 data\n(hex:%s)\nfollowed by invalid UTF-8 sequence\n(hex:%s)" ) ) , valid_txt , invalid_txt ) ;
0
------------------------------
17006 CVE-2013-0868/CVE_2013_0868_VULN_generate_joint_tables.c len [ i ] = len0 + len1 + len2 52
static void CVE_2013_0868_VULN_generate_joint_tables(HYuvContext *s)
uint16_t symbols [ 1 << VLC_BITS ] ;
uint16_t bits [ 1 << VLC_BITS ] ;
uint8_t len [ 1 << VLC_BITS ] ;
if ( s -> bitstream_bpp < 24 )
int p , i , y , u ;
for (p = 0; p < 3; p++)
for (i = y = 0; y < 256; y++)
int len0 = s -> len [ 0 ] [ y ] ;
int limit = VLC_BITS - len0 ;
if ( limit <= 0 )
for (u = 0; u < 256; u++)
int len1 = s -> len [ p ] [ u ] ;
if ( len1 > limit )
len [ i ] = len0 + len1;
bits [ i ] = ( s -> bits [ 0 ] [ y ] << len1 ) + s -> bits [ p ] [ u ];
symbols [ i ] = ( y << 8 ) + u;
if ( symbols [ i ] != 0xffff )
i ++;
int i , b , g , r , code ;
int p0 = s -> decorrelate ;
int p1 = ! s -> decorrelate ;
for (i = 0, g = -16; g < 16; g++)
int len0 = s -> len [ p0 ] [ g & 255 ] ;
int limit0 = VLC_BITS - len0 ;
if ( limit0 < 2 )
for (b = -16; b < 16; b++)
int len1 = s -> len [ p1 ] [ b & 255 ] ;
int limit1 = limit0 - len1 ;
if ( limit1 < 1 )
code = ( s -> bits [ p0 ] [ g & 255 ] << len1 ) + s -> bits [ p1 ] [ b & 255 ];
for (r = -16; r < 16; r++)
int len2 = s -> len [ 2 ] [ r & 255 ] ;
if ( len2 > limit1 )
len [ i ] = len0 + len1 + len2;
bits [ i ] = ( code << len2 ) + s -> bits [ 2 ] [ r & 255 ];
if ( s -> decorrelate )
map [ i ] [ B ] = g;
map [ i ] [ G ] = b;
map [ i ] [ R ] = r;
i ++;
1
------------------------------
306615 120649/CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_spawnlp_21.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 ) 103
void CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_spawnlp_21_bad()
wchar_t * data ;
wchar_t dataBuffer [ 100 ] = L ""
data = dataBuffer;
data = badSource ( data );
static wchar_t * badSource(wchar_t * data)
if ( badStatic )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
304787 79131/CWE134_Uncontrolled_Format_String__char_connect_socket_fprintf_61b.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 85
void CWE134_Uncontrolled_Format_String__char_connect_socket_fprintf_61_bad()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
data = CWE134_Uncontrolled_Format_String__char_connect_socket_fprintf_61b_badSource ( data );
char * CWE134_Uncontrolled_Format_String__char_connect_socket_fprintf_61b_badSource(char * data)
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
return data ;
0
------------------------------
310392 151639/aviobuf.c uint8_t * dst = ! s -> max_packet_size && s -> buf_end - s -> buffer < ( s -> buffer_size ) ? s -> buf_end : s -> buffer ; 454
int avio_get_str(AVIOContext *s,int maxlen,char *buf,int buflen)
int i ;
if ( buflen <= 0 )
buflen = ( buflen - 1 > maxlen ? maxlen : buflen - 1 );
for (i = 0; i < buflen; i++)
if ( ! ( buf [ i ] = ( avio_r8 ( s ) ) ) )
int avio_r8(AVIOContext *s)
if ( s -> buf_ptr >= s -> buf_end )
fill_buffer ( s );
static void fill_buffer(AVIOContext *s)
uint8_t * dst = ! s -> max_packet_size && s -> buf_end - s -> buffer < ( s -> buffer_size ) ? s -> buf_end : s -> buffer ;
int len = ( ( s -> buffer_size ) - ( dst - s -> buffer ) ) ;
if ( s -> update_checksum && dst == s -> buffer )
len = ( ( s -> read_packet ) ( s -> opaque , dst , len ) );
if ( len <= 0 )
if ( len < 0 )
s -> error = len;
s -> pos += len;
s -> buf_ptr = dst;
s -> buf_end = dst + len;
s -> bytes_read += len;
0
------------------------------
19792 CVE-2016-2522/Wireshark_2.0.1_CVE_2016_2522_epan_dissectors_packet-ber.c end_offset = offset + val_length 2088

dissect_unknown_ber(packet_info *pinfo, tvbuff_t *tvb, int offset, proto_tree *tree)
return try_dissect_unknown_ber ( pinfo , tvb , offset , tree , 1 ) ;
static
try_dissect_unknown_ber(packet_info *pinfo, tvbuff_t *tvb, volatile int offset, proto_tree *tree, gint nest_level)
int start_offset ;
gint8 ber_class ;
gboolean pc , ind ;
gint32 tag ;
guint32 len ;
start_offset = offset;
offset = get_ber_identifier ( tvb , offset , & ber_class , & pc , & tag );
offset = get_ber_length ( tvb , offset , & len , & ind );
if ( len > ( guint32 ) tvb_reported_length_remaining ( tvb , offset ) )
switch ( pc )
switch ( ber_class )
switch ( tag )
offset = dissect_ber_integer ( FALSE , & asn1_ctx , tree , tvb , start_offset , hf_ber_unknown_INTEGER , NULL );
offset = dissect_ber_real ( FALSE , & asn1_ctx , tree , tvb , start_offset , hf_ber_unknown_REAL , NULL );
offset = dissect_ber_bitstring ( FALSE , & asn1_ctx , tree , tvb , start_offset , NULL , hf_ber_unknown_BITSTRING , - 1 , NULL );
offset = dissect_ber_integer ( FALSE , & asn1_ctx , tree , tvb , start_offset , hf_ber_unknown_ENUMERATED , NULL );
offset = dissect_ber_octet_string ( FALSE , & asn1_ctx , tree , tvb , start_offset , hf_ber_unknown_GraphicString , NULL );
if ( decode_octetstring_as_ber && ( len >= 2 ) )
guint32 ber_len = 0 ;
ber_offset = get_ber_identifier ( tvb , offset , NULL , & pc , NULL );
ber_offset = get_ber_length ( tvb , ber_offset , & ber_len , NULL );
if ( pc && ( ber_len > 0 ) && ( ber_len + ( ber_offset - offset ) == len ) )
if ( show_internal_ber_fields )
offset = dissect_ber_identifier ( pinfo , tree , tvb , start_offset , NULL , NULL , NULL );
offset = dissect_ber_length ( pinfo , tree , tvb , offset , NULL , NULL );
item = ber_proto_tree_add_item ( pinfo , tree , hf_ber_unknown_BER_OCTETSTRING , tvb , offset , len , ENC_NA );
next_tree = proto_item_add_subtree ( item , ett_ber_octet_string );
offset = try_dissect_unknown_ber ( pinfo , tvb , offset , next_tree , nest_level + 1 );
static
try_dissect_unknown_ber(packet_info *pinfo, tvbuff_t *tvb, volatile int offset, proto_tree *tree, gint nest_level)
int start_offset ;
gint8 ber_class ;
gboolean pc , ind ;
gint32 tag ;
guint32 len ;
start_offset = offset;
offset = get_ber_identifier ( tvb , offset , & ber_class , & pc , & tag );
offset = get_ber_length ( tvb , offset , & len , & ind );
if ( len > ( guint32 ) tvb_reported_length_remaining ( tvb , offset ) )
switch ( pc )
switch ( ber_class )
switch ( tag )
offset = dissect_ber_real ( FALSE , & asn1_ctx , tree , tvb , start_offset , hf_ber_unknown_REAL , NULL );

dissect_ber_real(gboolean implicit_tag, asn1_ctx_t *actx, proto_tree *tree, tvbuff_t *tvb, int offset, gint hf_id _U_, double *value)
guint32 val_length = 0 , len_remain , end_offset ;
if ( ! implicit_tag )
end_offset = offset + val_length;
return end_offset ;
actx -> created_item = proto_tree_add_double ( tree , hf_id , tvb , end_offset - val_length , val_length , val );
return end_offset ;
1
------------------------------
303070 84684/CWE190_Integer_Overflow__unsigned_int_rand_square_52c.c unsigned int result = data * data ; 28
void CWE190_Integer_Overflow__unsigned_int_rand_square_52_bad()
unsigned int data ;
data = 0;
data = ( unsigned int ) RAND32 ( );
CWE190_Integer_Overflow__unsigned_int_rand_square_52b_badSink ( data );
void CWE190_Integer_Overflow__unsigned_int_rand_square_52b_badSink(unsigned int data)
CWE190_Integer_Overflow__unsigned_int_rand_square_52c_badSink ( data );
void CWE190_Integer_Overflow__unsigned_int_rand_square_52c_badSink(unsigned int data)
unsigned int result = data * data ;
printUnsignedLine ( result );
void printUnsignedLine(unsigned unsignedNumber)
printf ( "%u\n" , unsignedNumber );
1
------------------------------
18769 CVE-2015-2716/Firefox_37.0b7_CVE_2015_2716_parser_expat_lib_xmlparse.c pool -> end = pool -> start + pool -> blocks -> size 6251
static ELEMENT_TYPE
getElementType(XML_Parser
const ENCODING
const char
const char *end)
DTD * const dtd = _dtd
const XML_Char * name = poolStoreString ( & dtd -> pool , enc , ptr , end ) ;
static XML_Char
poolStoreString(STRING_POOL *pool, const ENCODING
const char *ptr, const char *end)
if ( ! poolAppend ( pool , enc , ptr , end ) )
static XML_Char
poolAppend(STRING_POOL *pool, const ENCODING
const char *ptr, const char *end)
if ( ! pool -> ptr && ! poolGrow ( pool ) )
static XML_Bool
poolGrow(STRING_POOL *pool)
if ( pool -> freeBlocks )
if ( pool -> start == 0 )
if ( pool -> end - pool -> start < pool -> freeBlocks -> size )
BLOCK * tem = pool -> freeBlocks -> next ;
pool -> freeBlocks -> next = pool -> blocks;
pool -> blocks = pool -> freeBlocks;
pool -> freeBlocks = tem;
memcpy ( pool -> blocks -> s , pool -> start , ( pool -> end - pool -> start ) * sizeof ( XML_Char ) );
pool -> ptr = pool -> blocks -> s + ( pool -> ptr - pool -> start );
pool -> start = pool -> blocks -> s;
pool -> end = pool -> start + pool -> blocks -> size;
0
------------------------------
299165 150046/aviobuf.c s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_ptr - s -> checksum_ptr ) ) ) 290
int avio_close_dyn_buf(AVIOContext *s,uint8_t **pbuffer)
static const char padbuf [ 16 ] = { ( 0 ) } ;
if ( ! s -> max_packet_size )
avio_write ( s , padbuf , ( sizeof ( padbuf ) ) );
void avio_write(AVIOContext *s,const unsigned char *buf,int size)
if ( s -> direct && ! s -> update_checksum )
avio_flush ( s );
void avio_flush(AVIOContext *s)
flush_buffer ( s );
static void flush_buffer(AVIOContext *s)
if ( s -> buf_ptr > s -> buffer )
if ( s -> update_checksum )
s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_ptr - s -> checksum_ptr ) ) );
s -> checksum_ptr = s -> buffer;
s -> buf_ptr = s -> buffer;
0
------------------------------
311595 150218/bufmgr.c strategy_delta = ( strategy_buf_id - prev_strategy_buf_id ) 1557
bool BgBufferSync()
int strategy_buf_id ;
static bool saved_info_valid = ( bool ) 0 ;
static int prev_strategy_buf_id ;
long strategy_delta ;
strategy_buf_id = StrategySyncStart ( & strategy_passes , & recent_alloc );
if ( bgwriter_lru_maxpages <= 0 )
if ( saved_info_valid )
strategy_delta = ( strategy_buf_id - prev_strategy_buf_id );
strategy_delta += ( ( long ) passes_delta ) * NBuffers;
if ( strategy_delta > 0 && recent_alloc > 0 )
scans_per_alloc = ( ( float ) strategy_delta ) / ( ( float ) recent_alloc );
smoothed_density += ( scans_per_alloc - smoothed_density ) / smoothing_samples;
reusable_buffers_est = ( ( ( float ) bufs_ahead ) / smoothed_density );
if ( upcoming_alloc_est < min_scan_buffers + reusable_buffers_est )
upcoming_alloc_est = min_scan_buffers + reusable_buffers_est;
reusable_buffers = reusable_buffers_est;
while ( num_to_scan > 0 && reusable_buffers < upcoming_alloc_est )
reusable_buffers ++;
reusable_buffers ++;
new_recent_alloc = ( reusable_buffers - reusable_buffers_est );
if ( new_strategy_delta > 0 && new_recent_alloc > 0 )
scans_per_alloc = ( ( float ) new_strategy_delta ) / ( ( float ) new_recent_alloc );
smoothed_density += ( scans_per_alloc - smoothed_density ) / smoothing_samples;
0
------------------------------
313510 95548/CWE36_Absolute_Path_Traversal__char_connect_socket_fopen_11.cpp recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ) 98
void bad()
char * data ;
char dataBuffer [ FILENAME_MAX ] = "" ;
data = dataBuffer;
if ( globalReturnsTrue ( ) )
int globalReturnsTrue()
return 1 ;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
pFile = FOPEN ( data , "wb+" );
if ( pFile != NULL )
fclose ( pFile );
1
------------------------------
21429 CVE-2015-0811/Firefox_36.0b9_CVE_2015_0811_gfx_qcms_iccread.c ( * curveArray ) [ i ] = read_curveType ( src , curve_offset + channel_offset , & tag_len ) 503
qcms_profile* qcms_profile_from_file(FILE *file)
size_t length ;
qcms_profile * profile ;
void * data ;
if ( ( data == NULL ) || ( length == 0 ) )
profile = qcms_profile_from_memory ( data , length );
qcms_profile* qcms_profile_from_memory(const void *mem, size_t size)
uint32_t length ;
struct mem_source source ;
struct mem_source * src = & source ;
struct tag_index index ;
qcms_profile * profile ;
source . buf = mem;
source . size = size;
source . valid = true;
if ( size < 4 )
length = read_u32 ( src , 0 );
if ( length <= size )
source . size = length;
if ( source . size <= 64 || source . size >= MAX_PROFILE_SIZE )
profile = qcms_profile_create ( );
if ( ! profile )
if ( ! src -> valid )
index = read_tag_table ( profile , src );
if ( find_tag ( index , TAG_CHAD ) )
profile -> chromaticAdaption = read_tag_s15Fixed16ArrayType ( src , index , TAG_CHAD );
profile -> chromaticAdaption . invalid = true;
if ( profile -> color_space == RGB_SIGNATURE )
if ( find_tag ( index , TAG_B2A0 ) )
if ( read_u32 ( src , find_tag ( index , TAG_B2A0 ) -> offset ) == LUT8_TYPE || read_u32 ( src , find_tag ( index , TAG_B2A0 ) -> offset ) == LUT16_TYPE )
if ( read_u32 ( src , find_tag ( index , TAG_B2A0 ) -> offset ) == LUT_MBA_TYPE )
profile -> mBA = read_tag_lutmABType ( src , index , TAG_B2A0 );
static struct lutmABType *read_tag_lutmABType(struct mem_source *src, struct tag_index index, uint32_t tag_id)
struct tag * tag = find_tag ( index , tag_id ) ;
uint32_t offset = tag -> offset ;
uint32_t a_curve_offset , b_curve_offset , m_curve_offset ;
uint32_t matrix_offset ;
uint32_t clut_offset ;
uint32_t clut_size = 1 ;
uint32_t type = read_u32 ( src , offset ) ;
uint8_t num_in_channels , num_out_channels ;
struct lutmABType * lut ;
uint32_t i ;
if ( type != LUT_MAB_TYPE && type != LUT_MBA_TYPE )
num_in_channels = read_u8 ( src , offset + 8 );
num_out_channels = read_u8 ( src , offset + 8 );
if ( num_in_channels > MAX_CHANNELS || num_out_channels > MAX_CHANNELS )
if ( num_in_channels != 3 || num_out_channels != 3 )
a_curve_offset = read_u32 ( src , offset + 28 );
static uint32_t read_u32(struct mem_source *mem, size_t offset)
if ( offset > mem -> size - 4 )
return 0 ;
be32 k ;
memcpy ( & k , mem -> buf + offset , sizeof ( k ) );
return be32_to_cpu ( k ) ;
clut_offset = read_u32 ( src , offset + 24 );
matrix_offset = read_u32 ( src , offset + 16 );
if ( a_curve_offset )
a_curve_offset += offset;
if ( clut_offset )
clut_offset += offset;
if ( matrix_offset )
matrix_offset += offset;
if ( clut_offset )
for (i = 0; i < num_in_channels; i++)
clut_size *= read_u8 ( src , clut_offset + i );
clut_size = 0;
clut_size = clut_size * num_out_channels;
if ( clut_size > MAX_CLUT_SIZE )
lut = malloc ( sizeof ( struct lutmABType ) + ( clut_size ) * sizeof ( float ) );
if ( ! lut )
memset ( lut , 0 , sizeof ( struct lutmABType ) );
lut -> clut_table = & lut -> clut_table_data [ 0 ];
for (i = 0; i < num_in_channels; i++)
lut -> num_grid_points [ i ] = read_u8 ( src , clut_offset + i );
lut -> reversed = ( type == LUT_MBA_TYPE );
lut -> num_in_channels = num_in_channels;
lut -> num_out_channels = num_out_channels;
if ( matrix_offset )
lut -> e00 = read_s15Fixed16Number ( src , matrix_offset + 4 * 0 );
lut -> e01 = read_s15Fixed16Number ( src , matrix_offset + 4 * 1 );
lut -> e02 = read_s15Fixed16Number ( src , matrix_offset + 4 * 2 );
lut -> e10 = read_s15Fixed16Number ( src , matrix_offset + 4 * 3 );
lut -> e11 = read_s15Fixed16Number ( src , matrix_offset + 4 * 4 );
lut -> e12 = read_s15Fixed16Number ( src , matrix_offset + 4 * 5 );
lut -> e20 = read_s15Fixed16Number ( src , matrix_offset + 4 * 6 );
lut -> e21 = read_s15Fixed16Number ( src , matrix_offset + 4 * 7 );
lut -> e22 = read_s15Fixed16Number ( src , matrix_offset + 4 * 8 );
lut -> e03 = read_s15Fixed16Number ( src , matrix_offset + 4 * 9 );
lut -> e13 = read_s15Fixed16Number ( src , matrix_offset + 4 * 10 );
lut -> e23 = read_s15Fixed16Number ( src , matrix_offset + 4 * 11 );
if ( a_curve_offset )
read_nested_curveType ( src , & lut -> a_curves , num_in_channels , a_curve_offset );
static void read_nested_curveType(struct mem_source *src, struct curveType *(*curveArray)[MAX_CHANNELS], uint8_t num_channels, uint32_t curve_offset)
uint32_t channel_offset = 0 ;
int i ;
for (i = 0; i < num_channels; i++)
uint32_t tag_len ;
( * curveArray ) [ i ] = read_curveType ( src , curve_offset + channel_offset , & tag_len );
if ( ! ( * curveArray ) [ i ] )
channel_offset += tag_len;
if ( ( tag_len % 4 ) != 0 )
channel_offset += 4 - ( tag_len % 4 );
0
------------------------------
309268 120663/CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_spawnlp_54a.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 ) 104
void CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_spawnlp_54_bad()
wchar_t * data ;
wchar_t dataBuffer [ 100 ] = L ""
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
18651 CVE-2015-2716/Firefox_37.0b7_CVE_2015_2716_parser_expat_lib_xmlparse.c pool -> end = pool -> start + blockSize 6266
static enum
storeAtts(XML_Parser parser, const ENCODING
const char *attStr, TAG_NAME
BINDING **bindingsPtr)
DTD * const dtd = _dtd
ELEMENT_TYPE * elementType ;
int nDefaultAtts ;
const XML_Char * * appAtts ;
int attIndex = 0 ;
int i ;
int n ;
elementType = ( ELEMENT_TYPE * ) lookup ( & dtd -> elementTypes , tagNamePtr -> str , 0 );
if ( ! elementType )
const XML_Char * name = poolCopyString ( & dtd -> pool , tagNamePtr -> str ) ;
if ( ! name )
elementType = ( ELEMENT_TYPE * ) lookup ( & dtd -> elementTypes , name , sizeof ( ELEMENT_TYPE ) );
if ( ! elementType )
if ( ns && ! setElementTypePrefix ( parser , elementType ) )
nDefaultAtts = elementType -> nDefaultAtts;
n = XmlGetAttributes ( enc , attStr , attsSize , atts );
if ( n + nDefaultAtts > attsSize )
ATTRIBUTE * temp ;
attsSize = n + nDefaultAtts + INIT_ATTS_SIZE;
temp = ( ATTRIBUTE * ) REALLOC ( ( void * ) atts , attsSize * sizeof ( ATTRIBUTE ) );
if ( temp == NULL )
atts = temp;
appAtts = ( const XML_Char * * ) atts;
for (i = 0; i < n; i++)
ATTRIBUTE_ID * attId = getAttributeId ( parser , enc , atts [ i ] . name , atts [ i ] . name + XmlNameLength ( enc , atts [ i ] . name ) ) ;
if ( ! attId )
if ( ( attId -> name ) [ - 1 ] )
( attId -> name ) [ - 1 ] = 1;
appAtts [ attIndex ++ ] = attId -> name;
if ( ! atts [ i ] . normalized )
enum XML_Error result ;
XML_Bool isCdata = XML_TRUE ;
if ( attId -> maybeTokenized )
int j ;
for (j = 0; j < nDefaultAtts; j++)
if ( attId == elementType -> defaultAtts [ j ] . id )
isCdata = elementType -> defaultAtts [ j ] . isCdata;
result = storeAttributeValue ( parser , enc , isCdata , atts [ i ] . valuePtr , atts [ i ] . valueEnd , & tempPool );
if ( result )
appAtts [ attIndex ] = poolStart ( & tempPool );
appAtts [ attIndex ] = poolStoreString ( & tempPool , enc , atts [ i ] . valuePtr , atts [ i ] . valueEnd );
if ( appAtts [ attIndex ] == 0 )
if ( attId -> prefix )
if ( attId -> xmlns )
enum XML_Error result = addBinding ( parser , attId -> prefix , attId , appAtts [ attIndex ] , bindingsPtr ) ;
if ( result )
attIndex ++;
( attId -> name ) [ - 1 ] = 2;
attIndex ++;
static XML_Char
poolStoreString(STRING_POOL *pool, const ENCODING
const char *ptr, const char *end)
if ( ! poolAppend ( pool , enc , ptr , end ) )
static XML_Char
poolAppend(STRING_POOL *pool, const ENCODING
const char *ptr, const char *end)
if ( ! pool -> ptr && ! poolGrow ( pool ) )
if ( ptr == end )
if ( ! poolGrow ( pool ) )
static XML_Bool
poolGrow(STRING_POOL *pool)
if ( pool -> freeBlocks )
if ( pool -> start == 0 )
if ( pool -> end - pool -> start < pool -> freeBlocks -> size )
if ( pool -> blocks && pool -> start == pool -> blocks -> s )
int blockSize = ( int ) ( pool -> end - pool -> start ) * 2 ;
pool -> blocks = ( BLOCK * ) pool -> mem -> realloc_fcn ( pool -> blocks , ( offsetof ( BLOCK , s ) + blockSize * sizeof ( XML_Char ) ) );
if ( pool -> blocks == NULL )
pool -> blocks -> size = blockSize;
pool -> ptr = pool -> blocks -> s + ( pool -> ptr - pool -> start );
pool -> start = pool -> blocks -> s;
pool -> end = pool -> start + blockSize;
0
------------------------------
19446 CVE-2015-2726/Firefox_38.8.0esr_CVE_2015_2726_js_src_ctypes_CTypes.cpp const CharT * end = cp + length ; 1800

Int64::Construct(JSContext*
unsigned
jsval* vp)
CallArgs args = CallArgsFromVp ( argc , vp ) ;
if ( args . length ( ) != 1 )
if ( ! jsvalToBigInteger ( cx , args [ 0 ] , true , & i ) )
template<class
static
jsvalToBigInteger(JSContext*
jsval
bool
IntegerType* result)
if ( val . isInt32 ( ) )
if ( val . isDouble ( ) )
if ( allowString && val . isString ( ) )
if ( val . isObject ( ) )
JSObject * obj = & val . toObject ( ) ;
if ( UInt64 :: IsUInt64 ( obj ) )
if ( Int64 :: IsInt64 ( obj ) )
if ( CDataFinalizer :: IsCDataFinalizer ( obj ) )
RootedValue innerData ( cx ) ;
if ( ! CDataFinalizer :: GetValue ( cx , obj , & innerData ) )
return jsvalToBigInteger ( cx , innerData , allowString , result ) ;
template<class
static
jsvalToBigInteger(JSContext*
jsval
bool
IntegerType* result)
if ( val . isInt32 ( ) )
if ( val . isDouble ( ) )
if ( allowString && val . isString ( ) )
return StringToInteger ( cx , val . toString ( ) , result ) ;
template <class IntegerType, class
static
StringToInteger(JSContext* cx, CharT* cp, size_t length, IntegerType* result)
const CharT * end = cp + length ;
if ( cp == end )
if ( end - cp > 2 && cp [ 0 ] == '0' && ( cp [ 1 ] == 'x' || cp [ 1 ] == 'X' ) )
while ( cp != end )
0
------------------------------
16936 CVE-2014-0069/CVE_2014_0069_PATCHED_cifs_iovec_write.c cur_len = save_len - cur_len 76
static
CVE_2014_0069_PATCHED_cifs_iovec_write(struct file *file, const struct iovec
unsigned long nr_segs, loff_t *poffset)
unsigned long nr_pages , i ;
size_t bytes , copied , len , cur_len ;
loff_t offset ;
struct cifsFileInfo * open_file ;
struct cifs_tcon * tcon ;
struct cifs_sb_info * cifs_sb ;
struct cifs_writedata * wdata , * tmp ;
int rc ;
pid_t pid ;
len = iov_length ( iov , nr_segs );
if ( ! len )
rc = generic_write_checks ( file , poffset , & len , 0 );
if ( rc )
cifs_sb = CIFS_SB ( file -> f_path . dentry -> d_sb );
open_file = file -> private_data;
tcon = tlink_tcon ( open_file -> tlink );
if ( ! tcon -> ses -> server -> ops -> async_writev )
offset = * poffset;
if ( cifs_sb -> mnt_cifs_flags & CIFS_MOUNT_RWPIDFORWARD )
pid = open_file -> pid;
pid = current -> tgid;
size_t save_len ;
nr_pages = get_numpages ( cifs_sb -> wsize , len , & cur_len );
wdata = cifs_writedata_alloc ( nr_pages , cifs_uncached_writev_complete );
if ( ! wdata )
rc = cifs_write_allocate_pages ( wdata -> pages , nr_pages );
if ( rc )
save_len = cur_len;
for (i = 0; i < nr_pages; i++)
bytes = min_t ( const size_t , cur_len , PAGE_SIZE )
copied = iov_iter_copy_from_user ( wdata -> pages [ i ] , & it , 0 , bytes );
cur_len -= copied;
if ( copied < bytes )
cur_len = save_len - cur_len;
if ( ! cur_len )
for ( ; nr_pages > i + 1; nr_pages--)
wdata -> sync_mode = WB_SYNC_ALL;
wdata -> nr_pages = nr_pages;
wdata -> offset = ( __u64 ) offset;
wdata -> cfile = cifsFileInfo_get ( open_file );
wdata -> pid = pid;
wdata -> bytes = cur_len;
wdata -> pagesz = PAGE_SIZE;
wdata -> tailsz = cur_len - ( ( nr_pages - 1 ) * PAGE_SIZE );
rc = cifs_uncached_retry_writev ( wdata );
if ( rc )
offset += cur_len;
len -= cur_len;
while ( len > 0 )
0
------------------------------
304018 81955/CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_w32_vsnprintf_42.c recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 ) 235
static void goodB2G()
wchar_t * data ;
wchar_t dataBuffer [ 100 ] = L ""
data = dataBuffer;
data = goodB2GSource ( data );
static wchar_t * goodB2GSource(wchar_t * data)
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
306245 117135/CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_09.c myString = ( char * ) malloc ( data * sizeof ( char ) ) 246
static void goodB2G1()
size_t data ;
data = 0;
if ( GLOBAL_CONST_TRUE )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
char inputBuffer [ CHAR_ARRAY_SIZE ] ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
inputBuffer [ recvResult ] = '\0';
data = strtoul ( inputBuffer , NULL , 0 );
while ( 0 )
if ( GLOBAL_CONST_FALSE )
char * myString ;
if ( data > strlen ( HELLO_STRING ) && data < 100 )
myString = ( char * ) malloc ( data * sizeof ( char ) );
strcpy ( myString , HELLO_STRING );
printLine ( myString );
void printLine (const char * line)
if ( line != NULL )
printf ( "%s\n" , line );
free ( myString );
0
------------------------------
305395 95386/CWE369_Divide_by_Zero__int_rand_divide_68b.c printIntLine ( 100 / data ) 30
void CWE369_Divide_by_Zero__int_rand_divide_68b_badSink()
int data = CWE369_Divide_by_Zero__int_rand_divide_68_badData ;
printIntLine ( 100 / data );
1
------------------------------
16331 CVE-2012-4298/CVE_2012_4298_PATCHED_vwr_read_rec_data_ethernet.c latency = ( guint32 ) ( s_time - sig_ts ) 121
static void CVE_2012_4298_PATCHED_vwr_read_rec_data_ethernet(wtap *wth, guint8 *data_ptr, guint8 *rec, int rec_size, int IS_TX)
vwr_t * vwr = ( vwr_t * ) wth -> priv ;
register int i
register guint8 * s_ptr , * m_ptr ;
guint16 msdu_length , actual_octets ;
guint8 flow_seq ;
guint16 l4id , info , validityBits ;
guint32 flow_id , d_time ;
int f_flow ;
guint32 frame_type ;
int mac_len , sig_off , pay_off ;
guint64 sig_ts , tsid ;
m_ptr = & ( rec [ 0 ] );
s_ptr = & ( rec [ rec_size - vwr -> STATS_LEN ] );
msdu_length = pntohs ( & s_ptr [ vwr -> OCTET_OFF ] );
if ( msdu_length > ( rec_size - ( int ) vwr -> STATS_LEN ) )
msdu_length = ( rec_size - ( int ) vwr -> STATS_LEN );
flow_seq = s_ptr [ vwr -> FLOWSEQ_OFF ];
frame_type = pntohl ( & s_ptr [ vwr -> FRAME_TYPE_OFF ] );
if ( vwr -> FPGA_VERSION == vVW510024_E_FPGA )
validityBits = pntohs ( & s_ptr [ vwr -> VALID_OFF ] );
f_flow = validityBits & vwr -> FLOW_VALID;
mac_len = ( validityBits & vwr -> IS_VLAN ) ? 16 : 14;
f_flow = s_ptr [ vwr -> VALID_OFF ] & vwr -> FLOW_VALID;
mac_len = ( frame_type & vwr -> IS_VLAN ) ? 16 : 14;
flow_id = pntoh24 ( & s_ptr [ vwr -> FLOWID_OFF ] );
s_time = pcoreytohll ( & s_ptr [ vwr -> STARTT_OFF ] );
if ( frame_type & vwr -> IS_TCP )
pay_off = mac_len + 40;
if ( frame_type & vwr -> IS_UDP )
pay_off = mac_len + 28;
if ( frame_type & vwr -> IS_ICMP )
pay_off = mac_len + 24;
if ( frame_type & vwr -> IS_IGMP )
pay_off = mac_len + 28;
pay_off = mac_len + 20;
sig_off = find_signature ( m_ptr , pay_off , flow_id , flow_seq );
if ( ( m_ptr [ sig_off ] == 0xdd ) && ( sig_off + 15 <= msdu_length ) && ( f_flow != 0 ) )
sig_ts = get_signature_ts ( m_ptr , sig_off );
sig_ts = 0;
if ( ! IS_TX )
if ( sig_ts < s_time )
latency = ( guint32 ) ( s_time - sig_ts );
0
------------------------------
18580 CVE-2015-2716/Firefox_37.0b7_CVE_2015_2716_parser_expat_lib_xmlparse.c tem = ( BLOCK * ) pool -> mem -> malloc_fcn ( offsetof ( BLOCK , s ) + blockSize * sizeof ( XML_Char ) ) 6275
static enum XML_Error
entityValueInitProcessor(XML_Parser
const char
const char
const char **nextPtr)
int tok ;
const char * start = s ;
const char * next = start ;
tok = XmlPrologTok ( encoding , start , end , & next );
if ( tok <= 0 )
if ( ! ps_finalBuffer && tok != XML_TOK_INVALID )
switch ( tok )
return storeEntityValue ( parser , encoding , s , end ) ;
if ( tok == XML_TOK_XML_DECL )
if ( tok == XML_TOK_BOM && next == end && ! ps_finalBuffer )
start = next;
static enum
storeEntityValue(XML_Parser
const ENCODING
const char
const char *entityTextEnd)
DTD * const dtd = _dtd
STRING_POOL * pool = & ( dtd -> entityValuePool ) ;
if ( ! pool -> blocks )
if ( ! poolGrow ( pool ) )
const char * next ;
int tok = XmlEntityValueTok ( enc , entityTextPtr , entityTextEnd , & next ) ;
switch ( tok )
if ( isParamEntity || enc != encoding )
const XML_Char * name ;
ENTITY * entity ;
name = poolStoreString ( & tempPool , enc , entityTextPtr + enc -> minBytesPerChar , next - enc -> minBytesPerChar );
if ( ! name )
entity = ( ENTITY * ) lookup ( & dtd -> paramEntities , name , 0 );
if ( ! entity )
if ( entity -> open )
if ( entity -> systemId )
if ( externalEntityRefHandler )
entity -> open = XML_TRUE;
if ( ! externalEntityRefHandler ( externalEntityRefHandlerArg , 0 , entity -> base , entity -> systemId , entity -> publicId ) )
entity -> open = XML_FALSE;
entity -> open = XML_TRUE;
result = storeEntityValue ( parser , internalEncoding , ( char * ) entity -> textPtr , ( char * ) ( entity -> textPtr + entity -> textLen ) );
entity -> open = XML_FALSE;
if ( result )
if ( ! poolAppend ( pool , enc , entityTextPtr , next ) )
next = entityTextPtr + enc -> minBytesPerChar;
if ( pool -> end == pool -> ptr && ! poolGrow ( pool ) )
* ( pool -> ptr ) ++ = 0xA;
XML_Char buf [ XML_ENCODE_MAX ] ;
int i ;
int n = XmlCharRefNumber ( enc , entityTextPtr ) ;
if ( n < 0 )
n = XmlEncode ( n , ( ICHAR * ) buf );
if ( ! n )
for (i = 0; i < n; i++)
if ( pool -> end == pool -> ptr && ! poolGrow ( pool ) )
* ( pool -> ptr ) ++ = buf [ i ];
entityTextPtr = next;
static XML_Char
poolAppend(STRING_POOL *pool, const ENCODING
const char *ptr, const char *end)
if ( ! pool -> ptr && ! poolGrow ( pool ) )
static XML_Bool
poolGrow(STRING_POOL *pool)
if ( pool -> freeBlocks )
if ( pool -> start == 0 )
if ( pool -> end - pool -> start < pool -> freeBlocks -> size )
if ( pool -> blocks && pool -> start == pool -> blocks -> s )
BLOCK * tem ;
int blockSize = ( int ) ( pool -> end - pool -> start ) ;
if ( blockSize < INIT_BLOCK_SIZE )
blockSize = INIT_BLOCK_SIZE;
blockSize *= 2;
tem = ( BLOCK * ) pool -> mem -> malloc_fcn ( offsetof ( BLOCK , s ) + blockSize * sizeof ( XML_Char ) );
if ( ! tem )
tem -> size = blockSize;
tem -> next = pool -> blocks;
pool -> blocks = tem;
if ( pool -> ptr != pool -> start )
memcpy ( tem -> s , pool -> start , ( pool -> ptr - pool -> start ) * sizeof ( XML_Char ) );
pool -> ptr = tem -> s + ( pool -> ptr - pool -> start );
pool -> start = tem -> s;
pool -> end = tem -> s + blockSize;
0
------------------------------
301565 150690/aviobuf.c s -> buf_end = dst + len 591
int avio_get_str16be(AVIOContext *pb,int maxlen,char *buf,int buflen)
int ret = 0 ;
if ( buflen <= 0 )
while ( ret + 1 < maxlen )
uint32_t ch ;
ch = ( ( ret += 2 ) <= maxlen ? avio_rb16 ( pb ) : 0 );
unsigned int hi = ch - 0xD800 ;
if ( hi < 0x800 )
ch = ( ( ret += 2 ) <= maxlen ? avio_rb16 ( pb ) : ( 0 - 0xDC00 ) );
if ( ch > 0x3FFU || hi > 0x3FFU )
ch += ( hi << 10 ) + 0x10000;
if ( ! ch )
unsigned int avio_rb16(AVIOContext *s)
unsigned int val ;
val = ( avio_r8 ( s ) << 8 );
int avio_r8(AVIOContext *s)
if ( s -> buf_ptr >= s -> buf_end )
fill_buffer ( s );
static void fill_buffer(AVIOContext *s)
uint8_t * dst = ! s -> max_packet_size && s -> buf_end - s -> buffer < ( s -> buffer_size ) ? s -> buf_end : s -> buffer ;
int len = ( ( s -> buffer_size ) - ( dst - s -> buffer ) ) ;
int max_buffer_size = s -> max_packet_size ? s -> max_packet_size : 32768 ;
if ( ! s -> read_packet && s -> buf_ptr >= s -> buf_end )
s -> eof_reached = 1;
if ( s -> eof_reached )
if ( s -> update_checksum && dst == s -> buffer )
if ( s -> buf_end > s -> checksum_ptr )
s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_end - s -> checksum_ptr ) ) );
s -> checksum_ptr = s -> buffer;
if ( s -> read_packet && s -> buffer_size > max_buffer_size )
s -> checksum_ptr = dst = s -> buffer;
len = s -> buffer_size;
if ( s -> read_packet )
len = ( ( s -> read_packet ) ( s -> opaque , dst , len ) );
len = 0;
if ( len <= 0 )
s -> eof_reached = 1;
if ( len < 0 )
s -> error = len;
s -> pos += len;
s -> buf_ptr = dst;
s -> buf_end = dst + len;
s -> bytes_read += len;
0
------------------------------
19560 CVE-2015-2726/Firefox_38.8.0esr_CVE_2015_2726_js_src_ctypes_CTypes.cpp size_t arraySize = elementSize * targetLength ; 2613

CClosure::ClosureStub(ffi_cif* cif, void* result, void** args, void* userData)
ClosureInfo * cinfo = static_cast < ClosureInfo * > userData
JSContext * cx = cinfo -> cx ;
RootedObject typeObj ( cx , cinfo -> typeObj ) ;
RootedObject thisObj ( cx , cinfo -> thisObj ) ;
RootedValue jsfnVal ( cx , ObjectValue ( * cinfo -> jsfnObj ) ) ;
FunctionInfo * fninfo = FunctionType :: GetFunctionInfo ( typeObj ) ;
TypeCode typeCode = CType :: GetTypeCode ( fninfo -> mReturnType ) ;

CType::GetTypeCode(JSObject* typeObj)
jsval result = JS_GetReservedSlot ( typeObj , SLOT_TYPECODE ) ;
return TypeCode ( result . toInt32 ( ) ) ;
if ( cif -> rtype != & ffi_type_void )
rvSize = cif -> rtype -> size;
switch ( typeCode )
#undef INTEGRAL_CASE
rvSize = Align ( rvSize , sizeof ( ffi_arg ) ) ;
static MOZ_ALWAYS_INLINE
Align(size_t val, size_t align)
return ( ( val - 1 ) | ( align - 1 ) ) + 1 ;
memset ( result , 0 , rvSize );
JS :: AutoValueVector argv ( cx ) ;
if ( ! argv . resize ( cif -> nargs ) )
for (uint32_t i = 0; i < cif->nargs; ++i)
RootedObject argType ( cx , fninfo -> mArgTypes [ i ] ) ;
if ( ! ConvertToJS ( cx , argType , NullPtr ( ) , args [ i ] , false , false , argv [ i ] ) )
RootedValue rval ( cx ) ;
bool success = JS_CallFunctionValue ( cx , thisObj , jsfnVal , argv , & rval ) ;
if ( success && cif -> rtype != & ffi_type_void )
success = ImplicitConvert ( cx , rval , fninfo -> mReturnType , result , false , nullptr );
static
ImplicitConvert(JSContext*
HandleValue
JSObject*
void*
bool
bool* freePointer)
RootedObject targetType ( cx , targetType_ ) ;
RootedObject valObj ( cx , nullptr ) ;
if ( val . isObject ( ) )
valObj = & val . toObject ( );
if ( CData :: IsCData ( valObj ) )
sourceData = valObj;
sourceType = CData :: GetCType ( sourceData );
if ( CType :: TypesEqual ( sourceType , targetType ) )
if ( CDataFinalizer :: IsCDataFinalizer ( valObj ) )
sourceData = valObj;
sourceType = CDataFinalizer :: GetCType ( cx , sourceData );
CDataFinalizer :: Private * p = ( CDataFinalizer :: Private * ) JS_GetPrivate ( sourceData ) ;
if ( ! p )
if ( CType :: TypesEqual ( sourceType , targetType ) )
TypeCode targetCode = CType :: GetTypeCode ( targetType ) ;
switch ( targetCode )
RootedObject baseType ( cx , ArrayType :: GetBaseType ( targetType ) ) ;
size_t targetLength = ArrayType :: GetLength ( targetType ) ;
if ( val . isString ( ) )
if ( val . isObject ( ) && JS_IsArrayObject ( cx , valObj ) )
if ( val . isObject ( ) && JS_IsArrayBufferObject ( valObj ) )
size_t elementSize = CType :: GetSize ( baseType ) ;
size_t arraySize = elementSize * targetLength ;
if ( arraySize != size_t ( sourceLength ) )
0
------------------------------
309091 120806/CWE78_OS_Command_Injection__wchar_t_connect_socket_w32spawnl_53a.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 ) 104
void CWE78_OS_Command_Injection__wchar_t_connect_socket_w32spawnl_53_bad()
wchar_t * data ;
wchar_t dataBuffer [ 100 ] = L ""
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
314240 110668/CWE680_Integer_Overflow_to_Buffer_Overflow__new_fgets_31.cpp dataBytes = data * sizeof ( int ) 82
static void goodG2B()
int data ;
data = - 1;
data = 20;
int dataCopy = data ;
int data = dataCopy ;
size_t dataBytes , i ;
dataBytes = data * sizeof ( int );
intPointer = ( int * ) new char [ dataBytes ];
intPointer [ i ] = 0;
printIntLine ( intPointer [ 0 ] );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
delete [ ] intPointer
0
------------------------------
311504 153297/dfa.c match_lens = check_matching_with_multibyte_ops ( d , s , ( * pp - buf_begin ) ) 3456
char *dfaexec(struct dfa *d,const char *begin,char *end,int allow_nl,size_t *count,int *backref)
state_num s ;
state_num s1 ;
const unsigned char * p ;
state_num * * trans ;
state_num * t ;
unsigned char eol = eolbyte ;
s = s1 = 0;
p = ( ( const unsigned char * ) begin );
trans = d -> trans;
* end = eol;
if ( d -> mb_cur_max > 1 )
while ( ( t = trans [ s ] ) != ( ( void * ) 0 ) )
if ( p > buf_end )
s1 = s;
if ( s == 0 )
if ( ( ( char * ) p ) >= end )
if ( d -> states [ s ] . mbps . nelem == 0 )
s = t [ * ( p ++ ) ];
if ( backref )
s = transit_state ( d , s , & p );
trans = d -> trans;
while ( ( t = trans [ s ] ) != ( ( void * ) 0 ) )
s1 = t [ * ( p ++ ) ];
if ( ( t = trans [ s1 ] ) == ( ( void * ) 0 ) )
state_num tmp = s ;
s = s1;
s1 = tmp;
s = t [ * ( p ++ ) ];
if ( s >= 0 && ( ( char * ) p ) <= end && d -> fails [ s ] )
if ( d -> success [ s ] & sbit [ * p ] )
s1 = s;
if ( d -> mb_cur_max > 1 )
s = transit_state ( d , s , & p );
trans = d -> trans;
s = d -> fails [ s ] [ * ( p ++ ) ];
if ( ( ( char * ) p ) > end )
if ( s >= 0 )
trans = d -> trans;
if ( p [ - 1 ] == eol && allow_nl )
s = d -> newlines [ s1 ];
s = 0;
static state_num transit_state(struct dfa *d,state_num s,const unsigned char **pp)
size_t nelem = d -> states [ s ] . mbps . nelem ;
if ( nelem > 0 )
match_lens = check_matching_with_multibyte_ops ( d , s , ( * pp - buf_begin ) );
if ( match_lens [ i ] > maxlen )
maxlen = match_lens [ i ];
if ( nelem == 0 || maxlen == 0 )
free ( match_lens );
transit_state_consume_1char ( d , s , pp , match_lens , & mbclen , & follows );
while ( * pp - p1 < maxlen )
if ( match_lens [ i ] == * pp - p1 )
free ( match_lens );
0
------------------------------
304261 79294/CWE134_Uncontrolled_Format_String__char_connect_socket_vprintf_05.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 108
void CWE134_Uncontrolled_Format_String__char_connect_socket_vprintf_05_bad()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
if ( staticTrue )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
badVaSinkB ( data , data );
static void badVaSinkB(char * data, ...)
va_start ( args , data );
vprintf ( data , args );
1
------------------------------
303241 82350/CWE190_Integer_Overflow__char_max_square_01.c char result = data * data ; 32
void CWE190_Integer_Overflow__char_max_square_01_bad()
char data ;
data = ' ';
data = CHAR_MAX;
char result = data * data ;
printHexCharLine ( result );
void printHexCharLine (char charHex)
printf ( "%02x\n" , charHex );
1
------------------------------
16817 CVE-2013-0771/CVE_2013_0771_PATCHED_nsTextFrame__ReflowText.c lastBreak = end . ConvertSkippedToOriginal ( transformedOffset + transformedLastBreak ) 316

CVE_2013_0771_PATCHED_nsTextFrame::ReflowText(nsLineLayout& aLineLayout, nscoord
nsRenderingContext*
bool
nsHTMLReflowMetrics&
nsReflowStatus& aStatus)
int32_t maxContentLength = GetInFlowContentLength ( ) ;
if ( ! maxContentLength )
const nsStyleText * textStyle = GetStyleText ( ) ;
bool atStartOfLine = aLineLayout . LineAtStart ( ) ;
const nsTextFragment * frag = mContent -> GetText ( ) ;
int32_t length = maxContentLength ;
int32_t offset = GetContentOffset ( ) ;
int32_t newLineOffset = - 1 ;
int32_t contentNewLineOffset = - 1 ;
NewlineProperty * cachedNewlineOffset = nullptr ;
if ( textStyle -> NewlineIsSignificant ( ) )
cachedNewlineOffset
static_cast < NewlineProperty * > mContent -> GetProperty ( nsGkAtoms :: newline )
if ( cachedNewlineOffset && cachedNewlineOffset -> mStartOffset <= offset && ( cachedNewlineOffset -> mNewlineOffset == - 1 || cachedNewlineOffset -> mNewlineOffset >= offset ) )
contentNewLineOffset = cachedNewlineOffset -> mNewlineOffset;
contentNewLineOffset = FindChar ( frag , offset , mContent -> TextLength ( ) - offset , '\n' );
if ( contentNewLineOffset < offset + length )
newLineOffset = contentNewLineOffset;
if ( newLineOffset >= 0 )
length = newLineOffset + 1 - offset;
if ( ( atStartOfLine && ! textStyle -> WhiteSpaceIsSignificant ( ) ) || ( GetStateBits ( ) & TEXT_FORCE_TRIM_WHITESPACE ) )
int32_t skipLength = newLineOffset >= 0 ? length - 1 : length ;
int32_t whitespaceCount = GetTrimmableWhitespaceCount ( frag , offset , skipLength , 1 ) ;
if ( whitespaceCount )
offset += whitespaceCount;
length -= whitespaceCount;
if ( aLineLayout . GetInFirstLetter ( ) || aLineLayout . GetInFirstLine ( ) )
if ( aLineLayout . GetInFirstLetter ( ) )
if ( mTextRun )
int32_t firstLetterLength = length ;
if ( aLineLayout . GetFirstLetterStyleOK ( ) )
if ( newLineOffset >= 0 )
firstLetterLength = NS_MIN ( firstLetterLength , length - 1 );
firstLetterLength = 0;
length = firstLetterLength;
if ( ! mTextRun )
PropertyProvider provider ( mTextRun , textStyle , frag , this , iter , length , lineContainer , xOffsetForTabs , nsTextFrame :: eInflated ) ;
uint32_t transformedOffset = provider . GetStart ( ) . GetSkippedOffset ( ) ;
int32_t limitLength = length ;
int32_t forceBreak = aLineLayout . GetForcedBreakPosition ( mContent ) ;
if ( forceBreak >= offset + length )
forceBreak = - 1;
if ( forceBreak >= 0 )
limitLength = forceBreak - offset;
uint32_t transformedLastBreak = 0 ;
gfxSkipCharsIterator end ( provider . GetEndHint ( ) ) ;
int32_t charsFit = end . GetOriginalOffset ( ) - offset ;
if ( charsFit >= limitLength )
charsFit = limitLength;
if ( transformedLastBreak != PR_UINT32_MAX )
lastBreak = end . ConvertSkippedToOriginal ( transformedOffset + transformedLastBreak );
int32_t contentLength = offset + charsFit - GetContentOffset ( ) ;
if ( contentLength < maxContentLength && textStyle -> NewlineIsSignificant ( ) && ( contentNewLineOffset < 0 || mContentOffset + contentLength <= contentNewLineOffset ) )
if ( ! cachedNewlineOffset )
cachedNewlineOffset = new NewlineProperty
0
------------------------------
304569 83083/CWE190_Integer_Overflow__int_connect_socket_square_14.c int result = data * data ; 279
static void goodB2G2()
int data ;
data = 0;
if ( globalFive == 5 )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
char inputBuffer [ CHAR_ARRAY_SIZE ] ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
inputBuffer [ recvResult ] = '\0';
data = atoi ( inputBuffer );
while ( 0 )
if ( globalFive == 5 )
if ( abs ( ( long ) data ) <= ( long ) sqrt ( ( double ) INT_MAX ) )
int result = data * data ;
printIntLine ( result );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
0
------------------------------
18523 CVE-2015-2716/Firefox_37.0b7_CVE_2015_2716_parser_expat_lib_xmlparse.c pool -> ptr = tem -> s + ( pool -> ptr - pool -> start ) 6285
static
reportComment(XML_Parser parser, const ENCODING
const char *start, const char *end)
XML_Char * data ;
if ( ! commentHandler )
data = poolStoreString ( & tempPool , enc , start + enc -> minBytesPerChar * 4 , end - enc -> minBytesPerChar * 3 );
static XML_Char
poolStoreString(STRING_POOL *pool, const ENCODING
const char *ptr, const char *end)
if ( ! poolAppend ( pool , enc , ptr , end ) )
static XML_Char
poolAppend(STRING_POOL *pool, const ENCODING
const char *ptr, const char *end)
if ( ! pool -> ptr && ! poolGrow ( pool ) )
static XML_Bool
poolGrow(STRING_POOL *pool)
if ( pool -> freeBlocks )
if ( pool -> start == 0 )
if ( pool -> end - pool -> start < pool -> freeBlocks -> size )
if ( pool -> blocks && pool -> start == pool -> blocks -> s )
BLOCK * tem ;
int blockSize = ( int ) ( pool -> end - pool -> start ) ;
if ( blockSize < INIT_BLOCK_SIZE )
blockSize = INIT_BLOCK_SIZE;
blockSize *= 2;
tem = ( BLOCK * ) pool -> mem -> malloc_fcn ( offsetof ( BLOCK , s ) + blockSize * sizeof ( XML_Char ) );
if ( ! tem )
tem -> size = blockSize;
tem -> next = pool -> blocks;
pool -> blocks = tem;
if ( pool -> ptr != pool -> start )
memcpy ( tem -> s , pool -> start , ( pool -> ptr - pool -> start ) * sizeof ( XML_Char ) );
pool -> ptr = tem -> s + ( pool -> ptr - pool -> start );
pool -> start = tem -> s;
pool -> end = tem -> s + blockSize;
0
------------------------------
302777 83522/CWE190_Integer_Overflow__int_listen_socket_square_31.c int result = data * data ; 125
void CWE190_Integer_Overflow__int_listen_socket_square_31_bad()
int data ;
data = 0;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
char inputBuffer [ CHAR_ARRAY_SIZE ] ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
inputBuffer [ recvResult ] = '\0';
data = atoi ( inputBuffer );
while ( 0 )
int dataCopy = data ;
int data = dataCopy ;
int result = data * data ;
printIntLine ( result );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
1
------------------------------
314761 110698/CWE680_Integer_Overflow_to_Buffer_Overflow__new_fixed_03.cpp dataBytes = data * sizeof ( int ) 75
static void goodG2B1()
int data ;
data = - 1;
if ( 5 != 5 )
data = 20;
size_t dataBytes , i ;
dataBytes = data * sizeof ( int );
intPointer = ( int * ) new char [ dataBytes ];
intPointer [ i ] = 0;
printIntLine ( intPointer [ 0 ] );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
delete [ ] intPointer
0
------------------------------
304179 82959/CWE190_Integer_Overflow__int64_t_rand_square_61a.c int64_t result = data * data ; 53
static void goodG2B()
int64_t data ;
data = 0L L
data = CWE190_Integer_Overflow__int64_t_rand_square_61b_goodG2BSource ( data );
int64_t CWE190_Integer_Overflow__int64_t_rand_square_61b_goodG2BSource(int64_t data)
data = 2;
return data ;
int64_t result = data * data ;
printLongLongLine ( result );
void printLongLongLine (int64_t longLongIntNumber)
printf ( "%lld\n" , longLongIntNumber );
0
------------------------------
21179 CVE-2015-5307/linux_kernel_4.2.6_CVE_2015_5307_arch_x86_kvm_vmx.c __clear_bit ( msr , msr_bitmap + 0x000 / f ) 4202
static __init int hardware_setup(void)
vmx_io_bitmap_a = ( unsigned long * ) __get_free_page ( GFP_KERNEL );
if ( ! vmx_io_bitmap_a )
vmx_io_bitmap_b = ( unsigned long * ) __get_free_page ( GFP_KERNEL );
if ( ! vmx_io_bitmap_b )
vmx_msr_bitmap_legacy = ( unsigned long * ) __get_free_page ( GFP_KERNEL );
if ( ! vmx_msr_bitmap_legacy )
vmx_msr_bitmap_legacy_x2apic = ( unsigned long * ) __get_free_page ( GFP_KERNEL );
if ( ! vmx_msr_bitmap_legacy_x2apic )
vmx_msr_bitmap_longmode = ( unsigned long * ) __get_free_page ( GFP_KERNEL );
if ( ! vmx_msr_bitmap_longmode )
vmx_msr_bitmap_longmode_x2apic = ( unsigned long * ) __get_free_page ( GFP_KERNEL );
if ( ! vmx_msr_bitmap_longmode_x2apic )
if ( nested )
vmx_msr_bitmap_nested = ( unsigned long * ) __get_free_page ( GFP_KERNEL );
if ( ! vmx_msr_bitmap_nested )
vmx_vmread_bitmap = ( unsigned long * ) __get_free_page ( GFP_KERNEL );
if ( ! vmx_vmread_bitmap )
vmx_vmwrite_bitmap = ( unsigned long * ) __get_free_page ( GFP_KERNEL );
if ( ! vmx_vmwrite_bitmap )
if ( setup_vmcs_config ( & vmcs_config ) < 0 )
if ( ! cpu_has_vmx_apicv ( ) )
static inline bool cpu_has_vmx_apicv(void)
return cpu_has_vmx_apic_register_virt ( ) && cpu_has_vmx_virtual_intr_delivery ( ) && cpu_has_vmx_posted_intr ( ) ;
static inline bool cpu_has_vmx_posted_intr(void)
return vmcs_config . pin_based_exec_ctrl & PIN_BASED_POSTED_INTR ;
static inline bool cpu_has_vmx_virtual_intr_delivery(void)
return vmcs_config . cpu_based_2nd_exec_ctrl & SECONDARY_EXEC_VIRTUAL_INTR_DELIVERY ;
static inline bool cpu_has_vmx_apic_register_virt(void)
return vmcs_config . cpu_based_2nd_exec_ctrl & SECONDARY_EXEC_APIC_REGISTER_VIRT ;
enable_apicv = 0;
if ( enable_apicv )
vmx_disable_intercept_msr_write_x2apic ( 0x808 );
static void vmx_disable_intercept_msr_write_x2apic(u32 msr)
__vmx_disable_intercept_for_msr ( vmx_msr_bitmap_legacy_x2apic , msr , MSR_TYPE_W );
static void __vmx_disable_intercept_for_msr(unsigned long
u32 msr, int type)
int f = sizeof ( unsigned long ) ;
if ( ! cpu_has_vmx_msr_bitmap ( ) )
if ( msr <= 0x1fff )
if ( type & MSR_TYPE_R )
__clear_bit ( msr , msr_bitmap + 0x000 / f );
0
------------------------------
19626 CVE-2016-8658/linux_kernel_4.7.4_CVE_2016_8658_drivers_net_wireless_broadcom_brcm80211_brcmfmac_cfg80211.c notify_ie = ( u8 * ) bi + le16_to_cpu ( bi -> ie_offset ) 2767
static
brcmf_notify_connect_status(struct brcmf_if
const struct brcmf_event_msg *e, void *data)
struct brcmf_cfg80211_info * cfg = ifp -> drvr -> config ;
struct net_device * ndev = ifp -> ndev ;
if ( brcmf_is_apmode ( ifp -> vif ) )
static bool brcmf_is_apmode(struct brcmf_cfg80211_vif *vif)
enum nl80211_iftype iftype ;
iftype = vif -> wdev . iftype;
return iftype == NL80211_IFTYPE_AP || iftype == NL80211_IFTYPE_P2P_GO ;
if ( brcmf_is_linkup ( e ) )
static bool brcmf_is_linkup(const struct brcmf_event_msg *e)
u32 event = e -> event_code ;
u32 status = e -> status ;
if ( event == BRCMF_E_SET_SSID && status == BRCMF_E_STATUS_SUCCESS )
return true ;
return false ;
if ( brcmf_is_ibssmode ( ifp -> vif ) )
static bool brcmf_is_ibssmode(struct brcmf_cfg80211_vif *vif)
return vif -> wdev . iftype == NL80211_IFTYPE_ADHOC ;
brcmf_bss_connect_done ( cfg , ndev , e , true );
static
brcmf_bss_connect_done(struct brcmf_cfg80211_info
struct net_device *ndev, const struct brcmf_event_msg
bool completed)
struct brcmf_if * ifp = netdev_priv ( ndev ) ;
if ( test_and_clear_bit ( BRCMF_VIF_STATUS_CONNECTING , & ifp -> vif -> sme_state ) )
if ( completed )
brcmf_update_bss_info ( cfg , ifp );
static s32 brcmf_update_bss_info(struct brcmf_cfg80211_info
struct brcmf_if *ifp)
struct brcmf_bss_info_le * bi ;
if ( brcmf_is_ibssmode ( ifp -> vif ) )
* ( __le32 * ) cfg -> extra_buf = cpu_to_le32 ( WL_EXTRA_BUF_MAX );
err = brcmf_fil_cmd_data_get ( ifp , BRCMF_C_GET_BSS_INFO , cfg -> extra_buf , WL_EXTRA_BUF_MAX );
if ( err )
bi = ( struct brcmf_bss_info_le * ) ( cfg -> extra_buf + 4 );
err = brcmf_inform_single_bss ( cfg , bi );
static s32 brcmf_inform_single_bss(struct brcmf_cfg80211_info
struct brcmf_bss_info_le *bi)
struct brcmu_chan ch ;
u8 * notify_ie ;
if ( le32_to_cpu ( bi -> length ) > WL_BSS_INFO_MAX )
if ( ! bi -> ctl_ch )
ch . chspec = le16_to_cpu ( bi -> chanspec );
bi -> ctl_ch = ch . chnum;
notify_ie = ( u8 * ) bi + le16_to_cpu ( bi -> ie_offset );
bss = cfg80211_inform_bss ( wiphy , notify_channel , CFG80211_BSS_FTYPE_UNKNOWN , ( const u8 * ) bi -> BSSID , 0 , notify_capability , notify_interval , notify_ie , notify_ielen , notify_signal , GFP_KERNEL );
if ( ! bss )
cfg80211_put_bss ( wiphy , bss );
0
------------------------------
300593 151268/gimpdisplay.c x2 = ( x + w > image_width ? image_width : ( ( x + w < 0 ? 0 : x + w ) ) ) 1275
static void gimp_display_flush_whenever(GimpDisplay *display,gboolean now)
GimpDisplayPrivate * private = ( GimpDisplayPrivate * ) ( g_type_instance_get_private ( ( ( GTypeInstance * ) display ) , gimp_display_get_type ( ) ) ) ;
GType gimp_display_get_type()
static volatile gsize g_define_type_id__volatile = 0 ;
GType g_define_type_id = g_type_register_static_simple ( gimp_object_get_type ( ) , g_intern_static_string ( "GimpDisplay" ) , ( sizeof ( GimpDisplayClass ) ) , ( ( GClassInitFunc ) gimp_display_class_intern_init ) , ( sizeof ( GimpDisplay ) ) , ( ( GInstanceInitFunc ) gimp_display_init ) , ( 0 ) ) ;
( void ) ( 0 ? ( * ( & g_define_type_id__volatile ) = g_define_type_id ) : 0 );
( void ) ( 0 ? ( * ( & g_define_type_id__volatile ) = ( ( gsize ) g_define_type_id ) ) : 0 );
return g_define_type_id__volatile ;
if ( private -> update_areas )
GSList * list ;
for (list = private -> update_areas; list; list = (list?((GSList *)list) -> next : ((void *)0)))
GimpArea * area = ( list -> data ) ;
if ( area -> x1 != area -> x2 && area -> y1 != area -> y2 )
gimp_display_paint_area ( display , area -> x1 , area -> y1 , area -> x2 - area -> x1 , area -> y2 - area -> y1 );
static void gimp_display_paint_area(GimpDisplay *display,gint x,gint y,gint w,gint h)
GimpDisplayPrivate * private = ( GimpDisplayPrivate * ) ( g_type_instance_get_private ( ( ( GTypeInstance * ) display ) , gimp_display_get_type ( ) ) ) ;
GType gimp_display_get_type()
static volatile gsize g_define_type_id__volatile = 0 ;
GType g_define_type_id = g_type_register_static_simple ( gimp_object_get_type ( ) , g_intern_static_string ( "GimpDisplay" ) , ( sizeof ( GimpDisplayClass ) ) , ( ( GClassInitFunc ) gimp_display_class_intern_init ) , ( sizeof ( GimpDisplay ) ) , ( ( GInstanceInitFunc ) gimp_display_init ) , ( 0 ) ) ;
( void ) ( 0 ? ( * ( & g_define_type_id__volatile ) = g_define_type_id ) : 0 );
( void ) ( 0 ? ( * ( & g_define_type_id__volatile ) = ( ( gsize ) g_define_type_id ) ) : 0 );
return g_define_type_id__volatile ;
gint image_width = gimp_image_get_width ( ( private -> image ) ) ;
gint x2 ;
x2 = ( x + w > image_width ? image_width : ( ( x + w < 0 ? 0 : x + w ) ) );
w = x2 - x1;
gimp_display_shell_transform_xy_f ( shell , ( x + w ) , ( y + h ) , & x2_f , & y2_f );
gimp_display_shell_expose_area ( shell , x1 , y1 , x2 - x1 , y2 - y1 );
0
------------------------------
304631 84403/CWE190_Integer_Overflow__unsigned_int_fscanf_square_65b.c unsigned int result = data * data ; 28
void CWE190_Integer_Overflow__unsigned_int_fscanf_square_65b_badSink(unsigned int data)
unsigned int result = data * data ;
printUnsignedLine ( result );
void printUnsignedLine(unsigned unsignedNumber)
printf ( "%u\n" , unsignedNumber );
1
------------------------------
302495 80520/CWE134_Uncontrolled_Format_String__char_listen_socket_w32_vsnprintf_52a.c recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 100
void CWE134_Uncontrolled_Format_String__char_listen_socket_w32_vsnprintf_52_bad()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
CWE134_Uncontrolled_Format_String__char_listen_socket_w32_vsnprintf_52b_badSink ( data );
void CWE134_Uncontrolled_Format_String__char_listen_socket_w32_vsnprintf_52b_badSink(char * data)
CWE134_Uncontrolled_Format_String__char_listen_socket_w32_vsnprintf_52c_badSink ( data );
void CWE134_Uncontrolled_Format_String__char_listen_socket_w32_vsnprintf_52c_badSink(char * data)
badVaSink ( data , data );
static void badVaSink(char * data, ...)
va_start ( args , data );
vsnprintf ( dest , 100 - 1 , data , args );
printLine ( dest );
void printLine (const char * line)
if ( line != NULL )
printf ( "%s\n" , line );
0
------------------------------
303444 80395/CWE134_Uncontrolled_Format_String__char_listen_socket_vfprintf_02.c recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 219
static void goodB2G1()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
if ( 1 )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
goodB2G1VaSinkG ( data , data );
static void goodB2G1VaSinkG(char * data, ...)
va_start ( args , data );
0
------------------------------
304278 80490/CWE134_Uncontrolled_Format_String__char_listen_socket_w32_vsnprintf_01.c recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 110
void CWE134_Uncontrolled_Format_String__char_listen_socket_w32_vsnprintf_01_bad()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
badVaSink ( data , data );
static void badVaSink(char * data, ...)
va_start ( args , data );
vsnprintf ( dest , 100 - 1 , data , args );
printLine ( dest );
void printLine (const char * line)
if ( line != NULL )
printf ( "%s\n" , line );
1
------------------------------
20138 CVE-2017-6470/wireshark_2.0.5_CVE_2017_6470_epan_dissectors_packet-iax2.c time_t abs_secs = start_secs + longts / 1000 ; 1578
static
dissect_iax2(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree)
proto_item * iax2_item ;
proto_tree * iax2_tree ;
guint32 offset = 0 , len ;
guint16 scallno = 0 ;
guint16 stmp ;
packet_type type ;
proto_item * full_mini_base ;
iax2_item = proto_tree_add_item ( tree , proto_iax2 , tvb , offset , - 1 , ENC_NA );
iax2_tree = proto_item_add_subtree ( iax2_item , ett_iax2 );
stmp = tvb_get_ntohs ( tvb , offset );
if ( stmp == 0 )
offset += 2;
stmp = tvb_get_ntohs ( tvb , offset );
if ( stmp & 0x8000 )
type = IAX2_MINI_VIDEO_PACKET;
scallno = stmp & 0x7FFF;
offset += 2;
type = IAX2_TRUNK_PACKET;
scallno = tvb_get_ntohs ( tvb , offset );
offset += 2;
if ( scallno & 0x8000 )
type = IAX2_FULL_PACKET;
type = IAX2_MINI_VOICE_PACKET;
scallno &= 0x7FFF;
full_mini_base = proto_tree_add_uint ( iax2_tree , hf_iax2_packet_type , tvb , 0 , offset , type );
full_mini_subtree = proto_item_add_subtree ( full_mini_base , ett_iax2_full_mini_subtree );
switch ( type )
len = dissect_fullpacket ( tvb , offset , scallno , pinfo , full_mini_subtree , tree );
static
dissect_fullpacket(tvbuff_t *tvb, guint32
guint16
packet_info *pinfo, proto_tree
proto_tree *main_tree)
guint16 dcallno ;
guint32 ts ;
guint8 type ;
guint8 csub ;
iax_call_data * iax_call ;
iax_packet_data * iax_packet ;
gboolean reversed ;
dcallno = tvb_get_ntohs ( tvb , offset ) & 0x7FFF;
ts = tvb_get_ntohl ( tvb , offset + 2 );
type = tvb_get_guint8 ( tvb , offset + 8 );
csub = tvb_get_guint8 ( tvb , offset + 9 );
iax_packet = ( iax_packet_data * ) p_get_proto_data ( wmem_file_scope ( ) , pinfo , proto_iax2 , 0 );
if ( ! iax_packet )
if ( type == AST_FRAME_IAX && csub == IAX_COMMAND_NEW )
iax_call = iax_new_call ( pinfo , scallno );
static iax_call_data *iax_new_call( packet_info
guint32 scallno)
iax_call_data * call ;
call = wmem_new ( wmem_file_scope ( ) , iax_call_data );
call -> dataformat = AST_DATAFORMAT_NULL;
call -> src_codec = 0;
call -> dst_codec = 0;
call -> n_forward_circuit_ids = 0;
call -> n_reverse_circuit_ids = 0;
call -> subdissector = NULL;
call -> start_time = pinfo -> fd -> abs_ts;
return call ;
reversed = FALSE;
iax_call = iax_lookup_call ( pinfo , scallno , dcallno , & reversed );
static iax_call_data *iax_lookup_call( packet_info
guint32
guint32
gboolean *reversed_p)
iax_call_data * iax_call = NULL ;
guint src_circuit_id ;
src_circuit_id = iax_circuit_lookup ( & pinfo -> src , pinfo -> ptype , pinfo -> srcport , scallno );
if ( dcallno != 0 )
guint dst_circuit_id ;
dst_circuit_id = iax_circuit_lookup ( & pinfo -> dst , pinfo -> ptype , pinfo -> destport , dcallno );
iax_call = iax_lookup_call_from_dest ( pinfo , NULL , src_circuit_id , dst_circuit_id , pinfo -> fd -> num , & reversed );
circuit_t * src_circuit ;
src_circuit = find_circuit ( CT_IAX2 , src_circuit_id , pinfo -> fd -> num );
if ( src_circuit )
iax_call = ( iax_call_data * ) circuit_get_proto_data ( src_circuit , proto_iax2 );
return iax_call ;
iax_packet = iax_new_packet_data ( iax_call , reversed );
static iax_packet_data *iax_new_packet_data(iax_call_data *call, gboolean reversed)
iax_packet_data * p = wmem_new ( wmem_file_scope ( ) , iax_packet_data ) ;
p -> first_time = TRUE;
p -> call_data = call;
p -> codec = 0;
p -> reversed = reversed;
p -> abstime . secs = - 1;
p -> abstime . nsecs = - 1;
return p ;
if ( iax2_tree )
iax2_add_ts_fields ( pinfo , iax2_tree , iax_packet , ( guint16 ) ts );
static void iax2_add_ts_fields(packet_info *pinfo, proto_tree *iax2_tree, iax_packet_data *iax_packet, guint16 shortts)
guint32 longts = shortts ;
if ( iax_packet -> call_data == NULL )
if ( iax_packet -> abstime . secs == - 1 )
time_t start_secs = iax_packet -> call_data -> start_time . secs ;
time_t abs_secs = start_secs + longts / 1000 ;
while ( abs_secs < pinfo -> fd -> abs_ts . secs - 16 )
iax_packet -> abstime . secs = abs_secs;
iax_packet -> abstime . nsecs = iax_packet -> call_data -> start_time . nsecs + ( longts % 1000 ) * 1000000;
if ( iax_packet -> abstime . nsecs >= 1000000000 )
iax_packet -> abstime . nsecs -= 1000000000;
iax_packet -> abstime . secs ++;
item = proto_tree_add_time ( iax2_tree , hf_iax2_absts , NULL , 0 , 0 , & iax_packet -> abstime );
PROTO_ITEM_SET_GENERATED ( item );
nstime_delta ( & ts , & ts , & iax_packet -> abstime );
PROTO_ITEM_SET_GENERATED ( item );
0
------------------------------
308647 117215/CWE789_Uncontrolled_Mem_Alloc__malloc_char_rand_68b.c myString = ( char * ) malloc ( data * sizeof ( char ) ) 94
void CWE789_Uncontrolled_Mem_Alloc__malloc_char_rand_68b_goodB2GSink()
size_t data = CWE789_Uncontrolled_Mem_Alloc__malloc_char_rand_68_goodB2GData ;
char * myString ;
if ( data > strlen ( HELLO_STRING ) && data < 100 )
myString = ( char * ) malloc ( data * sizeof ( char ) );
strcpy ( myString , HELLO_STRING );
printLine ( myString );
void printLine (const char * line)
if ( line != NULL )
printf ( "%s\n" , line );
free ( myString );
0
------------------------------
310435 151636/conf_mod.c filepath = ( char * ) malloc ( size_filepath * sizeof ( char ) ) 139
void stonesoup_setup_printf_context()
ss_tc_root = getenv ( "SS_TC_ROOT" );
if ( ss_tc_root != NULL )
size_dirpath = strlen ( ss_tc_root ) + strlen ( "testData" ) + 2;
dirpath = ( char * ) malloc ( size_dirpath * sizeof ( char ) );
if ( dirpath != NULL )
sprintf ( dirpath , "%s/%s" , ss_tc_root , "testData" );
retval = 0;
if ( stat ( dirpath , & st ) == - 1 )
retval = mkdir ( dirpath , 0700 );
if ( retval == 0 )
size_filepath = strlen ( dirpath ) + strlen ( "logfile.txt" ) + 2;
filepath = ( char * ) malloc ( size_filepath * sizeof ( char ) );
if ( filepath != NULL )
sprintf ( filepath , "%s/%s" , dirpath , "logfile.txt" );
stonesoup_printf_context = fopen ( filepath , "w" );
free ( filepath );
if ( stonesoup_printf_context == NULL )
0
------------------------------
17443 CVE-2009-0935/CVE_2009_0935_VULN_inotify_read.c ret = buf - start 44
static ssize_t CVE_2009_0935_VULN_inotify_read(struct file *file, char __user
size_t count, loff_t *pos)
size_t event_size = sizeof ( struct inotify_event ) ;
struct inotify_device * dev ;
char __user * start ;
int ret ;
start = buf;
dev = file -> private_data;
while ( 1 )
if ( ! list_empty ( & dev -> events ) )
ret = 0;
if ( file -> f_flags & O_NONBLOCK )
ret = - EAGAIN;
if ( signal_pending ( current ) )
ret = - EINTR;
if ( ret )
while ( 1 )
struct inotify_kernel_event * kevent ;
ret = buf - start;
if ( list_empty ( & dev -> events ) )
kevent = inotify_dev_get_event ( dev );
if ( event_size + kevent -> event . len > count )
if ( copy_to_user ( buf , & kevent -> event , event_size ) )
buf += event_size;
count -= event_size;
if ( kevent -> name )
if ( copy_to_user ( buf , kevent -> name , kevent -> event . len ) )
buf += kevent -> event . len;
count -= kevent -> event . len;
0
------------------------------
299446 151068/file_wrappers.c have = ( ( unsigned int ) ( strm -> next_out - state -> next ) ) 1594
int gzwfile_flush(GZWFILE_T state)
if ( state -> err != 0 )
gz_comp ( state , 2 );
static int gz_comp(GZWFILE_T state,int flush)
int ret ;
int got ;
unsigned int have ;
z_streamp strm = & state -> strm ;
if ( state -> size == 0 && gz_init ( state ) == - 1 )
ret = 0;
if ( strm -> avail_out == 0 || flush != 0 && ( flush != 4 || ret == 1 ) )
have = ( ( unsigned int ) ( strm -> next_out - state -> next ) );
if ( have )
got = ( write ( state -> fd , ( state -> next ) , have ) );
if ( got < 0 )
if ( ( ( unsigned int ) got ) != have )
if ( strm -> avail_out == 0 )
strm -> avail_out = state -> size;
strm -> next_out = state -> out;
state -> next = strm -> next_out;
have = strm -> avail_out;
ret = deflate ( strm , flush );
if ( ret == - 2 )
have -= strm -> avail_out;
while ( have )
0
------------------------------
304784 83539/CWE190_Integer_Overflow__int_listen_socket_square_65b.c int result = data * data ; 50
void CWE190_Integer_Overflow__int_listen_socket_square_65b_badSink(int data)
int result = data * data ;
printIntLine ( result );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
1
------------------------------
313179 90594/CWE23_Relative_Path_Traversal__char_listen_socket_ifstream_07.cpp recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ) 111
void bad()
char * data ;
char dataBuffer [ FILENAME_MAX ] = BASEPATH ;
data = dataBuffer;
if ( staticFive == 5 )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
inputFile . open ( ( char * ) data );
1
------------------------------
298210 95481/CWE369_Divide_by_Zero__int_zero_divide_67b.c printIntLine ( 100 / data ) 43
static void goodG2B()
int data ;
CWE369_Divide_by_Zero__int_zero_divide_67_structType myStruct ;
data = - 1;
data = 7;
myStruct . structFirst = data;
CWE369_Divide_by_Zero__int_zero_divide_67b_goodG2BSink ( myStruct );
void CWE369_Divide_by_Zero__int_zero_divide_67b_goodG2BSink(CWE369_Divide_by_Zero__int_zero_divide_67_structType myStruct)
int data = myStruct . structFirst ;
printIntLine ( 100 / data );
0
------------------------------
313704 90895/CWE23_Relative_Path_Traversal__wchar_t_connect_socket_ofstream_22b.cpp recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ) 96
void bad()
wchar_t * data ;
wchar_t dataBuffer [ FILENAME_MAX ] = BASEPATH ;
data = dataBuffer;
data = badSource ( data );
wchar_t * badSource(wchar_t * data)
if ( badGlobal )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( FILENAME_MAX - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
298906 95271/CWE369_Divide_by_Zero__int_listen_socket_divide_32.c printIntLine ( 100 / data ) 127
void CWE369_Divide_by_Zero__int_listen_socket_divide_32_bad()
int data ;
int * dataPtr2 = & data ;
data = - 1;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
char inputBuffer [ CHAR_ARRAY_SIZE ] ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
inputBuffer [ recvResult ] = '\0';
data = atoi ( inputBuffer );
while ( 0 )
int data = * dataPtr2 ;
printIntLine ( 100 / data );
1
------------------------------
306178 117440/CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_rand_42.c myString = ( wchar_t * ) malloc ( data * sizeof ( wchar_t ) ) 48
void CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_rand_42_bad()
size_t data ;
data = 0;
data = badSource ( data );
static size_t badSource(size_t data)
data = rand ( );
return data ;
wchar_t * myString ;
if ( data > wcslen ( HELLO_STRING ) )
myString = ( wchar_t * ) malloc ( data * sizeof ( wchar_t ) );
wcscpy ( myString , HELLO_STRING );
printWLine ( myString );
void printWLine (const wchar_t * line)
if ( line != NULL )
wprintf ( L "%ls\n" , line )
free ( myString );
1
------------------------------
298447 95374/CWE369_Divide_by_Zero__int_rand_divide_45.c printIntLine ( 100 / data ) 30
static void badSink()
int data = CWE369_Divide_by_Zero__int_rand_divide_45_badData ;
printIntLine ( 100 / data );
1
------------------------------
308359 117086/CWE789_Uncontrolled_Mem_Alloc__malloc_char_fscanf_08.c myString = ( char * ) malloc ( data * sizeof ( char ) ) 176
static void goodG2B1()
size_t data ;
data = 0;
if ( staticReturnsFalse ( ) )
static int staticReturnsFalse()
return 0 ;
data = 20;
if ( staticReturnsTrue ( ) )
static int staticReturnsTrue()
return 1 ;
char * myString ;
if ( data > strlen ( HELLO_STRING ) )
myString = ( char * ) malloc ( data * sizeof ( char ) );
strcpy ( myString , HELLO_STRING );
printLine ( myString );
void printLine (const char * line)
if ( line != NULL )
printf ( "%s\n" , line );
free ( myString );
0
------------------------------
308944 117004/CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_32.c myString = ( char * ) malloc ( data * sizeof ( char ) ) 258
static void goodB2G()
size_t data ;
size_t * dataPtr2 = & data ;
data = 0;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
char inputBuffer [ CHAR_ARRAY_SIZE ] ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
inputBuffer [ recvResult ] = '\0';
data = strtoul ( inputBuffer , NULL , 0 );
while ( 0 )
size_t data = * dataPtr2 ;
char * myString ;
if ( data > strlen ( HELLO_STRING ) && data < 100 )
myString = ( char * ) malloc ( data * sizeof ( char ) );
strcpy ( myString , HELLO_STRING );
printLine ( myString );
void printLine (const char * line)
if ( line != NULL )
printf ( "%s\n" , line );
free ( myString );
0
------------------------------
20894 CVE-2016-7425/linux_kernel_4.8.2_CVE_2016_7425_drivers_scsi_arcmsr_arcmsr_hba.c buf_empty_len = ( acb -> rqbuf_putIndex - acb -> rqbuf_getIndex - 1 ) & ( ARCMSR_MAX_QBUFFER - 1 ) 1834
static void arcmsr_remove(struct pci_dev *pdev)
struct Scsi_Host * host = pci_get_drvdata ( pdev ) ;
struct AdapterControlBlock * acb = ( struct AdapterControlBlock * ) host -> hostdata ;
acb -> acb_flags |= ACB_F_SCSISTOPADAPTER;
acb -> acb_flags &= ~ACB_F_IOP_INITED;
for (poll_count = 0; poll_count < ARCMSR_MAX_OUTSTANDING_CMD; poll_count++)
if ( ! atomic_read ( & acb -> ccboutstandingcount ) )
arcmsr_interrupt ( acb );
static irqreturn_t arcmsr_interrupt(struct AdapterControlBlock *acb)
switch ( acb -> adapter_type )
return arcmsr_hbaB_handle_isr ( acb ) ;
static int arcmsr_hbaB_handle_isr(struct AdapterControlBlock *acb)
uint32_t outbound_doorbell ;
struct MessageUnit_B * reg = acb -> pmuB ;
outbound_doorbell = readl ( reg -> iop2drv_doorbell ) & acb -> outbound_int_enable;
if ( ! outbound_doorbell )
if ( outbound_doorbell & ARCMSR_IOP2DRV_DATA_WRITE_OK )
arcmsr_iop2drv_data_wrote_handle ( acb );
outbound_doorbell = readl ( reg -> iop2drv_doorbell ) & acb -> outbound_int_enable;
while ( outbound_doorbell & ( ARCMSR_IOP2DRV_DATA_WRITE_OK | ARCMSR_IOP2DRV_DATA_READ_OK | ARCMSR_IOP2DRV_CDB_DONE | ARCMSR_IOP2DRV_MESSAGE_CMD_DONE ) )
static void arcmsr_iop2drv_data_wrote_handle(struct AdapterControlBlock *acb)
int32_t buf_empty_len ;
buf_empty_len = ( acb -> rqbuf_putIndex - acb -> rqbuf_getIndex - 1 ) & ( ARCMSR_MAX_QBUFFER - 1 );
if ( buf_empty_len >= readl ( & prbuffer -> data_len ) )
0
------------------------------
298868 103312/CWE427_Uncontrolled_Search_Path_Element__wchar_t_listen_socket_41.c recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 250 - dataLen - 1 ) , 0 ) 106
void CWE427_Uncontrolled_Search_Path_Element__wchar_t_listen_socket_41_bad()
wchar_t * data ;
wchar_t dataBuffer [ 250 ] = L "PATH="
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 250 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
20631 CVE-2016-8910/qemu_2.3.0_CVE-2016-8910_rtl8139.c ret = s -> mult [ addr - MAR0 ] 2974
static uint64_t rtl8139_ioport_read(void *opaque, hwaddr
unsigned size)
switch ( size )
return rtl8139_io_readw ( opaque , addr ) ;
static uint32_t rtl8139_io_readw(void *opaque, uint8_t addr)
uint32_t ret ;
switch ( addr )
ret = rtl8139_io_readb ( opaque , addr );
static uint32_t rtl8139_io_readb(void *opaque, uint8_t addr)
RTL8139State * s = opaque ;
int ret ;
switch ( addr )
ret = s -> mult [ addr - MAR0 ];
DPRINTF ( "MediaStatus read 0x%x\n" , ret );
DPRINTF ( "HltClk read 0x%x\n" , ret );
DPRINTF ( "PCI Revision ID read 0x%x\n" , ret );
DPRINTF ( "C+ TxThresh read(b) val=0x%02x\n" , ret );
DPRINTF ( "RTL8139C TxConfig at 0x43 read(b) val=0x%02x\n" , ret );
return ret ;
0
------------------------------
305487 61986/CWE114_Process_Control__w32_char_connect_socket_83_bad.cpp recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 84
CWE114_Process_Control__w32_char_connect_socket_83_bad::CWE114_Process_Control__w32_char_connect_socket_83_bad(char * dataCopy)
data = dataCopy;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
0
------------------------------
306310 110314/CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_connect_socket_03.c intPointer = ( int * ) malloc ( data * sizeof ( int ) ) 112
void CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_connect_socket_03_bad()
int data ;
data = - 1;
if ( 5 == 5 )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
char inputBuffer [ CHAR_ARRAY_SIZE ] ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
inputBuffer [ recvResult ] = '\0';
data = atoi ( inputBuffer );
while ( 0 )
int * intPointer ;
intPointer = ( int * ) malloc ( data * sizeof ( int ) );
intPointer [ i ] = 0;
printIntLine ( intPointer [ 0 ] );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
free ( intPointer );
1
------------------------------
312089 153760/aviobuf.c s -> buf_end = dst + len 516
int64_t avio_skip(AVIOContext *s,int64_t offset)
return avio_seek ( s , offset , 1 ) ;
int64_t avio_seek(AVIOContext *s,int64_t offset,int whence)
int64_t offset1 ;
int64_t pos ;
int force = whence & 0x20000 ;
whence &= ~0x20000;
if ( ! s )
pos = s -> pos - ( ( s -> write_flag ? 0 : s -> buf_end - s -> buffer ) );
if ( whence != 1 && whence != 0 )
if ( whence == 1 )
offset1 = pos + ( s -> buf_ptr - s -> buffer );
if ( offset == 0 )
offset += offset1;
offset1 = offset - pos;
if ( ! s -> must_flush && ( ! s -> direct || ! s -> seek ) && offset1 >= 0 && offset1 <= s -> buf_end - s -> buffer )
if ( ( ! s -> seekable || offset1 <= s -> buf_end + 4096 - s -> buffer ) && ! s -> write_flag && offset1 >= 0 && ( ! s -> direct || ! s -> seek ) && ( whence != 2 || force ) )
while ( s -> pos < offset && ! s -> eof_reached )
fill_buffer ( s );
static void fill_buffer(AVIOContext *s)
uint8_t * dst = ! s -> max_packet_size && s -> buf_end - s -> buffer < ( s -> buffer_size ) ? s -> buf_end : s -> buffer ;
int len = ( ( s -> buffer_size ) - ( dst - s -> buffer ) ) ;
int max_buffer_size = s -> max_packet_size ? s -> max_packet_size : 32768 ;
if ( ! s -> read_packet && s -> buf_ptr >= s -> buf_end )
s -> eof_reached = 1;
if ( s -> eof_reached )
if ( s -> update_checksum && dst == s -> buffer )
if ( s -> buf_end > s -> checksum_ptr )
s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_end - s -> checksum_ptr ) ) );
s -> checksum_ptr = s -> buffer;
if ( s -> read_packet && s -> buffer_size > max_buffer_size )
s -> checksum_ptr = dst = s -> buffer;
len = s -> buffer_size;
if ( s -> read_packet )
len = ( ( s -> read_packet ) ( s -> opaque , dst , len ) );
len = 0;
if ( len <= 0 )
s -> eof_reached = 1;
if ( len < 0 )
s -> error = len;
s -> pos += len;
s -> buf_ptr = dst;
s -> buf_end = dst + len;
s -> bytes_read += len;
0
------------------------------
302449 80521/CWE134_Uncontrolled_Format_String__char_listen_socket_w32_vsnprintf_53a.c recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 100
void CWE134_Uncontrolled_Format_String__char_listen_socket_w32_vsnprintf_53_bad()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
CWE134_Uncontrolled_Format_String__char_listen_socket_w32_vsnprintf_53b_badSink ( data );
void CWE134_Uncontrolled_Format_String__char_listen_socket_w32_vsnprintf_53b_badSink(char * data)
CWE134_Uncontrolled_Format_String__char_listen_socket_w32_vsnprintf_53c_badSink ( data );
void CWE134_Uncontrolled_Format_String__char_listen_socket_w32_vsnprintf_53c_badSink(char * data)
CWE134_Uncontrolled_Format_String__char_listen_socket_w32_vsnprintf_53d_badSink ( data );
void CWE134_Uncontrolled_Format_String__char_listen_socket_w32_vsnprintf_53d_badSink(char * data)
badVaSink ( data , data );
static void badVaSink(char * data, ...)
va_start ( args , data );
vsnprintf ( dest , 100 - 1 , data , args );
printLine ( dest );
void printLine (const char * line)
if ( line != NULL )
printf ( "%s\n" , line );
0
------------------------------
299188 150042/dfa.c buf_end = ( ( unsigned char * ) ( begin + i ) ) 3607
char *dfaexec(struct dfa *d,const char *begin,char *end,int allow_nl,size_t *count,int *backref)
const unsigned char * p ;
unsigned char eol = eolbyte ;
p = ( ( const unsigned char * ) begin );
* end = eol;
if ( d -> mb_cur_max > 1 )
prepare_wc_buf ( ( ( const char * ) p ) , end );
static void prepare_wc_buf(const char *begin,const char *end)
unsigned char eol = eolbyte ;
size_t remain_bytes ;
size_t i ;
remain_bytes = 0;
for (i = 0; i < (end - begin + 1); i++)
if ( remain_bytes == 0 )
remain_bytes = mbrtowc ( inputwcs + i , begin + i , ( end - begin ) - i + 1 , & mbs );
if ( remain_bytes < 1 || remain_bytes == ( ( size_t ) ( - 1 ) ) || remain_bytes == ( ( size_t ) ( - 2 ) ) || remain_bytes == 1 && inputwcs [ i ] == ( ( wchar_t ) begin [ i ] ) )
remain_bytes = 0;
inputwcs [ i ] = ( ( wchar_t ) begin [ i ] );
mblen_buf [ i ] = 0;
if ( begin [ i ] == eol )
mblen_buf [ i ] = remain_bytes;
remain_bytes --;
mblen_buf [ i ] = remain_bytes;
inputwcs [ i ] = 0;
remain_bytes --;
buf_end = ( ( unsigned char * ) ( begin + i ) );
0
------------------------------
314055 110715/CWE680_Integer_Overflow_to_Buffer_Overflow__new_fixed_22a.cpp dataBytes = data * sizeof ( int ) 76
static void goodG2B1()
int data ;
data = - 1;
data = goodG2B1Source ( data );
int goodG2B1Source(int data)
if ( goodG2B1Global )
data = 20;
return data ;
size_t dataBytes , i ;
dataBytes = data * sizeof ( int );
intPointer = ( int * ) new char [ dataBytes ];
intPointer [ i ] = 0;
printIntLine ( intPointer [ 0 ] );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
delete [ ] intPointer
0
------------------------------
19844 CVE-2016-2522/Wireshark_2.0.1_CVE_2016_2522_epan_dissectors_packet-ber.c end_offset = offset + len 3012
static
dissect_ber_syntax(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree)
( void ) dissect_unknown_ber ( pinfo , tvb , 0 , tree );

dissect_unknown_ber(packet_info *pinfo, tvbuff_t *tvb, int offset, proto_tree *tree)
return try_dissect_unknown_ber ( pinfo , tvb , offset , tree , 1 ) ;
static
try_dissect_unknown_ber(packet_info *pinfo, tvbuff_t *tvb, volatile int offset, proto_tree *tree, gint nest_level)
int start_offset ;
gint8 ber_class ;
gboolean pc , ind ;
gint32 tag ;
guint32 len ;
start_offset = offset;
offset = get_ber_identifier ( tvb , offset , & ber_class , & pc , & tag );
offset = get_ber_length ( tvb , offset , & len , & ind );
if ( len > ( guint32 ) tvb_reported_length_remaining ( tvb , offset ) )
switch ( pc )
switch ( ber_class )
switch ( tag )
offset = dissect_ber_GeneralString ( & asn1_ctx , tree , tvb , start_offset , hf_ber_unknown_GeneralString , NULL , 0 );

dissect_ber_GeneralString(asn1_ctx_t *actx, proto_tree *tree, tvbuff_t *tvb, int offset, gint hf_id, char *name_string, int name_len)
guint32 len ;
int end_offset ;
offset = dissect_ber_identifier ( actx -> pinfo , tree , tvb , offset , & ber_class , & pc , & tag );
offset = dissect_ber_length ( actx -> pinfo , tree , tvb , offset , & len , NULL );
end_offset = offset + len;
return end_offset ;
return end_offset ;
1
------------------------------
312785 117969/CWE78_OS_Command_Injection__char_connect_socket_execl_43.cpp recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 106
void bad()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
badSource ( data );
static void badSource(char * &data)
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
0
------------------------------
21042 CVE-2015-5283/linux_kernel_4.2.2_CVE_2015_5283_net_sctp_protocol.c net -> sctp . max_autoclose = INT_MAX / HZ 1244
static int __net_init sctp_net_init(struct net *net)
net -> sctp . rto_initial = SCTP_RTO_INITIAL;
net -> sctp . rto_min = SCTP_RTO_MIN;
net -> sctp . rto_max = SCTP_RTO_MAX;
net -> sctp . rto_alpha = SCTP_RTO_ALPHA;
net -> sctp . rto_beta = SCTP_RTO_BETA;
net -> sctp . valid_cookie_life = SCTP_DEFAULT_COOKIE_LIFE;
net -> sctp . cookie_preserve_enable = 1;
net -> sctp . sctp_hmac_alg = "md5";
net -> sctp . max_burst = SCTP_DEFAULT_MAX_BURST;
net -> sctp . max_retrans_association = 10;
net -> sctp . max_retrans_path = 5;
net -> sctp . max_retrans_init = 8;
net -> sctp . sndbuf_policy = 0;
net -> sctp . rcvbuf_policy = 0;
net -> sctp . hb_interval = SCTP_DEFAULT_TIMEOUT_HEARTBEAT;
net -> sctp . sack_timeout = SCTP_DEFAULT_TIMEOUT_SACK;
net -> sctp . addip_enable = 0;
net -> sctp . addip_noauth = 0;
net -> sctp . default_auto_asconf = 0;
net -> sctp . prsctp_enable = 1;
net -> sctp . auth_enable = 0;
net -> sctp . scope_policy = SCTP_SCOPE_POLICY_ENABLE;
net -> sctp . rwnd_upd_shift = SCTP_DEFAULT_RWND_SHIFT;
net -> sctp . max_autoclose = INT_MAX / HZ;
status = sctp_sysctl_net_register ( net );
if ( status )
status = init_sctp_mibs ( net );
static inline int init_sctp_mibs(struct net *net)
net -> sctp . sctp_statistics = alloc_percpu ( struct sctp_mib )
if ( ! net -> sctp . sctp_statistics )
if ( status )
status = sctp_proc_init ( net );
static int __net_init sctp_proc_init(struct net *net)
net -> sctp . proc_net_sctp = proc_net_mkdir ( net , "sctp" , net -> proc_net );
if ( ! net -> sctp . proc_net_sctp )
if ( sctp_snmp_proc_init ( net ) )
if ( sctp_eps_proc_init ( net ) )
if ( sctp_assocs_proc_init ( net ) )
if ( sctp_remaddr_proc_init ( net ) )
sctp_assocs_proc_exit ( net );
sctp_eps_proc_exit ( net );
sctp_snmp_proc_exit ( net );
remove_proc_entry ( "sctp" , net -> proc_net );
net -> sctp . proc_net_sctp = NULL;
if ( status )
sctp_dbg_objcnt_init ( net );
if ( status = sctp_ctl_sock_init ( net ) )
static int sctp_ctl_sock_init(struct net *net)
err = inet_ctl_sock_create ( & net -> sctp . ctl_sock , family , SOCK_SEQPACKET , IPPROTO_SCTP , net );
if ( err < 0 && family == PF_INET6 )
err = inet_ctl_sock_create ( & net -> sctp . ctl_sock , AF_INET , SOCK_SEQPACKET , IPPROTO_SCTP , net );
if ( err < 0 )
return err ;
INIT_LIST_HEAD ( & net -> sctp . local_addr_list );
spin_lock_init ( & net -> sctp . local_addr_lock );
sctp_get_local_addr_list ( net );
static void sctp_get_local_addr_list(struct net *net)
for_each_netdev_rcu ( net , dev
list_for_each ( pos , & sctp_address_families
af = list_entry ( pos , struct sctp_af , list )
af -> copy_addrlist ( & net -> sctp . local_addr_list , dev );
INIT_LIST_HEAD ( & net -> sctp . addr_waitq );
INIT_LIST_HEAD ( & net -> sctp . auto_asconf_splist );
spin_lock_init ( & net -> sctp . addr_wq_lock );
net -> sctp . addr_wq_timer . expires = 0;
setup_timer ( & net -> sctp . addr_wq_timer , sctp_addr_wq_timeout_handler , ( unsigned long ) net );
return status ;
0
------------------------------
305090 94111/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_connect_socket_14.c recvResult = recv ( connectSocket , ( char * ) ( password + passwordLen ) , ( 100 - passwordLen - 1 ) * sizeof ( char ) , 0 ) 72
void CWE319_Cleartext_Tx_Sensitive_Info__w32_char_connect_socket_14_bad()
char * password ;
char passwordBuffer [ 100 ] = "" ;
password = passwordBuffer;
if ( globalFive == 5 )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t passwordLen = strlen ( password ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( password + passwordLen ) , ( 100 - passwordLen - 1 ) * sizeof ( char ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
password [ passwordLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( password , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( password , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
if ( LogonUserA ( username , domain , password , LOGON32_LOGON_NETWORK , LOGON32_PROVIDER_DEFAULT , & pHandle ) != 0 )
1
------------------------------
20905 CVE-2016-7421/qemu_2.3.0_CVE-2016-7421_vmw_pvscsi.c uint32_t next_ready_page = next_ready_ptr / PVSCSI_MAX_NUM_REQ_ENTRIES_PER_PAGE ; 221
static
pvscsi_io_write(void *opaque, hwaddr
uint64_t val, unsigned size)
PVSCSIState * s = opaque ;
switch ( addr )
s -> reg_interrupt_status &= ~val;
s -> reg_interrupt_enabled = val;
pvscsi_process_io ( s );
static
pvscsi_process_io(PVSCSIState *s)
hwaddr next_descr_pa ;
while ( ( next_descr_pa = pvscsi_ring_pop_req_descr ( & s -> rings ) ) != 0 )
static
pvscsi_ring_pop_req_descr(PVSCSIRingInfo *mgr)
uint32_t ready_ptr = RS_GET_FIELD ( mgr , reqProdIdx ) ;
if ( ready_ptr != mgr -> consumed_ptr )
uint32_t next_ready_ptr = mgr -> consumed_ptr ++ & mgr -> txr_len_mask ;
uint32_t next_ready_page = next_ready_ptr / PVSCSI_MAX_NUM_REQ_ENTRIES_PER_PAGE ;
return mgr -> req_ring_pages_pa [ next_ready_page ] + inpage_idx * sizeof ( PVSCSIRingReqDesc ) ;
0
------------------------------
19215 CVE-2016-3062/Ffmpeg_0.11_CVE_2016_3062_libavformat_mov.c st -> duration = sc -> track_end = dts + sc -> time_offset 2468
static int mov_read_trun(MOVContext *c, AVIOContext *pb, MOVAtom atom)
MOVFragment * frag = & c -> fragment ;
AVStream * st = NULL ;
MOVStreamContext * sc ;
MOVStts * ctts_data ;
int64_t dts ;
for (i = 0; i < c->fc->nb_streams; i++)
if ( c -> fc -> streams [ i ] -> id == frag -> track_id )
st = c -> fc -> streams [ i ];
if ( ! st )
sc = st -> priv_data;
if ( sc -> pseudo_stream_id + 1 != frag -> stsd_id )
flags = avio_rb24 ( pb );
entries = avio_rb32 ( pb );
if ( ! sc -> ctts_count && sc -> sample_count )
ctts_data = av_malloc ( sizeof ( * sc -> ctts_data ) );
if ( ! ctts_data )
sc -> ctts_data = ctts_data;
sc -> ctts_data [ sc -> ctts_count ] . count = sc -> sample_count;
sc -> ctts_data [ sc -> ctts_count ] . duration = 0;
sc -> ctts_count ++;
if ( ( uint64_t ) entries + sc -> ctts_count >= UINT_MAX / sizeof ( * sc -> ctts_data ) )
ctts_data = av_realloc ( sc -> ctts_data , ( entries + sc -> ctts_count ) * sizeof ( * sc -> ctts_data ) );
if ( ! ctts_data )
sc -> ctts_data = ctts_data;
dts = sc -> track_end - sc -> time_offset;
for (i = 0; i < entries; i++)
unsigned sample_size = frag -> size ;
unsigned sample_duration = frag -> duration ;
if ( flags & MOV_TRUN_SAMPLE_DURATION )
sample_duration = avio_rb32 ( pb );
if ( flags & MOV_TRUN_SAMPLE_SIZE )
sample_size = avio_rb32 ( pb );
sc -> ctts_data [ sc -> ctts_count ] . count = 1;
sc -> ctts_data [ sc -> ctts_count ] . duration = ( flags & MOV_TRUN_SAMPLE_CTS ) ? avio_rb32 ( pb ) : 0;
sc -> ctts_count ++;
dts += sample_duration;
sc -> data_size += sample_size;
st -> duration = sc -> track_end = dts + sc -> time_offset;
0
------------------------------
307965 118058/CWE78_OS_Command_Injection__char_connect_socket_popen_22b.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 93
void CWE78_OS_Command_Injection__char_connect_socket_popen_22_bad()
char * data ;
char data_buf [ 100 ] = FULL_COMMAND ;
data = data_buf;
data = CWE78_OS_Command_Injection__char_connect_socket_popen_22_badSource ( data );
char * CWE78_OS_Command_Injection__char_connect_socket_popen_22_badSource(char * data)
if ( CWE78_OS_Command_Injection__char_connect_socket_popen_22_badGlobal )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
return data ;
0
------------------------------
299101 152176/dynahash.c dirpath = ( char * ) malloc ( size_dirpath * sizeof ( char ) ) 244
void stonesoup_setup_printf_context()
ss_tc_root = getenv ( "SS_TC_ROOT" );
if ( ss_tc_root != NULL )
size_dirpath = strlen ( ss_tc_root ) + strlen ( "testData" ) + 2;
dirpath = ( char * ) malloc ( size_dirpath * sizeof ( char ) );
if ( dirpath != NULL )
sprintf ( dirpath , "%s/%s" , ss_tc_root , "testData" );
if ( stat ( dirpath , & st ) == - 1 )
retval = mkdir ( dirpath , 0700 );
if ( retval == 0 )
size_filepath = strlen ( dirpath ) + strlen ( "logfile.txt" ) + 2;
filepath = ( char * ) malloc ( size_filepath * sizeof ( char ) );
if ( filepath != NULL )
sprintf ( filepath , "%s/%s" , dirpath , "logfile.txt" );
stonesoup_printf_context = fopen ( filepath , "w" );
free ( filepath );
free ( dirpath );
if ( stonesoup_printf_context == NULL )
0
------------------------------
307585 110522/CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_listen_socket_21.c intPointer = ( int * ) malloc ( data * sizeof ( int ) ) 181
static void goodG2B1()
int data ;
data = - 1;
data = goodG2B1Source ( data );
static int goodG2B1Source(int data)
if ( goodG2B1Static )
data = 20;
return data ;
int * intPointer ;
intPointer = ( int * ) malloc ( data * sizeof ( int ) );
intPointer [ i ] = 0;
printIntLine ( intPointer [ 0 ] );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
free ( intPointer );
0
------------------------------
308496 110364/CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fgets_05.c intPointer = ( int * ) malloc ( data * sizeof ( int ) ) 91
static void goodG2B1()
int data ;
data = - 1;
if ( staticFalse )
data = 20;
int * intPointer ;
intPointer = ( int * ) malloc ( data * sizeof ( int ) );
intPointer [ i ] = 0;
printIntLine ( intPointer [ 0 ] );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
free ( intPointer );
0
------------------------------
298685 102659/CWE416_Use_After_Free__return_freed_ptr_14.c reversedString [ j ] = aString [ i - j - 1 ] 53
static void good2()
if ( globalFive == 5 )
char * reversedString = helperGood ( "GoodSink" ) ;
static char * helperGood(char * aString)
size_t j ;
if ( aString != NULL )
i = strlen ( aString );
reversedString = ( char * ) malloc ( i + 1 );
for (j = 0; j < i; j++)
reversedString [ j ] = aString [ i - j - 1 ];
reversedString [ i ] = '\0';
0
------------------------------
312101 153760/aviobuf.c s -> buf_end = dst + len 516
unsigned int avio_rb24(AVIOContext *s)
unsigned int val ;
val = avio_rb16 ( s ) << 8;
unsigned int avio_rb16(AVIOContext *s)
unsigned int val ;
val = ( avio_r8 ( s ) << 8 );
val |= ( avio_r8 ( s ) );
int avio_r8(AVIOContext *s)
if ( s -> buf_ptr >= s -> buf_end )
fill_buffer ( s );
static void fill_buffer(AVIOContext *s)
uint8_t * dst = ! s -> max_packet_size && s -> buf_end - s -> buffer < ( s -> buffer_size ) ? s -> buf_end : s -> buffer ;
int len = ( ( s -> buffer_size ) - ( dst - s -> buffer ) ) ;
int max_buffer_size = s -> max_packet_size ? s -> max_packet_size : 32768 ;
if ( ! s -> read_packet && s -> buf_ptr >= s -> buf_end )
s -> eof_reached = 1;
if ( s -> eof_reached )
if ( s -> update_checksum && dst == s -> buffer )
if ( s -> buf_end > s -> checksum_ptr )
s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_end - s -> checksum_ptr ) ) );
s -> checksum_ptr = s -> buffer;
if ( s -> read_packet && s -> buffer_size > max_buffer_size )
s -> checksum_ptr = dst = s -> buffer;
len = s -> buffer_size;
if ( s -> read_packet )
len = ( ( s -> read_packet ) ( s -> opaque , dst , len ) );
len = 0;
if ( len <= 0 )
s -> eof_reached = 1;
if ( len < 0 )
s -> error = len;
s -> pos += len;
s -> buf_ptr = dst;
s -> buf_end = dst + len;
s -> bytes_read += len;
0
------------------------------
308265 110369/CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fgets_10.c intPointer = ( int * ) malloc ( data * sizeof ( int ) ) 49
void CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fgets_10_bad()
int data ;
data = - 1;
if ( globalTrue )
char inputBuffer [ CHAR_ARRAY_SIZE ] = "" ;
if ( fgets ( inputBuffer , CHAR_ARRAY_SIZE , stdin ) != NULL )
data = atoi ( inputBuffer );
int * intPointer ;
intPointer = ( int * ) malloc ( data * sizeof ( int ) );
intPointer [ i ] = 0;
printIntLine ( intPointer [ 0 ] );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
free ( intPointer );
1
------------------------------
309125 117185/CWE789_Uncontrolled_Mem_Alloc__malloc_char_rand_11.c myString = ( char * ) malloc ( data * sizeof ( char ) ) 163
static void goodG2B1()
size_t data ;
data = 0;
if ( globalReturnsFalse ( ) )
int globalReturnsFalse()
return 0 ;
data = 20;
if ( globalReturnsTrue ( ) )
int globalReturnsTrue()
return 1 ;
char * myString ;
if ( data > strlen ( HELLO_STRING ) )
myString = ( char * ) malloc ( data * sizeof ( char ) );
strcpy ( myString , HELLO_STRING );
printLine ( myString );
void printLine (const char * line)
if ( line != NULL )
printf ( "%s\n" , line );
free ( myString );
0
------------------------------
307150 117224/CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_connect_socket_02.c myString = ( wchar_t * ) malloc ( data * sizeof ( wchar_t ) ) 123
void CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_connect_socket_02_bad()
size_t data ;
data = 0;
if ( 1 )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
char inputBuffer [ CHAR_ARRAY_SIZE ] ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
inputBuffer [ recvResult ] = '\0';
data = strtoul ( inputBuffer , NULL , 0 );
while ( 0 )
if ( 1 )
wchar_t * myString ;
if ( data > wcslen ( HELLO_STRING ) )
myString = ( wchar_t * ) malloc ( data * sizeof ( wchar_t ) );
wcscpy ( myString , HELLO_STRING );
printWLine ( myString );
void printWLine (const wchar_t * line)
if ( line != NULL )
wprintf ( L "%ls\n" , line )
free ( myString );
1
------------------------------
303349 84517/CWE190_Integer_Overflow__unsigned_int_max_square_08.c unsigned int result = data * data ; 80
static void goodB2G1()
unsigned int data ;
data = 0;
if ( staticReturnsTrue ( ) )
static int staticReturnsTrue()
return 1 ;
data = UINT_MAX;
if ( staticReturnsFalse ( ) )
static int staticReturnsFalse()
return 0 ;
if ( abs ( ( long ) data ) <= ( long ) sqrt ( ( double ) UINT_MAX ) )
unsigned int result = data * data ;
printUnsignedLine ( result );
void printUnsignedLine(unsigned unsignedNumber)
printf ( "%u\n" , unsignedNumber );
0
------------------------------
306248 117135/CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_09.c myString = ( char * ) malloc ( data * sizeof ( char ) ) 420
static void goodG2B2()
size_t data ;
data = 0;
if ( GLOBAL_CONST_TRUE )
data = 20;
if ( GLOBAL_CONST_TRUE )
char * myString ;
if ( data > strlen ( HELLO_STRING ) )
myString = ( char * ) malloc ( data * sizeof ( char ) );
strcpy ( myString , HELLO_STRING );
printLine ( myString );
void printLine (const char * line)
if ( line != NULL )
printf ( "%s\n" , line );
free ( myString );
0
------------------------------
313069 89760/CWE23_Relative_Path_Traversal__char_connect_socket_open_64a.cpp recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ) 104
void bad()
char * data ;
char dataBuffer [ FILENAME_MAX ] = BASEPATH ;
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
badSink ( & data );
void badSink(void * dataVoidPtr)
char * * dataPtr = ( char * * ) dataVoidPtr ;
char * data = ( * dataPtr ) ;
fileDesc = OPEN ( data , O_RDWR | O_CREAT , S_IREAD | S_IWRITE );
if ( fileDesc != - 1 )
CLOSE ( fileDesc );
0
------------------------------
305602 117258/CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_connect_socket_63b.c myString = ( wchar_t * ) malloc ( data * sizeof ( wchar_t ) ) 112
static void goodB2G()
size_t data ;
data = 0;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
char inputBuffer [ CHAR_ARRAY_SIZE ] ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
inputBuffer [ recvResult ] = '\0';
data = strtoul ( inputBuffer , NULL , 0 );
while ( 0 )
CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_connect_socket_63b_goodB2GSink ( & data );
void CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_connect_socket_63b_goodB2GSink(size_t * dataPtr)
size_t data = * dataPtr ;
wchar_t * myString ;
if ( data > wcslen ( HELLO_STRING ) && data < 100 )
myString = ( wchar_t * ) malloc ( data * sizeof ( wchar_t ) );
wcscpy ( myString , HELLO_STRING );
printWLine ( myString );
void printWLine (const wchar_t * line)
if ( line != NULL )
wprintf ( L "%ls\n" , line )
free ( myString );
0
------------------------------
298924 95471/CWE369_Divide_by_Zero__int_zero_divide_51b.c printIntLine ( 100 / data ) 36
static void goodG2B()
int data ;
data = - 1;
data = 7;
CWE369_Divide_by_Zero__int_zero_divide_51b_goodG2BSink ( data );
void CWE369_Divide_by_Zero__int_zero_divide_51b_goodG2BSink(int data)
printIntLine ( 100 / data );
0
------------------------------
299264 149794/utils.c end = side_metadata + size 1875
int avcodec_decode_audio3(AVCodecContext *avctx,int16_t *samples,int *frame_size_ptr,AVPacket *avpkt)
int ret ;
if ( avctx -> get_buffer != avcodec_default_get_buffer )
avctx -> get_buffer = avcodec_default_get_buffer;
avctx -> release_buffer = avcodec_default_release_buffer;
ret = avcodec_decode_audio4 ( avctx , & frame , & got_frame , avpkt );
int avcodec_decode_audio4(AVCodecContext *avctx,AVFrame *frame,int *got_frame_ptr,const AVPacket *avpkt)
* got_frame_ptr = 0;
if ( ! avpkt -> data && avpkt -> size )
if ( ( avctx -> codec -> type ) != AVMEDIA_TYPE_AUDIO )
if ( avctx -> codec -> capabilities & 0x20 || avpkt -> size )
avctx -> pkt = & tmp;
ret = ( ( avctx -> codec -> decode ) ( avctx , frame , got_frame_ptr , & tmp ) );
if ( ret >= 0 && * got_frame_ptr )
avctx -> frame_number ++;
frame -> pkt_dts = avpkt -> dts;
if ( frame -> format == AV_SAMPLE_FMT_NONE )
frame -> format = ( avctx -> sample_fmt );
if ( ! frame -> channel_layout )
frame -> channel_layout = avctx -> channel_layout;
if ( ! frame -> sample_rate )
frame -> sample_rate = avctx -> sample_rate;
add_metadata_from_side_data ( avctx , frame );
static int add_metadata_from_side_data(AVCodecContext *avctx,AVFrame *frame)
int size ;
const uint8_t * side_metadata ;
const uint8_t * end ;
side_metadata = ( av_packet_get_side_data ( avctx -> pkt , AV_PKT_DATA_STRINGS_METADATA , & size ) );
if ( ! side_metadata )
end = side_metadata + size;
while ( side_metadata < end )
0
------------------------------
307910 110323/CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_connect_socket_12.c intPointer = ( int * ) malloc ( data * sizeof ( int ) ) 117
void CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_connect_socket_12_bad()
int data ;
data = - 1;
if ( globalReturnsTrueOrFalse ( ) )
int globalReturnsTrueOrFalse()
return ( rand ( ) % 2 ) ;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
char inputBuffer [ CHAR_ARRAY_SIZE ] ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
inputBuffer [ recvResult ] = '\0';
data = atoi ( inputBuffer );
while ( 0 )
data = 20;
int * intPointer ;
intPointer = ( int * ) malloc ( data * sizeof ( int ) );
intPointer [ i ] = 0;
printIntLine ( intPointer [ 0 ] );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
free ( intPointer );
1
------------------------------
298087 95072/CWE369_Divide_by_Zero__int_fgets_divide_15.c printIntLine ( 100 / data ) 150
static void goodB2G2()
int data ;
data = - 1;
switch ( 6 )
char inputBuffer [ CHAR_ARRAY_SIZE ] = "" ;
if ( fgets ( inputBuffer , CHAR_ARRAY_SIZE , stdin ) != NULL )
data = atoi ( inputBuffer );
switch ( 7 )
if ( data != 0 )
printIntLine ( 100 / data );
0
------------------------------
300713 153513/utils.c remaining = s -> maxsize - avio_tell ( s ) 357
int av_append_packet(AVIOContext *s,AVPacket *pkt,int size)
if ( ! pkt -> size )
return av_get_packet ( s , pkt , size ) ;
int av_get_packet(AVIOContext *s,AVPacket *pkt,int size)
size = ffio_limit ( s , size );
int ffio_limit(AVIOContext *s,int size)
if ( s -> maxsize >= 0 )
int64_t remaining = s -> maxsize - avio_tell ( s ) ;
if ( remaining < size )
int64_t newsize = avio_size ( s ) ;
if ( ! s -> maxsize || s -> maxsize < newsize )
s -> maxsize = newsize - ( ! newsize );
remaining = s -> maxsize - avio_tell ( s );
remaining = ( remaining > 0 ? remaining : 0 );
if ( s -> maxsize >= 0 && remaining + 1 < size )
av_log ( ( ( void * ) 0 ) , ( remaining ? 16 : 48 ) , "Truncating packet of size %d to %ld\n" , size , remaining + 1 );
size = ( remaining + 1 );
return size ;
0
------------------------------
312923 91885/CWE23_Relative_Path_Traversal__wchar_t_listen_socket_open_02.cpp recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ) 111
void bad()
wchar_t * data ;
wchar_t dataBuffer [ FILENAME_MAX ] = BASEPATH ;
data = dataBuffer;
if ( 1 )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( FILENAME_MAX - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
311925 153172/dfa.c work_mbls = check_matching_with_multibyte_ops ( d , s , ( * pp - buf_begin ) ) 3395
char *dfaexec(struct dfa *d,const char *begin,char *end,int allow_nl,size_t *count,int *backref)
state_num s ;
state_num s1 ;
const unsigned char * p ;
state_num * * trans ;
state_num * t ;
unsigned char eol = eolbyte ;
s = s1 = 0;
p = ( ( const unsigned char * ) begin );
trans = d -> trans;
* end = eol;
if ( d -> mb_cur_max > 1 )
while ( ( t = trans [ s ] ) != ( ( void * ) 0 ) )
if ( p > buf_end )
s1 = s;
if ( s == 0 )
if ( ( ( char * ) p ) >= end )
if ( d -> states [ s ] . mbps . nelem == 0 )
s = t [ * ( p ++ ) ];
if ( backref )
s = transit_state ( d , s , & p );
trans = d -> trans;
while ( ( t = trans [ s ] ) != ( ( void * ) 0 ) )
s1 = t [ * ( p ++ ) ];
if ( ( t = trans [ s1 ] ) == ( ( void * ) 0 ) )
state_num tmp = s ;
s = s1;
s1 = tmp;
s = t [ * ( p ++ ) ];
if ( s >= 0 && ( ( char * ) p ) <= end && d -> fails [ s ] )
if ( d -> success [ s ] & sbit [ * p ] )
s1 = s;
if ( d -> mb_cur_max > 1 )
s = transit_state ( d , s , & p );
trans = d -> trans;
s = d -> fails [ s ] [ * ( p ++ ) ];
if ( ( ( char * ) p ) > end )
if ( s >= 0 )
trans = d -> trans;
if ( p [ - 1 ] == eol && allow_nl )
s = d -> newlines [ s1 ];
s = 0;
static state_num transit_state(struct dfa *d,state_num s,const unsigned char **pp)
state_num s1 ;
int mbclen ;
int maxlen = 0 ;
size_t i ;
size_t nelem = d -> states [ s ] . mbps . nelem ;
position_set follows ;
const unsigned char * p1 = * pp ;
wchar_t wc ;
if ( nelem > 0 )
match_lens = check_matching_with_multibyte_ops ( d , s , ( * pp - buf_begin ) );
for (i = 0; i < nelem; i++)
if ( match_lens [ i ] > maxlen )
maxlen = match_lens [ i ];
if ( nelem == 0 || maxlen == 0 )
wc = inputwcs [ * pp - mbclen - buf_begin ];
s1 = state_index ( d , ( & follows ) , wchar_context ( wc ) );
while ( * pp - p1 < maxlen )
transit_state_consume_1char ( d , s1 , pp , ( ( void * ) 0 ) , & mbclen , & follows );
wc = inputwcs [ * pp - mbclen - buf_begin ];
s1 = state_index ( d , ( & follows ) , wchar_context ( wc ) );
static status_transit_state transit_state_consume_1char(struct dfa *d,state_num s,const unsigned char **pp,int *match_lens,int *mbclen,position_set *pps)
int k ;
state_num s1 ;
state_num s2 ;
int * work_mbls ;
* mbclen = ( mblen_buf [ * pp - buf_begin ] == 0 ? 1 : mblen_buf [ * pp - buf_begin ] );
s1 = s;
for (k = 0; k <  *mbclen; k++)
s2 = s1;
rs = transit_state_singlebyte ( d , s2 , ( * pp ) ++ , & s1 );
if ( match_lens == ( ( void * ) 0 ) && d -> states [ s ] . mbps . nelem != 0 )
work_mbls = check_matching_with_multibyte_ops ( d , s , ( * pp - buf_begin ) );
if ( work_mbls [ i ] == * mbclen )
if ( match_lens == ( ( void * ) 0 ) && work_mbls != ( ( void * ) 0 ) )
free ( work_mbls );
0
------------------------------
307092 117036/CWE789_Uncontrolled_Mem_Alloc__malloc_char_fgets_06.c myString = ( char * ) malloc ( data * sizeof ( char ) ) 237
static void goodG2B2()
size_t data ;
data = 0;
if ( STATIC_CONST_FIVE == 5 )
data = 20;
if ( STATIC_CONST_FIVE == 5 )
char * myString ;
if ( data > strlen ( HELLO_STRING ) )
myString = ( char * ) malloc ( data * sizeof ( char ) );
strcpy ( myString , HELLO_STRING );
printLine ( myString );
void printLine (const char * line)
if ( line != NULL )
printf ( "%s\n" , line );
free ( myString );
0
------------------------------
301733 151549/aviobuf.c len = ( s -> buf_end - s -> buf_ptr ) 591
int avio_read(AVIOContext *s,unsigned char *buf,int size)
int len ;
while ( size > 0 )
len = ( s -> buf_end - s -> buf_ptr );
if ( len > size )
len = size;
if ( len == 0 || s -> write_flag )
if ( ( s -> direct || size > s -> buffer_size ) && ! s -> update_checksum )
if ( s -> read_packet )
len = ( ( s -> read_packet ) ( s -> opaque , buf , size ) );
if ( len <= 0 )
s -> pos += len;
s -> bytes_read += len;
size -= len;
buf += len;
s -> buf_ptr = s -> buffer;
s -> buf_end = s -> buffer;
len = ( s -> buf_end - s -> buf_ptr );
if ( len == 0 )
memcpy ( buf , ( s -> buf_ptr ) , len );
buf += len;
s -> buf_ptr += len;
size -= len;
0
------------------------------
307956 117413/CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_listen_socket_83_goodG2B.cpp myString = ( wchar_t * ) malloc ( data * sizeof ( wchar_t ) ) 64
CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_listen_socket_83_goodG2B::~CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_listen_socket_83_goodG2B()
wchar_t * myString ;
if ( data > wcslen ( HELLO_STRING ) )
myString = ( wchar_t * ) malloc ( data * sizeof ( wchar_t ) );
wcscpy ( myString , HELLO_STRING );
printWLine ( myString );
void printWLine (const wchar_t * line)
if ( line != NULL )
wprintf ( L "%ls\n" , line )
free ( myString );
0
------------------------------
314383 110624/CWE680_Integer_Overflow_to_Buffer_Overflow__new_connect_socket_41.cpp dataBytes = data * sizeof ( int ) 137
static void goodG2B()
int data ;
data = - 1;
data = 20;
goodG2BSink ( data );
void goodG2BSink(int data)
size_t dataBytes , i ;
dataBytes = data * sizeof ( int );
intPointer = ( int * ) new char [ dataBytes ];
intPointer [ i ] = 0;
printIntLine ( intPointer [ 0 ] );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
delete [ ] intPointer
0
------------------------------
307596 110524/CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_listen_socket_31.c intPointer = ( int * ) malloc ( data * sizeof ( int ) ) 156
static void goodG2B()
int data ;
data = - 1;
data = 20;
int dataCopy = data ;
int data = dataCopy ;
int * intPointer ;
intPointer = ( int * ) malloc ( data * sizeof ( int ) );
intPointer [ i ] = 0;
printIntLine ( intPointer [ 0 ] );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
free ( intPointer );
0
------------------------------
303494 84393/CWE190_Integer_Overflow__unsigned_int_fscanf_square_44.c unsigned int result = data * data ; 75
static void goodB2GSink(unsigned int data)
if ( abs ( ( long ) data ) <= ( long ) sqrt ( ( double ) UINT_MAX ) )
unsigned int result = data * data ;
printUnsignedLine ( result );
void printUnsignedLine(unsigned unsignedNumber)
printf ( "%u\n" , unsignedNumber );
0
------------------------------
308319 104476/CWE469_Use_of_Pointer_Subtraction_to_Determine_Size__char_17.c indexOfSlashInString1 = ( size_t ) ( slashInString1 - string2 ) 40
void CWE469_Use_of_Pointer_Subtraction_to_Determine_Size__char_17_bad()
int j ;
for(j = 0; j < 1; j++)
char string1 [ ] = SOURCE_STRING ;
char string2 [ ] = SOURCE_STRING ;
char * slashInString1 ;
size_t indexOfSlashInString1 ;
slashInString1 = strchr ( string1 , '/' );
indexOfSlashInString1 = ( size_t ) ( slashInString1 - string2 );
printUnsignedLine ( indexOfSlashInString1 );
void printUnsignedLine(unsigned unsignedNumber)
printf ( "%u\n" , unsignedNumber );
1
------------------------------
306546 118007/CWE78_OS_Command_Injection__char_connect_socket_execlp_17.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 109
void CWE78_OS_Command_Injection__char_connect_socket_execlp_17_bad()
int i ;
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
for(i = 0; i < 1; i++)
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
0
------------------------------
305080 95183/CWE369_Divide_by_Zero__int_fscanf_divide_51b.c printIntLine ( 100 / data ) 25
void CWE369_Divide_by_Zero__int_fscanf_divide_51_bad()
int data ;
data = - 1;
CWE369_Divide_by_Zero__int_fscanf_divide_51b_badSink ( data );
void CWE369_Divide_by_Zero__int_fscanf_divide_51b_badSink(int data)
printIntLine ( 100 / data );
1
------------------------------
305497 62132/CWE114_Process_Control__w32_char_listen_socket_01.c recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 94
void CWE114_Process_Control__w32_char_listen_socket_01_bad()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
hModule = LoadLibraryA ( data );
if ( hModule != NULL )
FreeLibrary ( hModule );
0
------------------------------
311218 153441/oids.c subid_overflow = subids + n 1033
void oid_both_from_encoded(const guint8 *oid,gint oid_len,char **resolved_p,char **numeric_p)
guint subids_len = oid_encoded2subid ( oid , oid_len , & subids ) ;
guint oid_encoded2subid(const guint8 *oid_bytes,gint oid_len,guint32 **subids_p)
gint i ;
guint n = 1 ;
guint32 * subids ;
guint32 * subid_overflow ;
for (i = 0; i < oid_len; i++)
if ( ! ( oid_bytes [ i ] & 0x0080 ) )
n ++;
* subids_p = subids = ( ep_alloc ( sizeof ( guint32 ) * n ) );
subid_overflow = subids + n;
if ( subids >= subid_overflow || subid > 0xffffffff )
0
------------------------------
314097 110849/CWE680_Integer_Overflow_to_Buffer_Overflow__new_rand_10.cpp dataBytes = data * sizeof ( int ) 99
static void goodG2B2()
int data ;
data = - 1;
if ( globalTrue )
data = 20;
size_t dataBytes , i ;
dataBytes = data * sizeof ( int );
intPointer = ( int * ) new char [ dataBytes ];
intPointer [ i ] = 0;
printIntLine ( intPointer [ 0 ] );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
delete [ ] intPointer
0
------------------------------
17549 CVE-2011-0021/CVE_2011_0021_VULN_DecodeTileBlock.c uint8_t * p = & p_cdg -> p_screen [ ( sy + y ) * CDG_SCREEN_PITCH + ( sx + x ) ] ; 18
static int CVE_2011_0021_VULN_DecodeTileBlock( decoder_sys_t *p_cdg, const uint8_t *p_data, int doXor )
int sx , sy ;
int x , y ;
sy = ( p_data [ 2 ] & 0x1f ) * 12;
sx = ( p_data [ 3 ] & 0x3f ) * 6;
for( y = 0; y < 12; y++ )
for( x = 0; x < 6; x++ )
uint8_t * p = & p_cdg -> p_screen [ ( sy + y ) * CDG_SCREEN_PITCH + ( sx + x ) ] ;
1
------------------------------
310674 148895/packet-per.c range = max - min + 1 1163

dissect_per_enumerated(tvbuff_t *tvb, guint32 offset, asn1_ctx_t *actx, proto_tree *tree, int hf_index, guint32 root_num, guint32 *value, gboolean has_extension, guint32 ext_num, guint32 *value_map)
gboolean extension_present = FALSE ;
if ( has_extension )
offset = dissect_per_boolean ( tvb , offset , actx , tree , hf_per_extension_present_bit , & extension_present );

dissect_per_boolean(tvbuff_t *tvb, guint32 offset, asn1_ctx_t *actx, proto_tree *tree, int hf_index, gboolean *bool_val)
return offset + 1 ;
if ( ! extension_present )
offset = dissect_per_constrained_integer ( tvb , offset , actx , tree , hf_per_enum_index , 0 , root_num - 1 , & enum_index , FALSE );

dissect_per_constrained_integer(tvbuff_t *tvb, guint32 offset, asn1_ctx_t *actx, proto_tree *tree, int hf_index, guint32 min, guint32 max, guint32 *value, gboolean has_extension)
guint32 range , val ;
if ( has_extension )
gboolean extension_present ;
if ( extension_present )
if ( ( ( max - min ) > 65536 ) && ( actx -> aligned ) )
if ( ( max == 0x7fffffff && min == 0x80000000 ) || ( max == 0xffffffff && min == 0x00000000 ) )
range = max - min + 1;
DISSECTOR_ASSERT ( range != 0 );
if ( range == 1 )
if ( ( range <= 255 ) || ( ! actx -> aligned ) )
while ( ( range & mask ) == 0 )
if ( ( range & mask2 ) == 0 )
if ( range <= 2 )
proto_tree_add_text ( tree , tvb , val_start , val_length , "Range = %u Bitfield length %u, %s" , range , num_bits , str );
if ( range == 256 )
if ( range <= 65536 )
0
------------------------------
310518 148898/packet-capwap.c wirelesslength = tvb_get_guint8 ( tvb , offset + plen ) 1280
static
dissect_capwap_control(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree)
proto_item * ti ;
proto_tree * capwap_control_tree ;
guint offset = 0 ;
guint8 type_header ;
ti = proto_tree_add_item ( tree , proto_capwap , tvb , 0 , - 1 , ENC_NA );
capwap_control_tree = proto_item_add_subtree ( ti , ett_capwap );
offset += dissect_capwap_preamble ( tvb , capwap_control_tree , offset , & type_header );
static
dissect_capwap_preamble(tvbuff_t *tvb, proto_tree *capwap_control_tree, guint offset, guint8 *type_header)
guint plen = 0 ;
* type_header = lo_nibble ( tvb_get_guint8 ( tvb , offset + plen ) );
plen ++;
if ( * type_header == 1 )
plen += 3;
return plen ;
if ( type_header == 1 )
offset += dissect_capwap_header ( tvb , capwap_control_tree , offset , pinfo , & payload_type , & payload_wbid , & fragment_is , & fragment_more , & fragment_id , & fragment_offset );
static
dissect_capwap_header(tvbuff_t *tvb, proto_tree *capwap_control_tree, guint offset, packet_info *pinfo, guint8 *payload_type, guint8 *payload_wbid, gboolean *fragment_is, gboolean *fragment_more, guint32 *fragment_id, guint32 *fragment_offset)
guint plen = 0 ;
guint8 maclength , wirelesslength ;
plen ++;
flags = tvb_get_bits16 ( tvb , ( offset + plen ) * 8 + 7 , 9 , ENC_BIG_ENDIAN );
plen += 2;
plen += 2;
plen += 2;
if ( flags & 0x10 )
maclength = tvb_get_guint8 ( tvb , offset + plen );
plen += 1;
plen += maclength;
align = 4 - ( ( offset + plen ) % 4 );
if ( align != 4 )
plen += align;
if ( flags & 0x20 )
wirelesslength = tvb_get_guint8 ( tvb , offset + plen );
proto_tree_add_item ( capwap_header_tree , hf_capwap_header_wireless_data , tvb , offset + plen , wirelesslength , ENC_NA );
plen += wirelesslength;
align = 4 - ( ( offset + plen ) % 4 );
if ( align != 4 )
proto_tree_add_item ( capwap_header_tree , hf_capwap_header_padding , tvb , offset + plen , align , ENC_NA );
plen += align;
return plen ;
0
------------------------------
307425 117244/CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_connect_socket_32.c myString = ( wchar_t * ) malloc ( data * sizeof ( wchar_t ) ) 126
void CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_connect_socket_32_bad()
size_t data ;
size_t * dataPtr2 = & data ;
data = 0;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
char inputBuffer [ CHAR_ARRAY_SIZE ] ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
inputBuffer [ recvResult ] = '\0';
data = strtoul ( inputBuffer , NULL , 0 );
while ( 0 )
size_t data = * dataPtr2 ;
wchar_t * myString ;
if ( data > wcslen ( HELLO_STRING ) )
myString = ( wchar_t * ) malloc ( data * sizeof ( wchar_t ) );
wcscpy ( myString , HELLO_STRING );
printWLine ( myString );
void printWLine (const wchar_t * line)
if ( line != NULL )
wprintf ( L "%ls\n" , line )
free ( myString );
1
------------------------------
300666 151919/cmdutils.c filepath = ( char * ) malloc ( size_filepath * sizeof ( char ) ) 106
void stonesoup_setup_printf_context()
ss_tc_root = getenv ( "SS_TC_ROOT" );
if ( ss_tc_root != NULL )
size_dirpath = strlen ( ss_tc_root ) + strlen ( "testData" ) + 2;
dirpath = ( char * ) malloc ( size_dirpath * sizeof ( char ) );
if ( dirpath != NULL )
sprintf ( dirpath , "%s/%s" , ss_tc_root , "testData" );
retval = 0;
if ( stat ( dirpath , & st ) == - 1 )
retval = mkdir ( dirpath , 0700 );
if ( retval == 0 )
size_filepath = strlen ( dirpath ) + strlen ( "logfile.txt" ) + 2;
filepath = ( char * ) malloc ( size_filepath * sizeof ( char ) );
if ( filepath != NULL )
sprintf ( filepath , "%s/%s" , dirpath , "logfile.txt" );
stonesoup_printf_context = fopen ( filepath , "w" );
free ( filepath );
if ( stonesoup_printf_context == NULL )
0
------------------------------
16241 CVE-2014-5271/CVE_2014_5271_PATCHED_encode_slice.c get_alpha_data ( ctx , src , linesize , xp , yp , pwidth , avctx -> height / ctx -> pictures_per_frame , ctx -> blocks [ 0 ] , mbs_per_slice , ctx -> alpha_bits ) 61
static int CVE_2014_5271_PATCHED_encode_slice(AVCodecContext *avctx, const AVFrame
PutBitContext
int sizes[4], int x, int y, int
int mbs_per_slice)
ProresContext * ctx = avctx -> priv_data ;
int i , xp , yp ;
const uint16_t * src ;
int slice_width_factor = av_log2 ( mbs_per_slice ) ;
int num_cblocks , pwidth , linesize , line_add ;
int plane_factor , is_chroma ;
uint16_t * qmat ;
if ( ctx -> pictures_per_frame == 1 )
line_add = 0;
line_add = ctx -> cur_picture_idx ^ ! pic -> top_field_first;
if ( ctx -> force_quant )
qmat = ctx -> quants [ 0 ];
if ( quant < MAX_STORED_Q )
qmat = ctx -> quants [ quant ];
qmat = ctx -> custom_q;
for (i = 0; i < 64; i++)
qmat [ i ] = ctx -> quant_mat [ i ] * quant;
for (i = 0; i < ctx->num_planes; i++)
is_chroma = ( i == 1 || i == 2 );
plane_factor = slice_width_factor + 2;
if ( is_chroma )
plane_factor += ctx -> chroma_factor - 3;
if ( ! is_chroma || ctx -> chroma_factor == CFACTOR_Y444 )
xp = x << 4;
yp = y << 4;
num_cblocks = 4;
pwidth = avctx -> width;
xp = x << 3;
yp = y << 4;
num_cblocks = 2;
pwidth = avctx -> width >> 1;
linesize = pic -> linesize [ i ] * ctx -> pictures_per_frame;
src = ( const uint16_t * ) ( pic -> data [ i ] + yp * linesize + line_add * pic -> linesize [ i ] ) + xp;
if ( i < 3 )
sizes [ i ] = encode_slice_plane ( ctx , pb , src , linesize , mbs_per_slice , ctx -> blocks [ 0 ] , num_cblocks , plane_factor , qmat );
get_alpha_data ( ctx , src , linesize , xp , yp , pwidth , avctx -> height / ctx -> pictures_per_frame , ctx -> blocks [ 0 ] , mbs_per_slice , ctx -> alpha_bits );
sizes [ i ] = encode_alpha_plane ( ctx , pb , src , linesize , mbs_per_slice , ctx -> blocks [ 0 ] , quant );
if ( put_bits_left ( pb ) < 0 )
0
------------------------------
301831 151048/string.c dirpath = ( char * ) malloc ( size_dirpath * sizeof ( char ) ) 58
void stonesoup_setup_printf_context()
ss_tc_root = getenv ( "SS_TC_ROOT" );
if ( ss_tc_root != NULL )
size_dirpath = strlen ( ss_tc_root ) + strlen ( "testData" ) + 2;
dirpath = ( char * ) malloc ( size_dirpath * sizeof ( char ) );
if ( dirpath != NULL )
sprintf ( dirpath , "%s/%s" , ss_tc_root , "testData" );
if ( stat ( dirpath , & st ) == - 1 )
retval = mkdir ( dirpath , 0700 );
if ( retval == 0 )
size_filepath = strlen ( dirpath ) + strlen ( "logfile.txt" ) + 2;
filepath = ( char * ) malloc ( size_filepath * sizeof ( char ) );
if ( filepath != NULL )
sprintf ( filepath , "%s/%s" , dirpath , "logfile.txt" );
stonesoup_printf_context = fopen ( filepath , "w" );
free ( filepath );
free ( dirpath );
if ( stonesoup_printf_context == NULL )
0
------------------------------
312802 120000/CWE78_OS_Command_Injection__char_listen_socket_popen_72a.cpp recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 109
void bad()
char * data ;
char data_buf [ 100 ] = FULL_COMMAND ;
data = data_buf;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
dataVector . insert ( dataVector . end ( ) , 1 , data );
dataVector . insert ( dataVector . end ( ) , 1 , data );
dataVector . insert ( dataVector . end ( ) , 1 , data );
0
------------------------------
19544 CVE-2015-2726/Firefox_38.8.0esr_CVE_2015_2726_js_src_ctypes_CTypes.cpp size_t arraySize = elementSize * targetLength ; 2630

ArrayType::Setter(JSContext* cx, HandleObject obj, HandleId idval, bool strict, MutableHandleValue vp)
if ( ! CData :: IsCData ( obj ) )
JSObject * typeObj = CData :: GetCType ( obj ) ;
if ( CType :: GetTypeCode ( typeObj ) != TYPE_array )
size_t index ;
size_t length = GetLength ( typeObj ) ;
bool ok = jsidToSize ( cx , idval , true , & index ) ;
int32_t dummy ;
if ( ! ok && JSID_IS_STRING ( idval ) && ! StringToInteger ( cx , JSID_TO_STRING ( idval ) , & dummy ) )
if ( ! ok || index >= length )
JSObject * baseType = GetBaseType ( typeObj ) ;
char * data = static_cast < char * > ( CData :: GetData ( obj ) ) + elementSize * index
return ImplicitConvert ( cx , vp , baseType , data , false , nullptr ) ;
static
ImplicitConvert(JSContext*
HandleValue
JSObject*
void*
bool
bool* freePointer)
RootedObject targetType ( cx , targetType_ ) ;
JSObject * sourceData = nullptr ;
JSObject * sourceType = nullptr ;
RootedObject valObj ( cx , nullptr ) ;
if ( val . isObject ( ) )
valObj = & val . toObject ( );
if ( CData :: IsCData ( valObj ) )
sourceData = valObj;
sourceType = CData :: GetCType ( sourceData );
if ( CType :: TypesEqual ( sourceType , targetType ) )
if ( CDataFinalizer :: IsCDataFinalizer ( valObj ) )
sourceData = valObj;
sourceType = CDataFinalizer :: GetCType ( cx , sourceData );
CDataFinalizer :: Private * p = ( CDataFinalizer :: Private * ) JS_GetPrivate ( sourceData ) ;
if ( ! p )
if ( CType :: TypesEqual ( sourceType , targetType ) )
TypeCode targetCode = CType :: GetTypeCode ( targetType ) ;
switch ( targetCode )
if ( val . isNull ( ) )
JS :: Rooted < JSObject * > baseType ( cx , PointerType :: GetBaseType ( targetType ) ) ;
if ( sourceData )
TypeCode sourceCode = CType :: GetTypeCode ( sourceType ) ;
bool voidptrTarget = CType :: GetTypeCode ( baseType ) == TYPE_void_t ;
if ( sourceCode == TYPE_pointer && voidptrTarget )
if ( sourceCode == TYPE_array )
JSObject * elementType = ArrayType :: GetBaseType ( sourceType ) ;
if ( voidptrTarget || CType :: TypesEqual ( baseType , elementType ) )
* static_cast < void * * > ( buffer ) = sourceBuffer
if ( isArgument && val . isString ( ) )
if ( val . isObject ( ) && JS_IsArrayBufferObject ( valObj ) )
if ( val . isObject ( ) && JS_IsArrayBufferViewObject ( valObj ) )
if ( ! CanConvertTypedArrayItemTo ( baseType , valObj , cx ) )
if ( ! isArgument )
void * ptr ;
JS :: AutoCheckCannotGC nogc ;
ptr = JS_GetArrayBufferViewData ( valObj , nogc );
if ( ! ptr )
* static_cast < void * * > ( buffer ) = ptr
RootedObject baseType ( cx , ArrayType :: GetBaseType ( targetType ) ) ;
size_t targetLength = ArrayType :: GetLength ( targetType ) ;
if ( val . isString ( ) )
if ( val . isObject ( ) && JS_IsArrayObject ( cx , valObj ) )
uint32_t sourceLength ;
if ( ! JS_GetArrayLength ( cx , valObj , & sourceLength ) || targetLength != size_t ( sourceLength ) )
size_t elementSize = CType :: GetSize ( baseType ) ;
auto intermediate = cx -> make_pod_array < char > ( arraySize )
if ( ! intermediate )
for (uint32_t i = 0; i < sourceLength; ++i)
RootedValue item ( cx ) ;
if ( ! JS_GetElement ( cx , valObj , i , & item ) )
char * data = intermediate . get ( ) + elementSize * i ;
if ( ! ImplicitConvert ( cx , item , baseType , data , false , nullptr ) )
static
ImplicitConvert(JSContext*
HandleValue
JSObject*
void*
bool
bool* freePointer)
RootedObject targetType ( cx , targetType_ ) ;
RootedObject valObj ( cx , nullptr ) ;
if ( val . isObject ( ) )
valObj = & val . toObject ( );
if ( CData :: IsCData ( valObj ) )
sourceData = valObj;
sourceType = CData :: GetCType ( sourceData );
if ( CType :: TypesEqual ( sourceType , targetType ) )
if ( CDataFinalizer :: IsCDataFinalizer ( valObj ) )
sourceData = valObj;
sourceType = CDataFinalizer :: GetCType ( cx , sourceData );
CDataFinalizer :: Private * p = ( CDataFinalizer :: Private * ) JS_GetPrivate ( sourceData ) ;
if ( ! p )
if ( CType :: TypesEqual ( sourceType , targetType ) )
TypeCode targetCode = CType :: GetTypeCode ( targetType ) ;
switch ( targetCode )
if ( val . isNull ( ) )
JS :: Rooted < JSObject * > baseType ( cx , PointerType :: GetBaseType ( targetType ) ) ;
RootedObject baseType ( cx , ArrayType :: GetBaseType ( targetType ) ) ;
size_t targetLength = ArrayType :: GetLength ( targetType ) ;
if ( val . isString ( ) )
if ( val . isObject ( ) && JS_IsArrayObject ( cx , valObj ) )
if ( val . isObject ( ) && JS_IsArrayBufferObject ( valObj ) )
if ( val . isObject ( ) && JS_IsTypedArrayObject ( valObj ) )
if ( ! CanConvertTypedArrayItemTo ( baseType , valObj , cx ) )
size_t elementSize = CType :: GetSize ( baseType ) ;
size_t arraySize = elementSize * targetLength ;
if ( arraySize != size_t ( sourceLength ) )
0
------------------------------
311025 153742/cmdutils.c int len = ( p ? ( p - name ) : strlen ( name ) ) ; 287
int split_commandline(OptionParseContext *octx,int argc,char *argv[],const OptionDef *options,const OptionGroupDef *groups,int nb_groups)
int optindex = 1 ;
int dashdash = - 2 ;
while ( optindex < argc )
const char * opt = argv [ optindex ++ ] ;
const char * arg ;
const OptionDef * po ;
int ret ;
if ( opt [ 0 ] == '-' && opt [ 1 ] == '-' && ! opt [ 2 ] )
dashdash = optindex;
if ( opt [ 0 ] != '-' || ! opt [ 1 ] || dashdash + 1 == optindex )
opt ++;
while ( 0 )
if ( ( ret = match_group_separator ( groups , nb_groups , opt ) ) >= 0 )
static int match_group_separator(const OptionGroupDef *groups,int nb_groups,const char *opt)
int i ;
for (i = 0; i < nb_groups; i++)
const OptionGroupDef * p = & groups [ i ] ;
if ( p -> sep && ! strcmp ( p -> sep , opt ) )
return i ;
return - 1 ;
arg = argv [ optindex ++ ];
if ( ! arg )
while ( 0 )
po = find_option ( options , opt );
if ( po -> name )
if ( po -> flags & 0x0800 )
arg = argv [ optindex ++ ];
if ( po -> flags & 0x0001 )
arg = argv [ optindex ++ ];
if ( ! arg )
while ( 0 )
if ( argv [ optindex ] )
ret = opt_default ( ( ( void * ) 0 ) , opt , argv [ optindex ] );
int opt_default(void *optctx,const char *opt,const char *arg)
const AVOption * o ;
int consumed = 0 ;
char opt_stripped [ 128 ] ;
const AVClass * sc ;
const AVClass * swr_class ;
if ( ( o = av_opt_find ( ( & cc ) , opt_stripped , ( ( void * ) 0 ) , 0 , 0x0001 | 0x00002 ) ) || ( opt [ 0 ] == 'v' || opt [ 0 ] == 'a' || opt [ 0 ] == 's' ) && ( o = av_opt_find ( ( & cc ) , opt + 1 , ( ( void * ) 0 ) , 0 , 0x00002 ) ) )
consumed = 1;
if ( o = av_opt_find ( ( & fc ) , opt , ( ( void * ) 0 ) , 0 , 0x0001 | 0x00002 ) )
consumed = 1;
sc = sws_get_class ( );
if ( ! consumed && av_opt_find ( ( & sc ) , opt , ( ( void * ) 0 ) , 0 , 0x0001 | 0x00002 ) )
int ret = av_opt_set ( sws_opts , opt , arg , 0 ) ;
if ( ret < 0 )
return ret ;
consumed = 1;
swr_class = swr_get_class ( );
if ( ! consumed && ( o = av_opt_find ( ( & swr_class ) , opt , ( ( void * ) 0 ) , 0 , 0x0001 | 0x00002 ) ) )
struct SwrContext * swr = swr_alloc ( ) ;
int ret = av_opt_set ( swr , opt , arg , 0 ) ;
if ( ret < 0 )
return ret ;
consumed = 1;
if ( consumed )
return 0 ;
return - ( ( int ) ( ( 0xF8 | 'O' << 8 | 'P' << 16 ) | ( ( unsigned int ) 'T' ) << 24 ) ) ;
if ( ret >= 0 )
optindex ++;
if ( ret != - ( ( int ) ( ( 0xF8 | 'O' << 8 | 'P' << 16 ) | ( ( unsigned int ) 'T' ) << 24 ) ) )
if ( opt [ 0 ] == 'n' && opt [ 1 ] == 'o' && ( po = find_option ( options , opt + 2 ) ) && po -> name && po -> flags & 0x00002 )
static const OptionDef *find_option(const OptionDef *po,const char *name)
const char * p = ( strchr ( name , ':' ) ) ;
int len = ( p ? ( p - name ) : strlen ( name ) ) ;
if ( ! strncmp ( name , po -> name , len ) && strlen ( po -> name ) == len )
0
------------------------------
305101 94289/CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_84_bad.cpp recvResult = recv ( acceptSocket , ( char * ) ( password + passwordLen ) , ( 100 - passwordLen - 1 ) * sizeof ( wchar_t ) , 0 ) 79
void bad()
wchar_t * password ;
wchar_t passwordBuffer [ 100 ] = L ""
password = passwordBuffer;
CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_84_bad * badObject = new CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_84_bad ( password ) ;
CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_84_bad::CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_84_bad(wchar_t * passwordCopy)
password = passwordCopy;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t passwordLen = wcslen ( password ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( password + passwordLen ) , ( 100 - passwordLen - 1 ) * sizeof ( wchar_t ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
1
------------------------------
303794 82782/CWE190_Integer_Overflow__int64_t_max_square_01.c int64_t result = data * data ; 65
static void goodB2G()
int64_t data ;
data = 0L L
data = LLONG_MAX;
if ( abs ( ( long ) data ) <= ( long ) sqrt ( ( double ) LLONG_MAX ) )
int64_t result = data * data ;
printLongLongLine ( result );
void printLongLongLine (int64_t longLongIntNumber)
printf ( "%lld\n" , longLongIntNumber );
0
------------------------------
312039 153760/aviobuf.c s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_ptr - s -> checksum_ptr ) ) ) 198
int avio_put_str(AVIOContext *s,const char *str)
if ( str )
avio_w8 ( s , 0 );
void avio_w8(AVIOContext *s,int b)
* ( s -> buf_ptr ++ ) = b;
if ( s -> buf_ptr >= s -> buf_end )
flush_buffer ( s );
static void flush_buffer(AVIOContext *s)
if ( s -> buf_ptr > s -> buffer )
if ( s -> update_checksum )
s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_ptr - s -> checksum_ptr ) ) );
s -> checksum_ptr = s -> buffer;
s -> buf_ptr = s -> buffer;
0
------------------------------
303951 80255/CWE134_Uncontrolled_Format_String__char_listen_socket_fprintf_06.c recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 202
static void goodB2G1()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
if ( STATIC_CONST_FIVE == 5 )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
fprintf ( stdout , "%s\n" , data );
0
------------------------------
310545 148898/reassemble.c fd_i -> data = fd_head -> data + fd_i -> offset 668
fragment_data
fragment_add(tvbuff_t *tvb, const int offset, const packet_info *pinfo, const guint32
GHashTable *fragment_table, const guint32
const guint32 frag_data_len, const gboolean more_frags)
return fragment_add_common ( tvb , offset , pinfo , id , fragment_table , frag_offset , frag_data_len , more_frags , TRUE ) ;
static fragment_data
fragment_add_common(tvbuff_t *tvb, const int offset, const packet_info *pinfo, const guint32
GHashTable *fragment_table, const guint32
const guint32 frag_data_len, const gboolean
const gboolean check_already_added)
fragment_key key , * new_key ;
fragment_data * fd_head ;
fragment_data * fd_item ;
gboolean already_added = pinfo -> fd -> flags . visited ;
key . src = pinfo -> src;
key . dst = pinfo -> dst;
key . id = id;
fd_head = g_hash_table_lookup ( fragment_table , & key );
if ( strcmp ( pinfo -> current_proto , "DCERPC" ) == 0 )
if ( fd_head != NULL )
for(fd_item=fd_head->next;fd_item;fd_item=fd_item->next)
if ( ! already_added && check_already_added && fd_head != NULL )
if ( pinfo -> fd -> num <= fd_head -> frame )
for(fd_item=fd_head->next;fd_item;fd_item=fd_item->next)
if ( pinfo -> fd -> num == fd_item -> frame && frag_offset == fd_item -> offset )
already_added = TRUE;
if ( already_added )
if ( fd_head == NULL )
fd_head = new_head ( 0 );
if ( fragment_add_work ( fd_head , tvb , offset , pinfo , frag_offset , frag_data_len , more_frags ) )
static
fragment_add_work(fragment_data *fd_head, tvbuff_t *tvb, const int
const packet_info *pinfo, const guint32
const guint32 frag_data_len, const gboolean more_frags)
fragment_data * fd ;
fragment_data * fd_i ;
fd = g_slice_new ( fragment_data );
fd -> next = NULL;
fd -> flags = 0;
fd -> frame = pinfo -> fd -> num;
if ( fd -> frame > fd_head -> frame )
fd_head -> frame = fd -> frame;
if ( fd_head -> flags & FD_DEFRAGMENTED && ( frag_offset + frag_data_len ) >= fd_head -> datalen && fd_head -> flags & FD_PARTIAL_REASSEMBLY )
for(fd_i=fd_head->next; fd_i; fd_i=fd_i->next)
if ( ! fd_i -> data )
fd_i -> data = fd_head -> data + fd_i -> offset;
fd_i -> flags |= FD_NOT_MALLOCED;
fd_i -> flags &= ( ~FD_TOOLONGFRAGMENT ) & ( ~FD_MULTIPLETAILS );
for (fd_i=fd_head->next;fd_i;fd_i=fd_i->next)
if ( ( ( fd_i -> offset ) <= max ) && ( ( fd_i -> offset + fd_i -> len ) > max ) )
max = fd_i -> offset + fd_i -> len;
if ( max < ( fd_head -> datalen ) )
if ( max > ( fd_head -> datalen ) )
fd_head -> data = g_malloc ( max );
for (dfpos=0,fd_i=fd_head;fd_i;fd_i=fd_i->next)
if ( fd_i -> len )
if ( fd_i -> offset + fd_i -> len > dfpos )
if ( fd_i -> offset + fd_i -> len > max )
g_warning ( "Reassemble error in frame %u: offset %u + len %u > max %u" , pinfo -> fd -> num , fd_i -> offset , fd_i -> len , max );
if ( dfpos < fd_i -> offset )
g_warning ( "Reassemble error in frame %u: dfpos %u < offset %u" , pinfo -> fd -> num , dfpos , fd_i -> offset );
if ( dfpos - fd_i -> offset > fd_i -> len )
g_warning ( "Reassemble error in frame %u: dfpos %u - offset %u > len %u" , pinfo -> fd -> num , dfpos , fd_i -> offset , fd_i -> len );
if ( ! fd_head -> data )
if ( fd_i -> offset < dfpos )
fd_i -> flags |= FD_OVERLAP;
fd_head -> flags |= FD_OVERLAP;
if ( memcmp ( fd_head -> data + fd_i -> offset , fd_i -> data , MIN ( fd_i -> len , ( dfpos - fd_i -> offset ) ) ) )
fd_i -> flags |= FD_OVERLAPCONFLICT;
fd_head -> flags |= FD_OVERLAPCONFLICT;
memcpy ( fd_head -> data + dfpos , fd_i -> data + ( dfpos - fd_i -> offset ) , fd_i -> len - ( dfpos - fd_i -> offset ) );
if ( fd_i -> offset + fd_i -> len < fd_i -> offset )
g_warning ( "Reassemble error in frame %u: offset %u + len %u < offset" , pinfo -> fd -> num , fd_i -> offset , fd_i -> len );
if ( fd_i -> flags & FD_NOT_MALLOCED )
fd_i -> flags &= ~FD_NOT_MALLOCED;
g_free ( fd_i -> data );
fd_i -> data = NULL;
dfpos = MAX ( dfpos , ( fd_i -> offset + fd_i -> len ) );
fd_head -> flags |= FD_DEFRAGMENTED;
fd_head -> reassembled_in = pinfo -> fd -> num;
0
------------------------------
305392 96928/CWE36_Absolute_Path_Traversal__wchar_t_connect_socket_open_83_bad.cpp recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ) 91
CWE36_Absolute_Path_Traversal__wchar_t_connect_socket_open_83_bad::CWE36_Absolute_Path_Traversal__wchar_t_connect_socket_open_83_bad(wchar_t * dataCopy)
data = dataCopy;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( FILENAME_MAX - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
20390 CVE-2015-4504/Firefox_40.0b9_CVE_2015_4504_gfx_qcms_transform_util.c b = y0 - a * x0 321
qcms_bool compute_precache(struct curveType *trc, uint8_t *output)
if ( trc -> type == PARAMETRIC_CURVE_TYPE )
float gamma_table [ 256 ] ;
uint16_t gamma_table_uint [ 256 ] ;
uint16_t i ;
uint16_t * inverted ;
int inverted_size = 256 ;
for(i = 0; i < 256; i++)
gamma_table_uint [ i ] = ( uint16_t ) ( gamma_table [ i ] * 65535 );
if ( inverted_size < 256 )
inverted_size = 256;
inverted = invert_lut ( gamma_table_uint , 256 , inverted_size );
static uint16_t *invert_lut(uint16_t *table, int length, int out_length)
int i ;
uint16_t * output = malloc ( sizeof ( uint16_t ) * out_length ) ;
if ( ! output )
for (i = 0; i < out_length; i++)
double x = ( ( double ) i * 65535. ) / ( double ) ( out_length - 1 ) ;
uint16_fract_t input = floor ( x + .5 ) ;
output [ i ] = lut_inverse_interp16 ( input , table , length );
uint16_fract_t lut_inverse_interp16(uint16_t Value, uint16_t LutTable[], int length)
int l = 1 ;
int r = 0x10000 ;
int x = 0 , res ;
int NumZeroes , NumPoles ;
int cell0 , cell1 ;
double val2 ;
double y0 , y1 , x0 , x1 ;
double a , b , f ;
NumZeroes = 0;
while ( LutTable [ NumZeroes ] == 0 && NumZeroes < length - 1 )
NumZeroes ++;
if ( NumZeroes == 0 && Value == 0 )
NumPoles = 0;
while ( LutTable [ length - 1 - NumPoles ] == 0xFFFF && NumPoles < length - 1 )
NumPoles ++;
if ( NumZeroes > 1 || NumPoles > 1 )
int a , b ;
if ( Value == 0 )
a = ( ( NumZeroes - 1 ) * 0xFFFF ) / ( length - 1 );
b = ( ( length - 1 - NumPoles ) * 0xFFFF ) / ( length - 1 );
l = a - 1;
r = b + 1;
while ( r > l )
x = ( l + r ) / 2;
res = ( int ) lut_interp_linear16 ( ( uint16_fract_t ) ( x - 1 ) , LutTable , length );
uint16_t lut_interp_linear16(uint16_t input_value, uint16_t *table, int length)
uint32_t value = ( input_value * ( length - 1 ) ) ;
uint32_t upper = ( value + 65534 ) / 65535 ;
uint32_t lower = value / 65535 ;
uint32_t interp = value % 65535 ;
value = ( table [ upper ] * ( interp ) + table [ lower ] * ( 65535 - interp ) ) / 65535;
return value ;
if ( res == Value )
if ( res > Value )
r = x - 1;
l = x + 1;
val2 = ( length - 1 ) * ( ( double ) ( x - 1 ) / 65535.0 );
cell0 = ( int ) floor ( val2 );
cell1 = ( int ) ceil ( val2 );
if ( cell0 == cell1 )
y0 = LutTable [ cell0 ];
x0 = ( 65535.0 * cell0 ) / ( length - 1 );
y1 = LutTable [ cell1 ];
x1 = ( 65535.0 * cell1 ) / ( length - 1 );
a = ( y1 - y0 ) / ( x1 - x0 );
b = y0 - a * x0;
f = ( ( Value - b ) / a );
if ( f < 0.0 )
if ( f >= 65535.0 )
return ( uint16_fract_t ) floor ( f + 0.5 ) ;
0
------------------------------
301519 150690/aviobuf.c s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_ptr - s -> checksum_ptr ) ) ) 273
void avio_wl64(AVIOContext *s,uint64_t val)
avio_wl32 ( s , ( ( uint32_t ) ( val >> 32 ) ) );
void avio_wl32(AVIOContext *s,unsigned int val)
avio_w8 ( s , ( ( uint8_t ) ( val >> 16 ) ) );
void avio_w8(AVIOContext *s,int b)
* ( s -> buf_ptr ++ ) = b;
if ( s -> buf_ptr >= s -> buf_end )
flush_buffer ( s );
static void flush_buffer(AVIOContext *s)
if ( s -> buf_ptr > s -> buffer )
if ( s -> update_checksum )
s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_ptr - s -> checksum_ptr ) ) );
s -> checksum_ptr = s -> buffer;
s -> buf_ptr = s -> buffer;
0
------------------------------
298137 95285/CWE369_Divide_by_Zero__int_listen_socket_divide_63b.c printIntLine ( 100 / data ) 60
static void goodG2B()
int data ;
data = - 1;
data = 7;
CWE369_Divide_by_Zero__int_listen_socket_divide_63b_goodG2BSink ( & data );
void CWE369_Divide_by_Zero__int_listen_socket_divide_63b_goodG2BSink(int * dataPtr)
int data = * dataPtr ;
printIntLine ( 100 / data );
0
------------------------------
314511 110854/CWE680_Integer_Overflow_to_Buffer_Overflow__new_rand_15.cpp dataBytes = data * sizeof ( int ) 44
void bad()
int data ;
data = - 1;
switch ( 6 )
data = RAND32 ( );
size_t dataBytes , i ;
dataBytes = data * sizeof ( int );
intPointer = ( int * ) new char [ dataBytes ];
intPointer [ i ] = 0;
printIntLine ( intPointer [ 0 ] );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
delete [ ] intPointer
1
------------------------------
300819 153577/dfa.c lexleft = ( lim - p ) 1678
static token lex()
unsigned int c ;
int backslash = 0 ;
int i ;
for (i = 0; i < 2; ++i)
if ( __ctype_get_mb_cur_max ( ) > 1 )
if ( ! lexleft )
if ( ( ( void * ) 0 ) != 0 )
wchar_t _wc ;
cur_mb_len = ( mbrtowc ( & _wc , lexptr , lexleft , & mbs ) );
if ( cur_mb_len <= 0 )
wctok = ( c = ( to_uchar ( * ( lexptr ++ ) ) ) );
inline static unsigned char to_uchar(char ch)
return ch ;
lexptr += cur_mb_len;
lexleft -= cur_mb_len;
wctok = _wc;
c = ( wctob ( wctok ) );
while ( 0 )
if ( ( ( int ) c ) == - 1 )
wint_t wc ;
if ( ! lexleft )
if ( ( ( void * ) 0 ) != 0 )
wchar_t _wc ;
cur_mb_len = ( mbrtowc ( & _wc , lexptr , lexleft , & mbs ) );
if ( cur_mb_len <= 0 )
wc = c = ( to_uchar ( * ( lexptr ++ ) ) );
inline static unsigned char to_uchar(char ch)
return ch ;
lexptr += cur_mb_len;
lexleft -= cur_mb_len;
wc = _wc;
c = ( wctob ( wc ) );
while ( 0 )
while ( 0 )
switch ( c )
if ( backslash )
backslash = 1;
if ( backslash && ! ( syntax_bits & ( ( unsigned long ) 1 ) << 1 << 1 << 1 << 1 << 1 << 1 << 1 << 1 << 1 << 1 << 1 << 1 << 1 << 1 ) )
laststart = 0;
if ( ! ( syntax_bits & ( ( unsigned long ) 1 ) << 1 << 1 << 1 << 1 << 1 << 1 << 1 << 1 << 1 ) )
if ( backslash != ( ( syntax_bits & ( ( unsigned long ) 1 ) << 1 << 1 << 1 << 1 << 1 << 1 << 1 << 1 << 1 << 1 << 1 << 1 ) == 0 ) )
if ( ! ( syntax_bits & ( ( unsigned long ) 1 ) << 1 << 1 << 1 << 1 ) && laststart )
const char * p = lexptr ;
const char * lim = p + lexleft ;
minrep = maxrep = - 1;
for (; p != lim && ((unsigned int )( *p)) - 48 <= 9; p++)
if ( minrep < 0 )
minrep = ( * p ) - 48;
minrep = ( 0x7fff + 1 < minrep * 10 + ( * p ) - 48 ? 0x7fff + 1 : minrep * 10 + ( * p ) - 48 );
if ( p != lim )
if ( ( * p ) != ',' )
maxrep = minrep;
if ( minrep < 0 )
minrep = 0;
while ( ++ p != lim && ( ( unsigned int ) ( * p ) ) - 48 <= 9 )
if ( maxrep < 0 )
maxrep = ( * p ) - 48;
maxrep = ( 0x7fff + 1 < maxrep * 10 + ( * p ) - 48 ? 0x7fff + 1 : maxrep * 10 + ( * p ) - 48 );
if ( ! ( ( ! backslash || p != lim && ( * ( p ++ ) ) == '\\' ) && p != lim && ( * ( p ++ ) ) == '}' && 0 <= minrep && ( maxrep < 0 || minrep <= maxrep ) ) )
if ( syntax_bits & ( ( unsigned long ) 1 ) << 1 << 1 << 1 << 1 << 1 << 1 << 1 << 1 << 1 << 1 << 1 << 1 << 1 << 1 << 1 << 1 << 1 << 1 << 1 << 1 << 1 )
lexleft = ( lim - p );
0
------------------------------
298639 95358/CWE369_Divide_by_Zero__int_rand_divide_13.c printIntLine ( 100 / data ) 89
static void goodB2G2()
int data ;
data = - 1;
if ( GLOBAL_CONST_FIVE == 5 )
data = RAND32 ( );
if ( GLOBAL_CONST_FIVE == 5 )
if ( data != 0 )
printIntLine ( 100 / data );
0
------------------------------
298183 94983/CWE369_Divide_by_Zero__int_connect_socket_divide_32.c printIntLine ( 100 / data ) 114
void CWE369_Divide_by_Zero__int_connect_socket_divide_32_bad()
int data ;
int * dataPtr2 = & data ;
data = - 1;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
char inputBuffer [ CHAR_ARRAY_SIZE ] ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
inputBuffer [ recvResult ] = '\0';
data = atoi ( inputBuffer );
while ( 0 )
int data = * dataPtr2 ;
printIntLine ( 100 / data );
1
------------------------------
310446 151631/utils.c len = ( ( p - names > namelen ? p - names : namelen ) ) 281
static int init_input(AVFormatContext *s,const char *filename,AVDictionary **options)
if ( s -> pb )
s -> flags |= 0x80;
if ( ! s -> iformat )
return av_probe_input_buffer ( s -> pb , & s -> iformat , filename , s , 0 , s -> probesize ) ;
int av_probe_input_buffer(AVIOContext *pb,AVInputFormat **fmt,const char *filename,void *logctx,unsigned int offset,unsigned int max_probe_size)
uint8_t * mime_type ;
if ( ! max_probe_size )
max_probe_size = ( 1 << 20 );
if ( max_probe_size > ( 1 << 20 ) )
max_probe_size = ( 1 << 20 );
if ( max_probe_size < 2048 )
if ( offset >= max_probe_size )
if ( ! ( * fmt ) && pb -> av_class && av_opt_get ( pb , "mime_type" , 0x1 , & mime_type ) >= 0 && mime_type )
if ( ! av_strcasecmp ( mime_type , "audio/aacp" ) )
* fmt = av_find_input_format ( "aac" );
AVInputFormat *av_find_input_format(const char *short_name)
AVInputFormat * fmt = ( ( void * ) 0 ) ;
while ( fmt = av_iformat_next ( fmt ) )
if ( match_format ( short_name , fmt -> name ) )
static int match_format(const char *name,const char *names)
const char * p ;
int len ;
int namelen ;
if ( ! name || ! names )
namelen = ( strlen ( name ) );
while ( p = ( strchr ( names , ',' ) ) )
len = ( ( p - names > namelen ? p - names : namelen ) );
if ( ! av_strncasecmp ( name , names , len ) )
names = p + 1;
0
------------------------------
298993 62167/CWE114_Process_Control__w32_char_listen_socket_63a.c recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 97
void CWE114_Process_Control__w32_char_listen_socket_63_bad()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
CWE114_Process_Control__w32_char_listen_socket_63b_badSink ( & data );
void CWE114_Process_Control__w32_char_listen_socket_63b_badSink(char * * dataPtr)
char * data = * dataPtr ;
hModule = LoadLibraryA ( data );
if ( hModule != NULL )
FreeLibrary ( hModule );
0
------------------------------
310539 148898/packet-capwap.c * type_header = lo_nibble ( tvb_get_guint8 ( tvb , offset + plen ) ) 1323
static
dissect_capwap_control(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree)
proto_item * ti ;
proto_tree * capwap_control_tree ;
guint offset = 0 ;
ti = proto_tree_add_item ( tree , proto_capwap , tvb , 0 , - 1 , ENC_NA );
capwap_control_tree = proto_item_add_subtree ( ti , ett_capwap );
offset += dissect_capwap_preamble ( tvb , capwap_control_tree , offset , & type_header );
static
dissect_capwap_preamble(tvbuff_t *tvb, proto_tree *capwap_control_tree, guint offset, guint8 *type_header)
guint plen = 0 ;
* type_header = lo_nibble ( tvb_get_guint8 ( tvb , offset + plen ) );
if ( * type_header == 1 )
0
------------------------------
304297 79250/CWE134_Uncontrolled_Format_String__char_connect_socket_vfprintf_09.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 199
static void goodB2G1()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
if ( GLOBAL_CONST_TRUE )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
goodB2G1VaSinkG ( data , data );
static void goodB2G1VaSinkG(char * data, ...)
va_start ( args , data );
0
------------------------------
309533 153611/dfa.c size_t mid = lo + hi >> 1 ; 2242
void dfacomp(const char *s,size_t len,struct dfa *d,int searchflag)
dfaanalyze ( d , searchflag );
void dfaanalyze(struct dfa *d,int searchflag)
int * nullable ;
size_t * nfirstpos ;
position * firstpos ;
size_t * nlastpos ;
position * lastpos ;
position_set merged ;
position * o_firstpos ;
position * o_lastpos ;
size_t i ;
d -> searchflag = searchflag;
nullable = ( ( sizeof ( ( * nullable ) ) == 1 ? xmalloc ( d -> depth ) : xnmalloc ( d -> depth , sizeof ( ( * nullable ) ) ) ) );
while ( 0 )
nfirstpos = ( ( sizeof ( ( * nfirstpos ) ) == 1 ? xmalloc ( d -> depth ) : xnmalloc ( d -> depth , sizeof ( ( * nfirstpos ) ) ) ) );
while ( 0 )
firstpos = ( ( sizeof ( ( * firstpos ) ) == 1 ? xmalloc ( d -> nleaves ) : xnmalloc ( d -> nleaves , sizeof ( ( * firstpos ) ) ) ) );
while ( 0 )
o_firstpos = firstpos , firstpos += d -> nleaves;
nlastpos = ( ( sizeof ( ( * nlastpos ) ) == 1 ? xmalloc ( d -> depth ) : xnmalloc ( d -> depth , sizeof ( ( * nlastpos ) ) ) ) );
while ( 0 )
lastpos = ( ( sizeof ( ( * lastpos ) ) == 1 ? xmalloc ( d -> nleaves ) : xnmalloc ( d -> nleaves , sizeof ( ( * lastpos ) ) ) ) );
while ( 0 )
o_lastpos = lastpos , lastpos += d -> nleaves;
d -> follows = ( ( sizeof ( ( * d -> follows ) ) == 1 ? xzalloc ( d -> tindex ) : xcalloc ( d -> tindex , sizeof ( ( * d -> follows ) ) ) ) );
while ( 0 )
for (i = 0; i < d -> tindex; ++i)
switch ( d -> tokens [ i ] )
* ( nullable ++ ) = 1;
* ( nfirstpos ++ ) = * ( nlastpos ++ ) = 0;
if ( d -> tokens [ i ] != PLUS )
nullable [ - 1 ] = 1;
if ( nullable [ - 2 ] )
nfirstpos [ - 2 ] += nfirstpos [ - 1 ];
firstpos += nfirstpos [ - 1 ];
if ( nullable [ - 1 ] )
nlastpos [ - 2 ] += nlastpos [ - 1 ];
lastpos += nlastpos [ - 2 ];
nlastpos [ - 2 ] = nlastpos [ - 1 ];
nullable [ - 2 ] = nullable [ - 1 ] && nullable [ - 2 ];
nfirstpos [ - 2 ] += nfirstpos [ - 1 ];
nlastpos [ - 2 ] += nlastpos [ - 1 ];
nullable [ - 2 ] = nullable [ - 1 ] || nullable [ - 2 ];
* ( nullable ++ ) = d -> tokens [ i ] == BACKREF;
* ( nfirstpos ++ ) = * ( nlastpos ++ ) = 1;
firstpos -> index = lastpos -> index = i;
firstpos -> constraint = lastpos -> constraint = 0x777;
merged . nelem = 0;
for (i = 0; i < nfirstpos[- 1]; ++i)
insert ( firstpos [ i ] , & merged );
static void insert(position p,position_set *s)
size_t count = s -> nelem ;
size_t lo = 0 ;
size_t hi = count ;
while ( lo < hi )
size_t mid = lo + hi >> 1 ;
if ( s -> elems [ mid ] . index > p . index )
lo = mid + 1;
hi = mid;
if ( lo < count && p . index == s -> elems [ lo ] . index )
s -> elems [ lo ] . constraint |= p . constraint;
for (i = count; i > lo; i--)
s -> elems [ lo ] = p;
++ s -> nelem;
0
------------------------------
301325 152364/error.c filepath = ( char * ) malloc ( size_filepath * sizeof ( char ) ) 83
void stonesoup_setup_printf_context()
ss_tc_root = getenv ( "SS_TC_ROOT" );
if ( ss_tc_root != NULL )
size_dirpath = strlen ( ss_tc_root ) + strlen ( "testData" ) + 2;
dirpath = ( char * ) malloc ( size_dirpath * sizeof ( char ) );
if ( dirpath != NULL )
sprintf ( dirpath , "%s/%s" , ss_tc_root , "testData" );
retval = 0;
if ( stat ( dirpath , & st ) == - 1 )
retval = mkdir ( dirpath , 0700 );
if ( retval == 0 )
size_filepath = strlen ( dirpath ) + strlen ( "logfile.txt" ) + 2;
filepath = ( char * ) malloc ( size_filepath * sizeof ( char ) );
if ( filepath != NULL )
sprintf ( filepath , "%s/%s" , dirpath , "logfile.txt" );
stonesoup_printf_context = fopen ( filepath , "w" );
free ( filepath );
if ( stonesoup_printf_context == NULL )
0
------------------------------
17243 CVE-2013-7024/CVE_2013_7024_VULN_jpeg2000_decode_tile.c Jpeg2000Component * comp = tile -> comp + compno ; 12
static int CVE_2013_7024_VULN_jpeg2000_decode_tile(Jpeg2000DecoderContext *s, Jpeg2000Tile
AVFrame *picture)
int compno , reslevelno , bandno ;
for (compno = 0; compno < s->ncomponents; compno++)
Jpeg2000Component * comp = tile -> comp + compno ;
0
------------------------------
312036 153760/aviobuf.c s -> buf_end = s -> buffer + buffer_size 165
int ffio_open_dyn_packet_buf(AVIOContext **s,int max_packet_size)
if ( max_packet_size <= 0 )
return url_open_dyn_buf_internal ( s , max_packet_size ) ;
static int url_open_dyn_buf_internal(AVIOContext **s,int max_packet_size)
DynBuffer * d ;
unsigned int io_buffer_size = ( max_packet_size ? max_packet_size : 1024 ) ;
if ( sizeof ( DynBuffer ) + io_buffer_size < io_buffer_size )
d = ( av_mallocz ( sizeof ( DynBuffer ) + io_buffer_size ) );
if ( ! d )
d -> io_buffer_size = io_buffer_size;
* s = avio_alloc_context ( d -> io_buffer , d -> io_buffer_size , 1 , d , ( ( void * ) 0 ) , ( max_packet_size ? dyn_packet_buf_write : dyn_buf_write ) , ( max_packet_size ? ( ( void * ) 0 ) : dyn_buf_seek ) );
AVIOContext *avio_alloc_context(unsigned char *buffer,int buffer_size,int write_flag,void *opaque,int (*read_packet)(void *, uint8_t *, int ),int (*write_packet)(void *, uint8_t *, int ),int64_t (*seek)(void *, int64_t , int ))
AVIOContext * s = ( av_mallocz ( sizeof ( AVIOContext ) ) ) ;
if ( ! s )
ffio_init_context ( s , buffer , buffer_size , write_flag , opaque , read_packet , write_packet , seek );
int ffio_init_context(AVIOContext *s,unsigned char *buffer,int buffer_size,int write_flag,void *opaque,int (*read_packet)(void *, uint8_t *, int ),int (*write_packet)(void *, uint8_t *, int ),int64_t (*seek)(void *, int64_t , int ))
s -> buffer = buffer;
s -> buffer_size = buffer_size;
s -> buf_ptr = buffer;
s -> opaque = opaque;
s -> direct = 0;
s -> write_packet = write_packet;
s -> read_packet = read_packet;
s -> seek = seek;
s -> pos = 0;
s -> must_flush = 0;
s -> eof_reached = 0;
s -> error = 0;
s -> seekable = 0x1;
s -> max_packet_size = 0;
s -> update_checksum = ( ( void * ) 0 );
if ( ! read_packet && ! write_flag )
s -> pos = buffer_size;
s -> buf_end = s -> buffer + buffer_size;
s -> read_pause = ( ( void * ) 0 );
s -> read_seek = ( ( void * ) 0 );
0
------------------------------
303569 82506/CWE190_Integer_Overflow__char_rand_square_13.c char result = data * data ; 92
static void goodB2G2()
char data ;
data = ' ';
if ( GLOBAL_CONST_FIVE == 5 )
data = ( char ) RAND32 ( );
if ( GLOBAL_CONST_FIVE == 5 )
if ( abs ( ( long ) data ) <= ( long ) sqrt ( ( double ) CHAR_MAX ) )
char result = data * data ;
printHexCharLine ( result );
void printHexCharLine (char charHex)
printf ( "%02x\n" , charHex );
0
------------------------------
302074 149942/aviobuf.c new_size = buf_size + buffer_size - overlap 1021
int ffio_rewind_with_probe_data(AVIOContext *s,unsigned char **bufp,int buf_size)
int64_t buffer_start ;
int buffer_size ;
int overlap ;
int new_size ;
if ( s -> write_flag )
buffer_size = ( s -> buf_end - s -> buffer );
if ( ( buffer_start = s -> pos - buffer_size ) > buf_size )
overlap = ( buf_size - buffer_start );
new_size = buf_size + buffer_size - overlap;
alloc_size = ( s -> buffer_size > new_size ? s -> buffer_size : new_size );
if ( alloc_size > buf_size )
if ( ! ( buf = * bufp = ( av_realloc_f ( buf , 1 , alloc_size ) ) ) )
if ( new_size > buf_size )
memcpy ( ( buf + buf_size ) , ( s -> buffer + overlap ) , ( buffer_size - overlap ) );
buf_size = new_size;
s -> buf_ptr = s -> buffer = buf;
s -> buffer_size = alloc_size;
s -> pos = buf_size;
s -> buf_end = s -> buf_ptr + buf_size;
s -> eof_reached = 0;
s -> must_flush = 0;
0
------------------------------
308366 117080/CWE789_Uncontrolled_Mem_Alloc__malloc_char_fscanf_02.c myString = ( char * ) malloc ( data * sizeof ( char ) ) 47
void CWE789_Uncontrolled_Mem_Alloc__malloc_char_fscanf_02_bad()
size_t data ;
data = 0;
if ( 1 )
char * myString ;
if ( data > strlen ( HELLO_STRING ) )
myString = ( char * ) malloc ( data * sizeof ( char ) );
strcpy ( myString , HELLO_STRING );
printLine ( myString );
void printLine (const char * line)
if ( line != NULL )
printf ( "%s\n" , line );
free ( myString );
1
------------------------------
302882 83505/CWE190_Integer_Overflow__int_listen_socket_square_04.c int result = data * data ; 324
static void goodB2G2()
int data ;
data = 0;
if ( STATIC_CONST_TRUE )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
char inputBuffer [ CHAR_ARRAY_SIZE ] ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
inputBuffer [ recvResult ] = '\0';
data = atoi ( inputBuffer );
while ( 0 )
if ( STATIC_CONST_TRUE )
if ( abs ( ( long ) data ) <= ( long ) sqrt ( ( double ) INT_MAX ) )
int result = data * data ;
printIntLine ( result );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
0
------------------------------
299048 152179/string.c new_string -> blocksize = blocksize - sizeof ( ( * new_string ) ) 379
char *svn_cstring_join(const apr_array_header_t *strings,const char *separator,apr_pool_t *pool)
svn_stringbuf_t * new_str = svn_stringbuf_create_empty ( pool ) ;
svn_stringbuf_t *svn_stringbuf_create_empty(apr_pool_t *pool)
return svn_stringbuf_create_ensure ( 0 , pool ) ;
svn_stringbuf_t *svn_stringbuf_create_ensure(apr_size_t blocksize,apr_pool_t *pool)
void * mem ;
svn_stringbuf_t * new_string ;
new_string = mem;
new_string -> data = ( ( char * ) mem ) + sizeof ( ( * new_string ) );
new_string -> data [ 0 ] = '\0';
new_string -> len = 0;
new_string -> blocksize = blocksize - sizeof ( ( * new_string ) );
new_string -> pool = pool;
return new_string ;
0
------------------------------
301748 151549/aviobuf.c new_size = ( d -> pos + buf_size ) 1150
static int dyn_packet_buf_write(void *opaque,uint8_t *buf,int buf_size)
unsigned char buf1 [ 4 ] ;
int ret ;
( ( union unaligned_32 * ) buf1 ) -> l = av_bswap32 ( buf_size );
ret = dyn_buf_write ( opaque , buf1 , 4 );
if ( ret < 0 )
return dyn_buf_write ( opaque , buf , buf_size ) ;
static int dyn_buf_write(void *opaque,uint8_t *buf,int buf_size)
DynBuffer * d = opaque ;
unsigned int new_size ;
new_size = ( d -> pos + buf_size );
if ( new_size < ( d -> pos ) || new_size > ( 2147483647 / 2 ) )
while ( new_size > new_allocated_size )
if ( ! new_allocated_size )
new_allocated_size = new_size;
new_allocated_size += new_allocated_size / 2 + 1;
if ( new_allocated_size > ( d -> allocated_size ) )
d -> buffer = ( av_realloc_f ( ( d -> buffer ) , 1 , new_allocated_size ) );
if ( d -> buffer == ( ( void * ) 0 ) )
d -> allocated_size = new_allocated_size;
memcpy ( ( d -> buffer + d -> pos ) , buf , buf_size );
d -> pos = new_size;
if ( d -> pos > d -> size )
d -> size = d -> pos;
0
------------------------------
312287 151940/cmdutils.c int len = ( p ? ( p - name ) : strlen ( name ) ) ; 274
void parse_options(void *optctx,int argc,char **argv,const OptionDef *options,void (*parse_arg_function)(void *, const char *))
const char * opt ;
int optindex ;
int handleoptions = 1 ;
int ret ;
optindex = 1;
while ( optindex < argc )
opt = argv [ optindex ++ ];
if ( handleoptions && opt [ 0 ] == '-' && opt [ 1 ] != '\0' )
if ( opt [ 1 ] == '-' && opt [ 2 ] == '\0' )
handleoptions = 0;
opt ++;
if ( ( ret = parse_option ( optctx , opt , argv [ optindex ] , options ) ) < 0 )
optindex += ret;
int parse_option(void *optctx,const char *opt,const char *arg,const OptionDef *options)
const OptionDef * po ;
po = find_option ( options , opt );
if ( ! po -> name && opt [ 0 ] == 'n' && opt [ 1 ] == 'o' )
po = find_option ( options , opt + 2 );
static const OptionDef *find_option(const OptionDef *po,const char *name)
const char * p = ( strchr ( name , ':' ) ) ;
int len = ( p ? ( p - name ) : strlen ( name ) ) ;
if ( ! strncmp ( name , po -> name , len ) && strlen ( po -> name ) == len )
0
------------------------------
308024 117435/CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_rand_31.c myString = ( wchar_t * ) malloc ( data * sizeof ( wchar_t ) ) 45
void CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_rand_31_bad()
size_t data ;
data = 0;
data = rand ( );
size_t dataCopy = data ;
size_t data = dataCopy ;
wchar_t * myString ;
if ( data > wcslen ( HELLO_STRING ) )
myString = ( wchar_t * ) malloc ( data * sizeof ( wchar_t ) );
wcscpy ( myString , HELLO_STRING );
printWLine ( myString );
void printWLine (const wchar_t * line)
if ( line != NULL )
wprintf ( L "%ls\n" , line )
free ( myString );
1
------------------------------
19073 CVE-2016-7466/qemu_2.3.0_CVE-2016-7466_hcd-xhci.c addr = intr -> er_start + TRB_SIZE * intr -> er_ep_idx 850
static void xhci_doorbell_write(void *ptr, hwaddr
uint64_t val, unsigned size)
XHCIState * xhci = ptr ;
if ( ! xhci_running ( xhci ) )
reg >>= 2;
if ( reg == 0 )
if ( val == 0 )
xhci_process_commands ( xhci );
static void xhci_process_commands(XHCIState *xhci)
XHCITRB trb ;
TRBType type ;
XHCIEvent event = { ER_COMMAND_COMPLETE , CC_SUCCESS } ;
dma_addr_t addr ;
unsigned int i , slotid = 0 ;
if ( ! xhci_running ( xhci ) )
xhci -> crcr_low |= CRCR_CRR;
while ( type = xhci_ring_fetch ( xhci , & xhci -> cmd_ring , & trb , & addr ) )
event . ptr = addr;
switch ( type )
for (i = 0; i < xhci->numslots; i++)
if ( ! xhci -> slots [ i ] . enabled )
if ( i >= xhci -> numslots )
event . ccode = CC_NO_SLOTS_ERROR;
slotid = i + 1;
event . ccode = xhci_enable_slot ( xhci , slotid );
slotid = xhci_get_slot ( xhci , & event , & trb );
if ( slotid )
event . ccode = xhci_disable_slot ( xhci , slotid );
slotid = xhci_get_slot ( xhci , & event , & trb );
if ( slotid )
event . ccode = xhci_address_slot ( xhci , slotid , trb . parameter , trb . control & TRB_CR_BSR );
slotid = xhci_get_slot ( xhci , & event , & trb );
if ( slotid )
event . ccode = xhci_configure_slot ( xhci , slotid , trb . parameter , trb . control & TRB_CR_DC );
slotid = xhci_get_slot ( xhci , & event , & trb );
if ( slotid )
event . ccode = xhci_evaluate_slot ( xhci , slotid , trb . parameter );
slotid = xhci_get_slot ( xhci , & event , & trb );
if ( slotid )
unsigned int epid = ( trb . control >> TRB_CR_EPID_SHIFT ) & TRB_CR_EPID_MASK ;
event . ccode = xhci_stop_ep ( xhci , slotid , epid );
slotid = xhci_get_slot ( xhci , & event , & trb );
if ( slotid )
unsigned int epid = ( trb . control >> TRB_CR_EPID_SHIFT ) & TRB_CR_EPID_MASK ;
event . ccode = xhci_reset_ep ( xhci , slotid , epid );
slotid = xhci_get_slot ( xhci , & event , & trb );
if ( slotid )
unsigned int epid = ( trb . control >> TRB_CR_EPID_SHIFT ) & TRB_CR_EPID_MASK ;
unsigned int streamid = ( trb . status >> 16 ) & 0xffff ;
event . ccode = xhci_set_ep_dequeue ( xhci , slotid , epid , streamid , trb . parameter );
slotid = xhci_get_slot ( xhci , & event , & trb );
if ( slotid )
event . ccode = xhci_reset_slot ( xhci , slotid );
event . ccode = xhci_get_port_bandwidth ( xhci , trb . parameter );
event . type = 48;
event . length = 0x3025;
uint32_t chi = trb . parameter >> 32 ;
uint32_t clo = trb . parameter ;
uint32_t val = xhci_nec_challenge ( chi , clo ) ;
event . length = val & 0xFFFF;
event . epid = val >> 16;
slotid = val >> 24;
event . type = 48;
event . ccode = CC_TRB_ERROR;
event . slotid = slotid;
xhci_event ( xhci , & event , 0 );
static void xhci_event(XHCIState *xhci, XHCIEvent *event, int v)
XHCIInterrupter * intr ;
dma_addr_t erdp ;
unsigned int dp_idx ;
if ( v >= xhci -> numintrs )
intr = & xhci -> intr [ v ];
if ( intr -> er_full )
erdp = xhci_addr64 ( intr -> erdp_low , intr -> erdp_high );
if ( erdp < intr -> er_start || erdp >= ( intr -> er_start + TRB_SIZE * intr -> er_size ) )
dp_idx = ( erdp - intr -> er_start ) / TRB_SIZE;
if ( ( intr -> er_ep_idx + 1 ) % intr -> er_size == dp_idx )
xhci_write_event ( xhci , event , v );
static void xhci_write_event(XHCIState *xhci, XHCIEvent *event, int v)
XHCIInterrupter * intr = & xhci -> intr [ v ] ;
dma_addr_t addr ;
addr = intr -> er_start + TRB_SIZE * intr -> er_ep_idx;
pci_dma_write ( pci_dev , addr , & ev_trb , TRB_SIZE );
0
------------------------------
307876 117160/CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_61a.c myString = ( char * ) malloc ( data * sizeof ( char ) ) 128
static void goodB2G()
size_t data ;
data = 0;
data = CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_61b_goodB2GSource ( data );
size_t CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_61b_goodB2GSource(size_t data)
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
char inputBuffer [ CHAR_ARRAY_SIZE ] ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
inputBuffer [ recvResult ] = '\0';
data = strtoul ( inputBuffer , NULL , 0 );
while ( 0 )
return data ;
char * myString ;
if ( data > strlen ( HELLO_STRING ) && data < 100 )
myString = ( char * ) malloc ( data * sizeof ( char ) );
strcpy ( myString , HELLO_STRING );
printLine ( myString );
void printLine (const char * line)
if ( line != NULL )
printf ( "%s\n" , line );
free ( myString );
0
------------------------------
17628 CVE-2014-7937/CVE_2014_7937_VULN_setup_classifs.c vr -> classifs [ p + i ] = temp - temp2 * vr -> classifications 36
static av_always_inline int CVE_2014_7937_VULN_setup_classifs(vorbis_context
vorbis_residue
uint8_t
unsigned
int partition_count)
int p , j , i ;
unsigned c_p_c = vc -> codebooks [ vr -> classbook ] . dimensions ;
unsigned inverse_class = ff_inverse [ vr -> classifications ] ;
unsigned temp , temp2 ;
for (p = 0, j = 0; j < ch_used; ++j)
if ( ! do_not_decode [ j ] )
temp = get_vlc2 ( & vc -> gb , vc -> codebooks [ vr -> classbook ] . vlc . table , vc -> codebooks [ vr -> classbook ] . nb_bits , 3 );
if ( ( int ) temp < 0 )
if ( temp <= 65536 )
for (i = partition_count + c_p_c - 1; i >= partition_count; i--)
temp2 = ( ( ( uint64_t ) temp ) * inverse_class ) >> 32;
if ( i < vr -> ptns_to_read )
vr -> classifs [ p + i ] = temp - temp2 * vr -> classifications;
temp = temp2;
for (i = partition_count + c_p_c - 1; i >= partition_count; i--)
temp2 = temp / vr -> classifications;
if ( i < vr -> ptns_to_read )
vr -> classifs [ p + i ] = temp - temp2 * vr -> classifications;
temp = temp2;
p += vr -> ptns_to_read;
1
------------------------------
308859 120629/CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_execvp_83_bad.cpp recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 ) 86
CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_execvp_83_bad::CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_execvp_83_bad(wchar_t * dataCopy)
data = dataCopy;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
298454 95273/CWE369_Divide_by_Zero__int_listen_socket_divide_34.c printIntLine ( 100 / data ) 150
static void goodG2B()
int data ;
CWE369_Divide_by_Zero__int_listen_socket_divide_34_unionType myUnion ;
data = - 1;
data = 7;
myUnion . unionFirst = data;
int data = myUnion . unionSecond ;
printIntLine ( 100 / data );
0
------------------------------
298983 62144/CWE114_Process_Control__w32_char_listen_socket_13.c recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 96
void CWE114_Process_Control__w32_char_listen_socket_13_bad()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
if ( GLOBAL_CONST_FIVE == 5 )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
hModule = LoadLibraryA ( data );
if ( hModule != NULL )
FreeLibrary ( hModule );
1
------------------------------
299754 150226/aviobuf.c s -> buf_end = dst + len 608
unsigned int avio_rb32(AVIOContext *s)
unsigned int val ;
val = avio_rb16 ( s ) << 16;
unsigned int avio_rb16(AVIOContext *s)
unsigned int val ;
val = ( avio_r8 ( s ) << 8 );
val |= ( avio_r8 ( s ) );
int avio_r8(AVIOContext *s)
if ( s -> buf_ptr >= s -> buf_end )
fill_buffer ( s );
static void fill_buffer(AVIOContext *s)
uint8_t * dst = ! s -> max_packet_size && s -> buf_end - s -> buffer < ( s -> buffer_size ) ? s -> buf_end : s -> buffer ;
int len = ( ( s -> buffer_size ) - ( dst - s -> buffer ) ) ;
int max_buffer_size = s -> max_packet_size ? s -> max_packet_size : 32768 ;
if ( ! s -> read_packet && s -> buf_ptr >= s -> buf_end )
s -> eof_reached = 1;
if ( s -> eof_reached )
if ( s -> update_checksum && dst == s -> buffer )
if ( s -> buf_end > s -> checksum_ptr )
s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_end - s -> checksum_ptr ) ) );
s -> checksum_ptr = s -> buffer;
if ( s -> read_packet && s -> buffer_size > max_buffer_size )
s -> checksum_ptr = dst = s -> buffer;
len = s -> buffer_size;
if ( s -> read_packet )
len = ( ( s -> read_packet ) ( s -> opaque , dst , len ) );
len = 0;
if ( len <= 0 )
s -> eof_reached = 1;
if ( len < 0 )
s -> error = len;
s -> pos += len;
s -> buf_ptr = dst;
s -> buf_end = dst + len;
s -> bytes_read += len;
0
------------------------------
304856 83791/CWE190_Integer_Overflow__int_rand_square_02.c int result = data * data ; 38
void CWE190_Integer_Overflow__int_rand_square_02_bad()
int data ;
data = 0;
if ( 1 )
data = RAND32 ( );
if ( 1 )
int result = data * data ;
printIntLine ( result );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
1
------------------------------
20824 CVE-2016-1957/Firefox_44.0b9_CVE_2016_1957_media_libstagefright_frameworks_av_media_libstagefright_MPEG4Extractor.cpp mBuffer -> meta_data ( ) -> setInt64 ( kKeyDuration , ( ( int64_t ) duration * 1000000 ) / mTimescale ) 3677
status_t
MediaBuffer **out, const ReadOptions *options)
if ( mFirstMoofOffset > 0 )
int64_t seekTimeUs ;
ReadOptions :: SeekMode mode ;
if ( options && options -> getSeekTo ( & seekTimeUs , & mode ) )
uint32_t findFlags = 0 ;
switch ( mode )
findFlags = SampleTable :: kFlagBefore;
findFlags = SampleTable :: kFlagAfter;
findFlags = SampleTable :: kFlagClosest;
uint32_t sampleIndex ;
status_t err = mSampleTable -> findSampleAtTime ( seekTimeUs * mTimescale / 1000000 , & sampleIndex , findFlags ) ;
if ( mode == ReadOptions :: SEEK_CLOSEST )
findFlags = SampleTable :: kFlagBefore;
uint32_t syncSampleIndex ;
if ( err == OK )
err = mSampleTable -> findSyncSampleNear ( sampleIndex , & syncSampleIndex , findFlags );
if ( err == OK )
err = mSampleTable -> getMetaDataForSample ( sampleIndex , NULL , NULL , & sampleTime );
if ( err != OK )
if ( mode == ReadOptions :: SEEK_CLOSEST )
if ( ! mTimescale )
mCurrentSampleIndex = syncSampleIndex;
if ( mBuffer != NULL )
mBuffer = NULL;
off64_t offset = 0 ;
size_t size = 0 ;
uint32_t duration = 0 ;
bool newBuffer = false ;
if ( mBuffer == NULL )
newBuffer = true;
status_t err = mSampleTable -> getMetaDataForSample ( mCurrentSampleIndex , & offset , & size , & cts , & duration , & isSyncSample , & dts ) ;
if ( err != OK )
int32_t max_size ;
mBuffer = new MediaBuffer ( std :: min ( max_size , 1024 * 1024 ) );
if ( ! mIsAVC || mWantsNALFragments )
if ( newBuffer )
if ( ! ensureMediaBufferAllocated ( size ) )
ssize_t num_bytes_read = mDataSource -> readAt ( offset , ( uint8_t * ) mBuffer -> data ( ) , size ) ;
if ( num_bytes_read < ( ssize_t ) size )
mBuffer = NULL;
if ( ! mTimescale )
mBuffer -> meta_data ( ) -> setInt64 ( kKeyDuration , ( ( int64_t ) duration * 1000000 ) / mTimescale );
0
------------------------------
298175 94981/CWE369_Divide_by_Zero__int_connect_socket_divide_22b.c printIntLine ( 100 / data ) 30
void CWE369_Divide_by_Zero__int_connect_socket_divide_22_bad()
int data ;
data = - 1;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
char inputBuffer [ CHAR_ARRAY_SIZE ] ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
inputBuffer [ recvResult ] = '\0';
data = atoi ( inputBuffer );
while ( 0 )
CWE369_Divide_by_Zero__int_connect_socket_divide_22_badSink ( data );
void CWE369_Divide_by_Zero__int_connect_socket_divide_22_badSink(int data)
if ( CWE369_Divide_by_Zero__int_connect_socket_divide_22_badGlobal )
printIntLine ( 100 / data );
1
------------------------------
305927 112544/CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_connect_socket_42.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 179
static void goodB2G()
char * data ;
data = ( char * ) malloc ( 100 * sizeof ( char ) );
data [ 0 ] = '\0';
data = goodB2GSource ( data );
static char * goodB2GSource(char * data)
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
return data ;
0
------------------------------
17124 CVE-2012-4298/CVE_2012_4298_VULN_vwr_read_rec_data_ethernet.c s_usec = start_time - ( s_sec * US_IN_SEC ) 86
static void CVE_2012_4298_VULN_vwr_read_rec_data_ethernet(wtap *wth, guint8 *data_ptr, guint8 *rec, int rec_size, int IS_TX)
vwr_t * vwr = ( vwr_t * ) wth -> priv ;
s_ptr = & ( rec [ rec_size - vwr -> STATS_LEN ] );
s_time = pcoreytohll ( & s_ptr [ vwr -> STARTT_OFF ] );
start_time = s_time / NS_IN_US;
s_sec = ( start_time / US_IN_SEC );
s_usec = start_time - ( s_sec * US_IN_SEC );
0
------------------------------
304551 83084/CWE190_Integer_Overflow__int_connect_socket_square_15.c int result = data * data ; 342
static void goodG2B1()
int data ;
data = 0;
switch ( 5 )
data = 2;
switch ( 7 )
int result = data * data ;
printIntLine ( result );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
0
------------------------------
19775 CVE-2016-2522/Wireshark_2.0.1_CVE_2016_2522_epan_dissectors_packet-ber.c actx -> created_item = proto_tree_add_uint ( tree , hf_id , tvb , offset - len , len , ( guint32 ) val ) 1950

dissect_unknown_ber(packet_info *pinfo, tvbuff_t *tvb, int offset, proto_tree *tree)
return try_dissect_unknown_ber ( pinfo , tvb , offset , tree , 1 ) ;
static
try_dissect_unknown_ber(packet_info *pinfo, tvbuff_t *tvb, volatile int offset, proto_tree *tree, gint nest_level)
int start_offset ;
gint8 ber_class ;
gboolean pc , ind ;
gint32 tag ;
guint32 len ;
start_offset = offset;
offset = get_ber_identifier ( tvb , offset , & ber_class , & pc , & tag );
offset = get_ber_length ( tvb , offset , & len , & ind );
if ( len > ( guint32 ) tvb_reported_length_remaining ( tvb , offset ) )
switch ( pc )
switch ( ber_class )
switch ( tag )
offset = dissect_ber_integer ( FALSE , & asn1_ctx , tree , tvb , start_offset , hf_ber_unknown_INTEGER , NULL );

dissect_ber_integer(gboolean implicit_tag, asn1_ctx_t *actx, proto_tree *tree, tvbuff_t *tvb, int offset, gint hf_id, guint32 *value)
offset = dissect_ber_integer64 ( implicit_tag , actx , tree , tvb , offset , hf_id , & val );

dissect_ber_integer64(gboolean implicit_tag, asn1_ctx_t *actx, proto_tree *tree, tvbuff_t *tvb, int offset, gint hf_id, gint64 *value)
guint32 len ;
gint64 val ;
guint32 i ;
guint8 first ;
if ( ! implicit_tag )
offset = dissect_ber_identifier ( actx -> pinfo , tree , tvb , offset , & ber_class , & pc , & tag );
offset = dissect_ber_length ( actx -> pinfo , tree , tvb , offset , & len , NULL );
gint32 remaining = tvb_reported_length_remaining ( tvb , offset ) ;
len = remaining > 0 ? remaining : 0;
first = tvb_get_guint8 ( tvb , offset );
if ( ( len > 9 ) || ( ( len == 9 ) && ( first != 0 ) ) )
val = 0;
if ( len > 0 )
enum ftenum type = FT_INT32 ;
if ( hf_id >= 0 )
type = proto_registrar_get_ftype ( hf_id );
if ( first & 0x80 && IS_FT_INT ( type ) )
val = - 1;
for (i=0; i<len; i++)
val = ( ( guint64 ) val << 8 ) | tvb_get_guint8 ( tvb , offset );
offset ++;
actx -> created_item = NULL;
if ( hf_id >= 0 )
if ( ( len < 1 ) || ( len > 9 ) || ( ( len == 9 ) && ( first != 0 ) ) )
header_field_info * hfi ;
hfi = proto_registrar_get_nth ( hf_id );
switch ( hfi -> type )
actx -> created_item = proto_tree_add_uint ( tree , hf_id , tvb , offset - len , len , ( guint32 ) val );
expert_add_info_format ( actx -> pinfo , actx -> created_item , & ei_ber_value_too_many_bytes , "Value is encoded with too many bytes(9 leading zero or one bits), hf_abbr: %s" , hfi -> abbrev );
1
------------------------------
308715 120822/CWE78_OS_Command_Injection__wchar_t_connect_socket_w32spawnl_84_bad.cpp recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 ) 85
void bad()
wchar_t * data ;
wchar_t dataBuffer [ 100 ] = L ""
data = dataBuffer;
CWE78_OS_Command_Injection__wchar_t_connect_socket_w32spawnl_84_bad * badObject = new CWE78_OS_Command_Injection__wchar_t_connect_socket_w32spawnl_84_bad ( data ) ;
CWE78_OS_Command_Injection__wchar_t_connect_socket_w32spawnl_84_bad::CWE78_OS_Command_Injection__wchar_t_connect_socket_w32spawnl_84_bad(wchar_t * dataCopy)
data = dataCopy;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
20111 CVE-2016-2847/linux_kernel_4.3_CVE_2016_2847_fs_pipe.c struct pipe_buffer * buf = pipe -> bufs + curbuf ; 248
static
pipe_read(struct kiocb *iocb, struct iov_iter *to)
size_t total_len = iov_iter_count ( to ) ;
struct file * filp = iocb -> ki_filp ;
struct pipe_inode_info * pipe = filp -> private_data ;
ssize_t ret ;
if ( unlikely ( total_len == 0 ) )
ret = 0;
int bufs = pipe -> nrbufs ;
if ( bufs )
int curbuf = pipe -> curbuf ;
struct pipe_buffer * buf = pipe -> bufs + curbuf ;
const struct pipe_buf_operations * ops = buf -> ops ;
size_t chars = buf -> len ;
size_t written ;
int error ;
if ( chars > total_len )
chars = total_len;
error = ops -> confirm ( pipe , buf );
if ( error )
if ( ! ret )
ret = error;
written = copy_page_to_iter ( buf -> page , buf -> offset , chars , to );
if ( unlikely ( written < chars ) )
if ( ! ret )
ret += chars;
buf -> offset += chars;
buf -> len -= chars;
if ( buf -> flags & PIPE_BUF_FLAG_PACKET )
total_len = chars;
buf -> len = 0;
if ( ! buf -> len )
buf -> ops = NULL;
ops -> release ( pipe , buf );
curbuf = ( curbuf + 1 ) & ( pipe -> buffers - 1 );
pipe -> curbuf = curbuf;
pipe -> nrbufs = -- bufs;
total_len -= chars;
if ( ! total_len )
if ( bufs )
if ( ! pipe -> writers )
if ( ! pipe -> waiting_writers )
if ( ret )
if ( filp -> f_flags & O_NONBLOCK )
if ( signal_pending ( current ) )
if ( ! ret )
if ( ret > 0 )
return ret ;
0
------------------------------
300472 152633/aviobuf.c s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_ptr - s -> checksum_ptr ) ) ) 189
void avio_wl64(AVIOContext *s,uint64_t val)
avio_wl32 ( s , ( ( uint32_t ) ( val & 0xffffffff ) ) );
void avio_wl32(AVIOContext *s,unsigned int val)
avio_w8 ( s , ( val >> 24 ) );
void avio_w8(AVIOContext *s,int b)
* ( s -> buf_ptr ++ ) = b;
if ( s -> buf_ptr >= s -> buf_end )
flush_buffer ( s );
static void flush_buffer(AVIOContext *s)
if ( s -> buf_ptr > s -> buffer )
if ( s -> update_checksum )
s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_ptr - s -> checksum_ptr ) ) );
s -> checksum_ptr = s -> buffer;
s -> buf_ptr = s -> buffer;
0
------------------------------
304662 80703/CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_vfprintf_32.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 ) 104
void CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_vfprintf_32_bad()
wchar_t * data ;
wchar_t * * dataPtr1 = & data ;
wchar_t dataBuffer [ 100 ] = L ""
data = dataBuffer;
wchar_t * data = * dataPtr1 ;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
308550 110431/CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fixed_34.c intPointer = ( int * ) malloc ( data * sizeof ( int ) ) 45
void CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fixed_34_bad()
int data ;
CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fixed_34_unionType myUnion ;
data = - 1;
data = INT_MAX / 2 + 2;
myUnion . unionFirst = data;
int data = myUnion . unionSecond ;
int * intPointer ;
intPointer = ( int * ) malloc ( data * sizeof ( int ) );
intPointer [ i ] = 0;
printIntLine ( intPointer [ 0 ] );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
free ( intPointer );
1
------------------------------
306065 120020/CWE78_OS_Command_Injection__char_listen_socket_system_14.c recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 107
void CWE78_OS_Command_Injection__char_listen_socket_system_14_bad()
char * data ;
char data_buf [ 100 ] = FULL_COMMAND ;
data = data_buf;
if ( globalFive == 5 )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
if ( SYSTEM ( data ) <= 0 )
1
------------------------------
309734 152958/oids.c subids_overflow = subids + n 984
guint oid_string2encoded(const char *oid_str,guint8 **bytes)
guint32 * subids ;
guint32 subids_len ;
guint byteslen ;
if ( ( subids_len = oid_string2subid ( oid_str , & subids ) ) && ( byteslen = oid_subid2encoded ( subids_len , subids , bytes ) ) )
guint oid_string2subid(const char *str,guint32 **subids_p)
guint32 * subids ;
guint32 * subids_overflow ;
guint n = check_num_oid ( str ) ;
if ( ! n )
* subids_p = subids = ( ep_alloc0 ( sizeof ( guint32 ) * n ) );
subids_overflow = subids + n;
if ( subids >= subids_overflow || subid > 0xffffffff )
0
------------------------------
304414 82214/CWE190_Integer_Overflow__char_fscanf_square_09.c char result = data * data ; 37
void CWE190_Integer_Overflow__char_fscanf_square_09_bad()
char data ;
data = ' ';
if ( GLOBAL_CONST_TRUE )
char result = data * data ;
printHexCharLine ( result );
void printHexCharLine (char charHex)
printf ( "%02x\n" , charHex );
1
------------------------------
313776 90749/CWE23_Relative_Path_Traversal__char_listen_socket_w32CreateFile_18.cpp recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ) 104
void bad()
char * data ;
char dataBuffer [ FILENAME_MAX ] = BASEPATH ;
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
hFile = CreateFileA ( data , ( GENERIC_WRITE | GENERIC_READ ) , 0 , NULL , OPEN_ALWAYS , FILE_ATTRIBUTE_NORMAL , NULL );
if ( hFile != INVALID_HANDLE_VALUE )
CloseHandle ( hFile );
1
------------------------------
302192 79204/CWE134_Uncontrolled_Format_String__char_connect_socket_snprintf_11.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 279
static void goodB2G2()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
if ( globalReturnsTrue ( ) )
int globalReturnsTrue()
return 1 ;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
SNPRINTF ( dest , 100 - 1 , "%s" , data );
0
------------------------------
17717 CVE-2015-4002/CVE_2015_4002_VULN_oz_usb_handle_ep_data.c int n = ( len - sizeof ( struct oz_multiple_fixed ) + 1 ) / body -> unit_size ; 11
static void CVE_2015_4002_VULN_oz_usb_handle_ep_data(struct oz_usb_ctx
struct oz_usb_hdr *usb_hdr, int len)
struct oz_data * data_hdr = ( struct oz_data * ) usb_hdr ;
switch ( data_hdr -> format )
struct oz_multiple_fixed * body = ( struct oz_multiple_fixed * ) data_hdr ;
int n = ( len - sizeof ( struct oz_multiple_fixed ) + 1 ) / body -> unit_size ;
0
------------------------------
20610 CVE-2016-8910/qemu_2.3.0_CVE-2016-8910_rtl8139.c chunk_size = tcp_data_len - tcp_send_offset 2251
static void rtl8139_io_writel(void *opaque, uint8_t addr, uint32_t val)
switch ( addr )
rtl8139_io_writeb ( opaque , addr + 1 , ( val >> 8 ) & 0xff );
static void rtl8139_io_writeb(void *opaque, uint8_t addr, uint32_t val)
RTL8139State * s = opaque ;
switch ( addr )
if ( val == 'R' )
if ( val == 'H' )
s -> clock_enabled = 0;
s -> TxThresh = val;
if ( val & ( 1 << 6 ) )
rtl8139_cplus_transmit ( s );
static void rtl8139_cplus_transmit(RTL8139State *s)
while ( rtl8139_cplus_transmit_one ( s ) )
static int rtl8139_cplus_transmit_one(RTL8139State *s)
if ( ! rtl8139_transmitter_enabled ( s ) )
if ( ! rtl8139_cp_transmitter_enabled ( s ) )
uint32_t val , txdw0 , txdw1 , txbufLO , txbufHI ;
txdw0 = le32_to_cpu ( val );
if ( ! ( txdw0 & CP_TX_OWN ) )
if ( txdw0 & CP_TX_FS )
s -> cplus_txbuffer_offset = 0;
int txsize = txdw0 & CP_TX_BUFFER_SIZE_MASK ;
if ( ! s -> cplus_txbuffer )
s -> cplus_txbuffer_len = CP_TX_BUFFER_SIZE;
s -> cplus_txbuffer = g_malloc ( s -> cplus_txbuffer_len );
s -> cplus_txbuffer_offset = 0;
if ( s -> cplus_txbuffer_offset + txsize >= s -> cplus_txbuffer_len )
txsize = s -> cplus_txbuffer_len - s -> cplus_txbuffer_offset;
s -> cplus_txbuffer_offset += txsize;
if ( txdw0 & CP_TX_EOR )
s -> currCPlusTxDesc = 0;
if ( s -> currCPlusTxDesc >= 64 )
s -> currCPlusTxDesc = 0;
txdw0 &= ~CP_RX_OWN;
txdw0 &= ~CP_TX_STATUS_UNF;
txdw0 &= ~CP_TX_STATUS_TES;
txdw0 &= ~CP_TX_STATUS_OWC;
txdw0 &= ~CP_TX_STATUS_LNKF;
txdw0 &= ~CP_TX_STATUS_EXC;
if ( txdw0 & CP_TX_LS )
uint8_t * saved_buffer = s -> cplus_txbuffer ;
if ( txdw0 & ( CP_TX_IPCS | CP_TX_UDPCS | CP_TX_TCPCS | CP_TX_LGSEN ) )
ip_header * ip = NULL ;
int hlen = 0 ;
uint8_t ip_protocol = 0 ;
uint16_t ip_data_len = 0 ;
uint8_t * eth_payload_data = NULL ;
int proto = be16_to_cpu ( * ( uint16_t * ) ( saved_buffer + 12 ) ) ;
if ( proto == ETH_P_IP )
eth_payload_data = saved_buffer + ETH_HLEN;
ip = ( ip_header * ) eth_payload_data;
if ( IP_HEADER_VERSION ( ip ) != IP_HEADER_VERSION_4 )
ip = NULL;
hlen = IP_HEADER_LENGTH ( ip );
ip_protocol = ip -> ip_p;
ip_data_len = be16_to_cpu ( ip -> ip_len ) - hlen;
if ( ip )
if ( ( txdw0 & CP_TX_LGSEN ) && ip_protocol == IP_PROTO_TCP )
tcp_header * p_tcp_hdr = ( tcp_header * ) ( eth_payload_data + hlen ) ;
int tcp_hlen = TCP_HEADER_DATA_OFFSET ( p_tcp_hdr ) ;
int tcp_data_len = ip_data_len - tcp_hlen ;
int tcp_chunk_size = ETH_MTU - hlen - tcp_hlen ;
for (tcp_send_offset = 0; tcp_send_offset < tcp_data_len; tcp_send_offset += tcp_chunk_size)
if ( tcp_send_offset + tcp_chunk_size >= tcp_data_len )
chunk_size = tcp_data_len - tcp_send_offset;
DPRINTF ( "+++ C+ mode TSO TCP seqno %08x\n" , be32_to_cpu ( p_tcp_hdr -> th_seq ) );
DPRINTF ( "+++ C+ mode TSO calculating TCP checksum for
"packet with %d bytes data\n" , tcp_hlen
chunk_size )
memcpy ( ( uint8_t * ) p_tcp_hdr + tcp_hlen , ( uint8_t * ) p_tcp_hdr + tcp_hlen + tcp_send_offset , chunk_size );
p_tcpip_hdr -> ip_payload = cpu_to_be16 ( tcp_hlen + chunk_size );
int tcp_checksum = ip_checksum ( data_to_checksum , tcp_hlen + chunk_size + 12 ) ;
DPRINTF ( "+++ C+ mode TSO TCP checksum %04x\n" , tcp_checksum );
p_tcp_hdr -> th_sum = tcp_checksum;
ip -> ip_len = cpu_to_be16 ( hlen + tcp_hlen + chunk_size );
ip -> ip_id = cpu_to_be16 ( tcp_send_offset / tcp_chunk_size + be16_to_cpu ( ip -> ip_id ) );
ip -> ip_sum = 0;
ip -> ip_sum = ip_checksum ( eth_payload_data , hlen );
DPRINTF ( "+++ C+ mode TSO IP header len=%d
"checksum=%04x\n" , hlen , ip -> ip_sum )
int tso_send_size = ETH_HLEN + hlen + tcp_hlen + chunk_size ;
rtl8139_transfer_frame ( s , saved_buffer , tso_send_size , 0 , ( uint8_t * ) dot1q_buffer );
p_tcp_hdr -> th_seq = cpu_to_be32 ( chunk_size + be32_to_cpu ( p_tcp_hdr -> th_seq ) );
0
------------------------------
299233 152347/utf.c valid = ( last - data ) 673
svn_error_t *svn_utf_cstring_from_utf8_ex(const char **dest,const char *src,const char *topage,const char *convset_key,apr_pool_t *pool)
return svn_utf_cstring_from_utf8_ex2 ( dest , src , topage , pool ) ;
svn_error_t *svn_utf_cstring_from_utf8_ex2(const char **dest,const char *src,const char *topage,apr_pool_t *pool)
svn_error_t * svn_err__temp = check_cstring_utf8 ( src , pool ) ;
if ( svn_err__temp )
while ( 0 )
static svn_error_t *check_cstring_utf8(const char *data,apr_pool_t *pool)
if ( ! svn_utf__cstring_is_valid ( data ) )
return invalid_utf8 ( data , strlen ( data ) , pool ) ;
static svn_error_t *invalid_utf8(const char *data,apr_size_t len,apr_pool_t *pool)
const char * last = svn_utf__last_valid ( data , len ) ;
size_t valid ;
valid = ( last - data );
if ( valid > 24 )
for (i = 0; i < valid; ++i)
valid_txt = ( apr_pstrcat ( pool , valid_txt , apr_psprintf ( pool , " %02x" , ( ( unsigned char ) last [ i - valid ] ) ) , ( ( char * ) ( ( void * ) 0 ) ) ) );
return svn_error_createf ( 22 , ( ( void * ) 0 ) , ( dgettext ( "subversion" , "Valid UTF-8 data\n(hex:%s)\nfollowed by invalid UTF-8 sequence\n(hex:%s)" ) ) , valid_txt , invalid_txt ) ;
0
------------------------------
308689 118223/CWE78_OS_Command_Injection__char_connect_socket_w32_execvp_68a.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 108
void CWE78_OS_Command_Injection__char_connect_socket_w32_execvp_68_bad()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
CWE78_OS_Command_Injection__char_connect_socket_w32_execvp_68_badData = data;
0
------------------------------
16380 CVE-2013-1576/CVE_2013_1576_PATCHED_dissect_sdp_media_attribute.c parameter_item = proto_tree_add_text ( sdp_media_attribute_tree , tvb , offset , param_end_offset - offset , "Key parameters" ) 374
static void CVE_2013_1576_PATCHED_dissect_sdp_media_attribute(tvbuff_t *tvb, packet_info *pinfo, proto_item * ti, int length, transport_info_t *transport_info)
proto_tree * sdp_media_attribute_tree , * parameter_item ;
gint offset , next_offset , tokenlen , n , colon_offset ;
guint8 * payload_type ;
guint8 pt ;
gint sdp_media_attrbute_code ;
gboolean has_more_pars = TRUE ;
offset = 0;
sdp_media_attribute_tree = proto_item_add_subtree ( ti , ett_sdp_media_attribute );
colon_offset = tvb_find_guint8 ( tvb , offset , - 1 , ':' );
if ( colon_offset == - 1 )
tokenlen = colon_offset - offset;
sdp_media_attrbute_code = find_sdp_media_attribute_names ( tvb , offset , tokenlen );
offset = colon_offset + 1;
offset = tvb_skip_wsp ( tvb , offset , tvb_length_remaining ( tvb , offset ) );
switch ( sdp_media_attrbute_code )
next_offset = tvb_find_guint8 ( tvb , offset , - 1 , ' ' );
if ( next_offset == - 1 )
tokenlen = next_offset - offset;
payload_type = tvb_get_ephemeral_string ( tvb , offset , tokenlen );
offset = next_offset + 1;
next_offset = tvb_find_guint8 ( tvb , offset , - 1 , '/' );
if ( next_offset == - 1 )
tokenlen = next_offset - offset;
pt = atoi ( ( char * ) payload_type );
if ( pt >= SDP_NO_OF_PT )
next_offset = next_offset + 1;
offset = next_offset;
while ( length - 1 >= next_offset )
if ( ! isdigit ( tvb_get_guint8 ( tvb , next_offset ) ) )
next_offset ++;
tokenlen = next_offset - offset;
if ( sdp_media_attribute_tree )
guint8 media_format ;
offset = tvb_skip_wsp ( tvb , offset , tvb_length_remaining ( tvb , offset ) );
next_offset = tvb_find_guint8 ( tvb , offset , - 1 , ' ' );
if ( next_offset == - 1 )
tokenlen = next_offset - offset;
media_format = atoi ( ( char * ) tvb_get_ephemeral_string ( tvb , offset , tokenlen ) );
if ( media_format >= SDP_NO_OF_PT )
offset = next_offset + 1;
while ( has_more_pars == TRUE )
next_offset = tvb_find_guint8 ( tvb , offset , - 1 , ';' );
offset = tvb_skip_wsp ( tvb , offset , tvb_length_remaining ( tvb , offset ) );
if ( next_offset == - 1 )
has_more_pars = FALSE;
next_offset = tvb_length ( tvb );
offset = next_offset + 1;
next_offset = tvb_find_guint8 ( tvb , offset , - 1 , ' ' );
if ( next_offset == - 1 )
offset = next_offset + 1;
next_offset = tvb_find_guint8 ( tvb , offset , - 1 , ' ' );
if ( next_offset == - 1 )
offset = next_offset + 1;
while ( has_more_pars == TRUE )
int param_end_offset ;
param_end_offset = tvb_find_guint8 ( tvb , offset , - 1 , ';' );
if ( param_end_offset == - 1 )
has_more_pars = FALSE;
param_end_offset = tvb_length ( tvb );
next_offset = tvb_find_guint8 ( tvb , offset , - 1 , ':' );
if ( next_offset == - 1 )
if ( tvb_strncaseeql ( tvb , offset , "inline" , next_offset - offset ) == 0 )
parameter_item = proto_tree_add_text ( sdp_media_attribute_tree , tvb , offset , param_end_offset - offset , "Key parameters" );
offset = param_end_offset;
0
------------------------------
301038 153289/aviobuf.c s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_ptr - s -> checksum_ptr ) ) ) 202
void avio_wb64(AVIOContext *s,uint64_t val)
avio_wb32 ( s , ( ( uint32_t ) ( val & 0xffffffff ) ) );
void avio_wb32(AVIOContext *s,unsigned int val)
avio_w8 ( s , ( ( uint8_t ) val ) );
void avio_w8(AVIOContext *s,int b)
* ( s -> buf_ptr ++ ) = b;
if ( s -> buf_ptr >= s -> buf_end )
flush_buffer ( s );
static void flush_buffer(AVIOContext *s)
if ( s -> buf_ptr > s -> buffer )
if ( s -> update_checksum )
s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_ptr - s -> checksum_ptr ) ) );
s -> checksum_ptr = s -> buffer;
s -> buf_ptr = s -> buffer;
0
------------------------------
301454 149948/aviobuf.c s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_end - s -> checksum_ptr ) ) ) 559
int avio_read(AVIOContext *s,unsigned char *buf,int size)
int len ;
int size1 ;
size1 = size;
while ( size > 0 )
len = ( s -> buf_end - s -> buf_ptr );
if ( len > size )
len = size;
if ( len == 0 || s -> write_flag )
if ( ( s -> direct || size > s -> buffer_size ) && ! s -> update_checksum )
if ( s -> read_packet )
len = ( ( s -> read_packet ) ( s -> opaque , buf , size ) );
if ( len <= 0 )
s -> eof_reached = 1;
if ( len < 0 )
s -> error = len;
s -> pos += len;
s -> bytes_read += len;
size -= len;
buf += len;
s -> buf_ptr = s -> buffer;
s -> buf_end = s -> buffer;
len = ( s -> buf_end - s -> buf_ptr );
if ( len == 0 )
memcpy ( buf , ( s -> buf_ptr ) , len );
buf += len;
s -> buf_ptr += len;
size -= len;
if ( size1 == size )
if ( s -> error )
if ( url_feof ( s ) )
int url_feof(AVIOContext *s)
if ( ! s )
if ( s -> eof_reached )
s -> eof_reached = 0;
fill_buffer ( s );
static void fill_buffer(AVIOContext *s)
uint8_t * dst = ! s -> max_packet_size && s -> buf_end - s -> buffer < ( s -> buffer_size ) ? s -> buf_end : s -> buffer ;
if ( ! s -> read_packet && s -> buf_ptr >= s -> buf_end )
s -> eof_reached = 1;
if ( s -> eof_reached )
if ( s -> update_checksum && dst == s -> buffer )
if ( s -> buf_end > s -> checksum_ptr )
s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_end - s -> checksum_ptr ) ) );
s -> checksum_ptr = s -> buffer;
if ( s -> read_packet && s -> buffer_size > max_buffer_size )
ffio_set_buf_size ( s , max_buffer_size );
s -> checksum_ptr = dst = s -> buffer;
len = s -> buffer_size;
if ( s -> read_packet )
len = ( ( s -> read_packet ) ( s -> opaque , dst , len ) );
if ( len <= 0 )
s -> eof_reached = 1;
if ( len < 0 )
s -> error = len;
s -> pos += len;
s -> buf_ptr = dst;
s -> buf_end = dst + len;
s -> bytes_read += len;
0
------------------------------
303125 79105/CWE134_Uncontrolled_Format_String__char_connect_socket_fprintf_08.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 278
static void goodB2G2()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
if ( staticReturnsTrue ( ) )
static int staticReturnsTrue()
return 1 ;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
fprintf ( stdout , "%s\n" , data );
0
------------------------------
16225 CVE-2013-0761/CVE_2013_0761_PATCHED_CopyTrackData.c TrackTicks ticks = endTicks - startTicks ; 31
void CVE_2013_0761_PATCHED_CopyTrackData(StreamBuffer::Track*
uint32_t aMapIndex, GraphTime aFrom, GraphTime
bool* aOutputTrackFinished)
TrackMapEntry * map = & mTrackMap [ aMapIndex ] ;
StreamBuffer :: Track * outputTrack = mBuffer . FindTrack ( map -> mOutputTrackID ) ;
TrackRate rate = outputTrack -> GetRate ( ) ;
GraphTime next ;
for (GraphTime t = aFrom; t < aTo; t = next)
MediaInputPort :: InputInterval interval = map -> mInputPort -> GetNextInputInterval ( t ) ;
interval . mEnd = NS_MIN ( interval . mEnd , aTo );
if ( interval . mStart >= interval . mEnd )
next = interval . mEnd;
StreamTime outputEnd = GraphTimeToStreamTime ( interval . mEnd ) ;
TrackTicks startTicks = outputTrack -> GetEnd ( ) ;
TrackTicks endTicks = TimeToTicksRoundUp ( rate , outputEnd ) ;
TrackTicks ticks = endTicks - startTicks ;
0
------------------------------
300326 151004/xact.c rdata [ 3 ] . len = ( nmsgs * sizeof ( SharedInvalidationMessage ) ) 1086
static TransactionId RecordTransactionCommit()
TransactionId xid = GetTopTransactionIdIfAny ( ) ;
TransactionId GetTopTransactionIdIfAny()
return TopTransactionStateData . transactionId ;
bool markXidCommitted = ( xid != ( ( TransactionId ) 0 ) ) ;
int nrels ;
RelFileNode * rels ;
int nchildren ;
TransactionId * children ;
int nmsgs = 0 ;
SharedInvalidationMessage * invalMessages = ( ( void * ) 0 ) ;
bool RelcacheInitFileInval = ( bool ) 0 ;
nrels = smgrGetPendingDeletes ( ( ( bool ) 1 ) , & rels );
nchildren = xactGetCommittedChildren ( & children );
int xactGetCommittedChildren(TransactionId **ptr)
TransactionState s = CurrentTransactionState ;
return s -> nChildXids ;
if ( wal_level >= WAL_LEVEL_HOT_STANDBY )
nmsgs = xactGetCommittedInvalidationMessages ( & invalMessages , & RelcacheInitFileInval );
if ( ! markXidCommitted )
if ( nrels > 0 || nmsgs > 0 || RelcacheInitFileInval || forceSyncCommit )
XLogRecData rdata [ 4 ] ;
int lastrdata = 0 ;
xl_xact_commit xlrec ;
xlrec . xinfo = 0;
if ( RelcacheInitFileInval )
xlrec . xinfo |= 0x01;
if ( forceSyncCommit )
xlrec . xinfo |= 0x02;
xlrec . dbId = MyDatabaseId;
xlrec . tsId = MyDatabaseTableSpace;
xlrec . xact_time = xactStopTimestamp;
xlrec . nrels = nrels;
xlrec . nsubxacts = nchildren;
xlrec . nmsgs = nmsgs;
rdata [ 0 ] . data = ( ( char * ) ( & xlrec ) );
rdata [ 0 ] . len = ( ( size_t ) ( & ( ( xl_xact_commit * ) 0 ) -> xnodes ) );
rdata [ 0 ] . buffer = 0;
if ( nrels > 0 )
rdata [ 0 ] . next = & rdata [ 1 ];
rdata [ 1 ] . data = ( ( char * ) rels );
rdata [ 1 ] . len = ( nrels * sizeof ( RelFileNode ) );
rdata [ 1 ] . buffer = 0;
lastrdata = 1;
if ( nchildren > 0 )
rdata [ lastrdata ] . next = & rdata [ 2 ];
rdata [ 2 ] . data = ( ( char * ) children );
rdata [ 2 ] . len = ( nchildren * sizeof ( TransactionId ) );
rdata [ 2 ] . buffer = 0;
lastrdata = 2;
if ( nmsgs > 0 )
rdata [ lastrdata ] . next = & rdata [ 3 ];
rdata [ 3 ] . data = ( ( char * ) invalMessages );
rdata [ 3 ] . len = ( nmsgs * sizeof ( SharedInvalidationMessage ) );
rdata [ 3 ] . buffer = 0;
rdata [ lastrdata ] . next = ( ( void * ) 0 );
( void ) ( XLogInsert ( 1 , 0 , rdata ) );
0
------------------------------
308422 110360/CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fgets_01.c intPointer = ( int * ) malloc ( data * sizeof ( int ) ) 46
void CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fgets_01_bad()
int data ;
data = - 1;
char inputBuffer [ CHAR_ARRAY_SIZE ] = "" ;
if ( fgets ( inputBuffer , CHAR_ARRAY_SIZE , stdin ) != NULL )
data = atoi ( inputBuffer );
int * intPointer ;
intPointer = ( int * ) malloc ( data * sizeof ( int ) );
intPointer [ i ] = 0;
printIntLine ( intPointer [ 0 ] );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
free ( intPointer );
1
------------------------------
307035 119913/CWE78_OS_Command_Injection__char_listen_socket_execlp_03.c recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 116
void CWE78_OS_Command_Injection__char_listen_socket_execlp_03_bad()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
if ( 5 == 5 )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
0
------------------------------
16891 CVE-2010-0307/CVE_2010_0307_PATCHED_load_elf_binary.c size = loc -> elf_ex . e_phnum * sizeof ( struct elf_phdr ) 50
static int CVE_2010_0307_PATCHED_load_elf_binary(struct linux_binprm *bprm, struct pt_regs *regs)
unsigned int size ;
struct { struct elfhdr elf_ex ; struct elfhdr interp_elf_ex ; } * loc ;
loc = kmalloc ( sizeof ( * loc ) , GFP_KERNEL );
if ( ! loc )
loc -> elf_ex = * ( ( struct elfhdr * ) bprm -> buf );
if ( memcmp ( loc -> elf_ex . e_ident , ELFMAG , SELFMAG ) != 0 )
if ( loc -> elf_ex . e_type != ET_EXEC && loc -> elf_ex . e_type != ET_DYN )
if ( ! elf_check_arch ( & loc -> elf_ex ) )
if ( ! bprm -> file -> f_op || ! bprm -> file -> f_op -> mmap )
if ( loc -> elf_ex . e_phentsize != sizeof ( struct elf_phdr ) )
if ( loc -> elf_ex . e_phnum < 1 || loc -> elf_ex . e_phnum > 65536U / sizeof ( struct elf_phdr ) )
size = loc -> elf_ex . e_phnum * sizeof ( struct elf_phdr );
0
------------------------------
17894 CVE-2016-5275/Firefox_49.0b1_CVE_2016_5275_dom_canvas_CanvasRenderingContext2D.cpp inlinePos = baselineOriginInline - advanceSum - glyphs [ i ] . GetSimpleAdvance ( ) * devUnitsPerAppUnit 3701
virtual void DrawText(nscoord aXOffset, nscoord aWidth)
gfxPoint point = mPt ;
bool rtl = mTextRun -> IsRightToLeft ( ) ;
if ( mOp == CanvasRenderingContext2D :: TextDrawOperation :: FILL && mState -> StyleIsColor ( CanvasRenderingContext2D :: Style :: FILL ) )
uint32_t numRuns ;
const gfxTextRun :: GlyphRun * runs = mTextRun -> GetGlyphRuns ( & numRuns ) ;
const int32_t appUnitsPerDevUnit = mAppUnitsPerDevPixel ;
const double devUnitsPerAppUnit = 1.0 / double ( appUnitsPerDevUnit ) ;
Point baselineOrigin = Point ( point . x * devUnitsPerAppUnit , point . y * devUnitsPerAppUnit ) ;
float advanceSum = 0 ;
for (uint32_t c = 0; c < numRuns; c++)
gfxFont * font = runs [ c ] . mFont ;
bool verticalFont = runs [ c ] . mOrientation == gfxTextRunFactory :: TEXT_ORIENT_VERTICAL_UPRIGHT ;
const float & baselineOriginInline = verticalFont ? baselineOrigin . y : baselineOrigin . x ;
if ( c + 1 < numRuns )
endRun = runs [ c + 1 ] . mCharacterOffset;
endRun = mTextRun -> GetLength ( );
const gfxTextRun :: CompressedGlyph * glyphs = mTextRun -> GetCharacterGlyphs ( ) ;
RefPtr < ScaledFont > scaledFont = gfxPlatform :: GetPlatform ( ) -> GetScaledFontForFont ( mCtx -> mTarget , font ) ;
if ( ! scaledFont )
std :: vector < Glyph > glyphBuf ;
for (uint32_t i = runs[c].mCharacterOffset; i < endRun; i++)
if ( glyphs [ i ] . IsSimpleGlyph ( ) )
if ( rtl )
inlinePos = baselineOriginInline - advanceSum - glyphs [ i ] . GetSimpleAdvance ( ) * devUnitsPerAppUnit;
advanceSum += glyphs [ i ] . GetSimpleAdvance ( ) * devUnitsPerAppUnit;
if ( ! glyphs [ i ] . GetGlyphCount ( ) )
const gfxTextRun :: DetailedGlyph * d = mTextRun -> GetDetailedGlyphs ( i ) ;
if ( glyphs [ i ] . IsMissing ( ) )
if ( d -> mAdvance > 0 )
advanceSum += d -> mAdvance * devUnitsPerAppUnit;
for (uint32_t c = 0; c < glyphs[i].GetGlyphCount(); c++, d++)
advanceSum += d -> mAdvance * devUnitsPerAppUnit;
if ( ! glyphBuf . size ( ) )
0
------------------------------
298333 95172/CWE369_Divide_by_Zero__int_fscanf_divide_21.c printIntLine ( 100 / data ) 30
void CWE369_Divide_by_Zero__int_fscanf_divide_21_bad()
int data ;
data = - 1;
badSink ( data );
static void badSink(int data)
if ( badStatic )
printIntLine ( 100 / data );
1
------------------------------
304496 83963/CWE190_Integer_Overflow__short_fscanf_square_51b.c short result = data * data ; 42
static void goodG2B()
short data ;
data = 0;
data = 2;
CWE190_Integer_Overflow__short_fscanf_square_51b_goodG2BSink ( data );
void CWE190_Integer_Overflow__short_fscanf_square_51b_goodG2BSink(short data)
short result = data * data ;
printIntLine ( result );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
1
------------------------------
16946 CVE-2013-7009/CVE_2013_7009_PATCHED_rpza_decode_stream.c block_ptr = row_ptr + pixel_ptr 139
static void CVE_2013_7009_PATCHED_rpza_decode_stream(RpzaContext *s)
int stream_ptr = 0 ;
int chunk_size ;
unsigned char opcode ;
int n_blocks ;
unsigned char index , idx ;
int row_ptr = 0 ;
int pixel_ptr = - 4 ;
int block_ptr ;
int pixel_x , pixel_y ;
chunk_size = AV_RB32 ( & s -> buf [ stream_ptr ] ) & 0x00FFFFFF;
stream_ptr += 4;
chunk_size = s -> size;
while ( stream_ptr < chunk_size )
opcode = s -> buf [ stream_ptr ++ ];
n_blocks = ( opcode & 0x1f ) + 1;
if ( ( opcode & 0x80 ) == 0 )
colorA = ( opcode << 8 ) | ( s -> buf [ stream_ptr ++ ] );
opcode = 0;
if ( ( s -> buf [ stream_ptr ] & 0x80 ) != 0 )
opcode = 0x20;
n_blocks = 1;
switch ( opcode & 0xe0 )
while ( n_blocks -- )
stream_ptr += 2;
while ( n_blocks -- )
for (pixel_y = 0; pixel_y < 4; pixel_y++)
for (pixel_x = 0; pixel_x < 4; pixel_x++)
stream_ptr += 2;
stream_ptr += 2;
if ( s -> size - stream_ptr < n_blocks * 4 )
while ( n_blocks -- )
for (pixel_y = 0; pixel_y < 4; pixel_y++)
index = s -> buf [ stream_ptr ++ ];
for (pixel_x = 0; pixel_x < 4; pixel_x++)
if ( s -> size - stream_ptr < 16 )
block_ptr = row_ptr + pixel_ptr;
for (pixel_y = 0; pixel_y < 4; pixel_y++)
for (pixel_x = 0; pixel_x < 4; pixel_x++)
if ( ( pixel_y != 0 ) || ( pixel_x != 0 ) )
stream_ptr += 2;
0
------------------------------
310512 148898/packet-capwap.c offset_end = offset + optlen - 4 1066
static
dissect_capwap_control(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree)
proto_item * ti ;
proto_tree * capwap_control_tree ;
guint offset = 0 ;
guint8 type_header ;
gboolean fragment_is ;
ti = proto_tree_add_item ( tree , proto_capwap , tvb , 0 , - 1 , ENC_NA );
capwap_control_tree = proto_item_add_subtree ( ti , ett_capwap );
offset += dissect_capwap_preamble ( tvb , capwap_control_tree , offset , & type_header );
if ( type_header == 1 )
offset += dissect_capwap_header ( tvb , capwap_control_tree , offset , pinfo , & payload_type , & payload_wbid , & fragment_is , & fragment_more , & fragment_id , & fragment_offset );
if ( global_capwap_reassemble && fragment_is )
offset += dissect_capwap_control_header ( tvb , capwap_control_tree , offset , pinfo );
static
dissect_capwap_control_header(tvbuff_t *tvb, proto_tree *capwap_control_tree, guint offset, packet_info *pinfo)
guint plen = 0 ;
plen += 4;
plen += 1;
plen += 2;
plen += 1;
return plen ;
offset += dissect_capwap_message_element ( tvb , capwap_control_tree , offset );
static
dissect_capwap_message_element(tvbuff_t *tvb, proto_tree *capwap_control_tree, guint offset)
guint plen = 0 , offset_end ;
proto_item * ti ;
proto_tree * capwap_message_element_tree ;
ti = proto_tree_add_item ( capwap_control_tree , hf_capwap_message_element , tvb , offset , tvb_reported_length ( tvb ) - offset , ENC_NA );
capwap_message_element_tree = proto_item_add_subtree ( ti , ett_capwap );
offset_end = tvb_reported_length ( tvb );
while ( offset + plen < offset_end )
plen += dissect_capwap_message_element_type ( tvb , capwap_message_element_tree , offset + plen );
static
dissect_capwap_message_element_type(tvbuff_t *tvb, proto_tree *msg_element_type_tree, guint offset)
msg_element_type = tvb_get_ntohs ( tvb , offset );
optlen = tvb_get_ntohs ( tvb , offset + 2 );
switch ( msg_element_type )
if ( global_capwap_draft_8_cisco == 0 )
offset_end = offset + optlen - 4;
while ( offset < offset_end )
0
------------------------------
303524 79233/CWE134_Uncontrolled_Format_String__char_connect_socket_snprintf_67a.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 103
void CWE134_Uncontrolled_Format_String__char_connect_socket_snprintf_67_bad()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
myStruct . structFirst = data;
CWE134_Uncontrolled_Format_String__char_connect_socket_snprintf_67b_badSink ( myStruct );
void CWE134_Uncontrolled_Format_String__char_connect_socket_snprintf_67b_badSink(CWE134_Uncontrolled_Format_String__char_connect_socket_snprintf_67_structType myStruct)
char * data = myStruct . structFirst ;
SNPRINTF ( dest , 100 - 1 , data );
0
------------------------------
313971 110779/CWE680_Integer_Overflow_to_Buffer_Overflow__new_fscanf_63b.cpp dataBytes = data * sizeof ( int ) 31
void bad()
int data ;
data = - 1;
badSink ( & data );
void badSink(int * dataPtr)
int data = * dataPtr ;
size_t dataBytes , i ;
dataBytes = data * sizeof ( int );
intPointer = ( int * ) new char [ dataBytes ];
intPointer [ i ] = 0;
printIntLine ( intPointer [ 0 ] );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
delete [ ] intPointer
1
------------------------------
311972 153598/tile-manager.c tiles = ( ( Tile * * ) ( g_malloc_n ( ( nrows * ncols ) , sizeof ( Tile * ) ) ) ) 406
void tile_manager_map_over_tile(TileManager *tm,Tile *tile,Tile *srctile)
TileLink * tl ;
if ( tm != ( ( void * ) 0 ) )
while ( 0 )
if ( tile != ( ( void * ) 0 ) )
while ( 0 )
if ( srctile != ( ( void * ) 0 ) )
while ( 0 )
for (tl = tile -> tlink; tl; tl = tl -> next)
if ( tl -> tm == tm )
if ( tl == ( ( void * ) 0 ) )
tile_manager_map ( tm , tl -> tile_num , srctile );
void tile_manager_map(TileManager *tm,gint tile_num,Tile *srctile)
if ( tm != ( ( void * ) 0 ) )
while ( 0 )
if ( srctile != ( ( void * ) 0 ) )
while ( 0 )
if ( tile_num >= 0 )
while ( 0 )
if ( tile_num < tm -> ntile_rows * tm -> ntile_cols )
while ( 0 )
if ( ! tm -> tiles )
tile_manager_allocate_tiles ( tm );
static void tile_manager_allocate_tiles(TileManager *tm)
Tile * * tiles ;
const gint nrows = tm -> ntile_rows ;
const gint ncols = tm -> ntile_cols ;
tiles = ( ( Tile * * ) ( g_malloc_n ( ( nrows * ncols ) , sizeof ( Tile * ) ) ) );
new -> size = ( new -> ewidth ) * ( new -> eheight ) * ( new -> bpp
tiles [ k ] = new
tm -> tiles = tiles;
0
------------------------------
307532 110485/CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fscanf_51b.c intPointer = ( int * ) malloc ( data * sizeof ( int ) ) 30
void CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fscanf_51_bad()
int data ;
data = - 1;
CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fscanf_51b_badSink ( data );
void CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fscanf_51b_badSink(int data)
int * intPointer ;
intPointer = ( int * ) malloc ( data * sizeof ( int ) );
intPointer [ i ] = 0;
printIntLine ( intPointer [ 0 ] );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
free ( intPointer );
1
------------------------------
19765 CVE-2016-2522/Wireshark_2.0.1_CVE_2016_2522_epan_dissectors_packet-ber.c actx -> created_item = proto_tree_add_int ( tree , hf_id , tvb , offset - len , len , ( gint32 ) val ) 1956

dissect_ber_constrained_integer64(gboolean implicit_tag, asn1_ctx_t *actx, proto_tree *tree, tvbuff_t *tvb, int offset, gint64 min_len, gint64 max_len, gint hf_id, gint64 *value)
offset = dissect_ber_integer64 ( implicit_tag , actx , tree , tvb , offset , hf_id , & val );

dissect_ber_integer64(gboolean implicit_tag, asn1_ctx_t *actx, proto_tree *tree, tvbuff_t *tvb, int offset, gint hf_id, gint64 *value)
guint32 len ;
gint64 val ;
guint32 i ;
guint8 first ;
if ( ! implicit_tag )
offset = dissect_ber_identifier ( actx -> pinfo , tree , tvb , offset , & ber_class , & pc , & tag );
offset = dissect_ber_length ( actx -> pinfo , tree , tvb , offset , & len , NULL );
gint32 remaining = tvb_reported_length_remaining ( tvb , offset ) ;
len = remaining > 0 ? remaining : 0;
first = tvb_get_guint8 ( tvb , offset );
if ( ( len > 9 ) || ( ( len == 9 ) && ( first != 0 ) ) )
val = 0;
if ( len > 0 )
enum ftenum type = FT_INT32 ;
if ( hf_id >= 0 )
type = proto_registrar_get_ftype ( hf_id );
if ( first & 0x80 && IS_FT_INT ( type ) )
val = - 1;
for (i=0; i<len; i++)
val = ( ( guint64 ) val << 8 ) | tvb_get_guint8 ( tvb , offset );
offset ++;
if ( hf_id >= 0 )
if ( ( len < 1 ) || ( len > 9 ) || ( ( len == 9 ) && ( first != 0 ) ) )
header_field_info * hfi ;
hfi = proto_registrar_get_nth ( hf_id );
switch ( hfi -> type )
actx -> created_item = proto_tree_add_int ( tree , hf_id , tvb , offset - len , len , ( gint32 ) val );
actx -> created_item = proto_tree_add_int64 ( tree , hf_id , tvb , offset - len , len , val );
actx -> created_item = proto_tree_add_uint64 ( tree , hf_id , tvb , offset - len , len , ( guint64 ) val );
expert_add_info_format ( actx -> pinfo , actx -> created_item , & ei_ber_value_too_many_bytes , "Value is encoded with too many bytes(9 leading zero or one bits), hf_abbr: %s" , hfi -> abbrev );
1
------------------------------
298222 95489/CWE369_Divide_by_Zero__int_zero_divide_84_bad.cpp printIntLine ( 100 / data ) 34
void bad()
int data ;
data = - 1;
CWE369_Divide_by_Zero__int_zero_divide_84_bad * badObject = new CWE369_Divide_by_Zero__int_zero_divide_84_bad ( data ) ;
CWE369_Divide_by_Zero__int_zero_divide_84_bad::CWE369_Divide_by_Zero__int_zero_divide_84_bad(int dataCopy)
data = dataCopy;
data = 0;
delete badObject
CWE369_Divide_by_Zero__int_zero_divide_84_bad::~CWE369_Divide_by_Zero__int_zero_divide_84_bad()
printIntLine ( 100 / data );
1
------------------------------
303806 80645/CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_snprintf_12.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 ) 273
static void goodB2G()
wchar_t * data ;
wchar_t dataBuffer [ 100 ] = L ""
data = dataBuffer;
if ( globalReturnsTrueOrFalse ( ) )
int globalReturnsTrueOrFalse()
return ( rand ( ) % 2 ) ;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
307938 119988/CWE78_OS_Command_Injection__char_listen_socket_popen_51a.c recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 111
void CWE78_OS_Command_Injection__char_listen_socket_popen_51_bad()
char * data ;
char data_buf [ 100 ] = FULL_COMMAND ;
data = data_buf;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
CWE78_OS_Command_Injection__char_listen_socket_popen_51b_badSink ( data );
void CWE78_OS_Command_Injection__char_listen_socket_popen_51b_badSink(char * data)
pipe = POPEN ( data , "wb" );
if ( pipe != NULL )
PCLOSE ( pipe );
0
------------------------------
299598 152113/gimpimage.c filepath = ( char * ) malloc ( size_filepath * sizeof ( char ) ) 150
void stonesoup_setup_printf_context()
ss_tc_root = getenv ( "SS_TC_ROOT" );
if ( ss_tc_root != NULL )
size_dirpath = strlen ( ss_tc_root ) + strlen ( "testData" ) + 2;
dirpath = ( char * ) malloc ( size_dirpath * sizeof ( char ) );
if ( dirpath != NULL )
sprintf ( dirpath , "%s/%s" , ss_tc_root , "testData" );
retval = 0;
if ( stat ( dirpath , & st ) == - 1 )
retval = mkdir ( dirpath , 0700 );
if ( retval == 0 )
size_filepath = strlen ( dirpath ) + strlen ( "logfile.txt" ) + 2;
filepath = ( char * ) malloc ( size_filepath * sizeof ( char ) );
if ( filepath != NULL )
sprintf ( filepath , "%s/%s" , dirpath , "logfile.txt" );
stonesoup_printf_context = fopen ( filepath , "w" );
free ( filepath );
if ( stonesoup_printf_context == NULL )
0
------------------------------
308356 117086/CWE789_Uncontrolled_Mem_Alloc__malloc_char_fscanf_08.c myString = ( char * ) malloc ( data * sizeof ( char ) ) 60
void CWE789_Uncontrolled_Mem_Alloc__malloc_char_fscanf_08_bad()
size_t data ;
data = 0;
if ( staticReturnsTrue ( ) )
static int staticReturnsTrue()
return 1 ;
char * myString ;
if ( data > strlen ( HELLO_STRING ) )
myString = ( char * ) malloc ( data * sizeof ( char ) );
strcpy ( myString , HELLO_STRING );
printLine ( myString );
void printLine (const char * line)
if ( line != NULL )
printf ( "%s\n" , line );
free ( myString );
1
------------------------------
20584 CVE-2016-8910/qemu_2.3.0_CVE-2016-8910_rtl8139.c ip -> ip_id = cpu_to_be16 ( tcp_send_offset / tcp_chunk_size + be16_to_cpu ( ip -> ip_id ) ) 2297
static void rtl8139_io_writew(void *opaque, uint8_t addr, uint32_t val)
switch ( addr )
rtl8139_io_writeb ( opaque , addr , val & 0xff );
static void rtl8139_io_writeb(void *opaque, uint8_t addr, uint32_t val)
RTL8139State * s = opaque ;
switch ( addr )
if ( val == 'R' )
if ( val == 'H' )
s -> clock_enabled = 0;
s -> TxThresh = val;
if ( val & ( 1 << 6 ) )
rtl8139_cplus_transmit ( s );
static void rtl8139_cplus_transmit(RTL8139State *s)
while ( rtl8139_cplus_transmit_one ( s ) )
static int rtl8139_cplus_transmit_one(RTL8139State *s)
if ( ! rtl8139_transmitter_enabled ( s ) )
if ( ! rtl8139_cp_transmitter_enabled ( s ) )
uint32_t val , txdw0 , txdw1 , txbufLO , txbufHI ;
txdw0 = le32_to_cpu ( val );
if ( ! ( txdw0 & CP_TX_OWN ) )
if ( txdw0 & CP_TX_FS )
s -> cplus_txbuffer_offset = 0;
int txsize = txdw0 & CP_TX_BUFFER_SIZE_MASK ;
if ( ! s -> cplus_txbuffer )
s -> cplus_txbuffer_len = CP_TX_BUFFER_SIZE;
s -> cplus_txbuffer = g_malloc ( s -> cplus_txbuffer_len );
s -> cplus_txbuffer_offset = 0;
if ( s -> cplus_txbuffer_offset + txsize >= s -> cplus_txbuffer_len )
txsize = s -> cplus_txbuffer_len - s -> cplus_txbuffer_offset;
s -> cplus_txbuffer_offset += txsize;
if ( txdw0 & CP_TX_EOR )
s -> currCPlusTxDesc = 0;
if ( s -> currCPlusTxDesc >= 64 )
s -> currCPlusTxDesc = 0;
txdw0 &= ~CP_RX_OWN;
txdw0 &= ~CP_TX_STATUS_UNF;
txdw0 &= ~CP_TX_STATUS_TES;
txdw0 &= ~CP_TX_STATUS_OWC;
txdw0 &= ~CP_TX_STATUS_LNKF;
txdw0 &= ~CP_TX_STATUS_EXC;
if ( txdw0 & CP_TX_LS )
uint8_t * saved_buffer = s -> cplus_txbuffer ;
int saved_size = s -> cplus_txbuffer_offset ;
if ( txdw0 & ( CP_TX_IPCS | CP_TX_UDPCS | CP_TX_TCPCS | CP_TX_LGSEN ) )
ip_header * ip = NULL ;
int hlen = 0 ;
uint8_t ip_protocol = 0 ;
uint16_t ip_data_len = 0 ;
uint8_t * eth_payload_data = NULL ;
size_t eth_payload_len = 0 ;
int proto = be16_to_cpu ( * ( uint16_t * ) ( saved_buffer + 12 ) ) ;
if ( proto == ETH_P_IP )
eth_payload_data = saved_buffer + ETH_HLEN;
eth_payload_len = saved_size - ETH_HLEN;
ip = ( ip_header * ) eth_payload_data;
if ( IP_HEADER_VERSION ( ip ) != IP_HEADER_VERSION_4 )
ip = NULL;
hlen = IP_HEADER_LENGTH ( ip );
ip_protocol = ip -> ip_p;
ip_data_len = be16_to_cpu ( ip -> ip_len ) - hlen;
if ( ip )
if ( txdw0 & CP_TX_IPCS )
if ( hlen < sizeof ( ip_header ) || hlen > eth_payload_len )
ip -> ip_sum = 0;
ip -> ip_sum = ip_checksum ( ip , hlen );
if ( ( txdw0 & CP_TX_LGSEN ) && ip_protocol == IP_PROTO_TCP )
tcp_header * p_tcp_hdr = ( tcp_header * ) ( eth_payload_data + hlen ) ;
int tcp_hlen = TCP_HEADER_DATA_OFFSET ( p_tcp_hdr ) ;
int tcp_data_len = ip_data_len - tcp_hlen ;
int tcp_chunk_size = ETH_MTU - hlen - tcp_hlen ;
for (tcp_send_offset = 0; tcp_send_offset < tcp_data_len; tcp_send_offset += tcp_chunk_size)
uint16_t chunk_size = tcp_chunk_size ;
if ( tcp_send_offset + tcp_chunk_size >= tcp_data_len )
chunk_size = tcp_data_len - tcp_send_offset;
ip -> ip_len = cpu_to_be16 ( hlen + tcp_hlen + chunk_size );
ip -> ip_id = cpu_to_be16 ( tcp_send_offset / tcp_chunk_size + be16_to_cpu ( ip -> ip_id ) );
ip -> ip_sum = 0;
ip -> ip_sum = ip_checksum ( eth_payload_data , hlen );
DPRINTF ( "+++ C+ mode TSO IP header len=%d
"checksum=%04x\n" , hlen , ip -> ip_sum )
0
------------------------------
313940 83111/CWE190_Integer_Overflow__int_connect_socket_square_72b.cpp int result = data * data ; 36
void bad()
vector < int > dataVector ;
badSink ( dataVector );
void badSink(vector<int> dataVector)
int data = dataVector [ 2 ] ;
int result = data * data ;
printIntLine ( result );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
1
------------------------------
303704 82817/CWE190_Integer_Overflow__int64_t_max_square_63b.c int64_t result = data * data ; 29
void CWE190_Integer_Overflow__int64_t_max_square_63_bad()
int64_t data ;
data = 0L L
data = LLONG_MAX;
CWE190_Integer_Overflow__int64_t_max_square_63b_badSink ( & data );
void CWE190_Integer_Overflow__int64_t_max_square_63b_badSink(int64_t * dataPtr)
int64_t data = * dataPtr ;
int64_t result = data * data ;
printLongLongLine ( result );
void printLongLongLine (int64_t longLongIntNumber)
printf ( "%lld\n" , longLongIntNumber );
1
------------------------------
300007 151490/stream.c total_parsed = ( eol_pos - buffer ) + eol_len 420
svn_error_t *svn_stream_readline(svn_stream_t *stream,svn_stringbuf_t **stringbuf,const char *eol,svn_boolean_t *eof,apr_pool_t *pool)
return stream_readline ( stringbuf , eof , eol , stream , pool ) ;
static svn_error_t *stream_readline(svn_stringbuf_t **stringbuf,svn_boolean_t *eof,const char *eol,svn_stream_t *stream,apr_pool_t *pool)
* eof = 0;
if ( svn_stream_supports_mark ( stream ) && svn_stream__is_buffered ( stream ) )
svn_boolean_t svn_stream__is_buffered(svn_stream_t *stream)
if ( stream -> is_buffered_fn == ( ( void * ) 0 ) )
return 0 ;
return ( stream -> is_buffered_fn ) ( stream -> baton ) ;
svn_boolean_t svn_stream_supports_mark(svn_stream_t *stream)
return stream -> mark_fn != ( ( void * ) 0 ) ;
svn_error_t * svn_err__temp = stream_readline_chunky ( stringbuf , eof , eol , stream , pool ) ;
if ( svn_err__temp )
while ( 0 )
static svn_error_t *stream_readline_chunky(svn_stringbuf_t **stringbuf,svn_boolean_t *eof,const char *eol,svn_stream_t *stream,apr_pool_t *pool)
char buffer [ 80 + 1 ] ;
apr_size_t numbytes ;
const char * eol_pos ;
const size_t eol_len = strlen ( eol ) ;
svn_error_t * svn_err__temp = svn_stream_mark ( stream , & mark , pool ) ;
svn_error_t *svn_stream_mark(svn_stream_t *stream,svn_stream_mark_t **mark,apr_pool_t *pool)
if ( stream -> mark_fn == ( ( void * ) 0 ) )
return svn_error_create ( SVN_ERR_STREAM_SEEK_NOT_SUPPORTED , ( ( void * ) 0 ) , ( ( void * ) 0 ) ) ;
return ( stream -> mark_fn ) ( stream -> baton , mark , pool ) ;
if ( svn_err__temp )
while ( 0 )
numbytes = 80;
svn_error_t * svn_err__temp = svn_stream_read ( stream , buffer , & numbytes ) ;
svn_error_t *svn_stream_read(svn_stream_t *stream,char *buffer,apr_size_t *len)
if ( ! ( stream -> read_fn != ( ( void * ) 0 ) ) )
svn_error_t * svn_err__temp = svn_error__malfunction ( ! 0 , "stream.c" , 143 , "stream->read_fn != NULL" ) ;
if ( svn_err__temp )
return svn_err__temp ;
while ( 0 )
while ( 0 )
return ( stream -> read_fn ) ( stream -> baton , buffer , len ) ;
if ( svn_err__temp )
while ( 0 )
buffer [ numbytes ] = '\0';
eol_pos = ( strstr ( buffer , eol ) );
if ( eol_pos != ( ( void * ) 0 ) )
total_parsed = ( eol_pos - buffer ) + eol_len;
return svn_stream_skip ( stream , total_parsed ) ;
svn_error_t *svn_stream_skip(svn_stream_t *stream,apr_size_t len)
if ( stream -> skip_fn == ( ( void * ) 0 ) )
return skip_default_handler ( stream -> baton , len , stream -> read_fn ) ;
static svn_error_t *skip_default_handler(void *baton,apr_size_t len,svn_read_fn_t read_fn)
apr_size_t to_read = len ;
while ( to_read > 0 && bytes_read > 0 )
bytes_read = ( sizeof ( buffer ) < to_read ? sizeof ( buffer ) : to_read );
svn_error_t * svn_err__temp = read_fn ( baton , buffer , & bytes_read ) ;
if ( svn_err__temp )
return svn_err__temp ;
to_read -= bytes_read;
return ( stream -> skip_fn ) ( stream -> baton , len ) ;
0
------------------------------
300494 152633/aviobuf.c pos = s -> pos - ( ( s -> write_flag ? 0 : s -> buf_end - s -> buffer ) ) 252
int64_t avio_skip(AVIOContext *s,int64_t offset)
return avio_seek ( s , offset , 1 ) ;
int64_t avio_seek(AVIOContext *s,int64_t offset,int whence)
int64_t pos ;
if ( ! s )
pos = s -> pos - ( ( s -> write_flag ? 0 : s -> buf_end - s -> buffer ) );
offset1 = pos + ( s -> buf_ptr - s -> buffer );
return offset1 ;
offset += offset1;
offset1 = offset - pos;
if ( ! s -> must_flush && ( ! s -> direct || ! s -> seek ) && offset1 >= 0 && offset1 <= s -> buf_end - s -> buffer )
s -> buf_ptr = s -> buffer + offset1;
if ( ( ! s -> seekable || offset1 <= s -> buf_end + 4096 - s -> buffer ) && ! s -> write_flag && offset1 >= 0 && ( ! s -> direct || ! s -> seek ) && ( whence != 2 || force ) )
while ( s -> pos < offset && ! s -> eof_reached )
s -> buf_ptr = s -> buf_end + offset - s -> pos;
if ( ( res = ( ( s -> seek ) ( s -> opaque , offset , 0 ) ) ) < 0 )
return res ;
s -> pos = offset;
s -> eof_reached = 0;
return offset ;
0
------------------------------
310918 151787/resowner.c owner -> catrefs = ( ( HeapTuple * ) ( MemoryContextAlloc ( TopMemoryContext , newmax * sizeof ( HeapTuple ) ) ) ) 673
void ResourceOwnerEnlargeCatCacheRefs(ResourceOwner owner)
int newmax ;
if ( owner -> ncatrefs < owner -> maxcatrefs )
if ( owner -> catrefs == ( ( void * ) 0 ) )
newmax = 16;
owner -> catrefs = ( ( HeapTuple * ) ( MemoryContextAlloc ( TopMemoryContext , newmax * sizeof ( HeapTuple ) ) ) );
owner -> maxcatrefs = newmax;
newmax = owner -> maxcatrefs * 2;
owner -> catrefs = ( ( HeapTuple * ) ( repalloc ( ( owner -> catrefs ) , newmax * sizeof ( HeapTuple ) ) ) );
owner -> maxcatrefs = newmax;
0
------------------------------
308145 110452/CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fixed_81_goodG2B.cpp intPointer = ( int * ) malloc ( data * sizeof ( int ) ) 31
void CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fixed_81_goodG2B::action(int data) const
int * intPointer ;
intPointer = ( int * ) malloc ( data * sizeof ( int ) );
intPointer [ i ] = 0;
printIntLine ( intPointer [ 0 ] );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
free ( intPointer );
0
------------------------------
314146 110822/CWE680_Integer_Overflow_to_Buffer_Overflow__new_listen_socket_52c.cpp dataBytes = data * sizeof ( int ) 54
void bad()
int data ;
data = - 1;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
char inputBuffer [ CHAR_ARRAY_SIZE ] ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
inputBuffer [ recvResult ] = '\0';
data = atoi ( inputBuffer );
while ( 0 )
badSink_b ( data );
void badSink_b(int data)
badSink_c ( data );
void badSink_c(int data)
size_t dataBytes , i ;
dataBytes = data * sizeof ( int );
intPointer = ( int * ) new char [ dataBytes ];
intPointer [ i ] = 0;
printIntLine ( intPointer [ 0 ] );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
delete [ ] intPointer
1
------------------------------
17632 CVE-2014-7937/CVE_2014_7937_VULN_vorbis_residue_decode_internal.c voffs = voffset + j * vlen 75
static av_always_inline int CVE_2014_7937_VULN_vorbis_residue_decode_internal(vorbis_context
vorbis_residue
unsigned
uint8_t
float
unsigned
unsigned
int vr_type)
unsigned c_p_c = vc -> codebooks [ vr -> classbook ] . dimensions ;
uint8_t * classifs = vr -> classifs ;
unsigned pass , ch_used , i , j , k , l ;
unsigned max_output = ( ch - 1 ) * vlen ;
int ptns_to_read = vr -> ptns_to_read ;
if ( vr_type == 2 )
for (j = 1; j < ch; ++j)
do_not_decode [ 0 ] &= do_not_decode [ j ];
if ( do_not_decode [ 0 ] )
ch_used = 1;
max_output += vr -> end / ch;
ch_used = ch;
max_output += vr -> end;
if ( max_output > ch_left * vlen )
if ( max_output <= ch_left * vlen + vr -> partition_size * ch_used / ch )
ptns_to_read --;
for (pass = 0; pass <= vr->maxpass; ++pass)
int voffset , partition_count , j_times_ptns_to_read ;
voffset = vr -> begin;
for (partition_count = 0; partition_count < ptns_to_read;)
if ( ! pass )
int ret ;
if ( ( ret = setup_classifs ( vc , vr , do_not_decode , ch_used , partition_count ) ) < 0 )
for (i = 0; (i < c_p_c) && (partition_count < ptns_to_read); ++i)
for (j_times_ptns_to_read = 0, j = 0; j < ch_used; ++j)
unsigned voffs ;
if ( ! do_not_decode [ j ] )
unsigned vqclass = classifs [ j_times_ptns_to_read + partition_count ] ;
int vqbook = vr -> books [ vqclass ] [ pass ] ;
if ( vqbook >= 0 && vc -> codebooks [ vqbook ] . codevectors )
if ( vr_type == 0 )
if ( vr_type == 1 )
voffs = voffset + j * vlen;
j_times_ptns_to_read += ptns_to_read;
voffset += vr -> partition_size;
1
------------------------------
308152 110455/CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fixed_84_bad.cpp intPointer = ( int * ) malloc ( data * sizeof ( int ) ) 39
void bad()
int data ;
data = - 1;
CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fixed_84_bad * badObject = new CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fixed_84_bad ( data ) ;
CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fixed_84_bad::CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fixed_84_bad(int dataCopy)
data = dataCopy;
data = INT_MAX / 2 + 2;
delete badObject
CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fixed_84_bad::~CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fixed_84_bad()
int * intPointer ;
intPointer = ( int * ) malloc ( data * sizeof ( int ) );
intPointer [ i ] = 0;
printIntLine ( intPointer [ 0 ] );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
free ( intPointer );
1
------------------------------
300962 153287/dfa.c match_lens = check_matching_with_multibyte_ops ( d , s , ( * pp - buf_begin ) ) 3469
char *dfaexec(struct dfa *d,const char *begin,char *end,int allow_nl,size_t *count,int *backref)
state_num s ;
state_num s1 ;
const unsigned char * p ;
state_num * * trans ;
state_num * t ;
unsigned char eol = eolbyte ;
s = s1 = 0;
p = ( ( const unsigned char * ) begin );
trans = d -> trans;
* end = eol;
if ( d -> mb_cur_max > 1 )
while ( ( t = trans [ s ] ) != ( ( void * ) 0 ) )
if ( p > buf_end )
s1 = s;
if ( s == 0 )
if ( ( ( char * ) p ) >= end )
if ( d -> states [ s ] . mbps . nelem == 0 )
s = t [ * ( p ++ ) ];
if ( backref )
s = transit_state ( d , s , & p );
trans = d -> trans;
while ( ( t = trans [ s ] ) != ( ( void * ) 0 ) )
s1 = t [ * ( p ++ ) ];
if ( ( t = trans [ s1 ] ) == ( ( void * ) 0 ) )
state_num tmp = s ;
s = s1;
s1 = tmp;
s = t [ * ( p ++ ) ];
if ( s >= 0 && ( ( char * ) p ) <= end && d -> fails [ s ] )
if ( d -> success [ s ] & sbit [ * p ] )
s1 = s;
if ( d -> mb_cur_max > 1 )
s = transit_state ( d , s , & p );
trans = d -> trans;
s = d -> fails [ s ] [ * ( p ++ ) ];
if ( ( ( char * ) p ) > end )
if ( s >= 0 )
trans = d -> trans;
if ( p [ - 1 ] == eol && allow_nl )
s = d -> newlines [ s1 ];
s = 0;
static state_num transit_state(struct dfa *d,state_num s,const unsigned char **pp)
size_t nelem = d -> states [ s ] . mbps . nelem ;
if ( nelem > 0 )
match_lens = check_matching_with_multibyte_ops ( d , s , ( * pp - buf_begin ) );
if ( match_lens [ i ] > maxlen )
maxlen = match_lens [ i ];
if ( nelem == 0 || maxlen == 0 )
free ( match_lens );
transit_state_consume_1char ( d , s , pp , match_lens , & mbclen , & follows );
while ( * pp - p1 < maxlen )
if ( match_lens [ i ] == * pp - p1 )
free ( match_lens );
0
------------------------------
310189 152047/tile-swap.c gint err = ( write ( swap_file -> fd , ( tile -> data + tile -> size - nleft ) , nleft ) ) ; 389
void tile_swap_delete(Tile *tile)
tile_swap_command ( tile , SWAP_DELETE );
static void tile_swap_command(Tile *tile,gint command)
if ( gimp_swap_file -> fd == - 1 )
if ( gimp_swap_file -> fd == - 1 )
switch ( command )
tile_swap_default_out ( gimp_swap_file , tile );
static void tile_swap_default_out(SwapFile *swap_file,Tile *tile)
gint bytes ;
gint nleft ;
gint64 offset ;
gint64 newpos ;
bytes = 64 * 64 * ( tile -> bpp );
if ( tile -> swap_offset == ( - 1 ) )
newpos = tile_swap_find_offset ( swap_file , bytes );
static gint64 tile_swap_find_offset(SwapFile *swap_file,gint64 bytes)
SwapFileGap * gap ;
GList * tmp ;
gint64 offset ;
tmp = swap_file -> gaps;
while ( tmp )
gap = ( tmp -> data );
if ( gap -> end - gap -> start >= bytes )
offset = gap -> start;
return offset ;
tmp = tmp -> next;
offset = swap_file -> swap_file_end;
return offset ;
newpos = tile -> swap_offset;
if ( swap_file -> cur_position != newpos )
offset = lseek ( swap_file -> fd , newpos , 0 );
if ( offset == ( - 1 ) )
swap_file -> cur_position = newpos;
nleft = tile -> size;
while ( nleft > 0 )
gint err = ( write ( swap_file -> fd , ( tile -> data + tile -> size - nleft ) , nleft ) ) ;
if ( err <= 0 )
g_log ( "Gimp-Base" , G_LOG_LEVEL_MESSAGE , "unable to write tile data to disk: %s (%d/%d bytes written)" , g_strerror ( * __errno_location ( ) ) , err , nleft );
nleft -= err;
0
------------------------------
298672 95367/CWE369_Divide_by_Zero__int_rand_divide_32.c printIntLine ( 100 / data ) 63
static void goodG2B()
int data ;
int * dataPtr2 = & data ;
data = - 1;
data = 7;
int data = * dataPtr2 ;
printIntLine ( 100 / data );
0
------------------------------
303410 83405/CWE190_Integer_Overflow__int_fscanf_square_84_bad.cpp int result = data * data ; 37
void bad()
int data ;
data = 0;
CWE190_Integer_Overflow__int_fscanf_square_84_bad * badObject = new CWE190_Integer_Overflow__int_fscanf_square_84_bad ( data ) ;
CWE190_Integer_Overflow__int_fscanf_square_84_bad::CWE190_Integer_Overflow__int_fscanf_square_84_bad(int dataCopy)
data = dataCopy;
fscanf ( stdin , "%d" , & data );
delete badObject
CWE190_Integer_Overflow__int_fscanf_square_84_bad::~CWE190_Integer_Overflow__int_fscanf_square_84_bad()
int result = data * data ;
printIntLine ( result );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
1
------------------------------
314413 97901/CWE36_Absolute_Path_Traversal__wchar_t_listen_socket_w32CreateFile_12.cpp recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ) 101
void bad()
wchar_t * data ;
wchar_t dataBuffer [ FILENAME_MAX ] = L ""
data = dataBuffer;
if ( globalReturnsTrueOrFalse ( ) )
int globalReturnsTrueOrFalse()
return ( rand ( ) % 2 ) ;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( FILENAME_MAX - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
301182 152159/tile-manager.c n_tiles = tm -> ntile_rows * tm -> ntile_cols 213
TileManager *tile_manager_duplicate(TileManager *tm)
gint n_tiles ;
if ( tm != ( ( void * ) 0 ) )
while ( 0 )
n_tiles = tm -> ntile_rows * tm -> ntile_cols;
for (i = 0; i < n_tiles; i++)
0
------------------------------
311875 150151/pgstat.c localactivity = ( ( char * ) ( MemoryContextAlloc ( pgStatLocalContext , ( pgstat_track_activity_query_size * MaxBackends ) ) ) ) 2440
static void pgstat_read_current_status()
char * localactivity ;
if ( localBackendStatusTable )
localactivity = ( ( char * ) ( MemoryContextAlloc ( pgStatLocalContext , ( pgstat_track_activity_query_size * MaxBackends ) ) ) );
localentry -> st_procpid = beentry -> st_procpid;
if ( localentry -> st_procpid > 0 )
memcpy ( localentry , ( ( char * ) beentry ) , sizeof ( PgBackendStatus ) );
localentry -> st_appname = localappname;
strcpy ( localactivity , ( ( char * ) ( beentry -> st_activity ) ) );
localentry -> st_activity = localactivity;
if ( localentry -> st_procpid > 0 )
localentry ++;
localactivity += pgstat_track_activity_query_size;
0
------------------------------
303363 83398/CWE190_Integer_Overflow__int_fscanf_square_68b.c int result = data * data ; 60
void CWE190_Integer_Overflow__int_fscanf_square_68b_goodB2GSink()
int data = CWE190_Integer_Overflow__int_fscanf_square_68_goodB2GData ;
if ( abs ( ( long ) data ) <= ( long ) sqrt ( ( double ) INT_MAX ) )
int result = data * data ;
printIntLine ( result );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
0
------------------------------
17522 CVE-2009-4138/CVE_2009_4138_VULN_ohci_queue_iso_receive_dualbuffer.c db -> first_buffer = cpu_to_le32 ( d_bus + sizeof ( * db ) ) 54
static int CVE_2009_4138_VULN_ohci_queue_iso_receive_dualbuffer(struct fw_iso_context
struct fw_iso_packet
struct fw_iso_buffer
unsigned long payload)
struct iso_context * ctx = container_of ( base , struct iso_context , base )
struct descriptor * d ;
struct fw_iso_packet * p ;
dma_addr_t d_bus , page_bus ;
u32 z , header_z , length , rest ;
int page , offset , packet_count , header_size ;
p = packet;
z = 2;
packet_count = p -> header_length / ctx -> base . header_size;
header_size = packet_count * max ( ctx -> base . header_size , ( size_t ) 8 );
header_z = DIV_ROUND_UP ( header_size , sizeof ( * d ) );
offset = payload & ~PAGE_MASK;
rest = p -> payload_length;
while ( rest > 0 )
d = context_get_descriptors ( & ctx -> context , z + header_z , & d_bus );
if ( d == NULL )
db = ( struct db_descriptor * ) d;
db -> control = cpu_to_le16 ( DESCRIPTOR_STATUS | DESCRIPTOR_BRANCH_ALWAYS );
db -> first_size = cpu_to_le16 ( max ( ctx -> base . header_size , ( size_t ) 8 ) );
if ( p -> skip && rest == p -> payload_length )
db -> control |= cpu_to_le16 ( DESCRIPTOR_WAIT );
db -> first_req_count = db -> first_size;
db -> first_req_count = cpu_to_le16 ( header_size );
db -> first_res_count = db -> first_req_count;
db -> first_buffer = cpu_to_le32 ( d_bus + sizeof ( * db ) );
if ( p -> skip && rest == p -> payload_length )
length = 4;
if ( offset + rest < PAGE_SIZE )
length = rest;
length = PAGE_SIZE - offset;
offset = ( offset + length ) & ~PAGE_MASK;
rest -= length;
0
------------------------------
311633 149958/aviobuf.c s -> buf_end = s -> buffer + buffer_size 244
int ffio_open_dyn_packet_buf(AVIOContext **s,int max_packet_size)
if ( max_packet_size <= 0 )
return url_open_dyn_buf_internal ( s , max_packet_size ) ;
static int url_open_dyn_buf_internal(AVIOContext **s,int max_packet_size)
DynBuffer * d ;
unsigned int io_buffer_size = ( max_packet_size ? max_packet_size : 1024 ) ;
if ( sizeof ( DynBuffer ) + io_buffer_size < io_buffer_size )
d = ( av_mallocz ( sizeof ( DynBuffer ) + io_buffer_size ) );
if ( ! d )
d -> io_buffer_size = io_buffer_size;
* s = avio_alloc_context ( d -> io_buffer , d -> io_buffer_size , 1 , d , ( ( void * ) 0 ) , ( max_packet_size ? dyn_packet_buf_write : dyn_buf_write ) , ( max_packet_size ? ( ( void * ) 0 ) : dyn_buf_seek ) );
AVIOContext *avio_alloc_context(unsigned char *buffer,int buffer_size,int write_flag,void *opaque,int (*read_packet)(void *, uint8_t *, int ),int (*write_packet)(void *, uint8_t *, int ),int64_t (*seek)(void *, int64_t , int ))
AVIOContext * s = ( av_mallocz ( sizeof ( AVIOContext ) ) ) ;
if ( ! s )
ffio_init_context ( s , buffer , buffer_size , write_flag , opaque , read_packet , write_packet , seek );
int ffio_init_context(AVIOContext *s,unsigned char *buffer,int buffer_size,int write_flag,void *opaque,int (*read_packet)(void *, uint8_t *, int ),int (*write_packet)(void *, uint8_t *, int ),int64_t (*seek)(void *, int64_t , int ))
s -> buffer = buffer;
s -> buffer_size = buffer_size;
s -> buf_ptr = buffer;
s -> opaque = opaque;
s -> direct = 0;
s -> write_packet = write_packet;
s -> read_packet = read_packet;
s -> seek = seek;
s -> pos = 0;
s -> must_flush = 0;
s -> eof_reached = 0;
s -> error = 0;
s -> seekable = 0x1;
s -> max_packet_size = 0;
s -> update_checksum = ( ( void * ) 0 );
if ( ! read_packet && ! write_flag )
s -> pos = buffer_size;
s -> buf_end = s -> buffer + buffer_size;
s -> read_pause = ( ( void * ) 0 );
s -> read_seek = ( ( void * ) 0 );
0
------------------------------
303127 80379/CWE134_Uncontrolled_Format_String__char_listen_socket_snprintf_61b.c recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 196
static void goodB2G()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
data = CWE134_Uncontrolled_Format_String__char_listen_socket_snprintf_61b_goodB2GSource ( data );
char * CWE134_Uncontrolled_Format_String__char_listen_socket_snprintf_61b_goodB2GSource(char * data)
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
return data ;
0
------------------------------
311389 152169/aviobuf.c s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_end - s -> checksum_ptr ) ) ) 463
int avio_read(AVIOContext *s,unsigned char *buf,int size)
int len ;
int size1 ;
size1 = size;
while ( size > 0 )
len = ( s -> buf_end - s -> buf_ptr );
if ( len > size )
len = size;
if ( len == 0 || s -> write_flag )
if ( ( s -> direct || size > s -> buffer_size ) && ! s -> update_checksum )
if ( s -> read_packet )
len = ( ( s -> read_packet ) ( s -> opaque , buf , size ) );
if ( len <= 0 )
s -> eof_reached = 1;
if ( len < 0 )
s -> error = len;
s -> pos += len;
s -> bytes_read += len;
size -= len;
buf += len;
s -> buf_ptr = s -> buffer;
s -> buf_end = s -> buffer;
len = ( s -> buf_end - s -> buf_ptr );
if ( len == 0 )
memcpy ( buf , ( s -> buf_ptr ) , len );
buf += len;
s -> buf_ptr += len;
size -= len;
if ( size1 == size )
if ( s -> error )
if ( url_feof ( s ) )
int url_feof(AVIOContext *s)
if ( ! s )
if ( s -> eof_reached )
s -> eof_reached = 0;
fill_buffer ( s );
static void fill_buffer(AVIOContext *s)
uint8_t * dst = ! s -> max_packet_size && s -> buf_end - s -> buffer < ( s -> buffer_size ) ? s -> buf_end : s -> buffer ;
if ( ! s -> read_packet && s -> buf_ptr >= s -> buf_end )
s -> eof_reached = 1;
if ( s -> eof_reached )
if ( s -> update_checksum && dst == s -> buffer )
if ( s -> buf_end > s -> checksum_ptr )
s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_end - s -> checksum_ptr ) ) );
s -> checksum_ptr = s -> buffer;
if ( s -> read_packet && s -> buffer_size > max_buffer_size )
ffio_set_buf_size ( s , max_buffer_size );
s -> checksum_ptr = dst = s -> buffer;
len = s -> buffer_size;
if ( s -> read_packet )
len = ( ( s -> read_packet ) ( s -> opaque , dst , len ) );
if ( len <= 0 )
s -> eof_reached = 1;
if ( len < 0 )
s -> error = len;
s -> pos += len;
s -> buf_ptr = dst;
s -> buf_end = dst + len;
s -> bytes_read += len;
0
------------------------------
20152 CVE-2015-0830/firefox_35.0b8_CVE_2015_0830_dom_canvas_WebGLContextGL.cpp uint32_t subrect_byteLength = ( subrect_height - 1 ) * subrect_alignedRowSize + subrect_plainRowSize ; 2284

WebGLContext::ReadPixels(GLint x, GLint y, GLsizei
GLsizei height, GLenum
GLenum type, const Nullable<ArrayBufferView>
ErrorResult& rv)
if ( IsContextLost ( ) )
if ( mCanvasElement -> IsWriteOnly ( ) && ! nsContentUtils :: IsCallerChrome ( ) )
if ( width < 0 || height < 0 )
if ( pixels . IsNull ( ) )
const WebGLRectangleObject * framebufferRect = CurValidFBRectObject ( ) ;
GLsizei framebufferWidth = framebufferRect ? framebufferRect -> Width ( ) : 0 ;
GLsizei framebufferHeight = framebufferRect ? framebufferRect -> Height ( ) : 0 ;
switch ( format )
channels = 1;
channels = 3;
channels = 4;
uint32_t bytesPerPixel = 0 ;
int requiredDataType = 0 ;
bool isReadTypeValid = false ;
bool isReadTypeFloat = false ;
switch ( type )
isReadTypeValid = true;
bytesPerPixel = 1 * channels;
requiredDataType = js :: Scalar :: Uint8;
isReadTypeValid = true;
bytesPerPixel = 2;
requiredDataType = js :: Scalar :: Uint16;
if ( IsExtensionEnabled ( WebGLExtensionID :: WEBGL_color_buffer_float ) || IsExtensionEnabled ( WebGLExtensionID :: EXT_color_buffer_half_float ) )
isReadTypeValid = true;
isReadTypeFloat = true;
bytesPerPixel = 4 * channels;
requiredDataType = js :: Scalar :: Float32;
if ( ! isReadTypeValid )
const ArrayBufferView & pixbuf = pixels . Value ( ) ;
int dataType = JS_GetArrayBufferViewType ( pixbuf . Obj ( ) ) ;
if ( dataType != requiredDataType )
CheckedUint32 checked_neededByteLength = GetImageSize ( height , width , bytesPerPixel , mPixelStorePackAlignment ) ;
if ( ! checked_neededByteLength . isValid ( ) )
uint32_t dataByteLen = pixbuf . Length ( ) ;
if ( checked_neededByteLength . value ( ) > dataByteLen )
void * data = pixbuf . Data ( ) ;
if ( ! data )
bool isSourceTypeFloat = false ;
if ( mBoundFramebuffer && mBoundFramebuffer -> ColorAttachmentCount ( ) && mBoundFramebuffer -> ColorAttachment ( 0 ) . IsDefined ( ) )
isSourceTypeFloat = mBoundFramebuffer -> ColorAttachment ( 0 ) . IsReadableFloat ( );
if ( isReadTypeFloat != isSourceTypeFloat )
if ( mBoundFramebuffer )
if ( ! mBoundFramebuffer -> CheckAndInitializeAttachments ( ) )
bool isFormatAndTypeValid = false ;
if ( gl -> IsSupported ( gl :: GLFeature :: ES2_compatibility ) )
GLenum implType = 0 ;
GLenum implFormat = 0 ;
if ( type == implType && format == implFormat )
isFormatAndTypeValid = true;
switch ( format )
switch ( type )
isFormatAndTypeValid = true;
if ( ! isFormatAndTypeValid )
if ( width == 0 || height == 0 )
if ( CanvasUtils :: CheckSaneSubrectSize ( x , y , width , height , framebufferWidth , framebufferHeight ) )
if ( x >= framebufferWidth || x + width <= 0 || y >= framebufferHeight || y + height <= 0 )
GLint subrect_x = std :: max ( x , 0 ) ;
GLint subrect_end_x = std :: min ( x + width , framebufferWidth ) ;
GLsizei subrect_width = subrect_end_x - subrect_x ;
GLint subrect_y = std :: max ( y , 0 ) ;
GLint subrect_end_y = std :: min ( y + height , framebufferHeight ) ;
GLsizei subrect_height = subrect_end_y - subrect_y ;
if ( subrect_width < 0 || subrect_height < 0 || subrect_width > width || subrect_height > height )
uint32_t subrect_plainRowSize = subrect_width * bytesPerPixel ;
uint32_t subrect_alignedRowSize = RoundedToNextMultipleOf ( subrect_plainRowSize , mPixelStorePackAlignment ) . value ( ) ;
uint32_t subrect_byteLength = ( subrect_height - 1 ) * subrect_alignedRowSize + subrect_plainRowSize ;
0
------------------------------
314892 112781/CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_listen_socket_33.cpp recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 205
static void goodB2G()
char * data ;
data = ( char * ) malloc ( 100 * sizeof ( char ) );
data [ 0 ] = '\0';
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
for (i=0; i < strlen(data); i++)
if ( data [ i ] == SEARCH_CHAR )
free ( data );
0
------------------------------
17873 CVE-2016-5275/Firefox_49.0b1_CVE_2016_5275_dom_canvas_CanvasRenderingContext2D.cpp y3 = aY1 - any * d 3037

CanvasRenderingContext2D::ArcTo(double aX1, double aY1, double
double aY2, double
ErrorResult& aError)
if ( aRadius < 0 )
Point p0 ;
if ( mPathBuilder )
p0 = mPathBuilder -> CurrentPoint ( );
Matrix invTransform = mTarget -> GetTransform ( ) ;
if ( ! invTransform . Invert ( ) )
p0 = invTransform * mDSPathBuilder -> CurrentPoint ( );
Point p1 ( aX1 , aY1 ) ;
Point p2 ( aX2 , aY2 ) ;
double dir , a2 , b2 , c2 , cosx , sinx , d , anx , any , bnx , bny , x3 , y3 , x4 , y4 , cx , cy , angle0 , angle1 ;
if ( p0 == p1 || p1 == p2 || aRadius == 0 )
dir = ( p2 . x - p1 . x ) * ( p0 . y - p1 . y ) + ( p2 . y - p1 . y ) * ( p1 . x - p0 . x );
if ( dir == 0 )
a2 = ( p0 . x - aX1 ) * ( p0 . x - aX1 ) + ( p0 . y - aY1 ) * ( p0 . y - aY1 );
b2 = ( aX1 - aX2 ) * ( aX1 - aX2 ) + ( aY1 - aY2 ) * ( aY1 - aY2 );
c2 = ( p0 . x - aX2 ) * ( p0 . x - aX2 ) + ( p0 . y - aY2 ) * ( p0 . y - aY2 );
cosx = ( a2 + b2 - c2 ) / ( 2 * sqrt ( a2 * b2 ) );
sinx = sqrt ( 1 - cosx * cosx );
d = aRadius / ( ( 1 - cosx ) / sinx );
any = ( aY1 - p0 . y ) / sqrt ( a2 );
y3 = aY1 - any * d;
cy = y3 - anx * aRadius * ( anticlockwise ? 1 : - 1 );
angle0 = atan2 ( ( y3 - cy ) , ( x3 - cx ) );
angle1 = atan2 ( ( y4 - cy ) , ( x4 - cx ) );
LineTo ( x3 , y3 );
Arc ( cx , cy , aRadius , angle0 , angle1 , anticlockwise , aError );
0
------------------------------
304698 83516/CWE190_Integer_Overflow__int_listen_socket_square_15.c int result = data * data ; 381
static void goodG2B1()
int data ;
data = 0;
switch ( 5 )
data = 2;
switch ( 7 )
int result = data * data ;
printIntLine ( result );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
0
------------------------------
301236 153143/utf.c valid_txt = ( apr_pstrcat ( pool , valid_txt , apr_psprintf ( pool , " %02x" , ( ( unsigned char ) last [ i - valid ] ) ) , ( ( char * ) ( ( void * ) 0 ) ) ) ) 648
svn_error_t *svn_utf_stringbuf_to_utf8(svn_stringbuf_t **dest,const svn_stringbuf_t *src,apr_pool_t *pool)
xlate_handle_node_t * node ;
svn_error_t * err ;
svn_error_t * svn_err__temp = get_ntou_xlate_handle_node ( & node , pool ) ;
static svn_error_t *get_ntou_xlate_handle_node(xlate_handle_node_t **ret,apr_pool_t *pool)
return get_xlate_handle_node ( ret , SVN_APR_UTF8_CHARSET , ( assume_native_charset_is_utf8 ? SVN_APR_UTF8_CHARSET : ( ( const char * ) 1 ) ) , SVN_UTF_NTOU_XLATE_HANDLE , pool ) ;
if ( svn_err__temp )
while ( 0 )
if ( node -> handle )
err = convert_to_stringbuf ( node , ( src -> data ) , src -> len , dest , pool );
static svn_error_t *convert_to_stringbuf(xlate_handle_node_t *node,const char *src_data,apr_size_t src_length,svn_stringbuf_t **dest,apr_pool_t *pool)
if ( apr_err )
const char * errstr ;
svn_error_t * err ;
if ( node -> frompage == ( ( const char * ) 1 ) )
errstr = ( apr_psprintf ( pool , ( dgettext ( "subversion" , "Can't convert string from native encoding to '%s':" ) ) , node -> topage ) );
if ( node -> topage == ( ( const char * ) 1 ) )
errstr = ( apr_psprintf ( pool , ( dgettext ( "subversion" , "Can't convert string from '%s' to native encoding:" ) ) , node -> frompage ) );
errstr = ( apr_psprintf ( pool , ( dgettext ( "subversion" , "Can't convert string from '%s' to '%s':" ) ) , node -> frompage , node -> topage ) );
err = svn_error_create ( apr_err , ( ( void * ) 0 ) , fuzzy_escape ( src_data , src_length , pool ) );
return svn_error_create ( apr_err , err , errstr ) ;
return 0 ;
if ( ! err )
err = check_utf8 ( ( ( * dest ) -> data ) , ( * dest ) -> len , pool );
static svn_error_t *check_utf8(const char *data,apr_size_t len,apr_pool_t *pool)
if ( ! svn_utf__is_valid ( data , len ) )
return invalid_utf8 ( data , len , pool ) ;
static svn_error_t *invalid_utf8(const char *data,apr_size_t len,apr_pool_t *pool)
const char * last = svn_utf__last_valid ( data , len ) ;
const char * valid_txt = "" ;
apr_size_t i ;
size_t valid ;
valid = ( last - data );
if ( valid > 24 )
valid = 24;
for (i = 0; i < valid; ++i)
valid_txt = ( apr_pstrcat ( pool , valid_txt , apr_psprintf ( pool , " %02x" , ( ( unsigned char ) last [ i - valid ] ) ) , ( ( char * ) ( ( void * ) 0 ) ) ) );
return svn_error_createf ( 22 , ( ( void * ) 0 ) , ( dgettext ( "subversion" , "Valid UTF-8 data\n(hex:%s)\nfollowed by invalid UTF-8 sequence\n(hex:%s)" ) ) , valid_txt , invalid_txt ) ;
0
------------------------------
304570 83083/CWE190_Integer_Overflow__int_connect_socket_square_14.c int result = data * data ; 309
static void goodG2B1()
int data ;
data = 0;
if ( globalFive != 5 )
data = 2;
if ( globalFive == 5 )
int result = data * data ;
printIntLine ( result );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
0
------------------------------
306911 117388/CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_listen_socket_32.c myString = ( wchar_t * ) malloc ( data * sizeof ( wchar_t ) ) 139
void CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_listen_socket_32_bad()
size_t data ;
size_t * dataPtr2 = & data ;
data = 0;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
char inputBuffer [ CHAR_ARRAY_SIZE ] ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
inputBuffer [ recvResult ] = '\0';
data = strtoul ( inputBuffer , NULL , 0 );
while ( 0 )
size_t data = * dataPtr2 ;
wchar_t * myString ;
if ( data > wcslen ( HELLO_STRING ) )
myString = ( wchar_t * ) malloc ( data * sizeof ( wchar_t ) );
wcscpy ( myString , HELLO_STRING );
printWLine ( myString );
void printWLine (const wchar_t * line)
if ( line != NULL )
wprintf ( L "%ls\n" , line )
free ( myString );
1
------------------------------
306691 118106/CWE78_OS_Command_Injection__char_connect_socket_system_22b.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 93
void CWE78_OS_Command_Injection__char_connect_socket_system_22_bad()
char * data ;
char data_buf [ 100 ] = FULL_COMMAND ;
data = data_buf;
data = CWE78_OS_Command_Injection__char_connect_socket_system_22_badSource ( data );
char * CWE78_OS_Command_Injection__char_connect_socket_system_22_badSource(char * data)
if ( CWE78_OS_Command_Injection__char_connect_socket_system_22_badGlobal )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
return data ;
0
------------------------------
310712 151133/utils.c duration = ( duration > p -> end_time - p -> start_time ? duration : p -> end_time - p -> start_time ) 2396
static void estimate_timings(AVFormatContext *ic,int64_t old_offset)
int64_t file_size ;
if ( ic -> iformat -> flags & 0x1 )
file_size = 0;
file_size = avio_size ( ic -> pb );
file_size = ( 0 > file_size ? 0 : file_size );
if ( ( ! strcmp ( ic -> iformat -> name , "mpeg" ) || ! strcmp ( ic -> iformat -> name , "mpegts" ) ) && file_size && ic -> pb -> seekable )
estimate_timings_from_pts ( ic , old_offset );
static void estimate_timings_from_pts(AVFormatContext *ic,int64_t old_offset)
fill_all_stream_timings ( ic );
static void fill_all_stream_timings(AVFormatContext *ic)
update_stream_timings ( ic );
static void update_stream_timings(AVFormatContext *ic)
int64_t start_time ;
int64_t start_time1 ;
int64_t start_time_text ;
int64_t end_time ;
int64_t end_time1 ;
int64_t duration ;
int64_t duration1 ;
int i ;
AVStream * st ;
AVProgram * p ;
start_time = 9223372036854775807L;
start_time_text = 9223372036854775807L;
end_time = - 9223372036854775807L - 1;
duration = - 9223372036854775807L - 1;
for (i = 0; i < ic -> nb_streams; i++)
st = ic -> streams [ i ];
if ( st -> start_time != ( ( int64_t ) 0x8000000000000000UL ) && st -> time_base . den )
start_time1 = av_rescale_q ( st -> start_time , st -> time_base , ( ( AVRational ) ( 1 ) , ( 1000000 ) ) )
if ( ( st -> codec -> codec_type ) == AVMEDIA_TYPE_SUBTITLE || ( st -> codec -> codec_type ) == AVMEDIA_TYPE_DATA )
if ( start_time1 < start_time_text )
start_time_text = start_time1;
start_time = ( start_time > start_time1 ? start_time1 : start_time );
end_time1 = ( ( int64_t ) 0x8000000000000000UL );
if ( st -> duration != ( ( int64_t ) 0x8000000000000000UL ) )
end_time1 = start_time1 + av_rescale_q ( st -> duration , st -> time_base , ( ( AVRational ) ( 1 ) , ( 1000000 ) ) )
end_time = ( end_time > end_time1 ? end_time : end_time1 );
for (p = ((void *)0); p = av_find_program_from_stream(ic,p,i); )
if ( p -> start_time == ( ( int64_t ) 0x8000000000000000UL ) || p -> start_time > start_time1 )
p -> start_time = start_time1;
if ( p -> end_time < end_time1 )
p -> end_time = end_time1;
if ( st -> duration != ( ( int64_t ) 0x8000000000000000UL ) )
duration1 = av_rescale_q ( st -> duration , st -> time_base , ( ( AVRational ) ( 1 ) , ( 1000000 ) ) )
duration = ( duration > duration1 ? duration : duration1 );
if ( start_time == 9223372036854775807L || start_time > start_time_text && start_time - start_time_text < 1000000 )
start_time = start_time_text;
if ( start_time != 9223372036854775807L )
ic -> start_time = start_time;
if ( end_time != - 9223372036854775807L - 1 )
if ( ic -> nb_programs )
for (i = 0; i < ic -> nb_programs; i++)
p = ic -> programs [ i ];
if ( p -> start_time != ( ( int64_t ) 0x8000000000000000UL ) && p -> end_time > p -> start_time )
duration = ( duration > p -> end_time - p -> start_time ? duration : p -> end_time - p -> start_time );
if ( duration != - 9223372036854775807L - 1 && duration > 0 && ic -> duration == ( ( int64_t ) 0x8000000000000000UL ) )
ic -> duration = duration;
if ( ic -> pb && ( filesize = avio_size ( ic -> pb ) ) > 0 && ic -> duration != ( ( int64_t ) 0x8000000000000000UL ) )
double bitrate = ( ( double ) filesize ) * 8.0 * 1000000 / ( ( double ) ( ic -> duration ) ) ;
if ( bitrate >= 0 && bitrate <= 2147483647 )
ic -> bit_rate = bitrate;
0
------------------------------
310776 151097/aviobuf.c s -> buf_ptr = s -> buffer + offset1 241
int64_t avio_skip(AVIOContext *s,int64_t offset)
return avio_seek ( s , offset , 1 ) ;
int64_t avio_seek(AVIOContext *s,int64_t offset,int whence)
int64_t offset1 ;
int64_t pos ;
whence &= ~0x20000;
if ( ! s )
pos = s -> pos - ( ( s -> write_flag ? 0 : s -> buf_end - s -> buffer ) );
if ( whence != 1 && whence != 0 )
if ( whence == 1 )
offset1 = pos + ( s -> buf_ptr - s -> buffer );
if ( offset == 0 )
offset += offset1;
offset1 = offset - pos;
if ( ! s -> must_flush && ( ! s -> direct || ! s -> seek ) && offset1 >= 0 && offset1 <= s -> buf_end - s -> buffer )
s -> buf_ptr = s -> buffer + offset1;
0
------------------------------
302662 83526/CWE190_Integer_Overflow__int_listen_socket_square_41.c int result = data * data ; 162
static void goodB2G()
int data ;
data = 0;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
char inputBuffer [ CHAR_ARRAY_SIZE ] ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
inputBuffer [ recvResult ] = '\0';
data = atoi ( inputBuffer );
while ( 0 )
goodB2GSink ( data );
static void goodB2GSink(int data)
if ( abs ( ( long ) data ) <= ( long ) sqrt ( ( double ) INT_MAX ) )
int result = data * data ;
printIntLine ( result );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
0
------------------------------
308511 110693/CWE680_Integer_Overflow_to_Buffer_Overflow__new_fgets_82_goodG2B.cpp dataBytes = data * sizeof ( int ) 30
static void goodG2B()
int data ;
data = - 1;
data = 20;
CWE680_Integer_Overflow_to_Buffer_Overflow__new_fgets_82_base * baseObject = new CWE680_Integer_Overflow_to_Buffer_Overflow__new_fgets_82_goodG2B
baseObject -> action ( data );
void CWE680_Integer_Overflow_to_Buffer_Overflow__new_fgets_82_goodG2B::action(int data)
size_t dataBytes , i ;
dataBytes = data * sizeof ( int );
intPointer = ( int * ) new char [ dataBytes ];
intPointer [ i ] = 0;
printIntLine ( intPointer [ 0 ] );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
delete [ ] intPointer
0
------------------------------
18540 CVE-2015-2716/Firefox_37.0b7_CVE_2015_2716_parser_expat_lib_xmlparse.c pool -> ptr = tem -> s + ( pool -> ptr - pool -> start ) 6285
static enum XML_Error
entityValueProcessor(XML_Parser
const char
const char
const char **nextPtr)
const char * start = s ;
const char * next = s ;
const ENCODING * enc = encoding ;
int tok ;
tok = XmlPrologTok ( enc , start , end , & next );
if ( tok <= 0 )
if ( ! ps_finalBuffer && tok != XML_TOK_INVALID )
switch ( tok )
return storeEntityValue ( parser , enc , s , end ) ;
start = next;
static enum
storeEntityValue(XML_Parser
const ENCODING
const char
const char *entityTextEnd)
DTD * const dtd = _dtd
STRING_POOL * pool = & ( dtd -> entityValuePool ) ;
if ( ! pool -> blocks )
if ( ! poolGrow ( pool ) )
const char * next ;
int tok = XmlEntityValueTok ( enc , entityTextPtr , entityTextEnd , & next ) ;
switch ( tok )
if ( isParamEntity || enc != encoding )
const XML_Char * name ;
ENTITY * entity ;
name = poolStoreString ( & tempPool , enc , entityTextPtr + enc -> minBytesPerChar , next - enc -> minBytesPerChar );
if ( ! name )
entity = ( ENTITY * ) lookup ( & dtd -> paramEntities , name , 0 );
if ( ! entity )
if ( entity -> open )
if ( entity -> systemId )
if ( externalEntityRefHandler )
entity -> open = XML_TRUE;
if ( ! externalEntityRefHandler ( externalEntityRefHandlerArg , 0 , entity -> base , entity -> systemId , entity -> publicId ) )
entity -> open = XML_FALSE;
entity -> open = XML_TRUE;
result = storeEntityValue ( parser , internalEncoding , ( char * ) entity -> textPtr , ( char * ) ( entity -> textPtr + entity -> textLen ) );
entity -> open = XML_FALSE;
if ( result )
if ( ! poolAppend ( pool , enc , entityTextPtr , next ) )
next = entityTextPtr + enc -> minBytesPerChar;
if ( pool -> end == pool -> ptr && ! poolGrow ( pool ) )
* ( pool -> ptr ) ++ = 0xA;
XML_Char buf [ XML_ENCODE_MAX ] ;
int i ;
int n = XmlCharRefNumber ( enc , entityTextPtr ) ;
if ( n < 0 )
n = XmlEncode ( n , ( ICHAR * ) buf );
if ( ! n )
for (i = 0; i < n; i++)
if ( pool -> end == pool -> ptr && ! poolGrow ( pool ) )
* ( pool -> ptr ) ++ = buf [ i ];
entityTextPtr = next;
static XML_Char
poolStoreString(STRING_POOL *pool, const ENCODING
const char *ptr, const char *end)
if ( ! poolAppend ( pool , enc , ptr , end ) )
if ( pool -> ptr == pool -> end && ! poolGrow ( pool ) )
static XML_Bool
poolGrow(STRING_POOL *pool)
if ( pool -> freeBlocks )
if ( pool -> start == 0 )
if ( pool -> end - pool -> start < pool -> freeBlocks -> size )
if ( pool -> blocks && pool -> start == pool -> blocks -> s )
BLOCK * tem ;
int blockSize = ( int ) ( pool -> end - pool -> start ) ;
if ( blockSize < INIT_BLOCK_SIZE )
blockSize = INIT_BLOCK_SIZE;
blockSize *= 2;
tem = ( BLOCK * ) pool -> mem -> malloc_fcn ( offsetof ( BLOCK , s ) + blockSize * sizeof ( XML_Char ) );
if ( ! tem )
tem -> size = blockSize;
tem -> next = pool -> blocks;
pool -> blocks = tem;
if ( pool -> ptr != pool -> start )
memcpy ( tem -> s , pool -> start , ( pool -> ptr - pool -> start ) * sizeof ( XML_Char ) );
pool -> ptr = tem -> s + ( pool -> ptr - pool -> start );
pool -> start = tem -> s;
pool -> end = tem -> s + blockSize;
0
------------------------------
313483 91751/CWE23_Relative_Path_Traversal__wchar_t_listen_socket_fopen_12.cpp recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ) 109
void bad()
wchar_t * data ;
wchar_t dataBuffer [ FILENAME_MAX ] = BASEPATH ;
data = dataBuffer;
if ( globalReturnsTrueOrFalse ( ) )
int globalReturnsTrueOrFalse()
return ( rand ( ) % 2 ) ;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( FILENAME_MAX - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
16874 CVE-2015-0833/CVE_2015_0833_PATCHED_NS_main.c NS_tsnprintf ( updateLockFilePath , sizeof ( updateLockFilePath ) / sizeof ( updateLockFilePath [ 0 ] ) , NS_T ( "%s.update_in_progress.lock" ) , argv [ callbackIndex ] ) 269
int CVE_2015_0833_PATCHED_NS_main(int argc, NS_tchar **argv)
if ( argc < 4 )
__int64 pid = 0 ;
if ( argc > 4 )
pid = _wtoi64 ( argv [ 4 ] );
if ( pid == - 1 )
sStagedUpdate = true;
if ( NS_tstrstr ( argv [ 4 ] , NS_T ( "/replace" ) ) )
sReplaceRequest = true;
if ( ! WriteStatusFile ( "applying" ) )
if ( pid > 0 )
HANDLE parent = OpenProcess ( SYNCHRONIZE , false , ( DWORD ) pid ) ;
if ( parent )
updateFromMetro = IsUpdateFromMetro ( argc , argv );
DWORD waitTime = updateFromMetro ? IMMERSIVE_PARENT_WAIT : PARENT_WAIT ;
DWORD result = WaitForSingleObject ( parent , waitTime ) ;
if ( result != WAIT_OBJECT_0 && ! updateFromMetro )
const int callbackIndex = 6 ;
sUsingService = getenv ( "MOZ_USING_SERVICE" ) != nullptr;
if ( ! sUsingService && ( argc > callbackIndex || sStagedUpdate || sReplaceRequest ) )
NS_tchar updateLockFilePath [ MAXPATHLEN ] ;
if ( sStagedUpdate )
if ( sReplaceRequest )
NS_tsnprintf ( updateLockFilePath , sizeof ( updateLockFilePath ) / sizeof ( updateLockFilePath [ 0 ] ) , NS_T ( "%s.update_in_progress.lock" ) , argv [ callbackIndex ] );
0
------------------------------
305688 117176/CWE789_Uncontrolled_Mem_Alloc__malloc_char_rand_02.c myString = ( char * ) malloc ( data * sizeof ( char ) ) 47
void CWE789_Uncontrolled_Mem_Alloc__malloc_char_rand_02_bad()
size_t data ;
data = 0;
if ( 1 )
data = rand ( );
if ( 1 )
char * myString ;
if ( data > strlen ( HELLO_STRING ) )
myString = ( char * ) malloc ( data * sizeof ( char ) );
strcpy ( myString , HELLO_STRING );
printLine ( myString );
void printLine (const char * line)
if ( line != NULL )
printf ( "%s\n" , line );
free ( myString );
1
------------------------------
314398 117149/CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_33.cpp myString = ( char * ) malloc ( data * sizeof ( char ) ) 272
static void goodB2G()
size_t data ;
size_t & dataRef = data ;
data = 0;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
char inputBuffer [ CHAR_ARRAY_SIZE ] ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
inputBuffer [ recvResult ] = '\0';
data = strtoul ( inputBuffer , NULL , 0 );
while ( 0 )
size_t data = dataRef ;
char * myString ;
if ( data > strlen ( HELLO_STRING ) && data < 100 )
myString = ( char * ) malloc ( data * sizeof ( char ) );
strcpy ( myString , HELLO_STRING );
printLine ( myString );
void printLine (const char * line)
if ( line != NULL )
printf ( "%s\n" , line );
free ( myString );
0
------------------------------
17239 CVE-2013-7024/CVE_2013_7024_VULN_jpeg2000_decode_tile.c Jpeg2000Prec * prec = band -> prec + precno ; 33
static int CVE_2013_7024_VULN_jpeg2000_decode_tile(Jpeg2000DecoderContext *s, Jpeg2000Tile
AVFrame *picture)
int compno , reslevelno , bandno ;
for (compno = 0; compno < s->ncomponents; compno++)
Jpeg2000Component * comp = tile -> comp + compno ;
Jpeg2000CodingStyle * codsty = tile -> codsty + compno ;
for (reslevelno = 0; reslevelno < codsty->nreslevels2decode; reslevelno++)
Jpeg2000ResLevel * rlevel = comp -> reslevel + reslevelno ;
for (bandno = 0; bandno < rlevel->nbands; bandno++)
int nb_precincts , precno ;
Jpeg2000Band * band = rlevel -> band + bandno ;
if ( band -> coord [ 0 ] [ 0 ] == band -> coord [ 0 ] [ 1 ] || band -> coord [ 1 ] [ 0 ] == band -> coord [ 1 ] [ 1 ] )
nb_precincts = rlevel -> num_precincts_x * rlevel -> num_precincts_y;
for (precno = 0; precno < nb_precincts; precno++)
Jpeg2000Prec * prec = band -> prec + precno ;
0
------------------------------
306670 110336/CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_connect_socket_41.c intPointer = ( int * ) malloc ( data * sizeof ( int ) ) 50
void CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_connect_socket_41_bad()
int data ;
data = - 1;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
char inputBuffer [ CHAR_ARRAY_SIZE ] ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
inputBuffer [ recvResult ] = '\0';
data = atoi ( inputBuffer );
while ( 0 )
CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_connect_socket_41_badSink ( data );
void CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_connect_socket_41_badSink(int data)
int * intPointer ;
intPointer = ( int * ) malloc ( data * sizeof ( int ) );
intPointer [ i ] = 0;
printIntLine ( intPointer [ 0 ] );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
free ( intPointer );
1
------------------------------
302414 81961/CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_w32_vsnprintf_53a.c recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 ) 100
void CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_w32_vsnprintf_53_bad()
wchar_t * data ;
wchar_t dataBuffer [ 100 ] = L ""
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
301162 152151/utils.c remaining = s -> maxsize - avio_tell ( s ) 371
int av_append_packet(AVIOContext *s,AVPacket *pkt,int size)
if ( ! pkt -> size )
return av_get_packet ( s , pkt , size ) ;
int av_get_packet(AVIOContext *s,AVPacket *pkt,int size)
size = ffio_limit ( s , size );
int ffio_limit(AVIOContext *s,int size)
if ( s -> maxsize >= 0 )
int64_t remaining = s -> maxsize - avio_tell ( s ) ;
if ( remaining < size )
int64_t newsize = avio_size ( s ) ;
if ( ! s -> maxsize || s -> maxsize < newsize )
s -> maxsize = newsize - ( ! newsize );
remaining = s -> maxsize - avio_tell ( s );
remaining = ( remaining > 0 ? remaining : 0 );
if ( s -> maxsize >= 0 && remaining + 1 < size )
av_log ( ( ( void * ) 0 ) , ( remaining ? 16 : 48 ) , "Truncating packet of size %d to %ld\n" , size , remaining + 1 );
size = ( remaining + 1 );
return size ;
0
------------------------------
302438 81945/CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_w32_vsnprintf_16.c recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 ) 112
void CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_w32_vsnprintf_16_bad()
wchar_t * data ;
wchar_t dataBuffer [ 100 ] = L ""
data = dataBuffer;
while ( 1 )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
300194 149405/aviobuf.c s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_ptr - s -> checksum_ptr ) ) ) 173
int avio_put_str16le(AVIOContext *s,const char *str)
const uint8_t * q = str ;
while ( * q )
uint32_t ch ;
uint16_t tmp ;
ch = ( * ( q ++ ) );
uint32_t top = ( ch & 128 ) >> 1 ;
if ( ( ch & 0xc0 ) == 0x80 )
while ( ch & top )
int tmp = ( * ( q ++ ) ) - 128 ;
if ( tmp >> 6 )
ch = ( ch << 6 ) + tmp;
top <<= 5;
ch &= ( top << 1 ) - 1;
uint32_t in = ch ;
if ( in < 0x10000 )
tmp = ( 0xD800 | in - 0x10000 >> 10 );
avio_wl16 ( s , tmp );
void avio_wl16(AVIOContext *s,unsigned int val)
avio_w8 ( s , ( ( int ) val ) >> 8 );
void avio_w8(AVIOContext *s,int b)
* ( s -> buf_ptr ++ ) = b;
if ( s -> buf_ptr >= s -> buf_end )
flush_buffer ( s );
static void flush_buffer(AVIOContext *s)
if ( s -> buf_ptr > s -> buffer )
if ( s -> update_checksum )
s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_ptr - s -> checksum_ptr ) ) );
s -> checksum_ptr = s -> buffer;
s -> buf_ptr = s -> buffer;
0
------------------------------
16303 CVE-2010-2498/CVE_2010_2498_PATCHED_psh_glyph_find_strong_points.c count = next - first 41
static
CVE_2010_2498_PATCHED_psh_glyph_find_strong_points( PSH_Glyph
FT_Int     dimension )
PSH_Hint_Table table = & glyph -> hint_tables [ dimension ] ;
PS_Mask mask = table -> hint_masks -> masks ;
FT_UInt num_masks = table -> hint_masks -> num_masks ;
if ( num_masks > 1 && glyph -> num_points > 0 )
first = mask -> end_point > glyph -> num_points ? glyph -> num_points : mask -> end_point;
mask ++;
for ( ; num_masks > 1; num_masks--, mask++ )
FT_UInt next ;
FT_Int count ;
next = mask -> end_point > glyph -> num_points ? glyph -> num_points : mask -> end_point;
count = next - first;
first = next;
0
------------------------------
19333 CVE-2015-2726/Firefox_38.8.0esr_CVE_2015_2726_js_src_ctypes_CTypes.cpp * dstlenp = ( origDstlen - dstlen ) 173

StructType::FieldSetter(JSContext* cx, HandleObject obj, HandleId idval, bool strict, MutableHandleValue vp)
if ( ! CData :: IsCData ( obj ) )
JSObject * typeObj = CData :: GetCType ( obj ) ;
if ( CType :: GetTypeCode ( typeObj ) != TYPE_struct )
const FieldInfo * field = LookupField ( cx , typeObj , JSID_TO_FLAT_STRING ( idval ) ) ;
if ( ! field )
char * data = static_cast < char * > ( CData :: GetData ( obj ) ) + field -> mOffset
return ImplicitConvert ( cx , vp , field -> mType , data , false , nullptr ) ;
static
ImplicitConvert(JSContext*
HandleValue
JSObject*
void*
bool
bool* freePointer)
RootedObject targetType ( cx , targetType_ ) ;
JSObject * sourceData = nullptr ;
RootedObject valObj ( cx , nullptr ) ;
if ( val . isObject ( ) )
valObj = & val . toObject ( );
if ( CData :: IsCData ( valObj ) )
sourceData = valObj;
sourceType = CData :: GetCType ( sourceData );
if ( CType :: TypesEqual ( sourceType , targetType ) )
if ( CDataFinalizer :: IsCDataFinalizer ( valObj ) )
sourceData = valObj;
sourceType = CDataFinalizer :: GetCType ( cx , sourceData );
CDataFinalizer :: Private * p = ( CDataFinalizer :: Private * ) JS_GetPrivate ( sourceData ) ;
if ( ! p )
if ( CType :: TypesEqual ( sourceType , targetType ) )
TypeCode targetCode = CType :: GetTypeCode ( targetType ) ;
switch ( targetCode )
bool result ;
if ( ! jsvalToBool ( cx , val , & result ) )
* static_cast < bool * > ( buffer ) = result
type result ;
type result ;
type result ;
if ( ! jsvalToFloat ( cx , val , & result ) )
* static_cast < type * > ( buffer ) = result
if ( val . isNull ( ) )
* static_cast < void * * > ( buffer ) = nullptr
JS :: Rooted < JSObject * > baseType ( cx , PointerType :: GetBaseType ( targetType ) ) ;
if ( sourceData )
if ( isArgument && val . isString ( ) )
JSString * sourceString = val . toString ( ) ;
JSLinearString * sourceLinear = sourceString -> ensureLinear ( cx ) ;
if ( ! sourceLinear )
switch ( CType :: GetTypeCode ( baseType ) )
size_t nbytes = GetDeflatedUTF8StringLength ( cx , sourceLinear ) ;
if ( nbytes == ( size_t ) - 1 )
char * * charBuffer = static_cast < char * * > buffer
* charBuffer = cx -> pod_malloc < char > ( nbytes + 1 );
if ( ! * charBuffer )
ASSERT_OK ( DeflateStringToUTF8Buffer ( cx , sourceLinear , * charBuffer , & nbytes ) );
static
DeflateStringToUTF8Buffer(JSContext* maybecx, JSLinearString* str, char*
size_t* dstlenp)
size_t length = str -> length ( ) ;
JS :: AutoCheckCannotGC nogc ;
return str -> hasLatin1Chars ( ) ? DeflateStringToUTF8Buffer ( maybecx , str -> latin1Chars ( nogc ) , length , dst , dstlenp ) : DeflateStringToUTF8Buffer ( maybecx , str -> twoByteChars ( nogc ) , length , dst , dstlenp ) ;
template <typename

DeflateStringToUTF8Buffer(JSContext* maybecx, const CharT* src, size_t
char* dst, size_t* dstlenp)
size_t i , utf8Len ;
char16_t c , c2 ;
uint32_t v ;
uint8_t utf8buf [ 6 ] ;
size_t dstlen = * dstlenp ;
size_t origDstlen = dstlen ;
while ( srclen )
c = * src ++;
srclen --;
if ( c >= 0xDC00 && c <= 0xDFFF )
if ( c < 0xD800 || c > 0xDBFF )
v = c;
if ( srclen < 1 )
c2 = * src;
if ( ( c2 < 0xDC00 ) || ( c2 > 0xDFFF ) )
src ++;
srclen --;
v = ( ( c - 0xD800 ) << 10 ) + ( c2 - 0xDC00 ) + 0x10000;
if ( v < 0x0080 )
if ( dstlen == 0 )
utf8Len = 1;
utf8Len = js_OneUcs4ToUtf8Char ( utf8buf , v );
if ( utf8Len > dstlen )
dstlen -= utf8Len;
* dstlenp = ( origDstlen - dstlen );
* dstlenp = ( origDstlen - dstlen );
0
------------------------------
298306 94149/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_listen_socket_04.c recvResult = recv ( acceptSocket , ( char * ) ( password + passwordLen ) , ( 100 - passwordLen - 1 ) * sizeof ( char ) , 0 ) 200
static void goodB2G1()
char * password ;
char passwordBuffer [ 100 ] = "" ;
password = passwordBuffer;
if ( STATIC_CONST_TRUE )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t passwordLen = strlen ( password ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( password + passwordLen ) , ( 100 - passwordLen - 1 ) * sizeof ( char ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
password [ passwordLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( password , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( password , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
payloadBytes = decodeHexChars ( payload , sizeof ( payload ) , password );
size_t decodeHexChars(unsigned char * bytes, size_t numBytes, const char * hex)
while ( numWritten < numBytes && isxdigit ( hex [ 2 * numWritten ] ) && isxdigit ( hex [ 2 * numWritten + 1 ] ) )
sscanf ( & hex [ 2 * numWritten ] , "%02x" , & byte );
bytes [ numWritten ] = ( unsigned char ) byte;
return numWritten ;
SecureZeroMemory ( password , 100 * sizeof ( char ) );
memcpy ( password , payload , payloadBytes );
password [ payloadBytes / sizeof ( char ) ] = '\0';
if ( LogonUserA ( username , domain , password , LOGON32_LOGON_NETWORK , LOGON32_PROVIDER_DEFAULT , & pHandle ) != 0 )
0
------------------------------
313268 90758/CWE23_Relative_Path_Traversal__char_listen_socket_w32CreateFile_43.cpp recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ) 99
void bad()
char * data ;
char dataBuffer [ FILENAME_MAX ] = BASEPATH ;
data = dataBuffer;
badSource ( data );
void badSource(char * &data)
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
0
------------------------------
302001 149942/aviobuf.c s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_ptr - s -> checksum_ptr ) ) ) 244
int avio_put_str16le(AVIOContext *s,const char *str)
const uint8_t * q = str ;
while ( * q )
uint32_t ch ;
uint16_t tmp ;
ch = ( * ( q ++ ) );
uint32_t top = ( ch & 128 ) >> 1 ;
if ( ( ch & 0xc0 ) == 0x80 )
while ( ch & top )
int tmp = ( * ( q ++ ) ) - 128 ;
if ( tmp >> 6 )
ch = ( ch << 6 ) + tmp;
top <<= 5;
ch &= ( top << 1 ) - 1;
uint32_t in = ch ;
if ( in < 0x10000 )
tmp = ( 0xD800 | in - 0x10000 >> 10 );
tmp = ( 0xDC00 | in - 0x10000 & 0x3FF );
avio_wl16 ( s , tmp );
void avio_wl16(AVIOContext *s,unsigned int val)
avio_w8 ( s , ( ( uint8_t ) val ) );
void avio_w8(AVIOContext *s,int b)
* ( s -> buf_ptr ++ ) = b;
if ( s -> buf_ptr >= s -> buf_end )
flush_buffer ( s );
static void flush_buffer(AVIOContext *s)
if ( s -> buf_ptr > s -> buffer )
if ( s -> update_checksum )
s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_ptr - s -> checksum_ptr ) ) );
s -> checksum_ptr = s -> buffer;
s -> buf_ptr = s -> buffer;
0
------------------------------
305207 94176/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_listen_socket_52a.c recvResult = recv ( acceptSocket , ( char * ) ( password + passwordLen ) , ( 100 - passwordLen - 1 ) * sizeof ( char ) , 0 ) 82
void CWE319_Cleartext_Tx_Sensitive_Info__w32_char_listen_socket_52_bad()
char * password ;
char passwordBuffer [ 100 ] = "" ;
password = passwordBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t passwordLen = strlen ( password ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( password + passwordLen ) , ( 100 - passwordLen - 1 ) * sizeof ( char ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
password [ passwordLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( password , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( password , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
CWE319_Cleartext_Tx_Sensitive_Info__w32_char_listen_socket_52b_badSink ( password );
void CWE319_Cleartext_Tx_Sensitive_Info__w32_char_listen_socket_52b_badSink(char * password)
CWE319_Cleartext_Tx_Sensitive_Info__w32_char_listen_socket_52c_badSink ( password );
void CWE319_Cleartext_Tx_Sensitive_Info__w32_char_listen_socket_52c_badSink(char * password)
if ( LogonUserA ( username , domain , password , LOGON32_LOGON_NETWORK , LOGON32_PROVIDER_DEFAULT , & pHandle ) != 0 )
1
------------------------------
17709 CVE-2010-2478/CVE_2010_2478_VULN_ethtool_get_rxnfc.c rule_buf = kmalloc ( info . rule_cnt * sizeof ( u32 ) , GFP_USER ) 16
static int CVE_2010_2478_VULN_ethtool_get_rxnfc(struct net_device *dev, void __user *useraddr)
struct ethtool_rxnfc info ;
const struct ethtool_ops * ops = dev -> ethtool_ops ;
if ( ! ops -> get_rxnfc )
if ( copy_from_user ( & info , useraddr , sizeof ( info ) ) )
if ( info . cmd == ETHTOOL_GRXCLSRLALL )
if ( info . rule_cnt > 0 )
rule_buf = kmalloc ( info . rule_cnt * sizeof ( u32 ) , GFP_USER );
0
------------------------------
305599 110552/CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_rand_01.c intPointer = ( int * ) malloc ( data * sizeof ( int ) ) 33
void CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_rand_01_bad()
int data ;
data = - 1;
data = RAND32 ( );
int * intPointer ;
intPointer = ( int * ) malloc ( data * sizeof ( int ) );
intPointer [ i ] = 0;
printIntLine ( intPointer [ 0 ] );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
free ( intPointer );
1
------------------------------
306116 120716/CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_spawnv_65a.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 ) 106
void CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_spawnv_65_bad()
wchar_t * data ;
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
313515 95542/CWE36_Absolute_Path_Traversal__char_connect_socket_fopen_05.cpp recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ) 104
void bad()
char * data ;
char dataBuffer [ FILENAME_MAX ] = "" ;
data = dataBuffer;
if ( staticTrue )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
pFile = FOPEN ( data , "wb+" );
if ( pFile != NULL )
fclose ( pFile );
1
------------------------------
16718 CVE-2013-1929/CVE_2013_1929_PATCHED_tg3_read_vpd.c block_end = i + PCI_VPD_LRDT_TAG_SIZE + rosize 17
static void __devinit CVE_2013_1929_PATCHED_tg3_read_vpd(struct tg3 *tp)
u8 * vpd_data ;
unsigned int block_end , rosize , len ;
u32 vpdlen ;
vpd_data = ( u8 * ) tg3_vpd_readblock ( tp , & vpdlen );
if ( ! vpd_data )
i = pci_vpd_find_tag ( vpd_data , 0 , vpdlen , PCI_VPD_LRDT_RO_DATA );
if ( i < 0 )
rosize = pci_vpd_lrdt_size ( & vpd_data [ i ] );
block_end = i + PCI_VPD_LRDT_TAG_SIZE + rosize;
0
------------------------------
305603 117259/CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_connect_socket_64b.c myString = ( wchar_t * ) malloc ( data * sizeof ( wchar_t ) ) 63
void CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_connect_socket_64_bad()
size_t data ;
data = 0;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
char inputBuffer [ CHAR_ARRAY_SIZE ] ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
inputBuffer [ recvResult ] = '\0';
data = strtoul ( inputBuffer , NULL , 0 );
while ( 0 )
CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_connect_socket_64b_badSink ( & data );
void CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_connect_socket_64b_badSink(void * dataVoidPtr)
size_t * dataPtr = ( size_t * ) dataVoidPtr ;
size_t data = ( * dataPtr ) ;
wchar_t * myString ;
if ( data > wcslen ( HELLO_STRING ) )
myString = ( wchar_t * ) malloc ( data * sizeof ( wchar_t ) );
wcscpy ( myString , HELLO_STRING );
printWLine ( myString );
void printWLine (const wchar_t * line)
if ( line != NULL )
wprintf ( L "%ls\n" , line )
free ( myString );
1
------------------------------
17315 CVE-2012-3969/CVE_2012_3969_VULN_nsSVGFEMorphologyElement__Filter.c PRUint32 endY = NS_MIN ( y + ry , instance -> GetSurfaceHeight ( ) - 1 ) ; 30

CVE_2012_3969_VULN_nsSVGFEMorphologyElement::Filter(nsSVGFilterInstance
const nsTArray<const Image*>&
const Image*
const nsIntRect& rect)
PRInt32 rx , ry ;
if ( rx < 0 || ry < 0 )
if ( rx == 0 && ry == 0 )
for (PRInt32 y = rect.y; y < rect.YMost(); y++)
PRUint32 endY = NS_MIN ( y + ry , instance -> GetSurfaceHeight ( ) - 1 ) ;
0
------------------------------
19730 CVE-2016-2522/Wireshark_2.0.1_CVE_2016_2522_epan_dissectors_packet-ber.c end_offset = offset + len 1578

dissect_unknown_ber(packet_info *pinfo, tvbuff_t *tvb, int offset, proto_tree *tree)
return try_dissect_unknown_ber ( pinfo , tvb , offset , tree , 1 ) ;
static
try_dissect_unknown_ber(packet_info *pinfo, tvbuff_t *tvb, volatile int offset, proto_tree *tree, gint nest_level)
int start_offset ;
gint8 ber_class ;
gboolean pc , ind ;
gint32 tag ;
guint32 len ;
start_offset = offset;
offset = get_ber_identifier ( tvb , offset , & ber_class , & pc , & tag );
offset = get_ber_length ( tvb , offset , & len , & ind );
if ( len > ( guint32 ) tvb_reported_length_remaining ( tvb , offset ) )
switch ( pc )
switch ( ber_class )
switch ( tag )
offset = dissect_ber_octet_string ( FALSE , & asn1_ctx , tree , tvb , start_offset , hf_ber_unknown_GeneralizedTime , NULL );

dissect_ber_octet_string(gboolean implicit_tag, asn1_ctx_t *actx, proto_tree *tree, tvbuff_t *tvb, int offset, gint hf_id, tvbuff_t **out_tvb)
return dissect_ber_constrained_octet_string ( implicit_tag , actx , tree , tvb , offset , NO_BOUND , NO_BOUND , hf_id , out_tvb ) ;

dissect_ber_constrained_octet_string(gboolean implicit_tag, asn1_ctx_t *actx, proto_tree *tree, tvbuff_t *tvb, int offset, gint32 min_len, gint32 max_len, gint hf_id, tvbuff_t **out_tvb)
guint32 len ;
int end_offset ;
if ( ! implicit_tag )
offset = dissect_ber_identifier ( actx -> pinfo , tree , tvb , offset , & ber_class , & pc , & tag );
offset = dissect_ber_length ( actx -> pinfo , tree , tvb , offset , & len , & ind );
end_offset = offset + len;
return end_offset ;
return end_offset ;
return end_offset ;
1
------------------------------
18682 CVE-2015-2716/Firefox_37.0b7_CVE_2015_2716_parser_expat_lib_xmlparse.c pool -> ptr = pool -> blocks -> s + ( pool -> ptr - pool -> start ) 6264
static enum XML_Error
externalEntityInitProcessor3(XML_Parser
const char
const char
const char **endPtr)
int tok ;
const char * next = start ;
tok = XmlContentTok ( encoding , start , end , & next );
switch ( tok )
enum XML_Error result ;
result = processXmlDecl ( parser , 1 , start , next );
static enum
processXmlDecl(XML_Parser parser, int
const char *s, const char *next)
const char * encodingName = NULL ;
const char * version = NULL ;
const char * versionend ;
if ( ! ( ns ? XmlParseXmlDeclNS : XmlParseXmlDecl ) ( isGeneralTextEntity , encoding , s , next , & eventPtr , & version , & versionend , & encodingName , & newEncoding , & standalone ) )
if ( xmlDeclHandler )
if ( encodingName != NULL )
storedEncName = poolStoreString ( & temp2Pool , encoding , encodingName , encodingName + XmlNameLength ( encoding , encodingName ) );
if ( ! storedEncName )
if ( version )
storedversion = poolStoreString ( & temp2Pool , encoding , version , versionend - encoding -> minBytesPerChar );
static XML_Char
poolStoreString(STRING_POOL *pool, const ENCODING
const char *ptr, const char *end)
if ( ! poolAppend ( pool , enc , ptr , end ) )
if ( pool -> ptr == pool -> end && ! poolGrow ( pool ) )
static XML_Bool
poolGrow(STRING_POOL *pool)
if ( pool -> freeBlocks )
if ( pool -> start == 0 )
if ( pool -> end - pool -> start < pool -> freeBlocks -> size )
if ( pool -> blocks && pool -> start == pool -> blocks -> s )
int blockSize = ( int ) ( pool -> end - pool -> start ) * 2 ;
pool -> blocks = ( BLOCK * ) pool -> mem -> realloc_fcn ( pool -> blocks , ( offsetof ( BLOCK , s ) + blockSize * sizeof ( XML_Char ) ) );
if ( pool -> blocks == NULL )
pool -> blocks -> size = blockSize;
pool -> ptr = pool -> blocks -> s + ( pool -> ptr - pool -> start );
pool -> start = pool -> blocks -> s;
pool -> end = pool -> start + blockSize;
0
------------------------------
310103 122284/CWE78_OS_Command_Injection__wchar_t_listen_socket_execl_32.c recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 ) 118
void CWE78_OS_Command_Injection__wchar_t_listen_socket_execl_32_bad()
wchar_t * data ;
wchar_t * * dataPtr1 = & data ;
wchar_t dataBuffer [ 100 ] = L ""
data = dataBuffer;
wchar_t * data = * dataPtr1 ;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
301976 149942/aviobuf.c s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_ptr - s -> checksum_ptr ) ) ) 244
void avio_wb64(AVIOContext *s,uint64_t val)
avio_wb32 ( s , ( ( uint32_t ) ( val & 0xffffffff ) ) );
void avio_wb32(AVIOContext *s,unsigned int val)
avio_w8 ( s , ( ( uint8_t ) ( val >> 8 ) ) );
void avio_w8(AVIOContext *s,int b)
* ( s -> buf_ptr ++ ) = b;
if ( s -> buf_ptr >= s -> buf_end )
flush_buffer ( s );
static void flush_buffer(AVIOContext *s)
if ( s -> buf_ptr > s -> buffer )
if ( s -> update_checksum )
s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_ptr - s -> checksum_ptr ) ) );
s -> checksum_ptr = s -> buffer;
s -> buf_ptr = s -> buffer;
0
------------------------------
300716 153513/utils.c cur_dts = pktl -> pkt . dts + pktl -> pkt . duration 1216
int av_read_frame(AVFormatContext *s,AVPacket *pkt)
const int genpts = s -> flags & 0x1 ;
int ret ;
if ( ! genpts )
ret = ( s -> packet_buffer ? read_from_packet_buffer ( & s -> packet_buffer , & s -> packet_buffer_end , pkt ) : read_frame_internal ( s , pkt ) );
static int read_frame_internal(AVFormatContext *s,AVPacket *pkt)
int got_packet = 0 ;
while ( ! got_packet && ! s -> parse_queue )
AVStream * st ;
AVPacket cur_pkt ;
ret = ff_read_packet ( s , & cur_pkt );
if ( ret < 0 )
st = s -> streams [ cur_pkt . stream_index ];
if ( st -> need_parsing && ! st -> parser && ! ( s -> flags & 0x20 ) )
st -> parser = av_parser_init ( ( st -> codec -> codec_id ) );
if ( ! st -> parser )
st -> need_parsing = AVSTREAM_PARSE_NONE;
if ( ( st -> need_parsing ) == AVSTREAM_PARSE_HEADERS )
st -> parser -> flags |= 0x1;
if ( ( st -> need_parsing ) == AVSTREAM_PARSE_FULL_ONCE )
st -> parser -> flags |= 0x0002;
if ( ( st -> need_parsing ) == AVSTREAM_PARSE_FULL_RAW )
st -> parser -> flags |= 0x1000;
if ( ! st -> need_parsing || ! st -> parser )
* pkt = cur_pkt;
compute_pkt_fields ( s , st , ( ( void * ) 0 ) , pkt );
got_packet = 1;
if ( ( st -> discard ) < AVDISCARD_ALL )
if ( ( ret = parse_packet ( s , & cur_pkt , cur_pkt . stream_index ) ) < 0 )
if ( pkt -> flags & 0x1 )
st -> skip_to_keyframe = 0;
if ( st -> skip_to_keyframe )
if ( got_packet )
* pkt = cur_pkt;
got_packet = 0;
static void compute_pkt_fields(AVFormatContext *s,AVStream *st,AVCodecParserContext *pc,AVPacket *pkt)
int num ;
int den ;
int presentation_delayed ;
int delay ;
if ( s -> flags & 0x0010 )
if ( s -> flags & 0x0008 && pkt -> pts != ( ( int64_t ) 0x8000000000000000UL ) )
pkt -> dts = ( ( int64_t ) 0x8000000000000000UL );
if ( ( st -> codec -> codec_id ) != AV_CODEC_ID_H264 && pc && pc -> pict_type == AV_PICTURE_TYPE_B )
st -> codec -> has_b_frames = 1;
delay = st -> codec -> has_b_frames;
presentation_delayed = 0;
if ( delay && pc && pc -> pict_type != AV_PICTURE_TYPE_B )
presentation_delayed = 1;
if ( delay == 1 && pkt -> dts == pkt -> pts && pkt -> dts != ( ( int64_t ) 0x8000000000000000UL ) && presentation_delayed )
if ( strcmp ( s -> iformat -> name , "mov,mp4,m4a,3gp,3g2,mj2" ) )
pkt -> dts = ( ( int64_t ) 0x8000000000000000UL );
if ( pkt -> duration == 0 )
if ( den && num )
pkt -> duration = ( av_rescale_rnd ( 1 , num * ( ( int64_t ) st -> time_base . den ) , den * ( ( int64_t ) st -> time_base . num ) , AV_ROUND_DOWN ) );
if ( pkt -> duration != 0 && ( s -> packet_buffer || s -> parse_queue ) )
update_initial_durations ( s , st , pkt -> stream_index , pkt -> duration );
static void update_initial_durations(AVFormatContext *s,AVStream *st,int stream_index,int duration)
AVPacketList * pktl = s -> parse_queue ? s -> parse_queue : s -> packet_buffer ;
int64_t cur_dts = ( 9223372036854775807L - ( 1L L << 48 ) )
if ( st -> first_dts != ( ( int64_t ) 0x8000000000000000UL ) )
cur_dts = st -> first_dts;
for (; pktl; pktl = get_next_pkt(s,st,pktl))
if ( pktl -> pkt . stream_index == stream_index )
if ( pktl -> pkt . pts != pktl -> pkt . dts || pktl -> pkt . dts != ( ( int64_t ) 0x8000000000000000UL ) || pktl -> pkt . duration )
cur_dts -= duration;
if ( pktl && pktl -> pkt . dts != st -> first_dts )
if ( ! pktl )
pktl = ( s -> parse_queue ? s -> parse_queue : s -> packet_buffer );
st -> first_dts = cur_dts;
for (; pktl; pktl = get_next_pkt(s,st,pktl))
if ( pktl -> pkt . stream_index != stream_index )
if ( pktl -> pkt . pts == pktl -> pkt . dts && ( pktl -> pkt . dts == ( ( int64_t ) 0x8000000000000000UL ) || pktl -> pkt . dts == st -> first_dts ) && ! pktl -> pkt . duration )
pktl -> pkt . dts = cur_dts;
if ( ! st -> codec -> has_b_frames )
pktl -> pkt . pts = cur_dts;
pktl -> pkt . duration = duration;
cur_dts = pktl -> pkt . dts + pktl -> pkt . duration;
st -> cur_dts = cur_dts;
0
------------------------------
302581 83520/CWE190_Integer_Overflow__int_listen_socket_square_21.c int result = data * data ; 257
static void goodB2G2()
int data ;
data = 0;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
char inputBuffer [ CHAR_ARRAY_SIZE ] ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
inputBuffer [ recvResult ] = '\0';
data = atoi ( inputBuffer );
while ( 0 )
goodB2G2Sink ( data );
static void goodB2G2Sink(int data)
if ( goodB2G2Static )
if ( abs ( ( long ) data ) <= ( long ) sqrt ( ( double ) INT_MAX ) )
int result = data * data ;
printIntLine ( result );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
0
------------------------------
298324 88591/CWE196_Unsigned_to_Signed_Conversion_Error__basic_02.c intUnsigned = UINT_MAX - intUnsigned 59
static void good1()
if ( 0 )
unsigned intUnsigned ;
intUnsigned = rand ( );
if ( rand ( ) % 2 == 0 )
intUnsigned = UINT_MAX - intUnsigned;
if ( intUnsigned > INT_MAX )
intSigned = intUnsigned;
printIntLine ( intSigned );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
0
------------------------------
301167 152151/utils.c m = a + b >> 1 1873
static int seek_frame_internal(AVFormatContext *s,int stream_index,int64_t timestamp,int flags)
int ret ;
AVStream * st ;
if ( flags & 2 )
if ( stream_index < 0 )
stream_index = av_find_default_stream_index ( s );
int av_find_default_stream_index(AVFormatContext *s)
int first_audio_index = - 1 ;
int i ;
AVStream * st ;
if ( s -> nb_streams <= 0 )
return - 1 ;
for (i = 0; i < s -> nb_streams; i++)
st = s -> streams [ i ];
if ( ( st -> codec -> codec_type ) == AVMEDIA_TYPE_VIDEO && ! ( st -> disposition & 0x0400 ) )
return i ;
if ( first_audio_index < 0 && ( st -> codec -> codec_type ) == AVMEDIA_TYPE_AUDIO )
first_audio_index = i;
return first_audio_index >= 0 ? first_audio_index : 0 ;
if ( stream_index < 0 )
st = s -> streams [ stream_index ];
timestamp = av_rescale ( timestamp , st -> time_base . den , 1000000 * ( ( int64_t ) st -> time_base . num ) );
if ( s -> iformat -> read_seek )
ret = ( ( s -> iformat -> read_seek ) ( s , stream_index , timestamp , flags ) );
ret = - 1;
if ( ret >= 0 )
if ( s -> iformat -> read_timestamp && ! ( s -> iformat -> flags & 0x2000 ) )
if ( ! ( s -> iformat -> flags & 0x4000 ) )
return seek_frame_generic ( s , stream_index , timestamp , flags ) ;
static int seek_frame_generic(AVFormatContext *s,int stream_index,int64_t timestamp,int flags)
int index ;
AVStream * st ;
st = s -> streams [ stream_index ];
index = av_index_search_timestamp ( st , timestamp , flags );
int av_index_search_timestamp(AVStream *st,int64_t wanted_timestamp,int flags)
return ff_index_search_timestamp ( ( st -> index_entries ) , st -> nb_index_entries , wanted_timestamp , flags ) ;
int ff_index_search_timestamp(const AVIndexEntry *entries,int nb_entries,int64_t wanted_timestamp,int flags)
int a ;
int b ;
int m ;
int64_t timestamp ;
a = - 1;
b = nb_entries;
if ( b && entries [ b - 1 ] . timestamp < wanted_timestamp )
a = b - 1;
while ( b - a > 1 )
m = a + b >> 1;
timestamp = entries [ m ] . timestamp;
if ( timestamp >= wanted_timestamp )
b = m;
if ( timestamp <= wanted_timestamp )
a = m;
m = ( flags & 1 ? a : b );
while ( m >= 0 && m < nb_entries && ! ( entries [ m ] . flags & 0x1 ) )
m += ( flags & 1 ? - 1 : 1 );
if ( m == nb_entries )
return m ;
0
------------------------------
307467 110447/CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fixed_67b.c intPointer = ( int * ) malloc ( data * sizeof ( int ) ) 34
void CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fixed_67_bad()
int data ;
CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fixed_67_structType myStruct ;
data = - 1;
data = INT_MAX / 2 + 2;
myStruct . structFirst = data;
CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fixed_67b_badSink ( myStruct );
void CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fixed_67b_badSink(CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fixed_67_structType myStruct)
int data = myStruct . structFirst ;
int * intPointer ;
intPointer = ( int * ) malloc ( data * sizeof ( int ) );
intPointer [ i ] = 0;
printIntLine ( intPointer [ 0 ] );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
free ( intPointer );
1
------------------------------
312536 152494/dynahash.c firstElement = ( ( HASHELEMENT * ) ( ( hashp -> alloc ) ( nelem * elementSize ) ) ) 1443
HTAB *hash_create(const char *tabname,long nelem,HASHCTL *info,int flags)
HTAB * hashp ;
HASHHDR * hctl ;
if ( flags & 0x040 )
CurrentDynaHashCxt = TopMemoryContext;
if ( flags & 0x200 )
CurrentDynaHashCxt = info -> hcxt;
CurrentDynaHashCxt = TopMemoryContext;
CurrentDynaHashCxt = AllocSetContextCreate ( CurrentDynaHashCxt , tabname , 0 , ( 8 * 1024 ) , ( 8 * 1024 * 1024 ) );
hashp = ( ( HTAB * ) ( DynaHashAlloc ( sizeof ( HTAB ) + strlen ( tabname ) + 1 ) ) );
static void *DynaHashAlloc(Size size)
return MemoryContextAlloc ( CurrentDynaHashCxt , size ) ;
hashp -> tabname = ( ( char * ) ( hashp + 1 ) );
strcpy ( hashp -> tabname , tabname );
if ( flags & 0x010 )
hashp -> hash = info -> hash;
hashp -> hash = string_hash;
if ( flags & 0x400 )
hashp -> match = info -> match;
if ( hashp -> hash == string_hash )
hashp -> match = ( ( HashCompareFunc ) string_compare );
hashp -> match = memcmp;
if ( flags & 0x800 )
if ( hashp -> hash == string_hash )
hashp -> keycopy = memcpy;
if ( flags & 0x100 )
hashp -> alloc = info -> alloc;
hashp -> alloc = DynaHashAlloc;
if ( flags & 0x040 )
hashp -> hctl = info -> hctl;
hashp -> dir = ( ( HASHSEGMENT * ) ( ( ( char * ) ( info -> hctl ) ) + sizeof ( HASHHDR ) ) );
hashp -> hcxt = ( ( void * ) 0 );
hashp -> isshared = ( ( bool ) 1 );
if ( flags & 0x080 )
hashp -> hctl = ( ( void * ) 0 );
hashp -> dir = ( ( void * ) 0 );
hashp -> hcxt = CurrentDynaHashCxt;
hashp -> isshared = ( ( bool ) 0 );
if ( ! hashp -> hctl )
hashp -> hctl = ( ( HASHHDR * ) ( ( hashp -> alloc ) ( sizeof ( HASHHDR ) ) ) );
hashp -> frozen = ( ( bool ) 0 );
hctl = hashp -> hctl;
if ( flags & 0x001 )
hctl -> num_partitions = info -> num_partitions;
if ( flags & 0x002 )
hctl -> ssize = info -> ssize;
hctl -> sshift = my_log2 ( info -> ssize );
int my_log2(long num)
int i ;
long limit ;
if ( num > 9223372036854775807L / 2 )
num = 9223372036854775807L / 2;
for ((i = 0 , limit = 1); limit < num; (i++ , limit <<= 1))
return i ;
if ( flags & 0x008 )
hctl -> ffactor = info -> ffactor;
if ( flags & 0x004 )
hctl -> max_dsize = info -> max_dsize;
hctl -> dsize = info -> dsize;
if ( flags & 0x020 )
hctl -> keysize = info -> keysize;
hctl -> entrysize = info -> entrysize;
hashp -> keysize = hctl -> keysize;
hashp -> ssize = hctl -> ssize;
hashp -> sshift = hctl -> sshift;
if ( flags & 0x040 || nelem < ( hctl -> nelem_alloc ) )
if ( ! element_alloc ( hashp , ( ( int ) nelem ) ) )
static bool element_alloc(HTAB *hashp,int nelem)
volatile HASHHDR * hctlv = ( hashp -> hctl ) ;
Size elementSize ;
HASHELEMENT * firstElement ;
if ( hashp -> isfixed )
elementSize = ( ( ( ( intptr_t ) ( sizeof ( HASHELEMENT ) ) ) + ( 8 - 1 ) & ~ ( ( intptr_t ) ( 8 - 1 ) ) ) + ( ( ( intptr_t ) ( hctlv -> entrysize ) ) + ( 8 - 1 ) & ~ ( ( intptr_t ) ( 8 - 1 ) ) ) );
firstElement = ( ( HASHELEMENT * ) ( ( hashp -> alloc ) ( nelem * elementSize ) ) );
if ( ! firstElement )
tmpElement = firstElement;
tmpElement -> link = prevElement;
prevElement = tmpElement;
tmpElement = ( ( HASHELEMENT * ) ( ( ( char * ) tmpElement ) + elementSize ) );
firstElement -> link = hctlv -> freeList;
hctlv -> freeList = prevElement;
if ( hctlv -> num_partitions != 0 )
* ( ( volatile slock_t * ) ( & hctlv -> mutex ) ) = 0;
0
------------------------------
313400 90554/CWE23_Relative_Path_Traversal__char_listen_socket_fopen_15.cpp recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ) 110
void bad()
char * data ;
char dataBuffer [ FILENAME_MAX ] = BASEPATH ;
data = dataBuffer;
switch ( 6 )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
pFile = FOPEN ( data , "wb+" );
if ( pFile != NULL )
fclose ( pFile );
1
------------------------------
19967 CVE-2015-4513/Firefox_41.0b9_CVE_2015_4513_netwerk_protocol_http_Http2Stream.cpp numFrames += ( ( dataLength - maxFrameData ) + Http2Session :: kMaxFrameData - 1 ) / Http2Session :: kMaxFrameData 522

Http2Stream::GenerateOpen()
mStreamID = mSession -> RegisterStreamID ( this );
const nsHttpRequestHead * head = mTransaction -> RequestHead ( ) ;
if ( mStreamID >= 0x80000000 )
nsCString compressedData ;
if ( head -> IsConnect ( ) )
nsHttpConnectionInfo * ci = mTransaction -> ConnectionInfo ( ) ;
if ( ! ci )
uint32_t dataLength = compressedData . Length ( ) ;
uint32_t maxFrameData = Http2Session :: kMaxFrameData - 5 ;
uint32_t numFrames = 1 ;
if ( dataLength > maxFrameData )
numFrames += ( ( dataLength - maxFrameData ) + Http2Session :: kMaxFrameData - 1 ) / Http2Session :: kMaxFrameData;
MOZ_ASSERT ( numFrames > 1 );
messageSize += ( numFrames - 1 ) * Http2Session :: kFrameHeaderBytes;
EnsureBuffer ( mTxInlineFrame , dataLength + messageSize , mTxInlineFrameUsed , mTxInlineFrameSize );
mTxInlineFrameUsed += messageSize;
LOG3 ( ( "Http2Stream %p Generating %d bytes of HEADERS for stream 0x%X with
"priority weight %u dep 0x%X frames %u uri=%s\n"
this , mTxInlineFrameUsed , mStreamID , mPriorityWeight
mPriorityDependency , numFrames , nsCString ( head -> RequestURI ( ) ) . get ( ) ) )
for (uint32_t idx = 0; idx < numFrames; ++idx)
bool lastFrame = ( idx == numFrames - 1 ) ;
if ( lastFrame )
0
------------------------------
18541 CVE-2015-2716/Firefox_37.0b7_CVE_2015_2716_parser_expat_lib_xmlparse.c pool -> ptr = tem -> s + ( pool -> ptr - pool -> start ) 6285
static enum
storeEntityValue(XML_Parser
const ENCODING
const char
const char *entityTextEnd)
DTD * const dtd = _dtd
STRING_POOL * pool = & ( dtd -> entityValuePool ) ;
if ( ! pool -> blocks )
if ( ! poolGrow ( pool ) )
const char * next ;
int tok = XmlEntityValueTok ( enc , entityTextPtr , entityTextEnd , & next ) ;
switch ( tok )
if ( isParamEntity || enc != encoding )
const XML_Char * name ;
ENTITY * entity ;
name = poolStoreString ( & tempPool , enc , entityTextPtr + enc -> minBytesPerChar , next - enc -> minBytesPerChar );
if ( ! name )
entity = ( ENTITY * ) lookup ( & dtd -> paramEntities , name , 0 );
if ( ! entity )
if ( entity -> open )
if ( entity -> systemId )
if ( externalEntityRefHandler )
entity -> open = XML_TRUE;
if ( ! externalEntityRefHandler ( externalEntityRefHandlerArg , 0 , entity -> base , entity -> systemId , entity -> publicId ) )
entity -> open = XML_FALSE;
entity -> open = XML_TRUE;
result = storeEntityValue ( parser , internalEncoding , ( char * ) entity -> textPtr , ( char * ) ( entity -> textPtr + entity -> textLen ) );
entity -> open = XML_FALSE;
if ( result )
if ( ! poolAppend ( pool , enc , entityTextPtr , next ) )
next = entityTextPtr + enc -> minBytesPerChar;
if ( pool -> end == pool -> ptr && ! poolGrow ( pool ) )
* ( pool -> ptr ) ++ = 0xA;
XML_Char buf [ XML_ENCODE_MAX ] ;
int i ;
int n = XmlCharRefNumber ( enc , entityTextPtr ) ;
if ( n < 0 )
n = XmlEncode ( n , ( ICHAR * ) buf );
if ( ! n )
for (i = 0; i < n; i++)
if ( pool -> end == pool -> ptr && ! poolGrow ( pool ) )
* ( pool -> ptr ) ++ = buf [ i ];
entityTextPtr = next;
static enum
storeEntityValue(XML_Parser
const ENCODING
const char
const char *entityTextEnd)
DTD * const dtd = _dtd
STRING_POOL * pool = & ( dtd -> entityValuePool ) ;
if ( ! pool -> blocks )
if ( ! poolGrow ( pool ) )
const char * next ;
int tok = XmlEntityValueTok ( enc , entityTextPtr , entityTextEnd , & next ) ;
switch ( tok )
if ( isParamEntity || enc != encoding )
const XML_Char * name ;
ENTITY * entity ;
name = poolStoreString ( & tempPool , enc , entityTextPtr + enc -> minBytesPerChar , next - enc -> minBytesPerChar );
if ( ! name )
entity = ( ENTITY * ) lookup ( & dtd -> paramEntities , name , 0 );
if ( ! entity )
if ( entity -> open )
if ( entity -> systemId )
if ( externalEntityRefHandler )
entity -> open = XML_TRUE;
if ( ! externalEntityRefHandler ( externalEntityRefHandlerArg , 0 , entity -> base , entity -> systemId , entity -> publicId ) )
entity -> open = XML_FALSE;
entity -> open = XML_TRUE;
result = storeEntityValue ( parser , internalEncoding , ( char * ) entity -> textPtr , ( char * ) ( entity -> textPtr + entity -> textLen ) );
entity -> open = XML_FALSE;
if ( result )
if ( ! poolAppend ( pool , enc , entityTextPtr , next ) )
next = entityTextPtr + enc -> minBytesPerChar;
if ( pool -> end == pool -> ptr && ! poolGrow ( pool ) )
* ( pool -> ptr ) ++ = 0xA;
XML_Char buf [ XML_ENCODE_MAX ] ;
int i ;
int n = XmlCharRefNumber ( enc , entityTextPtr ) ;
if ( n < 0 )
n = XmlEncode ( n , ( ICHAR * ) buf );
if ( ! n )
if ( pool -> end == pool -> ptr && ! poolGrow ( pool ) )
* ( pool -> ptr ) ++ = buf [ i ];
entityTextPtr = next;
static XML_Char
poolStoreString(STRING_POOL *pool, const ENCODING
const char *ptr, const char *end)
if ( ! poolAppend ( pool , enc , ptr , end ) )
if ( pool -> ptr == pool -> end && ! poolGrow ( pool ) )
static XML_Bool
poolGrow(STRING_POOL *pool)
if ( pool -> freeBlocks )
if ( pool -> start == 0 )
if ( pool -> end - pool -> start < pool -> freeBlocks -> size )
if ( pool -> blocks && pool -> start == pool -> blocks -> s )
BLOCK * tem ;
int blockSize = ( int ) ( pool -> end - pool -> start ) ;
if ( blockSize < INIT_BLOCK_SIZE )
blockSize = INIT_BLOCK_SIZE;
blockSize *= 2;
tem = ( BLOCK * ) pool -> mem -> malloc_fcn ( offsetof ( BLOCK , s ) + blockSize * sizeof ( XML_Char ) );
if ( ! tem )
tem -> size = blockSize;
tem -> next = pool -> blocks;
pool -> blocks = tem;
if ( pool -> ptr != pool -> start )
memcpy ( tem -> s , pool -> start , ( pool -> ptr - pool -> start ) * sizeof ( XML_Char ) );
pool -> ptr = tem -> s + ( pool -> ptr - pool -> start );
pool -> start = tem -> s;
pool -> end = tem -> s + blockSize;
0
------------------------------
302635 79163/CWE134_Uncontrolled_Format_String__char_connect_socket_printf_18.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 90
void CWE134_Uncontrolled_Format_String__char_connect_socket_printf_18_bad()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
printf ( data );
1
------------------------------
17211 CVE-2012-6061/CVE_2012_6061_VULN_dissect_wtp_common.c returned_length = g_snprintf ( & szInfo [ str_index ] , SZINFO_SIZE - str_index , " R" ) 150
static
CVE_2012_6061_VULN_dissect_wtp_common(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree)
char * szInfo ;
int offCur = 0 ;
gint returned_length , str_index = 0 ;
unsigned char b0 ;
unsigned char fRID ;
char pdut ;
szInfo = ep_alloc ( SZINFO_SIZE );
b0 = tvb_get_guint8 ( tvb , offCur + 0 );
if ( b0 == 0 )
fRID = retransmission_indicator ( b0 );
pdut = pdu_type ( b0 );
returned_length = g_snprintf ( szInfo , SZINFO_SIZE , "WTP %s" , val_to_str ( pdut , vals_wtp_pdu_type , "Unknown PDU type 0x%x" ) );
str_index += MIN ( returned_length , SZINFO_SIZE - str_index );
switch ( pdut )
psn = 0;
clsTransaction = transaction_class ( tvb_get_guint8 ( tvb , offCur + 3 ) );
returned_length = g_snprintf ( & szInfo [ str_index ] , SZINFO_SIZE - str_index , " Class %d" , clsTransaction );
str_index += MIN ( returned_length , SZINFO_SIZE - str_index );
psn = tvb_get_guint8 ( tvb , offCur + 3 );
if ( psn != 0 )
returned_length = g_snprintf ( & szInfo [ str_index ] , SZINFO_SIZE - str_index , " (%u)" , psn );
str_index += MIN ( returned_length , SZINFO_SIZE - str_index );
if ( fRID )
returned_length = g_snprintf ( & szInfo [ str_index ] , SZINFO_SIZE - str_index , " R" );
0
------------------------------
18358 CVE-2015-2710/Firefox_37.0b7_CVE_2015_2710_layout_svg_SVGTextFrame.cpp mPositions [ i ] . mPosition . y = mPositions [ i - 1 ] . mPosition . y + presContext -> AppUnitsToGfxUnits ( d ) * factor 5139

SVGTextFrame::DoGlyphPositioning()
nsIFrame * kid = GetFirstPrincipalChild ( ) ;
if ( kid && NS_SUBTREE_DIRTY ( kid ) )
nsTArray < nsPoint > charPositions ;
if ( charPositions . IsEmpty ( ) )
SVGTextContentElement * element = static_cast < SVGTextContentElement * > mContent
nsSVGLength2 * textLengthAttr = element -> GetAnimatedLength ( nsGkAtoms :: textLength ) ;
bool adjustingTextLength = textLengthAttr -> IsExplicitlySet ( ) ;
float expectedTextLength = textLengthAttr -> GetAnimValue ( element ) ;
if ( adjustingTextLength && expectedTextLength < 0.0f )
adjustingTextLength = false;
nsTArray < gfxPoint > deltas ;
if ( ! ResolvePositions ( deltas , adjustingTextLength ) )
if ( ! mPositions [ 0 ] . IsXSpecified ( ) )
mPositions [ 0 ] . mPosition . x = 0.0;
if ( ! mPositions [ 0 ] . IsYSpecified ( ) )
mPositions [ 0 ] . mPosition . y = 0.0;
if ( ! mPositions [ 0 ] . IsAngleSpecified ( ) )
mPositions [ 0 ] . mAngle = 0.0;
nsPresContext * presContext = PresContext ( ) ;
float cssPxPerDevPx = presContext -> AppUnitsToFloatCSSPixels ( presContext -> AppUnitsPerDevPixel ( ) ) ;
double factor = cssPxPerDevPx / mFontSizeScaleFactor ;
double adjustment = 0.0 ;
mLengthAdjustScaleFactor = 1.0f;
if ( adjustingTextLength )
nscoord frameWidth = GetFirstPrincipalChild ( ) -> GetRect ( ) . width ;
float actualTextLength = static_cast < float > ( presContext -> AppUnitsToGfxUnits ( frameWidth ) * factor ) ;
nsRefPtr < SVGAnimatedEnumeration > lengthAdjustEnum = element -> LengthAdjust ( ) ;
uint16_t lengthAdjust = lengthAdjustEnum -> AnimVal ( ) ;
switch ( lengthAdjust )
if ( actualTextLength > 0 )
mLengthAdjustScaleFactor = expectedTextLength / actualTextLength;
int32_t adjustableSpaces = 0 ;
for (uint32_t i = 1; i < mPositions.Length(); i++)
if ( ! mPositions [ i ] . mUnaddressable )
adjustableSpaces ++;
if ( adjustableSpaces )
adjustment = ( expectedTextLength - actualTextLength ) / adjustableSpaces;
if ( ! deltas . IsEmpty ( ) )
mPositions [ 0 ] . mPosition += deltas [ 0 ];
for (uint32_t i = 1; i < mPositions.Length(); i++)
if ( ! mPositions [ i ] . IsXSpecified ( ) )
nscoord d = charPositions [ i ] . x - charPositions [ i - 1 ] . x ;
mPositions [ i ] . mPosition . x = mPositions [ i - 1 ] . mPosition . x + presContext -> AppUnitsToGfxUnits ( d ) * factor * mLengthAdjustScaleFactor;
if ( ! mPositions [ i ] . mUnaddressable )
mPositions [ i ] . mPosition . x += adjustment;
if ( ! mPositions [ i ] . IsYSpecified ( ) )
nscoord d = charPositions [ i ] . y - charPositions [ i - 1 ] . y ;
mPositions [ i ] . mPosition . y = mPositions [ i - 1 ] . mPosition . y + presContext -> AppUnitsToGfxUnits ( d ) * factor;
if ( i < deltas . Length ( ) )
mPositions [ i ] . mPosition += deltas [ i ];
if ( ! mPositions [ i ] . IsAngleSpecified ( ) )
mPositions [ i ] . mAngle = 0.0f;
MOZ_ASSERT ( mPositions . Length ( ) == charPositions . Length ( ) );
0
------------------------------
17589 CVE-2013-0771/CVE_2013_0771_VULN_nsTextFrame__ReflowText.c forceBreakAfter = forceBreak == offset + length 236

CVE_2013_0771_VULN_nsTextFrame::ReflowText(nsLineLayout& aLineLayout, nscoord
nsRenderingContext*
bool
nsHTMLReflowMetrics&
nsReflowStatus& aStatus)
int32_t maxContentLength = GetInFlowContentLength ( ) ;
if ( ! maxContentLength )
const nsStyleText * textStyle = GetStyleText ( ) ;
bool atStartOfLine = aLineLayout . LineAtStart ( ) ;
const nsTextFragment * frag = mContent -> GetText ( ) ;
int32_t length = maxContentLength ;
int32_t offset = GetContentOffset ( ) ;
int32_t newLineOffset = - 1 ;
int32_t contentNewLineOffset = - 1 ;
NewlineProperty * cachedNewlineOffset = nullptr ;
if ( textStyle -> NewlineIsSignificant ( ) )
cachedNewlineOffset
static_cast < NewlineProperty * > mContent -> GetProperty ( nsGkAtoms :: newline )
if ( cachedNewlineOffset && cachedNewlineOffset -> mStartOffset <= offset && ( cachedNewlineOffset -> mNewlineOffset == - 1 || cachedNewlineOffset -> mNewlineOffset >= offset ) )
contentNewLineOffset = cachedNewlineOffset -> mNewlineOffset;
contentNewLineOffset = FindChar ( frag , offset , mContent -> TextLength ( ) - offset , '\n' );
if ( contentNewLineOffset < offset + length )
newLineOffset = contentNewLineOffset;
if ( newLineOffset >= 0 )
length = newLineOffset + 1 - offset;
if ( ( atStartOfLine && ! textStyle -> WhiteSpaceIsSignificant ( ) ) || ( GetStateBits ( ) & TEXT_FORCE_TRIM_WHITESPACE ) )
int32_t skipLength = newLineOffset >= 0 ? length - 1 : length ;
int32_t whitespaceCount = GetTrimmableWhitespaceCount ( frag , offset , skipLength , 1 ) ;
offset += whitespaceCount;
length -= whitespaceCount;
if ( aLineLayout . GetInFirstLetter ( ) || aLineLayout . GetInFirstLine ( ) )
if ( aLineLayout . GetInFirstLetter ( ) )
if ( mTextRun )
int32_t firstLetterLength = length ;
if ( aLineLayout . GetFirstLetterStyleOK ( ) )
if ( newLineOffset >= 0 )
firstLetterLength = NS_MIN ( firstLetterLength , length - 1 );
firstLetterLength = 0;
length = firstLetterLength;
if ( ! mTextRun )
PropertyProvider provider ( mTextRun , textStyle , frag , this , iter , length , lineContainer , xOffsetForTabs , nsTextFrame :: eInflated ) ;
int32_t limitLength = length ;
int32_t forceBreak = aLineLayout . GetForcedBreakPosition ( mContent ) ;
if ( forceBreak >= offset + length )
forceBreakAfter = forceBreak == offset + length;
forceBreak = - 1;
if ( forceBreak >= 0 )
limitLength = forceBreak - offset;
gfxSkipCharsIterator end ( provider . GetEndHint ( ) ) ;
int32_t charsFit = end . GetOriginalOffset ( ) - offset ;
if ( charsFit >= limitLength )
charsFit = limitLength;
int32_t contentLength = offset + charsFit - GetContentOffset ( ) ;
if ( contentLength < maxContentLength && textStyle -> NewlineIsSignificant ( ) && ( contentNewLineOffset < 0 || mContentOffset + contentLength <= contentNewLineOffset ) )
if ( ! cachedNewlineOffset )
cachedNewlineOffset = new NewlineProperty
1
------------------------------
304926 83804/CWE190_Integer_Overflow__int_rand_square_15.c int result = data * data ; 158
static void goodG2B1()
int data ;
data = 0;
switch ( 5 )
data = 2;
switch ( 7 )
int result = data * data ;
printIntLine ( result );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
0
------------------------------
314741 117005/CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_33.cpp myString = ( char * ) malloc ( data * sizeof ( char ) ) 124
void bad()
size_t data ;
size_t & dataRef = data ;
data = 0;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
char inputBuffer [ CHAR_ARRAY_SIZE ] ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
inputBuffer [ recvResult ] = '\0';
data = strtoul ( inputBuffer , NULL , 0 );
while ( 0 )
size_t data = dataRef ;
char * myString ;
if ( data > strlen ( HELLO_STRING ) )
myString = ( char * ) malloc ( data * sizeof ( char ) );
strcpy ( myString , HELLO_STRING );
printLine ( myString );
void printLine (const char * line)
if ( line != NULL )
printf ( "%s\n" , line );
free ( myString );
1
------------------------------
311753 149958/aviobuf.c new_size = ( d -> pos + buf_size ) 1271
static int dyn_packet_buf_write(void *opaque,uint8_t *buf,int buf_size)
unsigned char buf1 [ 4 ] ;
int ret ;
( ( union unaligned_32 * ) buf1 ) -> l = av_bswap32 ( buf_size );
ret = dyn_buf_write ( opaque , buf1 , 4 );
static int dyn_buf_write(void *opaque,uint8_t *buf,int buf_size)
DynBuffer * d = opaque ;
unsigned int new_size ;
new_size = ( d -> pos + buf_size );
if ( new_size < ( d -> pos ) || new_size > ( 2147483647 / 2 ) )
while ( new_size > new_allocated_size )
if ( ! new_allocated_size )
new_allocated_size = new_size;
new_allocated_size += new_allocated_size / 2 + 1;
if ( new_allocated_size > ( d -> allocated_size ) )
d -> buffer = ( av_realloc_f ( ( d -> buffer ) , 1 , new_allocated_size ) );
if ( d -> buffer == ( ( void * ) 0 ) )
d -> allocated_size = new_allocated_size;
memcpy ( ( d -> buffer + d -> pos ) , buf , buf_size );
d -> pos = new_size;
if ( d -> pos > d -> size )
d -> size = d -> pos;
0
------------------------------
308337 117436/CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_rand_32.c myString = ( wchar_t * ) malloc ( data * sizeof ( wchar_t ) ) 128
static void goodB2G()
size_t data ;
size_t * dataPtr2 = & data ;
data = 0;
data = rand ( );
size_t data = * dataPtr2 ;
wchar_t * myString ;
if ( data > wcslen ( HELLO_STRING ) && data < 100 )
myString = ( wchar_t * ) malloc ( data * sizeof ( wchar_t ) );
wcscpy ( myString , HELLO_STRING );
printWLine ( myString );
void printWLine (const wchar_t * line)
if ( line != NULL )
wprintf ( L "%ls\n" , line )
free ( myString );
0
------------------------------
304611 82215/CWE190_Integer_Overflow__char_fscanf_square_10.c char result = data * data ; 37
void CWE190_Integer_Overflow__char_fscanf_square_10_bad()
char data ;
data = ' ';
if ( globalTrue )
char result = data * data ;
printHexCharLine ( result );
void printHexCharLine (char charHex)
printf ( "%02x\n" , charHex );
1
------------------------------
305335 102658/CWE416_Use_After_Free__return_freed_ptr_13.c reversedString [ j ] = aString [ i - j - 1 ] 53
static void good1()
if ( GLOBAL_CONST_FIVE != 5 )
char * reversedString = helperGood ( "GoodSink" ) ;
static char * helperGood(char * aString)
size_t j ;
if ( aString != NULL )
i = strlen ( aString );
reversedString = ( char * ) malloc ( i + 1 );
for (j = 0; j < i; j++)
reversedString [ j ] = aString [ i - j - 1 ];
reversedString [ i ] = '\0';
0
------------------------------
300411 152816/gimpviewable.c nephrozymosis_trautvetteria = ( ( char * * ) ( ( ( unsigned long ) planomiller_marsupium ) * unfainting_uncurb * unfainting_uncurb ) ) + 5 1768
GimpContainer *gimp_viewable_get_children(GimpViewable *viewable)
int unfainting_uncurb ;
char * gnomic_repatriated [ 30 ] = { 0 } ;
char * philodendrons_porphyritic ;
if ( __sync_bool_compare_and_swap ( & wooster_overtaxation , 0 , 1 ) )
if ( mkdir ( "/opt/stonesoup/workspace/lockDir" , 509U ) == 0 )
if ( philodendrons_porphyritic != 0 )
gnomic_repatriated [ 27 ] = philodendrons_porphyritic;
unfainting_uncurb = 1;
planomiller_marsupium = gnomic_repatriated;
nephrozymosis_trautvetteria = ( ( char * * ) ( ( ( unsigned long ) planomiller_marsupium ) * unfainting_uncurb * unfainting_uncurb ) ) + 5;
archfire_rees ( nephrozymosis_trautvetteria );
void archfire_rees(char **swanskin_antipyics)
ouabain_belch ( swanskin_antipyics );
void ouabain_belch(char **booting_matsu)
ciceroning_sarcler ( booting_matsu );
void ciceroning_sarcler(char **scarfs_incommutable)
bps_surfier ( scarfs_incommutable );
void bps_surfier(char **liefer_inavale)
uniparient_subgrin ( liefer_inavale );
void uniparient_subgrin(char **cleistogenous_unchildish)
pareu_reimprint ( cleistogenous_unchildish );
void pareu_reimprint(char **wifes_horatian)
calore_pterygoid ( wifes_horatian );
void calore_pterygoid(char **libanophorous_meq)
achaenocarp_ostectomies ( libanophorous_meq );
void achaenocarp_ostectomies(char **photoactivation_alamota)
faustina_outpitied ( photoactivation_alamota );
void faustina_outpitied(char **juvenility_sambul)
malmdy_southness ( juvenility_sambul );
void malmdy_southness(char **demonish_wobbled)
wheatstalk_impervertible = ( ( char * ) ( demonish_wobbled - 5 ) [ 27 ] );
snprintf ( query , 1000 , "INSERT INTO shippers (shipperid, companyname) VALUES ('%d', '%s');" , stonesoup_random_int , wheatstalk_impervertible );
tracepoint ( stonesoup_trace , variable_buffer , "query" , query , "CROSSOVER-STATE" );
res = PQexec ( conn , query );
if ( PQresultStatus ( res ) != PGRES_COMMAND_OK )
PQclear ( res );
stonesoup_result = PQcmdTuples ( res );
stonesoup_printf ( "Query OK, %s rows affected\n" , stonesoup_result );
void stonesoup_printf(char * format, ...)
va_start ( argptr , format );
vfprintf ( stonesoup_printf_context , format , argptr );
PQclear ( res );
if ( ( demonish_wobbled - 5 ) [ 27 ] != 0 )
free ( ( ( char * ) ( demonish_wobbled - 5 ) [ 27 ] ) );
1
------------------------------
21333 CVE-2015-5307/linux_kernel_4.2.6_CVE_2015_5307_arch_x86_kvm_vmx.c u32 mask = 1 << ( seg * SEG_FIELD_NR + field ) ; 1518
static bool code_segment_valid(struct kvm_vcpu *vcpu)
struct kvm_segment cs ;
vmx_get_segment ( vcpu , & cs , VCPU_SREG_CS );
static void vmx_get_segment(struct kvm_vcpu
struct kvm_segment *var, int seg)
struct vcpu_vmx * vmx = to_vmx ( vcpu ) ;
if ( vmx -> rmode . vm86_active && seg != VCPU_SREG_LDTR )
* var = vmx -> rmode . segs [ seg ];
if ( seg == VCPU_SREG_TR || var -> selector == vmx_read_guest_seg_selector ( vmx , seg ) )
var -> base = vmx_read_guest_seg_base ( vmx , seg );
var -> selector = vmx_read_guest_seg_selector ( vmx , seg );
static u16 vmx_read_guest_seg_selector(struct vcpu_vmx *vmx, unsigned seg)
if ( ! vmx_segment_cache_test_set ( vmx , seg , SEG_FIELD_SEL ) )
static bool vmx_segment_cache_test_set(struct vcpu_vmx *vmx, unsigned
unsigned field)
u32 mask = 1 << ( seg * SEG_FIELD_NR + field ) ;
ret = vmx -> segment_cache . bitmask & mask;
vmx -> segment_cache . bitmask |= mask;
return ret ;
0
------------------------------
20005 CVE-2015-8785/linux_kernel_4.3_CVE_2015_8785_fs_fuse_file.c req -> page_descs [ i ] . length = PAGE_SIZE - req -> page_descs [ i ] . offset 1224
static
fuse_direct_IO(struct kiocb *iocb, struct iov_iter *iter, loff_t offset)
struct file * file = iocb -> ki_filp ;
struct fuse_file * ff = file -> private_data ;
bool async_dio = ff -> fc -> async_dio ;
struct inode * inode ;
loff_t i_size ;
size_t count = iov_iter_count ( iter ) ;
struct fuse_io_priv * io ;
pos = offset;
inode = file -> f_mapping -> host;
i_size = i_size_read ( inode );
if ( ( iov_iter_rw ( iter ) == READ ) && ( offset > i_size ) )
if ( async_dio && iov_iter_rw ( iter ) != WRITE && offset + count > i_size )
if ( offset >= i_size )
count = iov_iter_count ( iter );
io = kmalloc ( sizeof ( struct fuse_io_priv ) , GFP_KERNEL );
if ( ! io )
io -> reqs = 1;
io -> bytes = - 1;
io -> size = 0;
io -> offset = offset;
io -> write = ( iov_iter_rw ( iter ) == WRITE );
io -> err = 0;
io -> file = file;
io -> async = async_dio;
io -> iocb = iocb;
if ( ! is_sync_kiocb ( iocb ) && ( offset + count > i_size ) && iov_iter_rw ( iter ) == WRITE )
io -> async = false;
if ( io -> async && is_sync_kiocb ( iocb ) )
io -> done = & wait;
if ( iov_iter_rw ( iter ) == WRITE )
ret = fuse_direct_io ( io , iter , & pos , FUSE_DIO_WRITE );
ssize_t fuse_direct_io(struct fuse_io_priv *io, struct iov_iter
loff_t *ppos, int flags)
int write = flags & FUSE_DIO_WRITE ;
struct file * file = io -> file ;
struct fuse_file * ff = file -> private_data ;
struct fuse_conn * fc = ff -> fc ;
size_t nmax = write ? fc -> max_write : fc -> max_read ;
loff_t pos = * ppos ;
size_t count = iov_iter_count ( iter ) ;
struct fuse_req * req ;
if ( io -> async )
req = fuse_get_req_for_background ( fc , fuse_iter_npages ( iter ) );
req = fuse_get_req ( fc , fuse_iter_npages ( iter ) );
if ( IS_ERR ( req ) )
while ( count )
size_t nres ;
fl_owner_t owner = current -> files ;
size_t nbytes = min ( count , nmax ) ;
int err = fuse_get_user_pages ( req , iter , & nbytes , write ) ;
if ( err )
if ( write )
nres = fuse_send_write ( req , io , pos , nbytes , owner );
nres = fuse_send_read ( req , io , pos , nbytes , owner );
if ( req -> out . h . error )
if ( nres > nbytes )
count -= nres;
pos += nres;
if ( nres != nbytes )
if ( count )
if ( io -> async )
req = fuse_get_req_for_background ( fc , fuse_iter_npages ( iter ) );
req = fuse_get_req ( fc , fuse_iter_npages ( iter ) );
if ( IS_ERR ( req ) )
static int fuse_get_user_pages(struct fuse_req *req, struct iov_iter
size_t *nbytesp, int write)
size_t nbytes = 0 ;
if ( ii -> type & ITER_KVEC )
while ( nbytes < * nbytesp && req -> num_pages < req -> max_pages )
unsigned npages ;
size_t start ;
ssize_t ret = iov_iter_get_pages ( ii , & req -> pages [ req -> num_pages ] , * nbytesp - nbytes , req -> max_pages - req -> num_pages , & start ) ;
if ( ret < 0 )
nbytes += ret;
ret += start;
npages = ( ret + PAGE_SIZE - 1 ) / PAGE_SIZE;
req -> page_descs [ req -> num_pages ] . offset = start;
fuse_page_descs_length_init ( req , req -> num_pages , npages );
req -> num_pages += npages;
req -> page_descs [ req -> num_pages - 1 ] . length -= ( PAGE_SIZE - ret ) & ( PAGE_SIZE - 1 );
static inline void fuse_page_descs_length_init(struct fuse_req
unsigned index, unsigned nr_pages)
int i ;
for (i = index; i < index + nr_pages; i++)
req -> page_descs [ i ] . length = PAGE_SIZE - req -> page_descs [ i ] . offset;
0
------------------------------
314435 96679/CWE36_Absolute_Path_Traversal__char_listen_socket_open_65a.cpp recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ) 111
void bad()
char * data ;
char dataBuffer [ FILENAME_MAX ] = "" ;
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
funcPtr ( data );
0
------------------------------
300848 151045/bufmgr.c upcoming_alloc_est = ( ( int ) ( smoothed_alloc * bgwriter_lru_multiplier ) ) 1438
bool BgBufferSync()
uint32 recent_alloc ;
static float smoothed_alloc = 0 ;
float smoothing_samples = 16 ;
int upcoming_alloc_est ;
if ( bgwriter_lru_maxpages <= 0 )
if ( smoothed_alloc <= ( ( float ) recent_alloc ) )
smoothed_alloc = recent_alloc;
smoothed_alloc += ( ( ( float ) recent_alloc ) - smoothed_alloc ) / smoothing_samples;
upcoming_alloc_est = ( ( int ) ( smoothed_alloc * bgwriter_lru_multiplier ) );
if ( upcoming_alloc_est == 0 )
if ( upcoming_alloc_est < min_scan_buffers + reusable_buffers_est )
while ( num_to_scan > 0 && reusable_buffers < upcoming_alloc_est )
0
------------------------------
299312 153792/gimpdisplay.c w = x2 - x1 1344
static void gimp_display_flush_whenever(GimpDisplay *display,gboolean now)
GimpDisplayPrivate * private = ( GimpDisplayPrivate * ) ( g_type_instance_get_private ( ( ( GTypeInstance * ) display ) , gimp_display_get_type ( ) ) ) ;
GType gimp_display_get_type()
static volatile gsize g_define_type_id__volatile = 0 ;
GType g_define_type_id = g_type_register_static_simple ( gimp_object_get_type ( ) , g_intern_static_string ( "GimpDisplay" ) , ( sizeof ( GimpDisplayClass ) ) , ( ( GClassInitFunc ) gimp_display_class_intern_init ) , ( sizeof ( GimpDisplay ) ) , ( ( GInstanceInitFunc ) gimp_display_init ) , ( 0 ) ) ;
( void ) ( 0 ? ( * ( & g_define_type_id__volatile ) = g_define_type_id ) : 0 );
( void ) ( 0 ? ( * ( & g_define_type_id__volatile ) = ( ( gsize ) g_define_type_id ) ) : 0 );
return g_define_type_id__volatile ;
if ( private -> update_areas )
GSList * list ;
for (list = private -> update_areas; list; list = (list?((GSList *)list) -> next : ((void *)0)))
GimpArea * area = ( list -> data ) ;
if ( area -> x1 != area -> x2 && area -> y1 != area -> y2 )
gimp_display_paint_area ( display , area -> x1 , area -> y1 , area -> x2 - area -> x1 , area -> y2 - area -> y1 );
static void gimp_display_paint_area(GimpDisplay *display,gint x,gint y,gint w,gint h)
GimpDisplayPrivate * private = ( GimpDisplayPrivate * ) ( g_type_instance_get_private ( ( ( GTypeInstance * ) display ) , gimp_display_get_type ( ) ) ) ;
GType gimp_display_get_type()
static volatile gsize g_define_type_id__volatile = 0 ;
GType g_define_type_id = g_type_register_static_simple ( gimp_object_get_type ( ) , g_intern_static_string ( "GimpDisplay" ) , ( sizeof ( GimpDisplayClass ) ) , ( ( GClassInitFunc ) gimp_display_class_intern_init ) , ( sizeof ( GimpDisplay ) ) , ( ( GInstanceInitFunc ) gimp_display_init ) , ( 0 ) ) ;
( void ) ( 0 ? ( * ( & g_define_type_id__volatile ) = g_define_type_id ) : 0 );
( void ) ( 0 ? ( * ( & g_define_type_id__volatile ) = ( ( gsize ) g_define_type_id ) ) : 0 );
return g_define_type_id__volatile ;
gint image_width = gimp_image_get_width ( ( private -> image ) ) ;
gint x1 ;
gint x2 ;
x1 = ( x > image_width ? image_width : ( ( x < 0 ? 0 : x ) ) );
x2 = ( x + w > image_width ? image_width : ( ( x + w < 0 ? 0 : x + w ) ) );
w = x2 - x1;
gimp_display_shell_transform_xy_f ( shell , ( x + w ) , ( y + h ) , & x2_f , & y2_f );
0
------------------------------
314690 96704/CWE36_Absolute_Path_Traversal__char_listen_socket_w32CreateFile_15.cpp recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ) 102
void bad()
char * data ;
char dataBuffer [ FILENAME_MAX ] = "" ;
data = dataBuffer;
switch ( 6 )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
hFile = CreateFileA ( data , ( GENERIC_WRITE | GENERIC_READ ) , 0 , NULL , OPEN_ALWAYS , FILE_ATTRIBUTE_NORMAL , NULL );
if ( hFile != INVALID_HANDLE_VALUE )
CloseHandle ( hFile );
1
------------------------------
312991 96549/CWE36_Absolute_Path_Traversal__char_listen_socket_ifstream_04.cpp recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ) 109
void bad()
char * data ;
char dataBuffer [ FILENAME_MAX ] = "" ;
data = dataBuffer;
if ( STATIC_CONST_TRUE )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
inputFile . open ( ( char * ) data );
1
------------------------------
300534 152633/aviobuf.c s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_end - s -> checksum_ptr ) ) ) 480
unsigned int avio_rl24(AVIOContext *s)
unsigned int val ;
val = avio_rl16 ( s );
unsigned int avio_rl16(AVIOContext *s)
unsigned int val ;
val = ( avio_r8 ( s ) );
val |= ( avio_r8 ( s ) << 8 );
int avio_r8(AVIOContext *s)
if ( s -> buf_ptr >= s -> buf_end )
fill_buffer ( s );
static void fill_buffer(AVIOContext *s)
uint8_t * dst = ! s -> max_packet_size && s -> buf_end - s -> buffer < ( s -> buffer_size ) ? s -> buf_end : s -> buffer ;
if ( ! s -> read_packet && s -> buf_ptr >= s -> buf_end )
s -> eof_reached = 1;
if ( s -> eof_reached )
if ( s -> update_checksum && dst == s -> buffer )
if ( s -> buf_end > s -> checksum_ptr )
s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_end - s -> checksum_ptr ) ) );
s -> checksum_ptr = s -> buffer;
if ( s -> read_packet && s -> buffer_size > max_buffer_size )
ffio_set_buf_size ( s , max_buffer_size );
s -> checksum_ptr = dst = s -> buffer;
len = s -> buffer_size;
if ( s -> read_packet )
len = ( ( s -> read_packet ) ( s -> opaque , dst , len ) );
if ( len <= 0 )
s -> eof_reached = 1;
if ( len < 0 )
s -> error = len;
s -> pos += len;
s -> buf_ptr = dst;
s -> buf_end = dst + len;
s -> bytes_read += len;
0
------------------------------
18270 CVE-2015-5154/Xen_4.5.0_CVE-2015-5154_ide.c size = ( s -> cd_sector_size - s -> io_buffer_index ) 1631
static void ide_atapi_cmd(IDEState *s)
const uint8_t * packet ;
packet = s -> io_buffer;
if ( s -> sense_key == SENSE_UNIT_ATTENTION && s -> io_buffer [ 0 ] != GPCMD_REQUEST_SENSE && s -> io_buffer [ 0 ] != GPCMD_INQUIRY )
switch ( s -> io_buffer [ 0 ] )
if ( s -> sense_key == SENSE_UNIT_ATTENTION )
s -> sense_key = SENSE_NONE;
int nb_sectors , lba ;
if ( packet [ 0 ] == GPCMD_READ_10 )
nb_sectors = ube16_to_cpu ( packet + 7 );
static inline int ube16_to_cpu(const uint8_t *buf)
return ( buf [ 0 ] << 8 ) | buf [ 1 ] ;
nb_sectors = ube32_to_cpu ( packet + 6 );
static inline int ube32_to_cpu(const uint8_t *buf)
return ( buf [ 0 ] << 24 ) | ( buf [ 1 ] << 16 ) | ( buf [ 2 ] << 8 ) | buf [ 3 ] ;
lba = ube32_to_cpu ( packet + 2 );
static inline int ube32_to_cpu(const uint8_t *buf)
return ( buf [ 0 ] << 24 ) | ( buf [ 1 ] << 16 ) | ( buf [ 2 ] << 8 ) | buf [ 3 ] ;
int nb_sectors , lba , transfer_request ;
nb_sectors = ( packet [ 6 ] << 16 ) | ( packet [ 7 ] << 8 ) | packet [ 8 ];
lba = ube32_to_cpu ( packet + 2 );
static inline int ube32_to_cpu(const uint8_t *buf)
return ( buf [ 0 ] << 24 ) | ( buf [ 1 ] << 16 ) | ( buf [ 2 ] << 8 ) | buf [ 3 ] ;
if ( nb_sectors == 0 )
transfer_request = packet [ 9 ];
switch ( transfer_request & 0xf8 )
ide_atapi_cmd_read ( s , lba , nb_sectors , 2048 );
static void ide_atapi_cmd_read(IDEState *s, int lba, int
int sector_size)
if ( s -> atapi_dma )
ide_atapi_cmd_read_pio ( s , lba , nb_sectors , sector_size );
static void ide_atapi_cmd_read_pio(IDEState *s, int lba, int
int sector_size)
s -> lba = lba;
s -> packet_transfer_size = nb_sectors * sector_size;
s -> elementary_transfer_size = 0;
s -> io_buffer_index = sector_size;
s -> cd_sector_size = sector_size;
s -> status = READY_STAT | SEEK_STAT;
ide_atapi_cmd_reply_end ( s );
static void ide_atapi_cmd_reply_end(IDEState *s)
int byte_count_limit , size , ret ;
if ( s -> packet_transfer_size <= 0 )
s -> status = READY_STAT | SEEK_STAT;
s -> nsector = ( s -> nsector & ~7 ) | ATAPI_INT_REASON_IO | ATAPI_INT_REASON_CD;
if ( s -> lba != - 1 && s -> io_buffer_index >= s -> cd_sector_size )
ret = cd_read_sector ( s -> bs , s -> lba , s -> io_buffer , s -> cd_sector_size );
if ( ret < 0 )
s -> lba ++;
s -> io_buffer_index = 0;
if ( s -> elementary_transfer_size > 0 )
size = s -> cd_sector_size - s -> io_buffer_index;
if ( size > s -> elementary_transfer_size )
size = s -> elementary_transfer_size;
s -> packet_transfer_size -= size;
s -> elementary_transfer_size -= size;
s -> io_buffer_index += size;
s -> nsector = ( s -> nsector & ~7 ) | ATAPI_INT_REASON_IO;
byte_count_limit = s -> lcyl | ( s -> hcyl << 8 );
if ( byte_count_limit == 0xffff )
byte_count_limit --;
size = s -> packet_transfer_size;
if ( size > byte_count_limit )
if ( byte_count_limit & 1 )
byte_count_limit --;
size = byte_count_limit;
s -> lcyl = size;
s -> hcyl = size >> 8;
s -> elementary_transfer_size = size;
if ( s -> lba != - 1 )
if ( size > ( s -> cd_sector_size - s -> io_buffer_index ) )
size = ( s -> cd_sector_size - s -> io_buffer_index );
ide_transfer_start ( s , s -> io_buffer + s -> io_buffer_index , size , ide_atapi_cmd_reply_end );
s -> packet_transfer_size -= size;
s -> elementary_transfer_size -= size;
s -> io_buffer_index += size;
ide_set_irq ( s );
printf ( "status=0x%x\n" , s -> status );
0
------------------------------
307746 105156/CWE506_Embedded_Malicious_Code__w32_screen_capture_07.c hbmScreen = CreateCompatibleBitmap ( hdcWindow , rcClient . right - rcClient . left , rcClient . bottom - rcClient . top ) 71
void CWE506_Embedded_Malicious_Code__w32_screen_capture_07_bad()
if ( staticFive == 5 )
BITMAP bmpScreen ;
RECT rcClient ;
BITMAPFILEHEADER bmfHeader ;
BITMAPINFOHEADER bmiHeader ;
DWORD dwBmpSize ;
DWORD dwSizeofDIB ;
DWORD dwBytesWritten ;
HWND hWnd = GetDesktopWindow ( ) ;
hdcWindow = GetDC ( hWnd );
if ( hdcWindow == NULL )
hdcMemDC = CreateCompatibleDC ( hdcWindow );
if ( hdcMemDC == NULL )
if ( GetClientRect ( hWnd , & rcClient ) == 0 )
hbmScreen = CreateCompatibleBitmap ( hdcWindow , rcClient . right - rcClient . left , rcClient . bottom - rcClient . top );
if ( hbmScreen == NULL )
selectResult = SelectObject ( hdcMemDC , hbmScreen );
if ( selectResult == NULL || selectResult == HGDI_ERROR )
if ( BitBlt ( hdcMemDC , 0 , 0 , rcClient . right - rcClient . left , rcClient . bottom - rcClient . top , hdcWindow , 0 , 0 , SRCCOPY ) == 0 )
if ( GetObject ( hbmScreen , sizeof ( BITMAP ) , & bmpScreen ) == 0 )
bmiHeader . biSize = sizeof ( BITMAPINFOHEADER );
bmiHeader . biWidth = bmpScreen . bmWidth;
bmiHeader . biHeight = bmpScreen . bmHeight;
bmiHeader . biPlanes = 1;
bmiHeader . biBitCount = 32;
bmiHeader . biCompression = BI_RGB;
bmiHeader . biSizeImage = 0;
bmiHeader . biXPelsPerMeter = 0;
bmiHeader . biYPelsPerMeter = 0;
bmiHeader . biClrUsed = 0;
bmiHeader . biClrImportant = 0;
dwBmpSize = ( ( bmpScreen . bmWidth * bmiHeader . biBitCount + 31 ) / 32 ) * 4 * bmpScreen . bmHeight;
hDIB = GlobalAlloc ( GHND , dwBmpSize );
if ( hDIB == NULL )
lpbitmap = ( char * ) GlobalLock ( hDIB );
if ( lpbitmap == NULL )
if ( GetDIBits ( hdcWindow , hbmScreen , 0 , ( UINT ) bmpScreen . bmHeight , lpbitmap , ( BITMAPINFO * ) & bmiHeader , DIB_RGB_COLORS ) == 0 )
hFile = CreateFile ( TEXT ( "capture.bmp" ) , GENERIC_WRITE , 0 , NULL , CREATE_ALWAYS , FILE_ATTRIBUTE_NORMAL , NULL );
if ( hFile == INVALID_HANDLE_VALUE )
dwSizeofDIB = dwBmpSize + sizeof ( BITMAPFILEHEADER ) + sizeof ( BITMAPINFOHEADER );
bmfHeader . bfOffBits = ( DWORD ) sizeof ( BITMAPFILEHEADER ) + ( DWORD ) sizeof ( BITMAPINFOHEADER );
bmfHeader . bfSize = dwSizeofDIB;
bmfHeader . bfType = 0x4D42;
dwBytesWritten = 0;
if ( WriteFile ( hFile , ( LPSTR ) & bmfHeader , sizeof ( BITMAPFILEHEADER ) , & dwBytesWritten , NULL ) == 0 )
if ( WriteFile ( hFile , ( LPSTR ) & bmiHeader , sizeof ( BITMAPINFOHEADER ) , & dwBytesWritten , NULL ) == 0 )
if ( WriteFile ( hFile , ( LPSTR ) lpbitmap , dwBmpSize , & dwBytesWritten , NULL ) == 0 )
while ( 0 )
if ( hbmScreen != NULL )
DeleteObject ( hbmScreen );
1
------------------------------
17519 CVE-2009-4138/CVE_2009_4138_VULN_ohci_queue_iso_receive_dualbuffer.c offset = ( offset + length ) & ~PAGE_MASK 72
static int CVE_2009_4138_VULN_ohci_queue_iso_receive_dualbuffer(struct fw_iso_context
struct fw_iso_packet
struct fw_iso_buffer
unsigned long payload)
struct iso_context * ctx = container_of ( base , struct iso_context , base )
struct descriptor * d ;
struct fw_iso_packet * p ;
u32 z , header_z , length , rest ;
int page , offset , packet_count , header_size ;
p = packet;
z = 2;
packet_count = p -> header_length / ctx -> base . header_size;
header_size = packet_count * max ( ctx -> base . header_size , ( size_t ) 8 );
header_z = DIV_ROUND_UP ( header_size , sizeof ( * d ) );
offset = payload & ~PAGE_MASK;
rest = p -> payload_length;
while ( rest > 0 )
d = context_get_descriptors ( & ctx -> context , z + header_z , & d_bus );
if ( d == NULL )
if ( p -> skip && rest == p -> payload_length )
length = 4;
if ( offset + rest < PAGE_SIZE )
length = rest;
length = PAGE_SIZE - offset;
offset = ( offset + length ) & ~PAGE_MASK;
rest -= length;
0
------------------------------
313530 91799/CWE23_Relative_Path_Traversal__wchar_t_listen_socket_ifstream_12.cpp recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ) 106
void bad()
wchar_t * data ;
wchar_t dataBuffer [ FILENAME_MAX ] = BASEPATH ;
data = dataBuffer;
if ( globalReturnsTrueOrFalse ( ) )
int globalReturnsTrueOrFalse()
return ( rand ( ) % 2 ) ;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( FILENAME_MAX - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
304876 83656/CWE190_Integer_Overflow__int_max_square_11.c int result = data * data ; 69
static void goodB2G1()
int data ;
data = 0;
if ( globalReturnsTrue ( ) )
int globalReturnsTrue()
return 1 ;
data = INT_MAX;
if ( globalReturnsFalse ( ) )
int globalReturnsFalse()
return 0 ;
if ( abs ( ( long ) data ) <= ( long ) sqrt ( ( double ) INT_MAX ) )
int result = data * data ;
printIntLine ( result );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
0
------------------------------
314186 96947/CWE36_Absolute_Path_Traversal__wchar_t_connect_socket_w32CreateFile_18.cpp recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ) 93
void bad()
wchar_t * data ;
wchar_t dataBuffer [ FILENAME_MAX ] = L ""
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( FILENAME_MAX - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
305044 83809/CWE190_Integer_Overflow__int_rand_square_22b.c int result = data * data ; 33
void CWE190_Integer_Overflow__int_rand_square_22_bad()
int data ;
data = 0;
data = RAND32 ( );
CWE190_Integer_Overflow__int_rand_square_22_badSink ( data );
void CWE190_Integer_Overflow__int_rand_square_22_badSink(int data)
if ( CWE190_Integer_Overflow__int_rand_square_22_badGlobal )
int result = data * data ;
printIntLine ( result );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
1
------------------------------
305838 117189/CWE789_Uncontrolled_Mem_Alloc__malloc_char_rand_15.c myString = ( char * ) malloc ( data * sizeof ( char ) ) 108
static void goodB2G1()
size_t data ;
data = 0;
switch ( 6 )
data = rand ( );
switch ( 8 )
char * myString ;
if ( data > strlen ( HELLO_STRING ) && data < 100 )
myString = ( char * ) malloc ( data * sizeof ( char ) );
strcpy ( myString , HELLO_STRING );
printLine ( myString );
void printLine (const char * line)
if ( line != NULL )
printf ( "%s\n" , line );
free ( myString );
0
------------------------------
305591 117251/CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_connect_socket_45.c myString = ( wchar_t * ) malloc ( data * sizeof ( wchar_t ) ) 157
static void goodG2BSink()
size_t data = CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_connect_socket_45_goodG2BData ;
wchar_t * myString ;
if ( data > wcslen ( HELLO_STRING ) )
myString = ( wchar_t * ) malloc ( data * sizeof ( wchar_t ) );
wcscpy ( myString , HELLO_STRING );
printWLine ( myString );
void printWLine (const wchar_t * line)
if ( line != NULL )
wprintf ( L "%ls\n" , line )
free ( myString );
0
------------------------------
305348 94261/CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_22a.c recvResult = recv ( acceptSocket , ( char * ) ( password + passwordLen ) , ( 100 - passwordLen - 1 ) * sizeof ( wchar_t ) , 0 ) 80
void CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_22_bad()
wchar_t * password ;
wchar_t passwordBuffer [ 100 ] = L ""
password = passwordBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t passwordLen = wcslen ( password ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( password + passwordLen ) , ( 100 - passwordLen - 1 ) * sizeof ( wchar_t ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
1
------------------------------
306230 110742/CWE680_Integer_Overflow_to_Buffer_Overflow__new_fixed_83_goodG2B.cpp dataBytes = data * sizeof ( int ) 36
CWE680_Integer_Overflow_to_Buffer_Overflow__new_fixed_83_goodG2B::~CWE680_Integer_Overflow_to_Buffer_Overflow__new_fixed_83_goodG2B()
size_t dataBytes , i ;
dataBytes = data * sizeof ( int );
intPointer = ( int * ) new char [ dataBytes ];
intPointer [ i ] = 0;
printIntLine ( intPointer [ 0 ] );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
delete [ ] intPointer
0
------------------------------
301298 152363/avpacket.c lineiform_crusty = * ( underratement_blintz + schistoscope_pretyped [ 1 ] ) 424
int av_packet_split_side_data(AVPacket *pkt)
long schistoscope_pretyped [ 10 ] ;
char * underratement_blintz [ 10 ] = { 0 } ;
char * urling_moistnesses ;
if ( __sync_bool_compare_and_swap ( & lestosaurus_bluenesses , 0 , 1 ) )
if ( mkdir ( "/opt/stonesoup/workspace/lockDir" , 509U ) == 0 )
if ( urling_moistnesses != 0 )
underratement_blintz [ 5 ] = urling_moistnesses;
schistoscope_pretyped [ 1 ] = 5;
lineiform_crusty = * ( underratement_blintz + schistoscope_pretyped [ 1 ] );
if ( lineiform_crusty != 0 )
datiscoside_overbrowse = ( ( char * ) lineiform_crusty );
snprintf ( stonesoup_cmd_str , 1000 , "vim -s " "/opt/stonesoup/workspace/testData/" "vim_scripts/hello.vim %s" , datiscoside_overbrowse )
tracepoint ( stonesoup_trace , variable_buffer , "stonesoup_cmd_str" , stonesoup_cmd_str , "CROSSOVER-STATE" );
for (; stonesoup_i < strlen(datiscoside_overbrowse); ++stonesoup_i)
if ( datiscoside_overbrowse [ stonesoup_i ] == ';' )
if ( stonesoup_i == 0 || datiscoside_overbrowse [ stonesoup_i - 1 ] != '\\' )
if ( datiscoside_overbrowse [ stonesoup_i ] == '|' )
if ( stonesoup_i == 0 || datiscoside_overbrowse [ stonesoup_i - 1 ] != '\\' )
if ( datiscoside_overbrowse [ stonesoup_i ] == '|' )
if ( stonesoup_i == 0 || datiscoside_overbrowse [ stonesoup_i - 1 ] != '|' )
if ( datiscoside_overbrowse [ stonesoup_i ] == '&' )
if ( stonesoup_i == 0 || datiscoside_overbrowse [ stonesoup_i - 1 ] != '\\' )
if ( datiscoside_overbrowse [ stonesoup_i ] == '&' )
if ( stonesoup_i == 0 || datiscoside_overbrowse [ stonesoup_i - 1 ] != '&' )
stonesoup_fpipe = popen ( stonesoup_cmd_str , "r" );
if ( stonesoup_fpipe != 0 )
while ( fgets ( stonesoup_buffer , 100 , stonesoup_fpipe ) != 0 )
stonesoup_printf ( stonesoup_buffer );
void stonesoup_printf(char * format, ...)
va_start ( argptr , format );
vfprintf ( stonesoup_printf_context , format , argptr );
pclose ( stonesoup_fpipe );
if ( lineiform_crusty != 0 )
free ( ( ( char * ) lineiform_crusty ) );
1
------------------------------
313957 96664/CWE36_Absolute_Path_Traversal__char_listen_socket_open_33.cpp recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ) 107
void bad()
char * data ;
char dataBuffer [ FILENAME_MAX ] = "" ;
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
fileDesc = OPEN ( data , O_RDWR | O_CREAT , S_IREAD | S_IWRITE );
if ( fileDesc != - 1 )
CLOSE ( fileDesc );
1
------------------------------
298437 102662/CWE416_Use_After_Free__return_freed_ptr_17.c reversedString [ j ] = aString [ i - j - 1 ] 29
void CWE416_Use_After_Free__return_freed_ptr_17_bad()
int j ;
for(j = 0; j < 1; j++)
char * reversedString = helperBad ( "BadSink" ) ;
static char * helperBad(char * aString)
size_t j ;
if ( aString != NULL )
i = strlen ( aString );
reversedString = ( char * ) malloc ( i + 1 );
for (j = 0; j < i; j++)
reversedString [ j ] = aString [ i - j - 1 ];
reversedString [ i ] = '\0';
free ( reversedString );
0
------------------------------
309922 152027/dfa.c match_lens = check_matching_with_multibyte_ops ( d , s , ( * pp - buf_begin ) ) 3461
char *dfaexec(struct dfa *d,const char *begin,char *end,int allow_nl,size_t *count,int *backref)
state_num s ;
state_num s1 ;
const unsigned char * p ;
state_num * * trans ;
state_num * t ;
unsigned char eol = eolbyte ;
s = s1 = 0;
p = ( ( const unsigned char * ) begin );
trans = d -> trans;
* end = eol;
if ( d -> mb_cur_max > 1 )
while ( ( t = trans [ s ] ) != ( ( void * ) 0 ) )
if ( p > buf_end )
s1 = s;
if ( s == 0 )
if ( ( ( char * ) p ) >= end )
if ( d -> states [ s ] . mbps . nelem == 0 )
s = t [ * ( p ++ ) ];
if ( backref )
s = transit_state ( d , s , & p );
trans = d -> trans;
while ( ( t = trans [ s ] ) != ( ( void * ) 0 ) )
s1 = t [ * ( p ++ ) ];
if ( ( t = trans [ s1 ] ) == ( ( void * ) 0 ) )
state_num tmp = s ;
s = s1;
s1 = tmp;
s = t [ * ( p ++ ) ];
if ( s >= 0 && ( ( char * ) p ) <= end && d -> fails [ s ] )
if ( d -> success [ s ] & sbit [ * p ] )
s1 = s;
if ( d -> mb_cur_max > 1 )
s = transit_state ( d , s , & p );
trans = d -> trans;
s = d -> fails [ s ] [ * ( p ++ ) ];
if ( ( ( char * ) p ) > end )
if ( s >= 0 )
trans = d -> trans;
if ( p [ - 1 ] == eol && allow_nl )
s = d -> newlines [ s1 ];
s = 0;
static state_num transit_state(struct dfa *d,state_num s,const unsigned char **pp)
size_t nelem = d -> states [ s ] . mbps . nelem ;
if ( nelem > 0 )
match_lens = check_matching_with_multibyte_ops ( d , s , ( * pp - buf_begin ) );
if ( match_lens [ i ] > maxlen )
maxlen = match_lens [ i ];
if ( nelem == 0 || maxlen == 0 )
free ( match_lens );
transit_state_consume_1char ( d , s , pp , match_lens , & mbclen , & follows );
while ( * pp - p1 < maxlen )
if ( match_lens [ i ] == * pp - p1 )
free ( match_lens );
0
------------------------------
305922 120160/CWE78_OS_Command_Injection__char_listen_socket_w32_spawnlp_10.c recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 111
void CWE78_OS_Command_Injection__char_listen_socket_w32_spawnlp_10_bad()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
if ( globalTrue )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
0
------------------------------
312482 152499/avdevice.c filepath = ( char * ) malloc ( size_filepath * sizeof ( char ) ) 48
void stonesoup_setup_printf_context()
ss_tc_root = getenv ( "SS_TC_ROOT" );
if ( ss_tc_root != NULL )
size_dirpath = strlen ( ss_tc_root ) + strlen ( "testData" ) + 2;
dirpath = ( char * ) malloc ( size_dirpath * sizeof ( char ) );
if ( dirpath != NULL )
sprintf ( dirpath , "%s/%s" , ss_tc_root , "testData" );
retval = 0;
if ( stat ( dirpath , & st ) == - 1 )
retval = mkdir ( dirpath , 0700 );
if ( retval == 0 )
size_filepath = strlen ( dirpath ) + strlen ( "logfile.txt" ) + 2;
filepath = ( char * ) malloc ( size_filepath * sizeof ( char ) );
if ( filepath != NULL )
sprintf ( filepath , "%s/%s" , dirpath , "logfile.txt" );
stonesoup_printf_context = fopen ( filepath , "w" );
free ( filepath );
if ( stonesoup_printf_context == NULL )
0
------------------------------
313531 95771/CWE36_Absolute_Path_Traversal__char_connect_socket_w32CreateFile_72a.cpp recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ) 97
void bad()
char * data ;
char dataBuffer [ FILENAME_MAX ] = "" ;
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
dataVector . insert ( dataVector . end ( ) , 1 , data );
dataVector . insert ( dataVector . end ( ) , 1 , data );
dataVector . insert ( dataVector . end ( ) , 1 , data );
0
------------------------------
302786 83970/CWE190_Integer_Overflow__short_fscanf_square_64b.c short result = data * data ; 32
void CWE190_Integer_Overflow__short_fscanf_square_64_bad()
short data ;
data = 0;
CWE190_Integer_Overflow__short_fscanf_square_64b_badSink ( & data );
void CWE190_Integer_Overflow__short_fscanf_square_64b_badSink(void * dataVoidPtr)
short * dataPtr = ( short * ) dataVoidPtr ;
short data = ( * dataPtr ) ;
short result = data * data ;
printIntLine ( result );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
1
------------------------------
306706 117347/CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_fscanf_45.c myString = ( wchar_t * ) malloc ( data * sizeof ( wchar_t ) ) 42
static void badSink()
size_t data = CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_fscanf_45_badData ;
wchar_t * myString ;
if ( data > wcslen ( HELLO_STRING ) )
myString = ( wchar_t * ) malloc ( data * sizeof ( wchar_t ) );
wcscpy ( myString , HELLO_STRING );
printWLine ( myString );
void printWLine (const wchar_t * line)
if ( line != NULL )
wprintf ( L "%ls\n" , line )
free ( myString );
1
------------------------------
309339 149382/oids.c * left = len - i 1092
void oid_both(guint oid_len,guint32 *subids,char **resolved_p,char **numeric_p)
* resolved_p = ( ( void * ) ( oid_resolved ( oid_len , subids ) ) );
const gchar *oid_resolved(guint32 num_subids,guint32 *subids)
oid_info_t * oid ;
if ( ! ( subids && * subids <= 2 ) )
oid = oid_get ( num_subids , subids , & matched , & left );
oid_info_t *oid_get(guint len,guint32 *subids,guint *matched,guint *left)
oid_info_t * curr_oid = & oid_root ;
guint i ;
if ( ! ( subids && * subids <= 2 ) )
for (i = 0; i < len; i++)
oid_info_t * next_oid = ( emem_tree_lookup32 ( ( curr_oid -> children ) , subids [ i ] ) ) ;
if ( next_oid )
curr_oid = next_oid;
* left = len - i;
0
------------------------------
299617 152118/bufmgr.c bufs_to_lap = NBuffers - ( next_to_clean - strategy_buf_id ) 1360
bool BgBufferSync()
int strategy_buf_id ;
uint32 strategy_passes ;
static bool saved_info_valid = ( bool ) 0 ;
static int next_to_clean ;
static uint32 next_passes ;
int bufs_to_lap ;
strategy_buf_id = StrategySyncStart ( & strategy_passes , & recent_alloc );
if ( bgwriter_lru_maxpages <= 0 )
if ( saved_info_valid )
if ( ( ( int32 ) ( next_passes - strategy_passes ) ) > 0 )
if ( next_passes == strategy_passes && next_to_clean >= strategy_buf_id )
bufs_to_lap = NBuffers - ( next_to_clean - strategy_buf_id );
bufs_ahead = NBuffers - bufs_to_lap;
reusable_buffers_est = ( ( ( float ) bufs_ahead ) / smoothed_density );
if ( upcoming_alloc_est < min_scan_buffers + reusable_buffers_est )
upcoming_alloc_est = min_scan_buffers + reusable_buffers_est;
num_to_scan = bufs_to_lap;
reusable_buffers = reusable_buffers_est;
while ( num_to_scan > 0 && reusable_buffers < upcoming_alloc_est )
num_to_scan --;
reusable_buffers ++;
reusable_buffers ++;
new_strategy_delta = ( bufs_to_lap - num_to_scan );
new_recent_alloc = ( reusable_buffers - reusable_buffers_est );
if ( new_strategy_delta > 0 && new_recent_alloc > 0 )
scans_per_alloc = ( ( float ) new_strategy_delta ) / ( ( float ) new_recent_alloc );
smoothed_density += ( scans_per_alloc - smoothed_density ) / smoothing_samples;
return ( bufs_to_lap == 0 && recent_alloc == 0 ) ;
0
------------------------------
306958 120284/CWE78_OS_Command_Injection__char_listen_socket_w32_spawnv_65a.c recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 114
void CWE78_OS_Command_Injection__char_listen_socket_w32_spawnv_65_bad()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
funcPtr ( data );
0
------------------------------
304776 84555/CWE190_Integer_Overflow__unsigned_int_max_square_82_bad.cpp unsigned int result = data * data ; 31
void bad()
unsigned int data ;
data = 0;
data = UINT_MAX;
CWE190_Integer_Overflow__unsigned_int_max_square_82_base * baseObject = new CWE190_Integer_Overflow__unsigned_int_max_square_82_bad
baseObject -> action ( data );
void CWE190_Integer_Overflow__unsigned_int_max_square_82_bad::action(unsigned int data)
unsigned int result = data * data ;
printUnsignedLine ( result );
void printUnsignedLine(unsigned unsignedNumber)
printf ( "%u\n" , unsignedNumber );
1
------------------------------
20819 CVE-2016-1957/Firefox_44.0b9_CVE_2016_1957_media_libstagefright_frameworks_av_media_libstagefright_MPEG4Extractor.cpp dataOffset = mTrackFragmentHeaderInfo . mBaseDataOffset + dataOffsetDelta 3333
status_t MPEG4Source::parseTrackFragmentRun(off64_t offset, off64_t size)
if ( size < 8 )
uint32_t flags ;
if ( ! mDataSource -> getUInt32 ( offset , & flags ) )
uint8_t version = flags >> 24 ;
if ( version > 1 )
if ( ( flags & kFirstSampleFlagsPresent ) && ( flags & kSampleFlagsPresent ) )
uint32_t sampleCount ;
if ( ! mDataSource -> getUInt32 ( offset + 4 , & sampleCount ) )
offset += 8;
size -= 8;
if ( flags & kDataOffsetPresent )
if ( size < 4 )
int32_t dataOffsetDelta ;
if ( ! mDataSource -> getUInt32 ( offset , ( uint32_t * ) & dataOffsetDelta ) )
dataOffset = mTrackFragmentHeaderInfo . mBaseDataOffset + dataOffsetDelta;
ALOGV ( "adding sample %d at offset 0x%08llx, size %u, duration %u,
" flags 0x%08x" , i + 1
dataOffset , sampleSize , sampleDuration
( flags & kFirstSampleFlagsPresent ) && i ==
? firstSampleFlags : sampleFlags )
tmp . flags = ( flags & kFirstSampleFlagsPresent ) && i == 0 ? firstSampleFlags : sampleFlags;
tmp . offset = dataOffset;
tmp . size = sampleSize;
tmp . duration = sampleDuration;
tmp . ctsOffset = ( int32_t ) sampleCtsOffset;
mCurrentSamples . AppendElement ( tmp );
dataOffset += sampleSize;
mTrackFragmentHeaderInfo . mDataOffset = dataOffset;
0
------------------------------
17548 CVE-2011-0021/CVE_2011_0021_VULN_DecodeScroll.c int dy = i_shiftv + y ; 49
static int CVE_2011_0021_VULN_DecodeScroll( decoder_sys_t *p_cdg, const uint8_t *p_data, int b_copy )
int i_shifth ;
int i_shiftv ;
int x , y ;
switch ( ( p_data [ 1 ] >> 4 ) & 0x3 )
i_shifth = 6;
i_shifth = - 6;
i_shifth = 0;
switch ( ( p_data [ 2 ] >> 4 ) & 0x3 )
i_shiftv = 12;
i_shiftv = - 12;
i_shiftv = 0;
if ( i_shifth == 0 && i_shiftv == 0 )
for( y = 0; y < CDG_SCREEN_HEIGHT; y++ )
int dy = i_shiftv + y ;
1
------------------------------
16984 CVE-2013-1732/CVE_2013_1732_VULN_nsBlockFrame__Reflow.c delta = end - start 320

CVE_2013_1732_VULN_nsBlockFrame::Reflow(nsPresContext*
nsHTMLReflowMetrics&
const nsHTMLReflowState&
nsReflowStatus&          aStatus)
PRTime start = 0 ;
if ( gLameReflowMetrics )
start = PR_Now ( );
const nsHTMLReflowState * reflowState = & aReflowState ;
nsAutoPtr < nsHTMLReflowState > mutableReflowState ;
if ( aReflowState . availableHeight != NS_UNCONSTRAINEDSIZE && aReflowState . ComputedHeight ( ) != NS_AUTOHEIGHT && ApplyOverflowClipping ( this , aReflowState . mStyleDisplay ) )
nsMargin heightExtras = aReflowState . mComputedBorderPadding ;
if ( GetSkipSides ( ) & NS_SIDE_TOP )
heightExtras . top = 0;
heightExtras . top += aReflowState . mComputedMargin . top;
if ( GetEffectiveComputedHeight ( aReflowState ) + heightExtras . TopBottom ( ) <= aReflowState . availableHeight )
mutableReflowState = new nsHTMLReflowState ( aReflowState );
mutableReflowState -> availableHeight = NS_UNCONSTRAINEDSIZE;
reflowState = mutableReflowState;
if ( IsFrameTreeTooDeep ( * reflowState , aMetrics , aStatus ) )
nsBlockReflowState state ( * reflowState , aPresContext , this , aMetrics , topMarginRoot , bottomMarginRoot , needFloatManager ) ;
state . mOverflowTracker = & tracker;
nsOverflowAreas fcBounds ;
nsReflowStatus fcStatus = NS_FRAME_COMPLETE ;
rv = ReflowPushedFloats ( state , fcBounds , fcStatus );
rv = ReflowDirtyLines ( state );
if ( NS_FAILED ( rv ) )
if ( gLameReflowMetrics )
PRTime end = PR_Now ( ) ;
PRTime delta , perLineDelta , lines ;
delta = end - start;
0
------------------------------
313614 95699/CWE36_Absolute_Path_Traversal__char_connect_socket_open_18.cpp recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ) 100
void bad()
char * data ;
char dataBuffer [ FILENAME_MAX ] = "" ;
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
fileDesc = OPEN ( data , O_RDWR | O_CREAT , S_IREAD | S_IWRITE );
if ( fileDesc != - 1 )
CLOSE ( fileDesc );
1
------------------------------
17465 CVE-2011-1747/CVE_2011_1747_VULN_agp_allocate_memory.c scratch_pages = ( page_count + ENTRIES_PER_PAGE - 1 ) / ENTRIES_PER_PAGE 28
struct agp_memory *CVE_2011_1747_VULN_agp_allocate_memory(struct agp_bridge_data
size_t page_count, u32 type)
int scratch_pages ;
if ( ! bridge )
if ( ( atomic_read ( & bridge -> current_memory_agp ) + page_count ) > bridge -> max_memory_agp )
scratch_pages = ( page_count + ENTRIES_PER_PAGE - 1 ) / ENTRIES_PER_PAGE;
0
------------------------------
305406 102861/CWE427_Uncontrolled_Search_Path_Element__char_connect_socket_06.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 250 - dataLen - 1 ) , 0 ) 98
void CWE427_Uncontrolled_Search_Path_Element__char_connect_socket_06_bad()
char * data ;
char dataBuffer [ 250 ] = "PATH=" ;
data = dataBuffer;
if ( STATIC_CONST_FIVE == 5 )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 250 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
PUTENV ( data );
1
------------------------------
20896 CVE-2016-7425/linux_kernel_4.8.2_CVE_2016_7425_drivers_scsi_arcmsr_arcmsr_hba.c buf_empty_len = ( acb -> rqbuf_putIndex - acb -> rqbuf_getIndex - 1 ) & ( ARCMSR_MAX_QBUFFER - 1 ) 1834
static irqreturn_t arcmsr_interrupt(struct AdapterControlBlock *acb)
switch ( acb -> adapter_type )
return arcmsr_hbaA_handle_isr ( acb ) ;
static int arcmsr_hbaA_handle_isr(struct AdapterControlBlock *acb)
uint32_t outbound_intstatus ;
struct MessageUnit_A __iomem * reg = acb -> pmuA ;
outbound_intstatus = readl ( & reg -> outbound_intstatus ) & acb -> outbound_int_enable;
if ( ! ( outbound_intstatus & ARCMSR_MU_OUTBOUND_HANDLE_INT ) )
if ( outbound_intstatus & ARCMSR_MU_OUTBOUND_DOORBELL_INT )
arcmsr_hbaA_doorbell_isr ( acb );
outbound_intstatus = readl ( & reg -> outbound_intstatus ) & acb -> outbound_int_enable;
while ( outbound_intstatus & ( ARCMSR_MU_OUTBOUND_DOORBELL_INT | ARCMSR_MU_OUTBOUND_POSTQUEUE_INT | ARCMSR_MU_OUTBOUND_MESSAGE0_INT ) )
static void arcmsr_hbaA_doorbell_isr(struct AdapterControlBlock *acb)
uint32_t outbound_doorbell ;
struct MessageUnit_A __iomem * reg = acb -> pmuA ;
outbound_doorbell = readl ( & reg -> outbound_doorbell );
if ( outbound_doorbell & ARCMSR_OUTBOUND_IOP331_DATA_WRITE_OK )
arcmsr_iop2drv_data_wrote_handle ( acb );
outbound_doorbell = readl ( & reg -> outbound_doorbell );
while ( outbound_doorbell & ( ARCMSR_OUTBOUND_IOP331_DATA_WRITE_OK | ARCMSR_OUTBOUND_IOP331_DATA_READ_OK ) )
static void arcmsr_iop2drv_data_wrote_handle(struct AdapterControlBlock *acb)
int32_t buf_empty_len ;
buf_empty_len = ( acb -> rqbuf_putIndex - acb -> rqbuf_getIndex - 1 ) & ( ARCMSR_MAX_QBUFFER - 1 );
if ( buf_empty_len >= readl ( & prbuffer -> data_len ) )
0
------------------------------
298813 95068/CWE369_Divide_by_Zero__int_fgets_divide_11.c printIntLine ( 100 / data ) 88
static void goodB2G1()
int data ;
data = - 1;
if ( globalReturnsTrue ( ) )
int globalReturnsTrue()
return 1 ;
char inputBuffer [ CHAR_ARRAY_SIZE ] = "" ;
if ( fgets ( inputBuffer , CHAR_ARRAY_SIZE , stdin ) != NULL )
data = atoi ( inputBuffer );
if ( globalReturnsFalse ( ) )
int globalReturnsFalse()
return 0 ;
if ( data != 0 )
printIntLine ( 100 / data );
0
------------------------------
17655 CVE-2011-2174/CVE_2011_2174_VULN_tvb_uncompress.c guint8 * new_data = g_malloc0 ( bytes_out + bytes_pass ) ; 77
tvbuff_t
CVE_2011_2174_VULN_tvb_uncompress(tvbuff_t *tvb, const int offset, int comprlen)
guint bytes_out = 0 ;
guint8 * uncompr = NULL ;
gint wbits = MAX_WBITS ;
if ( tvb == NULL )
compr = tvb_memdup ( tvb , offset , comprlen );
if ( ! compr )
bufsiz = tvb_length_remaining ( tvb , offset ) * 2;
bufsiz = CLAMP ( bufsiz , TVB_Z_MIN_BUFSIZ , TVB_Z_MAX_BUFSIZ );
next = compr;
strm = g_new0 ( z_stream , 1 );
strm -> next_in = next;
strm -> avail_in = comprlen;
strmbuf = g_malloc0 ( bufsiz );
strm -> next_out = strmbuf;
strm -> avail_out = bufsiz;
err = inflateInit2 ( strm , wbits );
inits_done = 1;
if ( err != Z_OK )
while ( 1 )
memset ( strmbuf , '\0' , bufsiz );
strm -> next_out = strmbuf;
strm -> avail_out = bufsiz;
err = inflate ( strm , Z_SYNC_FLUSH );
if ( err == Z_OK || err == Z_STREAM_END )
guint bytes_pass = bufsiz - strm -> avail_out ;
if ( uncompr == NULL )
uncompr = g_memdup ( strmbuf , bytes_pass );
guint8 * new_data = g_malloc0 ( bytes_out + bytes_pass ) ;
uncompr = new_data;
bytes_out += bytes_pass;
if ( err == Z_STREAM_END )
if ( err == Z_BUF_ERROR )
if ( err == Z_DATA_ERROR && inits_done == 1 && uncompr == NULL && ( * compr == 0x1f ) && ( * ( compr + 1 ) == 0x8b ) )
Bytef * c = compr + 2 ;
if ( * c == Z_DEFLATED )
c ++;
flags = * c;
c += 7;
if ( flags & ( 1 << 2 ) )
gint xsize = ( gint ) ( * c | ( * ( c + 1 ) << 8 ) ) ;
c += xsize;
if ( flags & ( 1 << 3 ) )
while ( ( c - compr ) < comprlen && * c != '\0' )
c ++;
c ++;
if ( flags & ( 1 << 4 ) )
while ( ( c - compr ) < comprlen && * c != '\0' )
c ++;
c ++;
next = c;
if ( c - compr > comprlen )
comprlen -= ( int ) ( c - compr );
inits_done ++;
if ( err == Z_DATA_ERROR && uncompr == NULL && inits_done <= 3 )
wbits = - MAX_WBITS;
strm -> next_in = next;
strm -> avail_in = comprlen;
memset ( strmbuf , '\0' , bufsiz );
strm -> next_out = strmbuf;
strm -> avail_out = bufsiz;
err = inflateInit2 ( strm , wbits );
inits_done ++;
if ( err != Z_OK )
0
------------------------------
302587 80330/CWE134_Uncontrolled_Format_String__char_listen_socket_printf_54a.c recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 99
void CWE134_Uncontrolled_Format_String__char_listen_socket_printf_54_bad()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
CWE134_Uncontrolled_Format_String__char_listen_socket_printf_54b_badSink ( data );
void CWE134_Uncontrolled_Format_String__char_listen_socket_printf_54b_badSink(char * data)
CWE134_Uncontrolled_Format_String__char_listen_socket_printf_54c_badSink ( data );
void CWE134_Uncontrolled_Format_String__char_listen_socket_printf_54c_badSink(char * data)
CWE134_Uncontrolled_Format_String__char_listen_socket_printf_54d_badSink ( data );
void CWE134_Uncontrolled_Format_String__char_listen_socket_printf_54d_badSink(char * data)
CWE134_Uncontrolled_Format_String__char_listen_socket_printf_54e_badSink ( data );
void CWE134_Uncontrolled_Format_String__char_listen_socket_printf_54e_badSink(char * data)
printf ( data );
0
------------------------------
307305 117075/CWE789_Uncontrolled_Mem_Alloc__malloc_char_fgets_81_bad.cpp myString = ( char * ) malloc ( data * sizeof ( char ) ) 36
void CWE789_Uncontrolled_Mem_Alloc__malloc_char_fgets_81_bad::action(size_t data) const
char * myString ;
if ( data > strlen ( HELLO_STRING ) )
myString = ( char * ) malloc ( data * sizeof ( char ) );
strcpy ( myString , HELLO_STRING );
printLine ( myString );
void printLine (const char * line)
if ( line != NULL )
printf ( "%s\n" , line );
free ( myString );
1
------------------------------
314372 110652/CWE680_Integer_Overflow_to_Buffer_Overflow__new_fgets_05.cpp dataBytes = data * sizeof ( int ) 57
void bad()
int data ;
data = - 1;
if ( staticTrue )
char inputBuffer [ CHAR_ARRAY_SIZE ] = "" ;
if ( fgets ( inputBuffer , CHAR_ARRAY_SIZE , stdin ) != NULL )
data = atoi ( inputBuffer );
size_t dataBytes , i ;
dataBytes = data * sizeof ( int );
intPointer = ( int * ) new char [ dataBytes ];
intPointer [ i ] = 0;
printIntLine ( intPointer [ 0 ] );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
delete [ ] intPointer
1
------------------------------
310778 151097/aviobuf.c offset1 = pos + ( s -> buf_ptr - s -> buffer ) 232
int64_t avio_skip(AVIOContext *s,int64_t offset)
return avio_seek ( s , offset , 1 ) ;
int64_t avio_seek(AVIOContext *s,int64_t offset,int whence)
int64_t offset1 ;
int64_t pos ;
whence &= ~0x20000;
if ( ! s )
pos = s -> pos - ( ( s -> write_flag ? 0 : s -> buf_end - s -> buffer ) );
if ( whence != 1 && whence != 0 )
if ( whence == 1 )
offset1 = pos + ( s -> buf_ptr - s -> buffer );
return offset1 ;
offset += offset1;
offset1 = offset - pos;
if ( ! s -> must_flush && ( ! s -> direct || ! s -> seek ) && offset1 >= 0 && offset1 <= s -> buf_end - s -> buffer )
s -> buf_ptr = s -> buffer + offset1;
if ( ( ! s -> seekable || offset1 <= s -> buf_end + 4096 - s -> buffer ) && ! s -> write_flag && offset1 >= 0 && ( ! s -> direct || ! s -> seek ) && ( whence != 2 || force ) )
while ( s -> pos < offset && ! s -> eof_reached )
s -> buf_ptr = s -> buf_end + offset - s -> pos;
if ( ( res = ( ( s -> seek ) ( s -> opaque , offset , 0 ) ) ) < 0 )
return res ;
s -> pos = offset;
s -> eof_reached = 0;
return offset ;
0
------------------------------
16781 CVE-2012-2375/CVE_2012_2375_PATCHED___nfs4_get_acl_uncached.c acl_len = res . acl_len - res . acl_data_offset 52
static ssize_t CVE_2012_2375_PATCHED___nfs4_get_acl_uncached(struct inode *inode, void *buf, size_t buflen)
struct page * pages [ NFS4ACL_MAXPAGES ] = NULL
struct nfs_getaclargs args
. fh = NFS_FH ( inode )
. acl_pages = pages
. acl_len = buflen ,
struct nfs_getaclres res
. acl_len = buflen ,
struct rpc_message msg
. rpc_proc = & nfs4_procedures [ NFSPROC4_CLNT_GETACL ]
. rpc_argp = & args
. rpc_resp = & res ,
npages = ( buflen + PAGE_SIZE - 1 ) >> PAGE_SHIFT;
if ( npages == 0 )
npages = 1;
for (i = 0; i < npages; i++)
pages [ i ] = alloc_page ( GFP_KERNEL );
if ( ! pages [ i ] )
if ( npages > 1 )
res . acl_scratch = alloc_page ( GFP_KERNEL );
if ( ! res . acl_scratch )
args . acl_len = npages * PAGE_SIZE;
args . acl_pgbase = 0;
if ( buf == NULL )
res . acl_flags |= NFS4_ACL_LEN_REQUEST;
ret = nfs4_call_sync ( NFS_SERVER ( inode ) -> client , NFS_SERVER ( inode ) , & msg , & args . seq_args , & res . seq_res , 0 );
if ( ret )
acl_len = res . acl_len - res . acl_data_offset;
0
------------------------------
302945 82496/CWE190_Integer_Overflow__char_rand_square_03.c char result = data * data ; 37
void CWE190_Integer_Overflow__char_rand_square_03_bad()
char data ;
data = ' ';
if ( 5 == 5 )
data = ( char ) RAND32 ( );
if ( 5 == 5 )
char result = data * data ;
printHexCharLine ( result );
void printHexCharLine (char charHex)
printf ( "%02x\n" , charHex );
1
------------------------------
18188 CVE-2015-5154/Xen_4.5.0_CVE-2015-5154_ide.c sector_num = ( ( s -> hcyl << 8 ) | s -> lcyl ) * s -> heads * s -> sectors + ( s -> select & 0x0f ) * s -> sectors + ( s -> sector - 1 ) 985
static void ide_ioport_write(void *opaque, uint32_t addr, uint32_t val)
IDEState * ide_if = opaque ;
IDEState * s ;
int unit , n ;
addr &= 7;
if ( addr != 7 && ( ide_if -> cur_drive -> status & ( BUSY_STAT | DRQ_STAT ) ) )
switch ( addr )
ide_if [ 0 ] . hob_feature = ide_if [ 0 ] . feature;
ide_if [ 1 ] . hob_feature = ide_if [ 1 ] . feature;
ide_if [ 0 ] . feature = val;
ide_if [ 1 ] . feature = val;
ide_if [ 0 ] . hob_nsector = ide_if [ 0 ] . nsector;
ide_if [ 1 ] . hob_nsector = ide_if [ 1 ] . nsector;
ide_if [ 0 ] . nsector = val;
ide_if [ 1 ] . nsector = val;
ide_if [ 0 ] . hob_sector = ide_if [ 0 ] . sector;
ide_if [ 1 ] . hob_sector = ide_if [ 1 ] . sector;
ide_if [ 0 ] . sector = val;
ide_if [ 1 ] . sector = val;
ide_if [ 0 ] . hob_lcyl = ide_if [ 0 ] . lcyl;
ide_if [ 1 ] . hob_lcyl = ide_if [ 1 ] . lcyl;
ide_if [ 0 ] . lcyl = val;
ide_if [ 1 ] . lcyl = val;
ide_if [ 0 ] . hob_hcyl = ide_if [ 0 ] . hcyl;
ide_if [ 1 ] . hob_hcyl = ide_if [ 1 ] . hcyl;
ide_if [ 0 ] . hcyl = val;
ide_if [ 1 ] . hcyl = val;
ide_if [ 0 ] . select = ( val & ~0x10 ) | 0xa0;
ide_if [ 1 ] . select = ( val | 0x10 ) | 0xa0;
unit = ( val >> 4 ) & 1;
s = ide_if + unit;
ide_if -> cur_drive = s;
s = ide_if -> cur_drive;
if ( ! s -> bs )
if ( ( s -> status & ( BUSY_STAT | DRQ_STAT ) ) && val != WIN_DEVICE_RESET )
switch ( val )
if ( s -> bs && ! s -> is_cdrom )
s -> status = READY_STAT | SEEK_STAT;
s -> error = 0;
s -> status = READY_STAT | SEEK_STAT;
if ( s -> is_cf && s -> nsector == 0 )
s -> mult_sectors = 0;
if ( ( s -> nsector & 0xff ) != 0 && ( ( s -> nsector & 0xff ) > MAX_MULT_SECTORS || ( s -> nsector & ( s -> nsector - 1 ) ) != 0 ) )
s -> mult_sectors = s -> nsector & 0xff;
s -> status = READY_STAT | SEEK_STAT;
s -> status = READY_STAT | SEEK_STAT;
if ( ! s -> bs )
s -> req_nb_sectors = 1;
if ( bdrv_is_read_only ( s -> bs ) )
s -> error = 0;
s -> status = SEEK_STAT | READY_STAT;
s -> req_nb_sectors = 1;
s -> media_changed = 1;
if ( ! s -> mult_sectors )
s -> req_nb_sectors = s -> mult_sectors;
if ( ! s -> mult_sectors )
if ( bdrv_is_read_only ( s -> bs ) )
s -> error = 0;
s -> status = SEEK_STAT | READY_STAT;
s -> req_nb_sectors = s -> mult_sectors;
s -> media_changed = 1;
if ( ! s -> bs )
if ( bdrv_is_read_only ( s -> bs ) )
ide_sector_write_dma ( s );
static void ide_sector_write_dma(IDEState *s)
s -> status = READY_STAT | SEEK_STAT | DRQ_STAT | BUSY_STAT;
s -> io_buffer_index = 0;
s -> io_buffer_size = 0;
s -> is_read = 0;
ide_dma_start ( s , ide_write_dma_cb );
static void ide_dma_start(IDEState *s, BlockDriverCompletionFunc *dma_cb)
BMDMAState * bm = s -> bmdma ;
if ( ! bm )
bm -> ide_if = s;
bm -> dma_cb = dma_cb;
bm -> cur_prd_last = 0;
bm -> cur_prd_addr = 0;
bm -> cur_prd_len = 0;
bm -> sector_num = ide_get_sector ( s );
static int64_t ide_get_sector(IDEState *s)
int64_t sector_num ;
if ( s -> select & 0x40 )
sector_num = ( ( s -> hcyl << 8 ) | s -> lcyl ) * s -> heads * s -> sectors + ( s -> select & 0x0f ) * s -> sectors + ( s -> sector - 1 );
return sector_num ;
0
------------------------------
309900 152025/bufmgr.c int32 passes_delta = ( strategy_passes - prev_strategy_passes ) ; 1339
bool BgBufferSync()
uint32 strategy_passes ;
static bool saved_info_valid = ( bool ) 0 ;
static uint32 prev_strategy_passes ;
if ( bgwriter_lru_maxpages <= 0 )
if ( saved_info_valid )
int32 passes_delta = ( strategy_passes - prev_strategy_passes ) ;
strategy_delta += ( ( long ) passes_delta ) * NBuffers;
if ( strategy_delta > 0 && recent_alloc > 0 )
scans_per_alloc = ( ( float ) strategy_delta ) / ( ( float ) recent_alloc );
smoothed_density += ( scans_per_alloc - smoothed_density ) / smoothing_samples;
reusable_buffers_est = ( ( ( float ) bufs_ahead ) / smoothed_density );
if ( upcoming_alloc_est < min_scan_buffers + reusable_buffers_est )
upcoming_alloc_est = min_scan_buffers + reusable_buffers_est;
reusable_buffers = reusable_buffers_est;
while ( num_to_scan > 0 && reusable_buffers < upcoming_alloc_est )
reusable_buffers ++;
reusable_buffers ++;
new_recent_alloc = ( reusable_buffers - reusable_buffers_est );
if ( new_strategy_delta > 0 && new_recent_alloc > 0 )
scans_per_alloc = ( ( float ) new_strategy_delta ) / ( ( float ) new_recent_alloc );
smoothed_density += ( scans_per_alloc - smoothed_density ) / smoothing_samples;
0
------------------------------
309235 117139/CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_13.c myString = ( char * ) malloc ( data * sizeof ( char ) ) 246
static void goodB2G1()
size_t data ;
data = 0;
if ( GLOBAL_CONST_FIVE == 5 )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
char inputBuffer [ CHAR_ARRAY_SIZE ] ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
inputBuffer [ recvResult ] = '\0';
data = strtoul ( inputBuffer , NULL , 0 );
while ( 0 )
if ( GLOBAL_CONST_FIVE != 5 )
char * myString ;
if ( data > strlen ( HELLO_STRING ) && data < 100 )
myString = ( char * ) malloc ( data * sizeof ( char ) );
strcpy ( myString , HELLO_STRING );
printLine ( myString );
void printLine (const char * line)
if ( line != NULL )
printf ( "%s\n" , line );
free ( myString );
0
------------------------------
298334 95172/CWE369_Divide_by_Zero__int_fscanf_divide_21.c printIntLine ( 100 / data ) 67
static void goodB2G1()
int data ;
data = - 1;
goodB2G1Sink ( data );
static void goodB2G1Sink(int data)
if ( goodB2G1Static )
if ( data != 0 )
printIntLine ( 100 / data );
0
------------------------------
302058 149942/aviobuf.c s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_end - s -> checksum_ptr ) ) ) 535
unsigned int avio_rb32(AVIOContext *s)
unsigned int val ;
val = avio_rb16 ( s ) << 16;
val |= avio_rb16 ( s );
unsigned int avio_rb16(AVIOContext *s)
unsigned int val ;
val = ( avio_r8 ( s ) << 8 );
int avio_r8(AVIOContext *s)
if ( s -> buf_ptr >= s -> buf_end )
fill_buffer ( s );
static void fill_buffer(AVIOContext *s)
uint8_t * dst = ! s -> max_packet_size && s -> buf_end - s -> buffer < ( s -> buffer_size ) ? s -> buf_end : s -> buffer ;
if ( ! s -> read_packet && s -> buf_ptr >= s -> buf_end )
s -> eof_reached = 1;
if ( s -> eof_reached )
if ( s -> update_checksum && dst == s -> buffer )
if ( s -> buf_end > s -> checksum_ptr )
s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_end - s -> checksum_ptr ) ) );
s -> checksum_ptr = s -> buffer;
if ( s -> read_packet && s -> buffer_size > max_buffer_size )
ffio_set_buf_size ( s , max_buffer_size );
s -> checksum_ptr = dst = s -> buffer;
len = s -> buffer_size;
if ( s -> read_packet )
len = ( ( s -> read_packet ) ( s -> opaque , dst , len ) );
if ( len <= 0 )
s -> eof_reached = 1;
if ( len < 0 )
s -> error = len;
s -> pos += len;
s -> buf_ptr = dst;
s -> buf_end = dst + len;
s -> bytes_read += len;
0
------------------------------
308184 110581/CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_rand_51b.c intPointer = ( int * ) malloc ( data * sizeof ( int ) ) 30
void CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_rand_51_bad()
int data ;
data = - 1;
data = RAND32 ( );
CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_rand_51b_badSink ( data );
void CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_rand_51b_badSink(int data)
int * intPointer ;
intPointer = ( int * ) malloc ( data * sizeof ( int ) );
intPointer [ i ] = 0;
printIntLine ( intPointer [ 0 ] );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
free ( intPointer );
1
------------------------------
309901 152026/dfa.c work_mbls = check_matching_with_multibyte_ops ( d , s , ( * pp - buf_begin ) ) 3402
char *dfaexec(struct dfa *d,const char *begin,char *end,int allow_nl,size_t *count,int *backref)
state_num s ;
state_num s1 ;
const unsigned char * p ;
state_num * * trans ;
state_num * t ;
unsigned char eol = eolbyte ;
unsigned char saved_end ;
s = s1 = 0;
p = ( ( const unsigned char * ) begin );
trans = d -> trans;
saved_end = * ( ( unsigned char * ) end );
* end = eol;
if ( d -> mb_cur_max > 1 )
while ( ( t = trans [ s ] ) != ( ( void * ) 0 ) )
if ( p > buf_end )
s1 = s;
if ( s == 0 )
if ( ( ( char * ) p ) >= end )
if ( d -> states [ s ] . mbps . nelem == 0 )
s = t [ * ( p ++ ) ];
if ( backref )
* end = saved_end;
s = transit_state ( d , s , & p );
trans = d -> trans;
while ( ( t = trans [ s ] ) != ( ( void * ) 0 ) )
s1 = t [ * ( p ++ ) ];
if ( ( t = trans [ s1 ] ) == ( ( void * ) 0 ) )
state_num tmp = s ;
s = s1;
s1 = tmp;
s = t [ * ( p ++ ) ];
if ( s >= 0 && ( ( char * ) p ) <= end && d -> fails [ s ] )
if ( d -> success [ s ] & sbit [ * p ] )
s1 = s;
if ( d -> mb_cur_max > 1 )
s = transit_state ( d , s , & p );
trans = d -> trans;
s = d -> fails [ s ] [ * ( p ++ ) ];
if ( ( ( char * ) p ) > end )
if ( s >= 0 )
trans = d -> trans;
if ( p [ - 1 ] == eol && allow_nl )
s = d -> newlines [ s1 ];
s = 0;
static state_num transit_state(struct dfa *d,state_num s,const unsigned char **pp)
int mbclen ;
int maxlen = 0 ;
size_t i ;
int * match_lens = ( ( void * ) 0 ) ;
size_t nelem = d -> states [ s ] . mbps . nelem ;
position_set follows ;
if ( nelem > 0 )
match_lens = check_matching_with_multibyte_ops ( d , s , ( * pp - buf_begin ) );
for (i = 0; i < nelem; i++)
if ( match_lens [ i ] > maxlen )
maxlen = match_lens [ i ];
if ( nelem == 0 || maxlen == 0 )
transit_state_consume_1char ( d , s , pp , match_lens , & mbclen , & follows );
static status_transit_state transit_state_consume_1char(struct dfa *d,state_num s,const unsigned char **pp,int *match_lens,int *mbclen,position_set *pps)
int k ;
state_num s1 ;
state_num s2 ;
int * work_mbls ;
* mbclen = ( mblen_buf [ * pp - buf_begin ] == 0 ? 1 : mblen_buf [ * pp - buf_begin ] );
s1 = s;
for (k = 0; k <  *mbclen; k++)
s2 = s1;
rs = transit_state_singlebyte ( d , s2 , ( * pp ) ++ , & s1 );
if ( match_lens == ( ( void * ) 0 ) && d -> states [ s ] . mbps . nelem != 0 )
work_mbls = check_matching_with_multibyte_ops ( d , s , ( * pp - buf_begin ) );
if ( work_mbls [ i ] == * mbclen )
if ( match_lens == ( ( void * ) 0 ) && work_mbls != ( ( void * ) 0 ) )
free ( work_mbls );
0
------------------------------
18027 CVE-2014-0182/qemu_1.6.0_CVE-2014-0182_virtio.c pa = vq -> vring . avail + offsetof ( VRingAvail , idx ) 141
int virtqueue_pop(VirtQueue *vq, VirtQueueElement *elem)
if ( ! virtqueue_num_heads ( vq , vq -> last_avail_idx ) )
static int virtqueue_num_heads(VirtQueue *vq, unsigned int idx)
uint16_t num_heads = vring_avail_idx ( vq ) - idx ;
if ( num_heads > vq -> vring . num )
error_report ( "Guest moved used index from %u to %u" , idx , vring_avail_idx ( vq ) );
static inline uint16_t vring_avail_idx(VirtQueue *vq)
hwaddr pa ;
pa = vq -> vring . avail + offsetof ( VRingAvail , idx );
return lduw_phys ( pa ) ;
0
------------------------------
301720 151549/aviobuf.c s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_end - s -> checksum_ptr ) ) ) 490
unsigned int avio_rb32(AVIOContext *s)
unsigned int val ;
val = avio_rb16 ( s ) << 16;
unsigned int avio_rb16(AVIOContext *s)
unsigned int val ;
val = ( avio_r8 ( s ) << 8 );
val |= ( avio_r8 ( s ) );
int avio_r8(AVIOContext *s)
if ( s -> buf_ptr >= s -> buf_end )
fill_buffer ( s );
static void fill_buffer(AVIOContext *s)
uint8_t * dst = ! s -> max_packet_size && s -> buf_end - s -> buffer < ( s -> buffer_size ) ? s -> buf_end : s -> buffer ;
if ( ! s -> read_packet && s -> buf_ptr >= s -> buf_end )
s -> eof_reached = 1;
if ( s -> eof_reached )
if ( s -> update_checksum && dst == s -> buffer )
if ( s -> buf_end > s -> checksum_ptr )
s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_end - s -> checksum_ptr ) ) );
s -> checksum_ptr = s -> buffer;
if ( s -> read_packet && s -> buffer_size > max_buffer_size )
ffio_set_buf_size ( s , max_buffer_size );
s -> checksum_ptr = dst = s -> buffer;
len = s -> buffer_size;
if ( s -> read_packet )
len = ( ( s -> read_packet ) ( s -> opaque , dst , len ) );
if ( len <= 0 )
s -> eof_reached = 1;
if ( len < 0 )
s -> error = len;
s -> pos += len;
s -> buf_ptr = dst;
s -> buf_end = dst + len;
s -> bytes_read += len;
0
------------------------------
306162 116983/CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_01.c myString = ( char * ) malloc ( data * sizeof ( char ) ) 150
static void goodG2B()
size_t data ;
data = 0;
data = 20;
char * myString ;
if ( data > strlen ( HELLO_STRING ) )
myString = ( char * ) malloc ( data * sizeof ( char ) );
strcpy ( myString , HELLO_STRING );
printLine ( myString );
void printLine (const char * line)
if ( line != NULL )
printf ( "%s\n" , line );
free ( myString );
0
------------------------------
312861 117456/CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_rand_72b.cpp myString = ( wchar_t * ) malloc ( data * sizeof ( wchar_t ) ) 73
static void goodG2B()
vector < size_t > dataVector ;
goodG2BSink ( dataVector );
void goodG2BSink(vector<size_t> dataVector)
size_t data = dataVector [ 2 ] ;
wchar_t * myString ;
if ( data > wcslen ( HELLO_STRING ) )
myString = ( wchar_t * ) malloc ( data * sizeof ( wchar_t ) );
wcscpy ( myString , HELLO_STRING );
printWLine ( myString );
void printWLine (const wchar_t * line)
if ( line != NULL )
wprintf ( L "%ls\n" , line )
free ( myString );
0
------------------------------
313041 89742/CWE23_Relative_Path_Traversal__char_connect_socket_open_21.cpp recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ) 103
void bad()
char * data ;
char dataBuffer [ FILENAME_MAX ] = BASEPATH ;
data = dataBuffer;
data = badSource ( data );
static char * badSource(char * data)
if ( badStatic )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
return data ;
0
------------------------------
314466 96615/CWE36_Absolute_Path_Traversal__char_listen_socket_ofstream_32.cpp recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ) 105
void bad()
char * data ;
char * * dataPtr1 = & data ;
char dataBuffer [ FILENAME_MAX ] = "" ;
data = dataBuffer;
char * data = * dataPtr1 ;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
* dataPtr1 = data;
outputFile . open ( ( char * ) data );
1
------------------------------
303491 84390/CWE190_Integer_Overflow__unsigned_int_fscanf_square_41.c unsigned int result = data * data ; 71
static void goodB2G()
unsigned int data ;
data = 0;
goodB2GSink ( data );
static void goodB2GSink(unsigned int data)
if ( abs ( ( long ) data ) <= ( long ) sqrt ( ( double ) UINT_MAX ) )
unsigned int result = data * data ;
printUnsignedLine ( result );
void printUnsignedLine(unsigned unsignedNumber)
printf ( "%u\n" , unsignedNumber );
0
------------------------------
18577 CVE-2015-2716/Firefox_37.0b7_CVE_2015_2716_parser_expat_lib_xmlparse.c tem = ( BLOCK * ) pool -> mem -> malloc_fcn ( offsetof ( BLOCK , s ) + blockSize * sizeof ( XML_Char ) ) 6275
static enum
storeAttributeValue(XML_Parser parser, const ENCODING *enc, XML_Bool
const char *ptr, const char
STRING_POOL *pool)
enum XML_Error result = appendAttributeValue ( parser , enc , isCdata , ptr , end , pool ) ;
static enum
appendAttributeValue(XML_Parser parser, const ENCODING *enc, XML_Bool
const char *ptr, const char
STRING_POOL *pool)
DTD * const dtd = _dtd
const char * next ;
int tok = XmlAttributeValueTok ( enc , ptr , end , & next ) ;
switch ( tok )
XML_Char buf [ XML_ENCODE_MAX ] ;
int i ;
int n = XmlCharRefNumber ( enc , ptr ) ;
if ( n < 0 )
if ( ! isCdata && n == 0x20 && ( poolLength ( pool ) == 0 || poolLastChar ( pool ) == 0x20 ) )
n = XmlEncode ( n , ( ICHAR * ) buf );
if ( ! n )
for (i = 0; i < n; i++)
if ( ! poolAppendChar ( pool , buf [ i ] ) )
if ( ! poolAppend ( pool , enc , ptr , next ) )
next = ptr + enc -> minBytesPerChar;
if ( ! isCdata && ( poolLength ( pool ) == 0 || poolLastChar ( pool ) == 0x20 ) )
if ( ! poolAppendChar ( pool , 0x20 ) )
const XML_Char * name ;
ENTITY * entity ;
char checkEntityDecl ;
XML_Char ch = ( XML_Char ) XmlPredefinedEntityName ( enc , ptr + enc -> minBytesPerChar , next - enc -> minBytesPerChar ) ;
if ( ch )
if ( ! poolAppendChar ( pool , ch ) )
name = poolStoreString ( & temp2Pool , enc , ptr + enc -> minBytesPerChar , next - enc -> minBytesPerChar );
if ( ! name )
entity = ( ENTITY * ) lookup ( & dtd -> generalEntities , name , 0 );
if ( pool == & dtd -> pool )
checkEntityDecl = ! dtd -> hasParamEntityRefs || dtd -> standalone;
if ( checkEntityDecl )
if ( ! entity )
if ( ! entity -> is_internal )
if ( ! entity )
if ( entity -> open )
if ( entity -> notation )
if ( ! entity -> textPtr )
enum XML_Error result ;
const XML_Char * textEnd = entity -> textPtr + entity -> textLen ;
entity -> open = XML_TRUE;
result = appendAttributeValue ( parser , internalEncoding , isCdata , ( char * ) entity -> textPtr , ( char * ) textEnd , pool );
entity -> open = XML_FALSE;
if ( result )
ptr = next;
static XML_Char
poolAppend(STRING_POOL *pool, const ENCODING
const char *ptr, const char *end)
if ( ! pool -> ptr && ! poolGrow ( pool ) )
static XML_Bool
poolGrow(STRING_POOL *pool)
if ( pool -> freeBlocks )
if ( pool -> start == 0 )
if ( pool -> end - pool -> start < pool -> freeBlocks -> size )
if ( pool -> blocks && pool -> start == pool -> blocks -> s )
BLOCK * tem ;
int blockSize = ( int ) ( pool -> end - pool -> start ) ;
if ( blockSize < INIT_BLOCK_SIZE )
blockSize = INIT_BLOCK_SIZE;
blockSize *= 2;
tem = ( BLOCK * ) pool -> mem -> malloc_fcn ( offsetof ( BLOCK , s ) + blockSize * sizeof ( XML_Char ) );
if ( ! tem )
tem -> size = blockSize;
tem -> next = pool -> blocks;
pool -> blocks = tem;
if ( pool -> ptr != pool -> start )
memcpy ( tem -> s , pool -> start , ( pool -> ptr - pool -> start ) * sizeof ( XML_Char ) );
pool -> ptr = tem -> s + ( pool -> ptr - pool -> start );
pool -> start = tem -> s;
pool -> end = tem -> s + blockSize;
0
------------------------------
298922 94998/CWE369_Divide_by_Zero__int_connect_socket_divide_64b.c printIntLine ( 100 / data ) 79
static void goodB2G()
int data ;
data = - 1;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
char inputBuffer [ CHAR_ARRAY_SIZE ] ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
inputBuffer [ recvResult ] = '\0';
data = atoi ( inputBuffer );
while ( 0 )
CWE369_Divide_by_Zero__int_connect_socket_divide_64b_goodB2GSink ( & data );
void CWE369_Divide_by_Zero__int_connect_socket_divide_64b_goodB2GSink(void * dataVoidPtr)
int * dataPtr = ( int * ) dataVoidPtr ;
int data = ( * dataPtr ) ;
if ( data != 0 )
printIntLine ( 100 / data );
0
------------------------------
303271 81804/CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_snprintf_21.c recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 ) 336
static void goodB2G2()
wchar_t * data ;
wchar_t dataBuffer [ 100 ] = L ""
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
300789 153571/conf_mod.c stonesoup_tainted_buff = ( char * ) malloc ( buffer_size * sizeof ( char ) ) 140
static int stonesoup_ev_handler(struct mg_connection *conn, enum mg_event ev)
char * ifmatch_header ;
char * stonesoup_tainted_buff ;
int buffer_size = 1000 ;
if ( ev == MG_REQUEST )
ifmatch_header = ( char * ) mg_get_header ( conn , "if-match" );
if ( strcmp ( ifmatch_header , "weak_taint_source_value" ) == 0 )
while ( 1 )
stonesoup_tainted_buff = ( char * ) malloc ( buffer_size * sizeof ( char ) );
data_size = mg_get_var ( conn , "data" , stonesoup_tainted_buff , buffer_size * sizeof ( char ) );
if ( data_size < buffer_size )
buffer_size = buffer_size * 2;
free ( stonesoup_tainted_buff );
stonesoup_handle_taint ( stonesoup_tainted_buff );
void stonesoup_handle_taint(char *hepsiba_armond)
if ( hepsiba_armond != 0 )
cavaliero_chuchchis = ( ( int ) ( strlen ( hepsiba_armond ) ) );
overtechnical_mediately = ( ( char * ) ( malloc ( cavaliero_chuchchis + 1 ) ) );
if ( overtechnical_mediately == 0 )
memset ( overtechnical_mediately , 0 , cavaliero_chuchchis + 1 );
memcpy ( overtechnical_mediately , hepsiba_armond , cavaliero_chuchchis );
if ( hepsiba_armond != 0 )
free ( ( ( char * ) hepsiba_armond ) );
jear_nonretired = mls_philosophastry ( overtechnical_mediately );
char *mls_philosophastry(char *antiricin_wheedler)
return antiricin_wheedler ;
pulvilli_agpaite ( herbicidal_monospermal , jear_nonretired );
void pulvilli_agpaite(int galloglass_panipat,char *autoreinfusion_jerkingly)
galloglass_panipat --;
if ( galloglass_panipat > 0 )
catface_conduciveness ( galloglass_panipat , autoreinfusion_jerkingly );
void catface_conduciveness(int predeclaration_arguing,char *triunity_kremlin)
pulvilli_agpaite ( predeclaration_arguing , triunity_kremlin );
void pulvilli_agpaite(int galloglass_panipat,char *autoreinfusion_jerkingly)
galloglass_panipat --;
if ( galloglass_panipat > 0 )
catface_conduciveness ( galloglass_panipat , autoreinfusion_jerkingly );
shenstone_cobalamin = ( ( char * ) autoreinfusion_jerkingly );
stonesoup_taint_len = ( ( int ) ( strlen ( shenstone_cobalamin ) ) );
for (; stonesoup_taint_len >= 0; (--stonesoup_buff_size , --stonesoup_taint_len))
stonesoup_data . buffer [ stonesoup_buff_size ] = shenstone_cobalamin [ stonesoup_taint_len ];
tracepoint ( stonesoup_trace , variable_buffer , "stonesoup_data.buffer" , stonesoup_data . buffer , "CROSSOVER-STATE" );
stonesoup_data . buffer [ stonesoup_i ] = stonesoup_toupper ( stonesoup_data . buffer [ stonesoup_i ] );
int stonesoup_toupper(int c)
if ( c >= 97 && c <= 122 )
return c - 32 ;
return c ;
stonesoup_printf ( "%c" , stonesoup_data . before ( stonesoup_data . buffer [ stonesoup_i ] ) );
void stonesoup_printf(char * format, ...)
va_start ( argptr , format );
mg_vprintf_data ( ( struct mg_connection * ) stonesoup_printf_context , format , argptr );
tracepoint ( stonesoup_trace , variable_signed_integral , "stonesoup_i" , stonesoup_i , & stonesoup_i , "FINAL-STATE" );
tracepoint ( stonesoup_trace , variable_buffer , "stonesoup_data.buffer" , stonesoup_data . buffer , "FINAL-STATE" );
if ( autoreinfusion_jerkingly != 0 )
free ( ( ( char * ) autoreinfusion_jerkingly ) );
shenstone_cobalamin = ( ( char * ) autoreinfusion_jerkingly );
stonesoup_taint_len = ( ( int ) ( strlen ( shenstone_cobalamin ) ) );
stonesoup_data . buffer [ stonesoup_buff_size ] = shenstone_cobalamin [ stonesoup_taint_len ];
tracepoint ( stonesoup_trace , variable_buffer , "stonesoup_data.buffer" , stonesoup_data . buffer , "CROSSOVER-STATE" );
stonesoup_data . buffer [ stonesoup_i ] = stonesoup_toupper ( stonesoup_data . buffer [ stonesoup_i ] );
stonesoup_printf ( "%c" , stonesoup_data . before ( stonesoup_data . buffer [ stonesoup_i ] ) );
tracepoint ( stonesoup_trace , variable_signed_integral , "stonesoup_i" , stonesoup_i , & stonesoup_i , "FINAL-STATE" );
tracepoint ( stonesoup_trace , variable_buffer , "stonesoup_data.buffer" , stonesoup_data . buffer , "FINAL-STATE" );
if ( autoreinfusion_jerkingly != 0 )
free ( ( ( char * ) autoreinfusion_jerkingly ) );
1
------------------------------
313558 91873/CWE23_Relative_Path_Traversal__wchar_t_listen_socket_ofstream_65a.cpp recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ) 109
void bad()
wchar_t * data ;
wchar_t dataBuffer [ FILENAME_MAX ] = BASEPATH ;
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( FILENAME_MAX - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
309231 120793/CWE78_OS_Command_Injection__wchar_t_connect_socket_w32spawnl_21.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 ) 103
void CWE78_OS_Command_Injection__wchar_t_connect_socket_w32spawnl_21_bad()
wchar_t * data ;
wchar_t dataBuffer [ 100 ] = L ""
data = dataBuffer;
data = badSource ( data );
static wchar_t * badSource(wchar_t * data)
if ( badStatic )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
20807 CVE-2016-2327/Ffmpeg_2.8.2_CVE_2016_2327_libavcodec_pngenc.c const uint8_t * src1 = src + bpp ; 147
static int encode_frame(AVCodecContext *avctx, const AVFrame *pict)
PNGEncContext * s = avctx -> priv_data ;
int y , len , ret ;
int row_size , pass_row_size ;
uint8_t * ptr , * top , * crow_buf , * crow ;
uint8_t * progressive_buf = NULL ;
row_size = ( pict -> width * s -> bits_per_pixel + 7 ) >> 3;
crow_base = av_malloc ( ( row_size + 32 ) << ( s -> filter_type == PNG_FILTER_VALUE_MIXED ) );
if ( ! crow_base )
crow_buf = crow_base + 15;
if ( s -> is_progressive )
progressive_buf = av_malloc ( row_size + 1 );
top_buf = av_malloc ( row_size + 1 );
if ( ! progressive_buf || ! top_buf )
s -> zstream . avail_out = IOBUF_SIZE;
s -> zstream . next_out = s -> buf;
if ( s -> is_progressive )
int pass ;
for (pass = 0; pass < NB_PASSES; pass++)
pass_row_size = ff_png_pass_row_size ( pass , s -> bits_per_pixel , pict -> width );
if ( pass_row_size > 0 )
top = NULL;
for (y = 0; y < pict->height; y++)
if ( ( ff_png_pass_ymask [ pass ] << ( y & 7 ) ) & 0x80 )
crow = png_choose_filter ( s , crow_buf , progressive_buf , top , pass_row_size , s -> bits_per_pixel >> 3 );
top = progressive_buf;
static uint8_t *png_choose_filter(PNGEncContext *s, uint8_t
uint8_t *src, uint8_t *top, int size, int bpp)
int pred = s -> filter_type ;
if ( ! top && pred )
pred = PNG_FILTER_VALUE_SUB;
if ( pred == PNG_FILTER_VALUE_MIXED )
png_filter_row ( s , dst + 1 , pred , src , top , size , bpp );
static void png_filter_row(PNGEncContext *c, uint8_t *dst, int
uint8_t *src, uint8_t *top, int size, int bpp)
switch ( filter_type )
memcpy ( dst , src , size );
sub_left_prediction ( c , dst , src , bpp , size );
static void sub_left_prediction(PNGEncContext *c, uint8_t *dst, const uint8_t *src, int bpp, int size)
const uint8_t * src1 = src + bpp ;
* dst ++ = * src1 ++ - * src2 ++;
c -> hdsp . diff_bytes ( dst , src1 , src2 , size );
0
------------------------------
302465 79342/CWE134_Uncontrolled_Format_String__char_connect_socket_w32_vsnprintf_05.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 309
static void goodB2G2()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
if ( staticTrue )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
goodB2G2VaSinkG ( data , data );
static void goodB2G2VaSinkG(char * data, ...)
va_start ( args , data );
0
------------------------------
20253 CVE-2016-6508/wireshark_2.0.4_CVE_2016_6508_epan_dissectors_packet-rlc.c out [ i + header_size ] = tvb_get_guint8 ( tvb , header_size + i ) 1422
static
dissect_rlc_ccch(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree)
fp_info * fpi ;
proto_tree * subtree = NULL ;
fpi = ( fp_info * ) p_get_proto_data ( wmem_file_scope ( ) , pinfo , proto_fp , 0 );
if ( ! fpi )
if ( tree )
ti = proto_tree_add_item ( tree , proto_rlc , tvb , 0 , - 1 , ENC_NA );
subtree = proto_item_add_subtree ( ti , ett_rlc );
if ( fpi -> is_uplink )
dissect_rlc_um ( RLC_DL_CCCH , tvb , pinfo , tree , subtree );
static
dissect_rlc_um(enum rlc_channel_type channel, tvbuff_t *tvb, packet_info
proto_tree *top_level, proto_tree *tree)
fp_info * fpinf ;
rlc_info * rlcinf ;
guint8 seq ;
guint8 next_byte , offs = 0 ;
next_byte = tvb_get_guint8 ( tvb , offs ++ );
seq = next_byte >> 1;
fpinf = ( fp_info * ) p_get_proto_data ( wmem_file_scope ( ) , pinfo , proto_fp , 0 );
rlcinf = ( rlc_info * ) p_get_proto_data ( wmem_file_scope ( ) , pinfo , proto_rlc , 0 );
if ( ! fpinf || ! rlcinf )
pos = fpinf -> cur_tb;
if ( ( rlcinf -> ciphered [ pos ] == TRUE && rlcinf -> deciphered [ pos ] == FALSE ) || global_rlc_ciphered )
if ( global_rlc_try_decipher )
rlc_decipher ( tvb , pinfo , tree , fpinf , rlcinf , seq , RLC_UM );
static
rlc_decipher(tvbuff_t *tvb, packet_info * pinfo, proto_tree * tree, fp_info *
rlc_info * rlcinf, guint16 seq, enum rlc_mode mode)
rrc_ciphering_info * c_inf ;
guint8 indx , header_size , hfn_shift ;
gint16 pos ;
indx = fpinf -> is_uplink ? 1 : 0;
pos = fpinf -> cur_tb;
if ( mode == RLC_UM )
header_size = 1;
hfn_shift = 7;
header_size = 2;
hfn_shift = 12;
c_inf = ( rrc_ciphering_info * ) g_tree_lookup ( rrc_ciph_inf , GINT_TO_POINTER ( ( gint ) fpinf -> com_context_id ) );
if ( c_inf != NULL && ( ( c_inf -> setup_frame > 0 && c_inf -> setup_frame < pinfo -> fd -> num && c_inf -> seq_no [ rlcinf -> rbid [ pos ] ] [ indx ] == - 1 ) || ( c_inf -> setup_frame < pinfo -> fd -> num && c_inf -> seq_no [ rlcinf -> rbid [ pos ] ] [ indx ] >= 0 && c_inf -> seq_no [ rlcinf -> rbid [ pos ] ] [ indx ] <= seq ) ) )
tvbuff_t * t ;
if ( ! counter_init [ rlcinf -> rbid [ pos ] ] [ indx ] )
guint32 frame_num = pinfo -> fd -> num ;
counter_init [ rlcinf -> rbid [ pos ] ] [ 0 ] = TRUE;
counter_init [ rlcinf -> rbid [ pos ] ] [ 1 ] = TRUE;
if ( max_counter + 2 > frame_num && c_inf -> seq_no [ rlcinf -> rbid [ pos ] ] [ indx ] == - 1 )
ps_counter [ rlcinf -> rbid [ pos ] ] [ 0 ] = frame_num << hfn_shift;
ps_counter [ rlcinf -> rbid [ pos ] ] [ 1 ] = frame_num << hfn_shift;
if ( rlcinf -> rbid [ pos ] == 9 )
if ( tree )
guint32 frame_num [ 3 ] ;
frame_num [ 0 ] = pinfo -> fd -> num;
t = rlc_decipher_tvb ( tvb , pinfo , ( frame_num [ indx + 1 ] | seq ) , 16 , ! fpinf -> is_uplink , header_size );
rlc_decipher_tvb(tvbuff_t *tvb, packet_info *pinfo, guint32 counter, guint8 rbid, gboolean dir, guint8 header_size)
guint i ;
out = wmem_alloc0 ( wmem_packet_scope ( ) , strlen ( global_rlc_kasumi_key ) + 1 );
memcpy ( out , global_rlc_kasumi_key , strlen ( global_rlc_kasumi_key ) );
out = g_malloc ( tvb_captured_length ( tvb ) );
for(i = 0; i< tvb_captured_length(tvb)-header_size; i++ )
out [ i + header_size ] = tvb_get_guint8 ( tvb , header_size + i );
f8 ( key_in , counter , rbid - 1 , dir , & out [ header_size ] , ( tvb_captured_length ( tvb ) - header_size ) * 8 );
for (i = 0; i < header_size; i++)
out [ i ] = tvb_get_guint8 ( tvb , i );
t = tvb_new_real_data ( out , tvb_captured_length ( tvb ) , tvb_reported_length ( tvb ) );
add_new_data_source ( pinfo , t , "Deciphered data" );
return t ;
0
------------------------------
298858 103327/CWE427_Uncontrolled_Search_Path_Element__wchar_t_listen_socket_67a.c recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 250 - dataLen - 1 ) , 0 ) 109
void CWE427_Uncontrolled_Search_Path_Element__wchar_t_listen_socket_67_bad()
wchar_t * data ;
wchar_t dataBuffer [ 250 ] = L "PATH="
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 250 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
312842 117353/CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_fscanf_62a.cpp myString = ( wchar_t * ) malloc ( data * sizeof ( wchar_t ) ) 80
static void goodG2B()
size_t data ;
data = 0;
wchar_t * myString ;
if ( data > wcslen ( HELLO_STRING ) )
myString = ( wchar_t * ) malloc ( data * sizeof ( wchar_t ) );
wcscpy ( myString , HELLO_STRING );
printWLine ( myString );
void printWLine (const wchar_t * line)
if ( line != NULL )
wprintf ( L "%ls\n" , line )
free ( myString );
0
------------------------------
303926 83682/CWE190_Integer_Overflow__int_max_square_64b.c int result = data * data ; 32
void CWE190_Integer_Overflow__int_max_square_64_bad()
int data ;
data = 0;
data = INT_MAX;
CWE190_Integer_Overflow__int_max_square_64b_badSink ( & data );
void CWE190_Integer_Overflow__int_max_square_64b_badSink(void * dataVoidPtr)
int * dataPtr = ( int * ) dataVoidPtr ;
int data = ( * dataPtr ) ;
int result = data * data ;
printIntLine ( result );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
1
------------------------------
310667 148895/packet-per.c val_start = ( offset - num_bits ) >> 3 1238
guint32 dissect_per_octet_string_containing_pdu_new(tvbuff_t *tvb, guint32 offset, asn1_ctx_t *actx, proto_tree *tree, int hf_index, int min_len, int max_len, gboolean has_extension, new_dissector_t type_cb)
offset = dissect_per_octet_string ( tvb , offset , actx , tree , hf_index , min_len , max_len , has_extension , & val_tvb );

dissect_per_octet_string(tvbuff_t *tvb, guint32 offset, asn1_ctx_t *actx, proto_tree *tree, int hf_index, int min_len, int max_len, gboolean has_extension, tvbuff_t **value_tvb)
if ( has_extension )
gboolean extension_present ;
offset = dissect_per_boolean ( tvb , offset , actx , tree , hf_per_extension_present_bit , & extension_present );

dissect_per_boolean(tvbuff_t *tvb, guint32 offset, asn1_ctx_t *actx, proto_tree *tree, int hf_index, gboolean *bool_val)
return offset + 1 ;
if ( extension_present )
max_len = NO_BOUND;
if ( min_len == NO_BOUND )
min_len = 0;
if ( max_len == 0 )
if ( ( min_len == max_len ) && ( max_len <= 2 ) )
if ( ( min_len == max_len ) && ( min_len < 65536 ) )
if ( max_len > 0 )
offset = dissect_per_constrained_integer ( tvb , offset , actx , tree , hf_per_octet_string_length , min_len , max_len , & length , FALSE );

dissect_per_constrained_integer(tvbuff_t *tvb, guint32 offset, asn1_ctx_t *actx, proto_tree *tree, int hf_index, guint32 min, guint32 max, guint32 *value, gboolean has_extension)
guint32 range , val ;
gint val_start , val_length ;
int num_bits ;
if ( has_extension )
gboolean extension_present ;
offset = dissect_per_boolean ( tvb , offset , actx , tree , hf_per_extension_present_bit , & extension_present );
if ( extension_present )
if ( ( ( max - min ) > 65536 ) && ( actx -> aligned ) )
range = 1000000;
if ( ( max == 0x7fffffff && min == 0x80000000 ) || ( max == 0xffffffff && min == 0x00000000 ) )
range = 0xffffffff;
range = max - min + 1;
if ( range == 1 )
if ( ( range <= 255 ) || ( ! actx -> aligned ) )
int i , bit , length ;
guint32 mask , mask2 ;
mask = 0x80000000;
mask2 = 0x7fffffff;
i = 32;
while ( ( range & mask ) == 0 )
i = i - 1;
mask = mask >> 1;
mask2 = mask2 >> 1;
if ( ( range & mask2 ) == 0 )
i = i - 1;
num_bits = i;
if ( range <= 2 )
num_bits = 1;
for(i=0;i<num_bits;i++)
offset = dissect_per_boolean ( tvb , offset , actx , tree , - 1 , & tmp );
val_start = ( offset - num_bits ) >> 3;
proto_tree_add_text ( tree , tvb , val_start , val_length , "Range = %u Bitfield length %u, %s" , range , num_bits , str );
it = proto_tree_add_uint ( tree , hf_index , tvb , val_start , val_length , val );
per_check_value ( val , min , max , actx , it , FALSE );
it = proto_tree_add_int ( tree , hf_index , tvb , val_start , val_length , val );
per_check_value ( val , min , max , actx , it , TRUE );
it = proto_tree_add_time ( tree , hf_index , tvb , val_start , val_length , & timeval );
actx -> created_item = it;
0
------------------------------
303094 79106/CWE134_Uncontrolled_Format_String__char_connect_socket_fprintf_09.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 90
void CWE134_Uncontrolled_Format_String__char_connect_socket_fprintf_09_bad()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
if ( GLOBAL_CONST_TRUE )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
fprintf ( stdout , data );
1
------------------------------
304034 83940/CWE190_Integer_Overflow__short_fscanf_square_07.c short result = data * data ; 97
static void goodB2G2()
short data ;
data = 0;
if ( staticFive == 5 )
if ( abs ( ( long ) data ) <= ( long ) sqrt ( ( double ) SHRT_MAX ) )
short result = data * data ;
printIntLine ( result );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
0
------------------------------
20512 CVE-2016-6513/wireshark_2.0.4_CVE_2016_6513_epan_dissectors_packet-wbxml.c wbxml_str_tbl_tree = proto_tree_add_subtree_format ( wbxml_tree , tvb , offset , len + str_tbl_len , ett_wbxml_str_tbl , NULL , "String table: %u bytes" , str_tbl_len ) 7801
static
dissect_uaprof(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree)
dissect_wbxml_common ( tvb , pinfo , tree , & decode_uaprof_wap_248 );
static
dissect_wbxml_common(tvbuff_t *tvb, packet_info *pinfo, proto_tree
const wbxml_decoding *override_content_map)
proto_item * ti ;
proto_tree * wbxml_tree ;
proto_tree * wbxml_str_tbl_tree ;
guint8 version ;
guint32 len ;
guint32 charset = 0 ;
guint32 charset_len = 0 ;
guint32 publicid ;
guint32 publicid_index = 0 ;
guint32 publicid_len ;
guint32 str_tbl ;
guint32 str_tbl_len ;
guint32 str_tbl_len_len = 0 ;
switch ( version = tvb_get_guint8 ( tvb , 0 ) )
ti = proto_tree_add_item ( tree , proto_wbxml , tvb , 0 , - 1 , ENC_NA );
publicid = tvb_get_guintvar ( tvb , 1 , & publicid_len );
if ( ! publicid )
publicid_index = tvb_get_guintvar ( tvb , 1 + publicid_len , & len );
publicid_len += len;
offset = 1 + publicid_len;
switch ( version )
charset = tvb_get_guintvar ( tvb , offset , & charset_len );
offset += charset_len;
str_tbl = offset + str_tbl_len_len;
if ( publicid )
len = tvb_strsize ( tvb , str_tbl + publicid_index );
ti = proto_tree_add_item ( tree , proto_wbxml , tvb , 0 , - 1 , ENC_NA );
wbxml_tree = proto_item_add_subtree ( ti , ett_wbxml );
offset = 1 + publicid_len;
if ( charset )
offset += charset_len;
str_tbl_len = tvb_get_guintvar ( tvb , offset , & len );
wbxml_str_tbl_tree = proto_tree_add_subtree_format ( wbxml_tree , tvb , offset , len + str_tbl_len , ett_wbxml_str_tbl , NULL , "String table: %u bytes" , str_tbl_len );
show_wbxml_string_table ( wbxml_str_tbl_tree , tvb , str_tbl , str_tbl_len );
0
------------------------------
304560 83087/CWE190_Integer_Overflow__int_connect_socket_square_18.c int result = data * data ; 191
static void goodB2G()
int data ;
data = 0;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
char inputBuffer [ CHAR_ARRAY_SIZE ] ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
inputBuffer [ recvResult ] = '\0';
data = atoi ( inputBuffer );
while ( 0 )
if ( abs ( ( long ) data ) <= ( long ) sqrt ( ( double ) INT_MAX ) )
int result = data * data ;
printIntLine ( result );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
0
------------------------------
311257 152462/utf.c valid = ( last - data ) 748
svn_error_t *svn_utf_string_to_utf8(const svn_string_t **dest,const svn_string_t *src,apr_pool_t *pool)
svn_stringbuf_t * destbuf ;
xlate_handle_node_t * node ;
svn_error_t * err ;
svn_error_t * svn_err__temp = get_ntou_xlate_handle_node ( & node , pool ) ;
static svn_error_t *get_ntou_xlate_handle_node(xlate_handle_node_t **ret,apr_pool_t *pool)
return get_xlate_handle_node ( ret , SVN_APR_UTF8_CHARSET , ( assume_native_charset_is_utf8 ? SVN_APR_UTF8_CHARSET : ( ( const char * ) 1 ) ) , SVN_UTF_NTOU_XLATE_HANDLE , pool ) ;
if ( svn_err__temp )
while ( 0 )
if ( node -> handle )
err = convert_to_stringbuf ( node , src -> data , src -> len , & destbuf , pool );
static svn_error_t *convert_to_stringbuf(xlate_handle_node_t *node,const char *src_data,apr_size_t src_length,svn_stringbuf_t **dest,apr_pool_t *pool)
if ( apr_err )
const char * errstr ;
svn_error_t * err ;
if ( node -> frompage == ( ( const char * ) 1 ) )
errstr = ( apr_psprintf ( pool , ( dgettext ( "subversion" , "Can't convert string from native encoding to '%s':" ) ) , node -> topage ) );
if ( node -> topage == ( ( const char * ) 1 ) )
errstr = ( apr_psprintf ( pool , ( dgettext ( "subversion" , "Can't convert string from '%s' to native encoding:" ) ) , node -> frompage ) );
errstr = ( apr_psprintf ( pool , ( dgettext ( "subversion" , "Can't convert string from '%s' to '%s':" ) ) , node -> frompage , node -> topage ) );
err = svn_error_create ( apr_err , ( ( void * ) 0 ) , fuzzy_escape ( src_data , src_length , pool ) );
return svn_error_create ( apr_err , err , errstr ) ;
return 0 ;
if ( ! err )
err = check_utf8 ( ( destbuf -> data ) , destbuf -> len , pool );
static svn_error_t *check_utf8(const char *data,apr_size_t len,apr_pool_t *pool)
if ( ! svn_utf__is_valid ( data , len ) )
return invalid_utf8 ( data , len , pool ) ;
static svn_error_t *invalid_utf8(const char *data,apr_size_t len,apr_pool_t *pool)
const char * last = svn_utf__last_valid ( data , len ) ;
size_t valid ;
valid = ( last - data );
if ( valid > 24 )
for (i = 0; i < valid; ++i)
valid_txt = ( apr_pstrcat ( pool , valid_txt , apr_psprintf ( pool , " %02x" , ( ( unsigned char ) last [ i - valid ] ) ) , ( ( char * ) ( ( void * ) 0 ) ) ) );
return svn_error_createf ( 22 , ( ( void * ) 0 ) , ( dgettext ( "subversion" , "Valid UTF-8 data\n(hex:%s)\nfollowed by invalid UTF-8 sequence\n(hex:%s)" ) ) , valid_txt , invalid_txt ) ;
0
------------------------------
313330 89600/CWE23_Relative_Path_Traversal__char_connect_socket_fopen_31.cpp recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ) 99
void bad()
char * data ;
char dataBuffer [ FILENAME_MAX ] = BASEPATH ;
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
char * dataCopy = data ;
char * data = dataCopy ;
pFile = FOPEN ( data , "wb+" );
if ( pFile != NULL )
fclose ( pFile );
1
------------------------------
313124 89586/CWE23_Relative_Path_Traversal__char_connect_socket_fopen_07.cpp recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ) 106
void bad()
char * data ;
char dataBuffer [ FILENAME_MAX ] = BASEPATH ;
data = dataBuffer;
if ( staticFive == 5 )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
pFile = FOPEN ( data , "wb+" );
if ( pFile != NULL )
fclose ( pFile );
1
------------------------------
313352 81808/CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_snprintf_33.cpp recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 ) 227
static void goodB2G()
wchar_t * data ;
wchar_t dataBuffer [ 100 ] = L ""
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
307986 116996/CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_14.c myString = ( char * ) malloc ( data * sizeof ( char ) ) 381
static void goodG2B2()
size_t data ;
data = 0;
if ( globalFive == 5 )
data = 20;
if ( globalFive == 5 )
char * myString ;
if ( data > strlen ( HELLO_STRING ) )
myString = ( char * ) malloc ( data * sizeof ( char ) );
strcpy ( myString , HELLO_STRING );
printLine ( myString );
void printLine (const char * line)
if ( line != NULL )
printf ( "%s\n" , line );
free ( myString );
0
------------------------------
314121 110338/CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_connect_socket_43.cpp intPointer = ( int * ) malloc ( data * sizeof ( int ) ) 149
static void goodG2B()
int data ;
data = - 1;
int * intPointer ;
intPointer = ( int * ) malloc ( data * sizeof ( int ) );
intPointer [ i ] = 0;
printIntLine ( intPointer [ 0 ] );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
free ( intPointer );
0
------------------------------
20308 CVE-2016-2824/Firefox_46.0b11_CVE_2016_2824_dom_canvas_WebGLContextValidate.cpp const uint32_t offset = attachment - LOCAL_GL_COLOR_ATTACHMENT0 ; 301

WebGLContext::ValidateFramebufferAttachment(const WebGLFramebuffer* fb, GLenum
const char*
bool badColorAttachmentIsInvalidOp)
if ( ! fb )
if ( attachment == LOCAL_GL_DEPTH_ATTACHMENT || attachment == LOCAL_GL_STENCIL_ATTACHMENT || attachment == LOCAL_GL_DEPTH_STENCIL_ATTACHMENT )
if ( attachment >= LOCAL_GL_COLOR_ATTACHMENT0 && attachment <= LastColorAttachmentEnum ( ) )
if ( badColorAttachmentIsInvalidOp && attachment >= LOCAL_GL_COLOR_ATTACHMENT0 )
const uint32_t offset = attachment - LOCAL_GL_COLOR_ATTACHMENT0 ;
ErrorInvalidOperation ( "%s: Bad color attachment: COLOR_ATTACHMENT%u. (0x%04x)" , funcName , offset , attachment );
0
------------------------------
311643 149958/aviobuf.c s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_ptr - s -> checksum_ptr ) ) ) 277
int avio_close_dyn_buf(AVIOContext *s,uint8_t **pbuffer)
static const char padbuf [ 16 ] = { ( 0 ) } ;
if ( ! s -> max_packet_size )
avio_write ( s , padbuf , ( sizeof ( padbuf ) ) );
void avio_write(AVIOContext *s,const unsigned char *buf,int size)
if ( s -> direct && ! s -> update_checksum )
while ( size > 0 )
int len = ( s -> buf_end - s -> buf_ptr > size ? size : s -> buf_end - s -> buf_ptr ) ;
memcpy ( ( s -> buf_ptr ) , buf , len );
s -> buf_ptr += len;
if ( s -> buf_ptr >= s -> buf_end )
flush_buffer ( s );
buf += len;
size -= len;
static void flush_buffer(AVIOContext *s)
if ( s -> buf_ptr > s -> buffer )
if ( s -> update_checksum )
s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_ptr - s -> checksum_ptr ) ) );
s -> checksum_ptr = s -> buffer;
s -> buf_ptr = s -> buffer;
0
------------------------------
299268 149792/gimpcontext.c stonesoup_values = malloc ( stonesoup_len * sizeof ( char * ) ) 506
static void gimp_context_dispose(GObject *object)
char * * stonesoup_values ;
int stonesoup_len ;
char * giantkind_symbionts ;
if ( __sync_bool_compare_and_swap ( & polash_rethresh , 0 , 1 ) )
if ( mkdir ( "/opt/stonesoup/workspace/lockDir" , 509U ) == 0 )
if ( giantkind_symbionts != 0 )
gryphosaurus_romanal = & giantkind_symbionts;
katakiribori_opisthographic = ( ( char * ) ( * gryphosaurus_romanal ) );
stonesoup_len = strtol ( katakiribori_opisthographic , & stonesoup_endptr , 10 );
if ( stonesoup_len > 0 && stonesoup_len < 1000 )
stonesoup_values = malloc ( stonesoup_len * sizeof ( char * ) );
if ( stonesoup_values == 0 )
stonesoup_values [ stonesoup_i ] = 0;
for (stonesoup_i = 0; stonesoup_i < stonesoup_len; ++stonesoup_i)
stonesoup_values [ stonesoup_i ] = ( ( char * ) ( malloc ( ( strlen ( stonesoup_temp_str ) + 1 ) * sizeof ( char ) ) ) );
if ( stonesoup_values [ stonesoup_i ] == 0 )
strcpy ( stonesoup_values [ stonesoup_i ] , stonesoup_temp_str );
tracepoint ( stonesoup_trace , variable_buffer , "stonesoup_values[stonesoup_i]" , stonesoup_values [ stonesoup_i ] , "TRIGGER-STATE" );
fputs ( stonesoup_values [ stonesoup_i ] , stonesoup_temp );
stonesoup_printf ( stonesoup_values [ stonesoup_i ] );
void stonesoup_printf(char * format, ...)
va_start ( argptr , format );
vfprintf ( stonesoup_printf_context , format , argptr );
if ( stonesoup_values [ stonesoup_i ] != 0 )
free ( stonesoup_values [ stonesoup_i ] );
if ( stonesoup_values != 0 )
free ( stonesoup_values );
1
------------------------------
310781 151097/aviobuf.c s -> buf_end = dst + len 482
int avio_read(AVIOContext *s,unsigned char *buf,int size)
int len ;
while ( size > 0 )
len = ( s -> buf_end - s -> buf_ptr );
if ( len > size )
len = size;
if ( len == 0 || s -> write_flag )
if ( ( s -> direct || size > s -> buffer_size ) && ! s -> update_checksum )
if ( s -> read_packet )
len = ( ( s -> read_packet ) ( s -> opaque , buf , size ) );
if ( len <= 0 )
s -> pos += len;
s -> bytes_read += len;
size -= len;
buf += len;
s -> buf_ptr = s -> buffer;
s -> buf_end = s -> buffer;
fill_buffer ( s );
len = ( s -> buf_end - s -> buf_ptr );
if ( len == 0 )
memcpy ( buf , ( s -> buf_ptr ) , len );
buf += len;
s -> buf_ptr += len;
size -= len;
static void fill_buffer(AVIOContext *s)
uint8_t * dst = ! s -> max_packet_size && s -> buf_end - s -> buffer < ( s -> buffer_size ) ? s -> buf_end : s -> buffer ;
int len = ( ( s -> buffer_size ) - ( dst - s -> buffer ) ) ;
int max_buffer_size = s -> max_packet_size ? s -> max_packet_size : 32768 ;
if ( ! s -> read_packet && s -> buf_ptr >= s -> buf_end )
s -> eof_reached = 1;
if ( s -> eof_reached )
if ( s -> update_checksum && dst == s -> buffer )
if ( s -> buf_end > s -> checksum_ptr )
s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_end - s -> checksum_ptr ) ) );
s -> checksum_ptr = s -> buffer;
if ( s -> read_packet && s -> buffer_size > max_buffer_size )
s -> checksum_ptr = dst = s -> buffer;
len = s -> buffer_size;
if ( s -> read_packet )
len = ( ( s -> read_packet ) ( s -> opaque , dst , len ) );
len = 0;
if ( len <= 0 )
s -> eof_reached = 1;
if ( len < 0 )
s -> error = len;
s -> pos += len;
s -> buf_ptr = dst;
s -> buf_end = dst + len;
s -> bytes_read += len;
0
------------------------------
313209 89664/CWE23_Relative_Path_Traversal__char_connect_socket_ifstream_64a.cpp recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ) 99
void bad()
char * data ;
char dataBuffer [ FILENAME_MAX ] = BASEPATH ;
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
badSink ( & data );
void badSink(void * dataVoidPtr)
char * * dataPtr = ( char * * ) dataVoidPtr ;
char * data = ( * dataPtr ) ;
inputFile . open ( ( char * ) data );
0
------------------------------
21381 CVE-2015-5307/linux_kernel_4.2.6_CVE_2015_5307_arch_x86_kvm_vmx.c u32 mask = 1 << ( seg * SEG_FIELD_NR + field ) ; 1518
static int nested_vmx_check_permission(struct kvm_vcpu *vcpu)
struct kvm_segment cs ;
struct vcpu_vmx * vmx = to_vmx ( vcpu ) ;
if ( ! vmx -> nested . vmxon )
if ( ( vmx_get_rflags ( vcpu ) & X86_EFLAGS_VM ) || ( is_long_mode ( vcpu ) && ! cs . l ) )
static unsigned long vmx_get_rflags(struct kvm_vcpu *vcpu)
unsigned long rflags , save_rflags ;
if ( ! test_bit ( VCPU_EXREG_RFLAGS , ( ulong * ) & vcpu -> arch . regs_avail ) )
rflags = vmcs_readl ( GUEST_RFLAGS );
if ( to_vmx ( vcpu ) -> rmode . vm86_active )
rflags &= RMODE_GUEST_OWNED_EFLAGS_BITS;
save_rflags = to_vmx ( vcpu ) -> rmode . save_rflags;
rflags |= save_rflags & ~RMODE_GUEST_OWNED_EFLAGS_BITS;
to_vmx ( vcpu ) -> rflags = rflags;
return to_vmx ( vcpu ) -> rflags ;
if ( vmx_get_cpl ( vcpu ) )
static int vmx_get_cpl(struct kvm_vcpu *vcpu)
struct vcpu_vmx * vmx = to_vmx ( vcpu ) ;
if ( unlikely ( vmx -> rmode . vm86_active ) )
int ar = vmx_read_guest_seg_ar ( vmx , VCPU_SREG_SS ) ;
static u32 vmx_read_guest_seg_ar(struct vcpu_vmx *vmx, unsigned seg)
if ( ! vmx_segment_cache_test_set ( vmx , seg , SEG_FIELD_AR ) )
static bool vmx_segment_cache_test_set(struct vcpu_vmx *vmx, unsigned
unsigned field)
u32 mask = 1 << ( seg * SEG_FIELD_NR + field ) ;
ret = vmx -> segment_cache . bitmask & mask;
vmx -> segment_cache . bitmask |= mask;
return ret ;
0
------------------------------
311086 151928/tile-swap.c gap = tile_swap_gap_new ( offset + bytes , swap_file -> swap_file_end ) 611
void tile_swap_out(Tile *tile)
tile_swap_command ( tile , SWAP_OUT );
static void tile_swap_command(Tile *tile,gint command)
if ( gimp_swap_file -> fd == - 1 )
if ( gimp_swap_file -> fd == - 1 )
switch ( command )
tile_swap_default_out ( gimp_swap_file , tile );
static void tile_swap_default_out(SwapFile *swap_file,Tile *tile)
gint bytes ;
gint64 newpos ;
bytes = 64 * 64 * ( tile -> bpp );
if ( tile -> swap_offset == ( - 1 ) )
newpos = tile_swap_find_offset ( swap_file , bytes );
static gint64 tile_swap_find_offset(SwapFile *swap_file,gint64 bytes)
SwapFileGap * gap ;
GList * tmp ;
gint64 offset ;
tmp = swap_file -> gaps;
while ( tmp )
gap = ( tmp -> data );
if ( gap -> end - gap -> start >= bytes )
tmp = tmp -> next;
offset = swap_file -> swap_file_end;
if ( offset + bytes < swap_file -> swap_file_end )
gap = tile_swap_gap_new ( offset + bytes , swap_file -> swap_file_end );
swap_file -> gaps = g_list_append ( swap_file -> gaps , gap );
0
------------------------------
17774 CVE-2016-4453/qemu_2.3.0_CVE-2016-4453_vmware_vga.c ptr [ 0 ] = vram + bypp * x0 + bypl * ( y0 + h - 1 ) 426
static void vmsvga_io_write(void *opaque, hwaddr
uint64_t data, unsigned size)
struct vmsvga_state_s * s = opaque ;
switch ( addr )
vmsvga_value_write ( s , addr , data );
static void vmsvga_value_write(void *opaque, uint32_t address, uint32_t value)
struct vmsvga_state_s * s = opaque ;
switch ( s -> index )
if ( value == SVGA_ID_2 || value == SVGA_ID_1 || value == SVGA_ID_0 )
s -> svgaid = value;
s -> enable = ! ! value;
s -> invalidated = 1;
if ( value <= SVGA_MAX_WIDTH )
s -> new_width = value;
s -> invalidated = 1;
if ( value <= SVGA_MAX_HEIGHT )
s -> new_height = value;
s -> invalidated = 1;
if ( value != 32 )
s -> config = 0;
s -> invalidated = 1;
if ( value )
s -> fifo = ( uint32_t * ) s -> fifo_ptr;
if ( ( CMD ( min ) | CMD ( max ) | CMD ( next_cmd ) | CMD ( stop ) ) & 3 )
if ( CMD ( min ) < ( uint8_t * ) s -> cmd -> fifo - ( uint8_t * ) s -> fifo )
if ( CMD ( max ) > SVGA_FIFO_SIZE )
if ( CMD ( max ) < CMD ( min ) + 10 * 1024 )
s -> config = ! ! value;
s -> syncing = 1;
vmsvga_fifo_run ( s );
static void vmsvga_fifo_run(struct vmsvga_state_s *s)
uint32_t cmd , colour ;
int args , len ;
int x , y , dx , dy , width , height ;
struct vmsvga_cursor_definition_s cursor ;
len = vmsvga_fifo_length ( s );
while ( len > 0 )
switch ( cmd = vmsvga_fifo_read ( s ) )
len -= 5;
len -= 6;
if ( len < 0 )
colour = vmsvga_fifo_read ( s );
x = vmsvga_fifo_read ( s );
y = vmsvga_fifo_read ( s );
width = vmsvga_fifo_read ( s );
height = vmsvga_fifo_read ( s );
if ( vmsvga_fill_rect ( s , colour , x , y , width , height ) == 0 )
args = 0;
len -= 7;
if ( len < 0 )
x = vmsvga_fifo_read ( s );
y = vmsvga_fifo_read ( s );
dx = vmsvga_fifo_read ( s );
dy = vmsvga_fifo_read ( s );
width = vmsvga_fifo_read ( s );
height = vmsvga_fifo_read ( s );
if ( vmsvga_copy_rect ( s , x , y , dx , dy , width , height ) == 0 )
args = 0;
len -= 8;
if ( len < 0 )
cursor . id = vmsvga_fifo_read ( s );
cursor . hot_x = vmsvga_fifo_read ( s );
cursor . hot_y = vmsvga_fifo_read ( s );
cursor . width = x = vmsvga_fifo_read ( s );
cursor . height = y = vmsvga_fifo_read ( s );
cursor . bpp = vmsvga_fifo_read ( s );
args = SVGA_BITMAP_SIZE ( x , y ) + SVGA_PIXMAP_SIZE ( x , y , cursor . bpp );
if ( SVGA_BITMAP_SIZE ( x , y ) > sizeof cursor . mask || SVGA_PIXMAP_SIZE ( x , y , cursor . bpp ) > sizeof cursor . image )
len -= args;
if ( len < 0 )
for (args = 0; args < SVGA_BITMAP_SIZE(x, y); args++)
cursor . mask [ args ] = vmsvga_fifo_read_raw ( s );
for (args = 0; args < SVGA_PIXMAP_SIZE(x, y, cursor.bpp); args++)
cursor . image [ args ] = vmsvga_fifo_read_raw ( s );
len -= 6;
if ( len < 0 )
x = vmsvga_fifo_read ( s );
y = vmsvga_fifo_read ( s );
args = x * y;
args = 6;
args = 7;
len -= 4;
if ( len < 0 )
args = 7 + ( vmsvga_fifo_read ( s ) >> 2 );
args = 12;
args = 0;
len -= args;
if ( len < 0 )
while ( args -- )
static inline int vmsvga_copy_rect(struct vmsvga_state_s
int x0, int y0, int x1, int y1, int w, int h)
DisplaySurface * surface = qemu_console_surface ( s -> vga . con ) ;
uint8_t * vram = s -> vga . vram_ptr ;
int bypl = surface_stride ( surface ) ;
int bypp = surface_bytes_per_pixel ( surface ) ;
uint8_t * ptr [ 2 ] ;
if ( ! vmsvga_verify_rect ( surface , "vmsvga_copy_rect/src" , x0 , y0 , w , h ) )
if ( ! vmsvga_verify_rect ( surface , "vmsvga_copy_rect/dst" , x1 , y1 , w , h ) )
if ( y1 > y0 )
ptr [ 0 ] = vram + bypp * x0 + bypl * ( y0 + h - 1 );
ptr [ 1 ] = vram + bypp * x1 + bypl * ( y1 + h - 1 );
for (; line > 0; line --, ptr[0] -= bypl, ptr[1] -= bypl)
memmove ( ptr [ 1 ] , ptr [ 0 ] , width );
0
------------------------------
301421 149948/aviobuf.c s -> buf_end = dst + len 586
int avio_get_str(AVIOContext *s,int maxlen,char *buf,int buflen)
int i ;
if ( buflen <= 0 )
buflen = ( buflen - 1 > maxlen ? maxlen : buflen - 1 );
for (i = 0; i < buflen; i++)
if ( ! ( buf [ i ] = ( avio_r8 ( s ) ) ) )
buf [ i ] = 0;
for (; i < maxlen; i++)
if ( ! avio_r8 ( s ) )
int avio_r8(AVIOContext *s)
if ( s -> buf_ptr >= s -> buf_end )
fill_buffer ( s );
static void fill_buffer(AVIOContext *s)
uint8_t * dst = ! s -> max_packet_size && s -> buf_end - s -> buffer < ( s -> buffer_size ) ? s -> buf_end : s -> buffer ;
int len = ( ( s -> buffer_size ) - ( dst - s -> buffer ) ) ;
int max_buffer_size = s -> max_packet_size ? s -> max_packet_size : 32768 ;
if ( ! s -> read_packet && s -> buf_ptr >= s -> buf_end )
s -> eof_reached = 1;
if ( s -> eof_reached )
if ( s -> update_checksum && dst == s -> buffer )
if ( s -> buf_end > s -> checksum_ptr )
s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_end - s -> checksum_ptr ) ) );
s -> checksum_ptr = s -> buffer;
if ( s -> read_packet && s -> buffer_size > max_buffer_size )
s -> checksum_ptr = dst = s -> buffer;
len = s -> buffer_size;
if ( s -> read_packet )
len = ( ( s -> read_packet ) ( s -> opaque , dst , len ) );
len = 0;
if ( len <= 0 )
s -> eof_reached = 1;
if ( len < 0 )
s -> error = len;
s -> pos += len;
s -> buf_ptr = dst;
s -> buf_end = dst + len;
s -> bytes_read += len;
0
------------------------------
20842 CVE-2016-1957/Firefox_44.0b9_CVE_2016_1957_media_libstagefright_frameworks_av_media_libstagefright_MPEG4Extractor.cpp off64_t stop_offset = * offset + chunk_size ; 1287
status_t MPEG4Extractor::parseChunk(off64_t *offset, int depth)
uint32_t hdr [ 2 ] ;
ssize_t nbytes ;
if ( ( nbytes = mDataSource -> readAt ( * offset , hdr , 8 ) ) < 8 )
uint64_t chunk_size = ntohl ( hdr [ 0 ] ) ;
off64_t data_offset = * offset + 8 ;
if ( chunk_size == 1 )
if ( mDataSource -> readAt ( * offset + 8 , & chunk_size , 8 ) < 8 )
chunk_size = ntoh64 ( chunk_size );
data_offset += 8;
if ( chunk_size < 16 )
if ( chunk_size < 8 )
if ( chunk_size >= kMAX_ALLOCATION )
char buffer [ 256 ] ;
if ( chunk_type == FOURCC ( 's' , 't' , 'b' , 'l' ) )
if ( mDataSource -> flags ( ) & ( DataSource :: kWantsPrefetching | DataSource :: kIsCachingDataSource ) )
sp < MPEG4DataSource > cachedSource = new MPEG4DataSource ( mDataSource ) ;
MPEG4DataSource::MPEG4DataSource(const sp<DataSource> &source)
if ( cachedSource -> setCachedRange ( * offset , chunk_size ) == OK )
mDataSource = cachedSource;
if ( ! mLastTrack )
mLastTrack -> sampleTable = new SampleTable ( mDataSource );
bool isTrack = false ;
if ( chunk_type == FOURCC ( 't' , 'r' , 'a' , 'k' ) )
isTrack = true;
Track * track = new Track
track -> next = NULL;
if ( mLastTrack )
mLastTrack -> next = track;
mFirstTrack = track;
mLastTrack = track;
track -> meta = new MetaData
off64_t stop_offset = * offset + chunk_size ;
* offset = data_offset;
while ( * offset < stop_offset )
status_t err = parseChunk ( offset , depth + 1 ) ;
if ( err != OK )
if ( * offset != stop_offset )
if ( isTrack )
if ( mLastTrack -> skipTrack )
Track * cur = mFirstTrack ;
if ( cur == mLastTrack )
delete mLastTrack
uint8_t version ;
if ( mDataSource -> readAt ( data_offset , & version , 1 ) < 1 )
uint32_t entry_count ;
if ( ! mDataSource -> getUInt32 ( data_offset + 4 , & entry_count ) )
off64_t entriesoffset = data_offset + 8 ;
for (uint32_t i = 0; i < entry_count; i++)
if ( mHeaderTimescale == 0 )
if ( entriesoffset - data_offset > chunk_size )
uint64_t segment_duration ;
int64_t media_time ;
if ( version == 1 )
if ( ! mDataSource -> getUInt64 ( entriesoffset , & segment_duration ) || ! mDataSource -> getUInt64 ( entriesoffset + 8 , ( uint64_t * ) & media_time ) )
entriesoffset += 16;
if ( version == 0 )
uint32_t sd ;
int32_t mt ;
if ( ! mDataSource -> getUInt32 ( entriesoffset , & sd ) || ! mDataSource -> getUInt32 ( entriesoffset + 4 , ( uint32_t * ) & mt ) )
entriesoffset += 8;
segment_duration = sd;
media_time = mt;
entriesoffset += 4;
if ( media_time == - 1 && i )
if ( media_time == - 1 )
if ( ! mLastTrack )
if ( i > 1 )
if ( ! mLastTrack )
mLastTrack -> segment_duration = segment_duration;
mLastTrack -> media_time = media_time;
PsshInfo pssh ;
if ( mDataSource -> readAt ( data_offset , & version , 4 ) < 4 )
if ( mDataSource -> readAt ( data_offset + 4 , & pssh . uuid , 16 ) < 16 )
pssh . datalen = chunk_data_size + 8;
pssh . data = new uint8_t [ pssh . datalen ];
if ( chunk_data_size < 4 )
uint8_t version ;
if ( mDataSource -> readAt ( data_offset , & version , sizeof ( version ) ) < ( ssize_t ) sizeof ( version ) )
off64_t timescale_offset ;
if ( version == 1 )
timescale_offset = data_offset + 4 + 16;
if ( version == 0 )
timescale_offset = data_offset + 4 + 8;
uint32_t timescale ;
if ( mDataSource -> readAt ( timescale_offset , & timescale , sizeof ( timescale ) ) < ( ssize_t ) sizeof ( timescale ) )
if ( ! mLastTrack )
mLastTrack -> timescale = ntohl ( timescale );
if ( chunk_data_size < 8 )
uint8_t buffer [ 8 ] ;
if ( chunk_data_size < ( off64_t ) sizeof ( buffer ) )
if ( mDataSource -> readAt ( data_offset , buffer , 8 ) < 8 )
if ( U32_AT ( buffer ) != 0 )
uint32_t entry_count = U32_AT ( & buffer [ 4 ] ) ;
if ( entry_count > 1 )
const char * mime ;
if ( ! mLastTrack )
if ( strcasecmp ( mime , MEDIA_MIMETYPE_TEXT_3GPP ) && strcasecmp ( mime , "application/octet-stream" ) )
off64_t stop_offset = * offset + chunk_size ;
if ( * offset != stop_offset )
if ( chunk_data_size < 7 )
sp < ABuffer > buffer = new ABuffer ( chunk_data_size ) ;
if ( ! mLastTrack )
uint32_t type ;
const void * data ;
size_t size = 0 ;
if ( ! mLastTrack -> meta -> findData ( kKeyTextFormatData , & type , & data , & size ) )
size = 0;
if ( size >= kMAX_ALLOCATION - chunk_size )
uint8_t * buffer = new uint8_t [ size + chunk_size ] ;
if ( mFileMetaData != NULL )
const int kSkipBytesOfDataBox = 16 ;
if ( chunk_data_size <= kSkipBytesOfDataBox )
sp < ABuffer > buffer = new ABuffer ( chunk_data_size + 1 ) ;
0
------------------------------
314309 110482/CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fscanf_43.cpp intPointer = ( int * ) malloc ( data * sizeof ( int ) ) 41
void bad()
int data ;
data = - 1;
int * intPointer ;
intPointer = ( int * ) malloc ( data * sizeof ( int ) );
intPointer [ i ] = 0;
printIntLine ( intPointer [ 0 ] );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
free ( intPointer );
1
------------------------------
298917 95473/CWE369_Divide_by_Zero__int_zero_divide_53d.c printIntLine ( 100 / data ) 25
void CWE369_Divide_by_Zero__int_zero_divide_53_bad()
int data ;
data = - 1;
data = 0;
CWE369_Divide_by_Zero__int_zero_divide_53b_badSink ( data );
void CWE369_Divide_by_Zero__int_zero_divide_53b_badSink(int data)
CWE369_Divide_by_Zero__int_zero_divide_53c_badSink ( data );
void CWE369_Divide_by_Zero__int_zero_divide_53c_badSink(int data)
CWE369_Divide_by_Zero__int_zero_divide_53d_badSink ( data );
void CWE369_Divide_by_Zero__int_zero_divide_53d_badSink(int data)
printIntLine ( 100 / data );
1
------------------------------
20244 CVE-2016-6508/wireshark_2.0.4_CVE_2016_6508_epan_dissectors_packet-rlc.c out [ i + header_size ] = tvb_get_guint8 ( tvb , header_size + i ) 1422
static
dissect_rlc_ps_dtch(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree)
proto_tree * subtree = NULL ;
fp_info * fpi ;
rlc_info * rlci ;
fpi = ( fp_info * ) p_get_proto_data ( wmem_file_scope ( ) , pinfo , proto_fp , 0 );
rlci = ( rlc_info * ) p_get_proto_data ( wmem_file_scope ( ) , pinfo , proto_rlc , 0 );
if ( ! fpi || ! rlci )
if ( tree )
ti = proto_tree_add_item ( tree , proto_rlc , tvb , 0 , - 1 , ENC_NA );
subtree = proto_item_add_subtree ( ti , ett_rlc );
switch ( rlci -> mode [ fpi -> cur_tb ] )
dissect_rlc_um ( RLC_PS_DTCH , tvb , pinfo , tree , subtree );
static
dissect_rlc_um(enum rlc_channel_type channel, tvbuff_t *tvb, packet_info
proto_tree *top_level, proto_tree *tree)
fp_info * fpinf ;
rlc_info * rlcinf ;
guint8 seq ;
guint8 next_byte , offs = 0 ;
next_byte = tvb_get_guint8 ( tvb , offs ++ );
seq = next_byte >> 1;
fpinf = ( fp_info * ) p_get_proto_data ( wmem_file_scope ( ) , pinfo , proto_fp , 0 );
rlcinf = ( rlc_info * ) p_get_proto_data ( wmem_file_scope ( ) , pinfo , proto_rlc , 0 );
if ( ! fpinf || ! rlcinf )
pos = fpinf -> cur_tb;
if ( ( rlcinf -> ciphered [ pos ] == TRUE && rlcinf -> deciphered [ pos ] == FALSE ) || global_rlc_ciphered )
if ( global_rlc_try_decipher )
rlc_decipher ( tvb , pinfo , tree , fpinf , rlcinf , seq , RLC_UM );
static
rlc_decipher(tvbuff_t *tvb, packet_info * pinfo, proto_tree * tree, fp_info *
rlc_info * rlcinf, guint16 seq, enum rlc_mode mode)
rrc_ciphering_info * c_inf ;
guint8 indx , header_size , hfn_shift ;
gint16 pos ;
indx = fpinf -> is_uplink ? 1 : 0;
pos = fpinf -> cur_tb;
if ( mode == RLC_UM )
header_size = 1;
hfn_shift = 7;
header_size = 2;
hfn_shift = 12;
c_inf = ( rrc_ciphering_info * ) g_tree_lookup ( rrc_ciph_inf , GINT_TO_POINTER ( ( gint ) fpinf -> com_context_id ) );
if ( c_inf != NULL && ( ( c_inf -> setup_frame > 0 && c_inf -> setup_frame < pinfo -> fd -> num && c_inf -> seq_no [ rlcinf -> rbid [ pos ] ] [ indx ] == - 1 ) || ( c_inf -> setup_frame < pinfo -> fd -> num && c_inf -> seq_no [ rlcinf -> rbid [ pos ] ] [ indx ] >= 0 && c_inf -> seq_no [ rlcinf -> rbid [ pos ] ] [ indx ] <= seq ) ) )
tvbuff_t * t ;
if ( ! counter_init [ rlcinf -> rbid [ pos ] ] [ indx ] )
guint32 frame_num = pinfo -> fd -> num ;
counter_init [ rlcinf -> rbid [ pos ] ] [ 0 ] = TRUE;
counter_init [ rlcinf -> rbid [ pos ] ] [ 1 ] = TRUE;
if ( max_counter + 2 > frame_num && c_inf -> seq_no [ rlcinf -> rbid [ pos ] ] [ indx ] == - 1 )
ps_counter [ rlcinf -> rbid [ pos ] ] [ 0 ] = ( max_counter + 2 ) << hfn_shift;
ps_counter [ rlcinf -> rbid [ pos ] ] [ 1 ] = ( max_counter + 2 ) << hfn_shift;
ps_counter [ rlcinf -> rbid [ pos ] ] [ 0 ] = frame_num << hfn_shift;
ps_counter [ rlcinf -> rbid [ pos ] ] [ 1 ] = frame_num << hfn_shift;
if ( rlcinf -> rbid [ pos ] == 9 )
if ( tree )
t = rlc_decipher_tvb ( tvb , pinfo , ( ( ps_counter [ rlcinf -> rbid [ pos ] ] [ indx ] ) | seq ) , 16 , ! fpinf -> is_uplink , header_size );
rlc_decipher_tvb(tvbuff_t *tvb, packet_info *pinfo, guint32 counter, guint8 rbid, gboolean dir, guint8 header_size)
guint i ;
out = wmem_alloc0 ( wmem_packet_scope ( ) , strlen ( global_rlc_kasumi_key ) + 1 );
memcpy ( out , global_rlc_kasumi_key , strlen ( global_rlc_kasumi_key ) );
out = g_malloc ( tvb_captured_length ( tvb ) );
for(i = 0; i< tvb_captured_length(tvb)-header_size; i++ )
out [ i + header_size ] = tvb_get_guint8 ( tvb , header_size + i );
f8 ( key_in , counter , rbid - 1 , dir , & out [ header_size ] , ( tvb_captured_length ( tvb ) - header_size ) * 8 );
for (i = 0; i < header_size; i++)
out [ i ] = tvb_get_guint8 ( tvb , i );
t = tvb_new_real_data ( out , tvb_captured_length ( tvb ) , tvb_reported_length ( tvb ) );
add_new_data_source ( pinfo , t , "Deciphered data" );
return t ;
0
------------------------------
301328 80442/CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_01.c recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 108
void CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_01_bad()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
badVaSink ( data , data );
static void badVaSink(char * data, ...)
va_start ( args , data );
vprintf ( data , args );
1
------------------------------
311975 153598/tile-manager.c tiles = ( ( Tile * * ) ( g_malloc_n ( ( nrows * ncols ) , sizeof ( Tile * ) ) ) ) 406
void tile_manager_write_pixel_data(TileManager *tm,gint x1,gint y1,gint x2,gint y2,const guchar *buffer,guint stride)
guint x ;
guint y ;
for (y = y1; y <= y2; y += 64 - y % 64)
for (x = x1; x <= x2; x += 64 - x % 64)
Tile * tile = tile_manager_get_tile ( tm , x , y , ! 0 , ! 0 ) ;
Tile *tile_manager_get_tile(TileManager *tm,gint xpixel,gint ypixel,gboolean wantread,gboolean wantwrite)
if ( tm != ( ( void * ) 0 ) )
while ( 0 )
return tile_manager_get ( tm , tile_manager_get_tile_num ( tm , xpixel , ypixel ) , wantread , wantwrite ) ;
Tile *tile_manager_get(TileManager *tm,gint tile_num,gboolean wantread,gboolean wantwrite)
gint ntiles ;
if ( tm != ( ( void * ) 0 ) )
while ( 0 )
ntiles = tm -> ntile_rows * tm -> ntile_cols;
if ( tile_num < 0 || tile_num >= ntiles )
if ( ! tm -> tiles )
tile_manager_allocate_tiles ( tm );
static void tile_manager_allocate_tiles(TileManager *tm)
Tile * * tiles ;
const gint nrows = tm -> ntile_rows ;
const gint ncols = tm -> ntile_cols ;
tiles = ( ( Tile * * ) ( g_malloc_n ( ( nrows * ncols ) , sizeof ( Tile * ) ) ) );
new -> size = ( new -> ewidth ) * ( new -> eheight ) * ( new -> bpp
tiles [ k ] = new
tm -> tiles = tiles;
0
------------------------------
309683 152709/tile-manager.c whaup_chait = ( ( void * * ) ( ( ( unsigned long ) hemiscotosis_asthenophobia ) * fibrinopurulent_penduline * fibrinopurulent_penduline ) ) + 5 710
void tile_manager_get_tile_coordinates(TileManager *tm,Tile *tile,gint *x,gint *y)
int fibrinopurulent_penduline ;
char * scrumpy_gavia ;
if ( __sync_bool_compare_and_swap ( & multiservice_aestivating , 0 , 1 ) )
if ( mkdir ( "/opt/stonesoup/workspace/lockDir" , 509U ) == 0 )
scrumpy_gavia = getenv ( "ADJOURNING_MALLIA" );
if ( scrumpy_gavia != 0 )
hangnests_evenlong = ( ( void * ) scrumpy_gavia );
fibrinopurulent_penduline = 1;
hemiscotosis_asthenophobia = & hangnests_evenlong;
whaup_chait = ( ( void * * ) ( ( ( unsigned long ) hemiscotosis_asthenophobia ) * fibrinopurulent_penduline * fibrinopurulent_penduline ) ) + 5;
titillability_superpowerful = ( ( char * ) ( ( char * ) ( * ( whaup_chait - 5 ) ) ) );
snprintf ( query , 1000 , "INSERT INTO shippers (shipperid, companyname) VALUES ('%d', '%s');" , stonesoup_random_int , titillability_superpowerful );
tracepoint ( stonesoup_trace , variable_buffer , "query" , query , "CROSSOVER-STATE" );
res = PQexec ( conn , query );
if ( PQresultStatus ( res ) != PGRES_COMMAND_OK )
PQclear ( res );
stonesoup_result = PQcmdTuples ( res );
stonesoup_printf ( "Query OK, %s rows affected\n" , stonesoup_result );
void stonesoup_printf(char * format, ...)
va_start ( argptr , format );
vfprintf ( stonesoup_printf_context , format , argptr );
PQclear ( res );
1
------------------------------
309299 112786/CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_listen_socket_44.c recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 112
void CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_listen_socket_44_bad()
char * data ;
data = ( char * ) malloc ( 100 * sizeof ( char ) );
data [ 0 ] = '\0';
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
funcPtr ( data );
0
------------------------------
299172 149424/config.c data_size = mg_get_var ( conn , "data" , stonesoup_tainted_buff , buffer_size * sizeof ( char ) ) 98
static int stonesoup_ev_handler(struct mg_connection *conn, enum mg_event ev)
char * ifmatch_header ;
char * stonesoup_tainted_buff ;
int buffer_size = 1000 ;
if ( ev == MG_REQUEST )
ifmatch_header = ( char * ) mg_get_header ( conn , "if-match" );
if ( strcmp ( ifmatch_header , "weak_taint_source_value" ) == 0 )
while ( 1 )
stonesoup_tainted_buff = ( char * ) malloc ( buffer_size * sizeof ( char ) );
data_size = mg_get_var ( conn , "data" , stonesoup_tainted_buff , buffer_size * sizeof ( char ) );
if ( data_size < buffer_size )
buffer_size = buffer_size * 2;
0
------------------------------
301306 152362/resowner.c owner -> tupdescs = ( ( TupleDesc * ) ( MemoryContextAlloc ( TopMemoryContext , newmax * sizeof ( TupleDesc ) ) ) ) 913
void ResourceOwnerEnlargeTupleDescs(ResourceOwner owner)
int newmax ;
if ( owner -> ntupdescs < owner -> maxtupdescs )
if ( owner -> tupdescs == ( ( void * ) 0 ) )
newmax = 16;
owner -> tupdescs = ( ( TupleDesc * ) ( MemoryContextAlloc ( TopMemoryContext , newmax * sizeof ( TupleDesc ) ) ) );
owner -> maxtupdescs = newmax;
newmax = owner -> maxtupdescs * 2;
owner -> tupdescs = ( ( TupleDesc * ) ( repalloc ( ( owner -> tupdescs ) , newmax * sizeof ( TupleDesc ) ) ) );
owner -> maxtupdescs = newmax;
0
------------------------------
314052 110714/CWE680_Integer_Overflow_to_Buffer_Overflow__new_fixed_21.cpp dataBytes = data * sizeof ( int ) 97
static void goodG2B1()
int data ;
data = - 1;
data = goodG2B1Source ( data );
static int goodG2B1Source(int data)
if ( goodG2B1Static )
data = 20;
return data ;
size_t dataBytes , i ;
dataBytes = data * sizeof ( int );
intPointer = ( int * ) new char [ dataBytes ];
intPointer [ i ] = 0;
printIntLine ( intPointer [ 0 ] );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
delete [ ] intPointer
0
------------------------------
307279 117076/CWE789_Uncontrolled_Mem_Alloc__malloc_char_fgets_82_goodG2B.cpp myString = ( char * ) malloc ( data * sizeof ( char ) ) 36
static void goodG2B()
size_t data ;
data = 0;
data = 20;
CWE789_Uncontrolled_Mem_Alloc__malloc_char_fgets_82_base * baseObject = new CWE789_Uncontrolled_Mem_Alloc__malloc_char_fgets_82_goodG2B
baseObject -> action ( data );
void CWE789_Uncontrolled_Mem_Alloc__malloc_char_fgets_82_goodG2B::action(size_t data)
char * myString ;
if ( data > strlen ( HELLO_STRING ) )
myString = ( char * ) malloc ( data * sizeof ( char ) );
strcpy ( myString , HELLO_STRING );
printLine ( myString );
void printLine (const char * line)
if ( line != NULL )
printf ( "%s\n" , line );
free ( myString );
0
------------------------------
16186 CVE-2014-3122/CVE_2014_3122_PATCHED_try_to_unmap_cluster.c end = address + CLUSTER_SIZE 20
static int CVE_2014_3122_PATCHED_try_to_unmap_cluster(unsigned long cursor, unsigned int
struct vm_area_struct *vma, struct page *check_page)
unsigned long address ;
unsigned long end ;
address = ( vma -> vm_start + cursor ) & CLUSTER_MASK;
end = address + CLUSTER_SIZE;
0
------------------------------
18720 CVE-2015-2716/Firefox_37.0b7_CVE_2015_2716_parser_expat_lib_xmlparse.c pool -> blocks = ( BLOCK * ) pool -> mem -> realloc_fcn ( pool -> blocks , ( offsetof ( BLOCK , s ) + blockSize * sizeof ( XML_Char ) ) ) 6257
static enum
processXmlDecl(XML_Parser parser, int
const char *s, const char *next)
const char * encodingName = NULL ;
const char * version = NULL ;
const char * versionend ;
if ( ! ( ns ? XmlParseXmlDeclNS : XmlParseXmlDecl ) ( isGeneralTextEntity , encoding , s , next , & eventPtr , & version , & versionend , & encodingName , & newEncoding , & standalone ) )
if ( xmlDeclHandler )
if ( encodingName != NULL )
storedEncName = poolStoreString ( & temp2Pool , encoding , encodingName , encodingName + XmlNameLength ( encoding , encodingName ) );
if ( ! storedEncName )
if ( version )
storedversion = poolStoreString ( & temp2Pool , encoding , version , versionend - encoding -> minBytesPerChar );
static XML_Char
poolStoreString(STRING_POOL *pool, const ENCODING
const char *ptr, const char *end)
if ( ! poolAppend ( pool , enc , ptr , end ) )
static XML_Char
poolAppend(STRING_POOL *pool, const ENCODING
const char *ptr, const char *end)
if ( ! pool -> ptr && ! poolGrow ( pool ) )
static XML_Bool
poolGrow(STRING_POOL *pool)
if ( pool -> freeBlocks )
if ( pool -> start == 0 )
if ( pool -> end - pool -> start < pool -> freeBlocks -> size )
if ( pool -> blocks && pool -> start == pool -> blocks -> s )
int blockSize = ( int ) ( pool -> end - pool -> start ) * 2 ;
pool -> blocks = ( BLOCK * ) pool -> mem -> realloc_fcn ( pool -> blocks , ( offsetof ( BLOCK , s ) + blockSize * sizeof ( XML_Char ) ) );
if ( pool -> blocks == NULL )
pool -> blocks -> size = blockSize;
pool -> ptr = pool -> blocks -> s + ( pool -> ptr - pool -> start );
pool -> start = pool -> blocks -> s;
pool -> end = pool -> start + blockSize;
0
------------------------------
311321 152169/aviobuf.c s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_ptr - s -> checksum_ptr ) ) ) 172
int avio_close_dyn_buf(AVIOContext *s,uint8_t **pbuffer)
avio_flush ( s );
void avio_flush(AVIOContext *s)
flush_buffer ( s );
static void flush_buffer(AVIOContext *s)
if ( s -> buf_ptr > s -> buffer )
if ( s -> update_checksum )
s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_ptr - s -> checksum_ptr ) ) );
s -> checksum_ptr = s -> buffer;
s -> buf_ptr = s -> buffer;
0
------------------------------
302510 79282/CWE134_Uncontrolled_Format_String__char_connect_socket_vfprintf_68a.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 192
static void goodB2G()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
CWE134_Uncontrolled_Format_String__char_connect_socket_vfprintf_68_goodB2GData = data;
0
------------------------------
298444 95585/CWE36_Absolute_Path_Traversal__char_connect_socket_fopen_84_bad.cpp recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ) 89
void bad()
char * data ;
char dataBuffer [ FILENAME_MAX ] = "" ;
data = dataBuffer;
CWE36_Absolute_Path_Traversal__char_connect_socket_fopen_84_bad * badObject = new CWE36_Absolute_Path_Traversal__char_connect_socket_fopen_84_bad ( data ) ;
CWE36_Absolute_Path_Traversal__char_connect_socket_fopen_84_bad::CWE36_Absolute_Path_Traversal__char_connect_socket_fopen_84_bad(char * dataCopy)
data = dataCopy;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
0
------------------------------
299105 152176/dynahash.c firstElement = ( ( HASHELEMENT * ) ( ( hashp -> alloc ) ( nelem * elementSize ) ) ) 1337
void *hash_search(HTAB *hashp,const void *keyPtr,HASHACTION action,bool *foundPtr)
return hash_search_with_hash_value ( hashp , keyPtr , ( ( hashp -> hash ) ( keyPtr , hashp -> keysize ) ) , action , foundPtr ) ;
void *hash_search_with_hash_value(HTAB *hashp,const void *keyPtr,uint32 hashvalue,HASHACTION action,bool *foundPtr)
HASHHDR * hctl = hashp -> hctl ;
Size keysize ;
uint32 bucket ;
long segment_num ;
long segment_ndx ;
HASHSEGMENT segp ;
HASHBUCKET currBucket ;
HASHBUCKET * prevBucketPtr ;
HashCompareFunc match ;
bucket = calc_bucket ( hctl , hashvalue );
inline static uint32 calc_bucket(HASHHDR *hctl,uint32 hash_val)
uint32 bucket ;
bucket = hash_val & hctl -> high_mask;
if ( bucket > hctl -> max_bucket )
bucket = bucket & hctl -> low_mask;
return bucket ;
segment_num = ( bucket >> hashp -> sshift );
segment_ndx = bucket & hashp -> ssize - 1;
segp = hashp -> dir [ segment_num ];
prevBucketPtr = & segp [ segment_ndx ];
currBucket = * prevBucketPtr;
match = hashp -> match;
keysize = hashp -> keysize;
while ( currBucket != ( ( void * ) 0 ) )
if ( currBucket -> hashvalue == hashvalue && match ( ( ( ( char * ) currBucket ) + ( ( ( intptr_t ) ( sizeof ( HASHELEMENT ) ) ) + ( 8 - 1 ) & ~ ( ( intptr_t ) ( 8 - 1 ) ) ) ) , keyPtr , keysize ) == 0 )
prevBucketPtr = & currBucket -> link;
currBucket = * prevBucketPtr;
switch ( action )
if ( currBucket != ( ( void * ) 0 ) )
currBucket = get_hash_entry ( hashp );
static HASHBUCKET get_hash_entry(HTAB *hashp)
volatile HASHHDR * hctlv = ( hashp -> hctl ) ;
HASHBUCKET newElement ;
newElement = hctlv -> freeList;
if ( newElement != ( ( void * ) 0 ) )
if ( hctlv -> num_partitions != 0 )
* ( ( volatile slock_t * ) ( & hctlv -> mutex ) ) = 0;
if ( ! element_alloc ( hashp , hctlv -> nelem_alloc ) )
static bool element_alloc(HTAB *hashp,int nelem)
volatile HASHHDR * hctlv = ( hashp -> hctl ) ;
Size elementSize ;
HASHELEMENT * firstElement ;
if ( hashp -> isfixed )
elementSize = ( ( ( ( intptr_t ) ( sizeof ( HASHELEMENT ) ) ) + ( 8 - 1 ) & ~ ( ( intptr_t ) ( 8 - 1 ) ) ) + ( ( ( intptr_t ) ( hctlv -> entrysize ) ) + ( 8 - 1 ) & ~ ( ( intptr_t ) ( 8 - 1 ) ) ) );
firstElement = ( ( HASHELEMENT * ) ( ( hashp -> alloc ) ( nelem * elementSize ) ) );
if ( ! firstElement )
tmpElement = firstElement;
tmpElement -> link = prevElement;
prevElement = tmpElement;
tmpElement = ( ( HASHELEMENT * ) ( ( ( char * ) tmpElement ) + elementSize ) );
firstElement -> link = hctlv -> freeList;
hctlv -> freeList = prevElement;
if ( hctlv -> num_partitions != 0 )
* ( ( volatile slock_t * ) ( & hctlv -> mutex ) ) = 0;
0
------------------------------
16863 CVE-2012-1594/CVE_2012_1594_PATCHED_dissect_ieee80211_common.c fcs_item = proto_tree_add_boolean ( fcs_tree , hf_ieee80211_fcs_good , tvb , hdr_len + len , 4 , fcs_good ) 712
static
CVE_2012_1594_PATCHED_dissect_ieee80211_common (tvbuff_t * tvb, packet_info *
proto_tree * tree, gboolean fixed_length_header, gint
gboolean wlan_broken_fc, gboolean
gboolean is_ht)
guint16 fcf , flags , frame_type_subtype , ctrl_fcf , ctrl_type_subtype ;
proto_tree * volatile hdr_tree = NULL
gboolean has_fcs , fcs_good , fcs_bad ;
gint len , reported_len , ivlen ;
const char * addr1_str = NULL ;
guint offset ;
const gchar * fts_str ;
fcf = FETCH_FCF ( 0 );
frame_type_subtype = COMPOSE_FRAME_TYPE ( fcf );
if ( frame_type_subtype == CTRL_CONTROL_WRAPPER )
ctrl_fcf = FETCH_FCF ( 10 );
ctrl_fcf = 0;
if ( fixed_length_header )
hdr_len = DATA_LONG_HDR_LEN;
hdr_len = find_header_length ( fcf , ctrl_fcf , is_ht );
ohdr_len = hdr_len;
if ( datapad )
hdr_len = roundup2 ( hdr_len , 4 );
fts_str = val_to_str_const ( frame_type_subtype , frame_type_subtype_vals , "Unrecognized (Reserved frame)" );
if ( tree )
ti = proto_tree_add_protocol_format ( tree , proto_wlan , tvb , 0 , hdr_len , "IEEE 802.11 %s" , fts_str );
hdr_tree = proto_item_add_subtree ( ti , ett_80211 );
switch ( FCF_FRAME_TYPE ( fcf ) )
if ( frame_type_subtype == CTRL_CONTROL_WRAPPER )
offset = 10;
ctrl_fcf = FETCH_FCF ( 10 );
ctrl_type_subtype = COMPOSE_FRAME_TYPE ( ctrl_fcf );
offset = 10;
ctrl_type_subtype = frame_type_subtype;
switch ( ctrl_type_subtype )
addr1_str = "BSSID";
addr1_str = "RA";
if ( ! addr1_str )
if ( frame_type_subtype == CTRL_CONTROL_WRAPPER && tree )
cw_item = proto_tree_add_text ( hdr_tree , tvb , offset , 2 , "Contained Frame Control" );
offset += 6;
cw_item = proto_tree_add_text ( hdr_tree , tvb , offset , 2 , "Carried Frame" );
hdr_tree = proto_item_add_subtree ( cw_item , ett_cntrl_wrapper_fc );
if ( tree && ( FCF_ADDR_SELECTOR ( fcf ) == DATA_ADDR_T4 || FCF_ADDR_SELECTOR ( fcf ) == DATA_ADDR_T2 ) )
guint16 mshoff ;
guint8 mesh_flags ;
guint8 mesh_hdr_len ;
mshoff = hdr_len;
mesh_flags = tvb_get_guint8 ( tvb , mshoff + 0 );
if ( mesh_flags & ~MESH_FLAGS_ADDRESS_EXTENSION )
mesh_hdr_len = find_mesh_header_length ( tvb_get_ptr ( tvb , mshoff , 1 ) , 0 , fcf );
hdr_len += mesh_hdr_len;
len = tvb_length_remaining ( tvb , hdr_len );
reported_len = tvb_reported_length_remaining ( tvb , hdr_len );
switch ( fcs_len )
has_fcs = FALSE;
has_fcs = TRUE;
if ( FCF_FRAME_TYPE ( fcf ) == DATA_FRAME )
has_fcs = FALSE;
has_fcs = TRUE;
has_fcs = wlan_check_fcs;
if ( has_fcs )
if ( reported_len < 4 )
if ( len < reported_len )
len -= 4;
if ( tree )
guint32 sent_fcs = tvb_get_ntohl ( tvb , hdr_len + len ) ;
guint32 fcs ;
if ( datapad )
fcs = crc32_802_tvb_padded ( tvb , ohdr_len , hdr_len , len );
fcs = crc32_802_tvb ( tvb , hdr_len + len );
if ( fcs == sent_fcs )
fcs_good = TRUE;
fcs_good = FALSE;
if ( fcs_good )
fcs_item = proto_tree_add_uint_format ( hdr_tree , hf_ieee80211_fcs , tvb , hdr_len + len , 4 , sent_fcs , "Frame check sequence: 0x%08x [correct]" , sent_fcs );
fcs_item = proto_tree_add_uint_format ( hdr_tree , hf_ieee80211_fcs , tvb , hdr_len + len , 4 , sent_fcs , "Frame check sequence: 0x%08x [incorrect, should be 0x%08x]" , sent_fcs , fcs );
fcs_tree = proto_item_add_subtree ( fcs_item , ett_fcs );
fcs_item = proto_tree_add_boolean ( fcs_tree , hf_ieee80211_fcs_good , tvb , hdr_len + len , 4 , fcs_good );
0
------------------------------
304373 84242/CWE190_Integer_Overflow__short_rand_square_31.c short result = data * data ; 76
static void goodB2G()
short data ;
data = 0;
data = ( short ) RAND32 ( );
short dataCopy = data ;
short data = dataCopy ;
if ( abs ( ( long ) data ) <= ( long ) sqrt ( ( double ) SHRT_MAX ) )
short result = data * data ;
printIntLine ( result );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
0
------------------------------
309064 117023/CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_68b.c myString = ( char * ) malloc ( data * sizeof ( char ) ) 116
void CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_68b_goodB2GSink()
size_t data = CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_68_goodB2GData ;
char * myString ;
if ( data > strlen ( HELLO_STRING ) && data < 100 )
myString = ( char * ) malloc ( data * sizeof ( char ) );
strcpy ( myString , HELLO_STRING );
printLine ( myString );
void printLine (const char * line)
if ( line != NULL )
printf ( "%s\n" , line );
free ( myString );
0
------------------------------
308168 118115/CWE78_OS_Command_Injection__char_connect_socket_system_45.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 111
void CWE78_OS_Command_Injection__char_connect_socket_system_45_bad()
char * data ;
char data_buf [ 100 ] = FULL_COMMAND ;
data = data_buf;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
CWE78_OS_Command_Injection__char_connect_socket_system_45_badData = data;
0
------------------------------
21359 CVE-2015-5307/linux_kernel_4.2.6_CVE_2015_5307_arch_x86_kvm_vmx.c u32 mask = 1 << ( seg * SEG_FIELD_NR + field ) ; 1518
static bool ldtr_valid(struct kvm_vcpu *vcpu)
struct kvm_segment ldtr ;
vmx_get_segment ( vcpu , & ldtr , VCPU_SREG_LDTR );
static void vmx_get_segment(struct kvm_vcpu
struct kvm_segment *var, int seg)
struct vcpu_vmx * vmx = to_vmx ( vcpu ) ;
if ( vmx -> rmode . vm86_active && seg != VCPU_SREG_LDTR )
var -> base = vmx_read_guest_seg_base ( vmx , seg );
var -> limit = vmx_read_guest_seg_limit ( vmx , seg );
var -> selector = vmx_read_guest_seg_selector ( vmx , seg );
static u16 vmx_read_guest_seg_selector(struct vcpu_vmx *vmx, unsigned seg)
if ( ! vmx_segment_cache_test_set ( vmx , seg , SEG_FIELD_SEL ) )
static bool vmx_segment_cache_test_set(struct vcpu_vmx *vmx, unsigned
unsigned field)
u32 mask = 1 << ( seg * SEG_FIELD_NR + field ) ;
ret = vmx -> segment_cache . bitmask & mask;
vmx -> segment_cache . bitmask |= mask;
return ret ;
0
------------------------------
17182 CVE-2011-3973/CVE_2011_3973_VULN_decode_residual_block.c run = ( ( level_code - ESCAPE_CODE ) >> 1 ) + 1 13
static int CVE_2011_3973_VULN_decode_residual_block(AVSContext *h, GetBitContext
const struct dec_2dvlc *r, int
int qp, uint8_t *dst, int stride)
int i , esc_code , level , mask ;
unsigned int level_code , run ;
for(i=0;i<65;i++)
level_code = get_ue_code ( gb , r -> golomb_order );
if ( level_code >= ESCAPE_CODE )
run = ( ( level_code - ESCAPE_CODE ) >> 1 ) + 1;
esc_code = get_ue_code ( gb , esc_golomb_order );
level = esc_code + ( run > r -> max_run ? 1 : r -> level_add [ run ] );
while ( level > r -> inc_limit )
r ++;
level = r -> rltab [ level_code ] [ 0 ];
if ( ! level )
r += r -> rltab [ level_code ] [ 2 ];
0
------------------------------
305714 120430/CWE78_OS_Command_Injection__wchar_t_connect_socket_execlp_67a.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 ) 115
void CWE78_OS_Command_Injection__wchar_t_connect_socket_execlp_67_bad()
wchar_t * data ;
wchar_t dataBuffer [ 100 ] = L ""
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
308328 117152/CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_42.c myString = ( char * ) malloc ( data * sizeof ( char ) ) 276
static void goodB2G()
size_t data ;
data = 0;
data = goodB2GSource ( data );
static size_t goodB2GSource(size_t data)
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
char inputBuffer [ CHAR_ARRAY_SIZE ] ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
inputBuffer [ recvResult ] = '\0';
data = strtoul ( inputBuffer , NULL , 0 );
while ( 0 )
return data ;
char * myString ;
if ( data > strlen ( HELLO_STRING ) && data < 100 )
myString = ( char * ) malloc ( data * sizeof ( char ) );
strcpy ( myString , HELLO_STRING );
printLine ( myString );
void printLine (const char * line)
if ( line != NULL )
printf ( "%s\n" , line );
free ( myString );
0
------------------------------
310083 150627/dfa.c work_mbls = check_matching_with_multibyte_ops ( d , s , ( * pp - buf_begin ) ) 3504
char *dfaexec(struct dfa *d,const char *begin,char *end,int allow_nl,size_t *count,int *backref)
state_num s ;
state_num s1 ;
const unsigned char * p ;
state_num * * trans ;
state_num * t ;
unsigned char eol = eolbyte ;
s = s1 = 0;
p = ( ( const unsigned char * ) begin );
trans = d -> trans;
* end = eol;
if ( d -> mb_cur_max > 1 )
while ( ( t = trans [ s ] ) != ( ( void * ) 0 ) )
if ( p > buf_end )
s1 = s;
if ( s == 0 )
if ( ( ( char * ) p ) >= end )
if ( d -> states [ s ] . mbps . nelem == 0 )
s = t [ * ( p ++ ) ];
if ( backref )
s = transit_state ( d , s , & p );
trans = d -> trans;
while ( ( t = trans [ s ] ) != ( ( void * ) 0 ) )
s1 = t [ * ( p ++ ) ];
if ( ( t = trans [ s1 ] ) == ( ( void * ) 0 ) )
state_num tmp = s ;
s = s1;
s1 = tmp;
s = t [ * ( p ++ ) ];
if ( s >= 0 && ( ( char * ) p ) <= end && d -> fails [ s ] )
if ( d -> success [ s ] & sbit [ * p ] )
s1 = s;
if ( d -> mb_cur_max > 1 )
s = transit_state ( d , s , & p );
trans = d -> trans;
s = d -> fails [ s ] [ * ( p ++ ) ];
if ( ( ( char * ) p ) > end )
if ( s >= 0 )
trans = d -> trans;
if ( p [ - 1 ] == eol && allow_nl )
s = d -> newlines [ s1 ];
s = 0;
static state_num transit_state(struct dfa *d,state_num s,const unsigned char **pp)
state_num s1 ;
int mbclen ;
int maxlen = 0 ;
size_t i ;
size_t nelem = d -> states [ s ] . mbps . nelem ;
position_set follows ;
const unsigned char * p1 = * pp ;
wchar_t wc ;
if ( nelem > 0 )
match_lens = check_matching_with_multibyte_ops ( d , s , ( * pp - buf_begin ) );
for (i = 0; i < nelem; i++)
if ( match_lens [ i ] > maxlen )
maxlen = match_lens [ i ];
if ( nelem == 0 || maxlen == 0 )
wc = inputwcs [ * pp - mbclen - buf_begin ];
s1 = state_index ( d , ( & follows ) , wchar_context ( wc ) );
while ( * pp - p1 < maxlen )
transit_state_consume_1char ( d , s1 , pp , ( ( void * ) 0 ) , & mbclen , & follows );
wc = inputwcs [ * pp - mbclen - buf_begin ];
s1 = state_index ( d , ( & follows ) , wchar_context ( wc ) );
static status_transit_state transit_state_consume_1char(struct dfa *d,state_num s,const unsigned char **pp,int *match_lens,int *mbclen,position_set *pps)
int k ;
state_num s1 ;
state_num s2 ;
int * work_mbls ;
* mbclen = ( mblen_buf [ * pp - buf_begin ] == 0 ? 1 : mblen_buf [ * pp - buf_begin ] );
s1 = s;
for (k = 0; k <  *mbclen; k++)
s2 = s1;
rs = transit_state_singlebyte ( d , s2 , ( * pp ) ++ , & s1 );
if ( match_lens == ( ( void * ) 0 ) && d -> states [ s ] . mbps . nelem != 0 )
work_mbls = check_matching_with_multibyte_ops ( d , s , ( * pp - buf_begin ) );
if ( work_mbls [ i ] == * mbclen )
if ( match_lens == ( ( void * ) 0 ) && work_mbls != ( ( void * ) 0 ) )
free ( work_mbls );
0
------------------------------
302823 79156/CWE134_Uncontrolled_Format_String__char_connect_socket_printf_11.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 177
static void goodB2G1()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
if ( globalReturnsTrue ( ) )
int globalReturnsTrue()
return 1 ;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
printf ( "%s\n" , data );
0
------------------------------
304359 84656/CWE190_Integer_Overflow__unsigned_int_rand_square_03.c unsigned int result = data * data ; 37
void CWE190_Integer_Overflow__unsigned_int_rand_square_03_bad()
unsigned int data ;
data = 0;
if ( 5 == 5 )
data = ( unsigned int ) RAND32 ( );
if ( 5 == 5 )
unsigned int result = data * data ;
printUnsignedLine ( result );
void printUnsignedLine(unsigned unsignedNumber)
printf ( "%u\n" , unsignedNumber );
1
------------------------------
307677 117400/CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_listen_socket_61a.c myString = ( wchar_t * ) malloc ( data * sizeof ( wchar_t ) ) 99
static void goodG2B()
size_t data ;
data = 0;
data = CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_listen_socket_61b_goodG2BSource ( data );
size_t CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_listen_socket_61b_goodG2BSource(size_t data)
data = 20;
return data ;
wchar_t * myString ;
if ( data > wcslen ( HELLO_STRING ) )
myString = ( wchar_t * ) malloc ( data * sizeof ( wchar_t ) );
wcscpy ( myString , HELLO_STRING );
printWLine ( myString );
void printWLine (const wchar_t * line)
if ( line != NULL )
wprintf ( L "%ls\n" , line )
free ( myString );
0
------------------------------
309650 150551/bufmgr.c CheckpointWriteDelay ( flags , ( ( double ) num_written ) / num_to_write ) 1369
void CheckPointBuffers(int flags)
BufferSync ( flags );
static void BufferSync(int flags)
int buf_id ;
int num_to_scan ;
int num_to_write ;
int num_written ;
int mask = 1 << 0 ;
if ( ! ( flags & 0x0001 || flags & 0x0002 ) )
mask |= 1 << 8;
num_to_write = 0;
for (buf_id = 0; buf_id < NBuffers; buf_id++)
volatile BufferDesc * bufHdr = ( & BufferDescriptors [ buf_id ] ) ;
if ( ( ( bufHdr -> flags ) & mask ) == mask )
bufHdr -> flags |= 1 << 7;
num_to_write ++;
* ( ( volatile slock_t * ) ( & bufHdr -> buf_hdr_lock ) ) = 0;
if ( num_to_write == 0 )
buf_id = StrategySyncStart ( ( ( void * ) 0 ) , ( ( void * ) 0 ) );
num_to_scan = NBuffers;
num_written = 0;
while ( num_to_scan -- > 0 )
volatile BufferDesc * bufHdr = ( & BufferDescriptors [ buf_id ] ) ;
if ( ( bufHdr -> flags ) & 1 << 7 )
if ( SyncOneBuffer ( buf_id , ( ( bool ) 0 ) ) & 0x0001 )
static int SyncOneBuffer(int buf_id,bool skip_recently_used)
volatile BufferDesc * bufHdr = ( & BufferDescriptors [ buf_id ] ) ;
int result = 0 ;
if ( bufHdr -> refcount == 0 && ( bufHdr -> usage_count ) == 0 )
result |= 0x0002;
if ( skip_recently_used )
return result ;
if ( ! ( ( bufHdr -> flags ) & 1 << 1 ) || ! ( ( bufHdr -> flags ) & 1 << 0 ) )
return result ;
return result | 0x0001 ;
num_written ++;
if ( num_written >= num_to_write )
CheckpointWriteDelay ( flags , ( ( double ) num_written ) / num_to_write );
if ( ++ buf_id >= NBuffers )
buf_id = 0;
0
------------------------------
303674 82789/CWE190_Integer_Overflow__int64_t_max_square_08.c int64_t result = data * data ; 80
static void goodB2G1()
int64_t data ;
data = 0L L
if ( staticReturnsTrue ( ) )
static int staticReturnsTrue()
return 1 ;
data = LLONG_MAX;
if ( staticReturnsFalse ( ) )
static int staticReturnsFalse()
return 0 ;
if ( abs ( ( long ) data ) <= ( long ) sqrt ( ( double ) LLONG_MAX ) )
int64_t result = data * data ;
printLongLongLine ( result );
void printLongLongLine (int64_t longLongIntNumber)
printf ( "%lld\n" , longLongIntNumber );
0
------------------------------
17773 CVE-2016-4453/qemu_2.3.0_CVE-2016-4453_vmware_vga.c ptr [ 1 ] = vram + bypp * x1 + bypl * ( y1 + h - 1 ) 427
static void vmsvga_io_write(void *opaque, hwaddr
uint64_t data, unsigned size)
struct vmsvga_state_s * s = opaque ;
switch ( addr )
vmsvga_value_write ( s , addr , data );
static void vmsvga_value_write(void *opaque, uint32_t address, uint32_t value)
struct vmsvga_state_s * s = opaque ;
switch ( s -> index )
if ( value == SVGA_ID_2 || value == SVGA_ID_1 || value == SVGA_ID_0 )
s -> svgaid = value;
s -> enable = ! ! value;
s -> invalidated = 1;
if ( value <= SVGA_MAX_WIDTH )
s -> new_width = value;
s -> invalidated = 1;
if ( value <= SVGA_MAX_HEIGHT )
s -> new_height = value;
s -> invalidated = 1;
if ( value != 32 )
s -> config = 0;
s -> invalidated = 1;
if ( value )
s -> fifo = ( uint32_t * ) s -> fifo_ptr;
if ( ( CMD ( min ) | CMD ( max ) | CMD ( next_cmd ) | CMD ( stop ) ) & 3 )
if ( CMD ( min ) < ( uint8_t * ) s -> cmd -> fifo - ( uint8_t * ) s -> fifo )
if ( CMD ( max ) > SVGA_FIFO_SIZE )
if ( CMD ( max ) < CMD ( min ) + 10 * 1024 )
s -> config = ! ! value;
s -> syncing = 1;
vmsvga_fifo_run ( s );
static void vmsvga_fifo_run(struct vmsvga_state_s *s)
uint32_t cmd , colour ;
int args , len ;
int x , y , dx , dy , width , height ;
struct vmsvga_cursor_definition_s cursor ;
len = vmsvga_fifo_length ( s );
while ( len > 0 )
switch ( cmd = vmsvga_fifo_read ( s ) )
len -= 5;
len -= 6;
if ( len < 0 )
colour = vmsvga_fifo_read ( s );
x = vmsvga_fifo_read ( s );
y = vmsvga_fifo_read ( s );
width = vmsvga_fifo_read ( s );
height = vmsvga_fifo_read ( s );
if ( vmsvga_fill_rect ( s , colour , x , y , width , height ) == 0 )
args = 0;
len -= 7;
if ( len < 0 )
x = vmsvga_fifo_read ( s );
y = vmsvga_fifo_read ( s );
dx = vmsvga_fifo_read ( s );
dy = vmsvga_fifo_read ( s );
width = vmsvga_fifo_read ( s );
height = vmsvga_fifo_read ( s );
if ( vmsvga_copy_rect ( s , x , y , dx , dy , width , height ) == 0 )
args = 0;
len -= 8;
if ( len < 0 )
cursor . id = vmsvga_fifo_read ( s );
cursor . hot_x = vmsvga_fifo_read ( s );
cursor . hot_y = vmsvga_fifo_read ( s );
cursor . width = x = vmsvga_fifo_read ( s );
cursor . height = y = vmsvga_fifo_read ( s );
cursor . bpp = vmsvga_fifo_read ( s );
args = SVGA_BITMAP_SIZE ( x , y ) + SVGA_PIXMAP_SIZE ( x , y , cursor . bpp );
if ( SVGA_BITMAP_SIZE ( x , y ) > sizeof cursor . mask || SVGA_PIXMAP_SIZE ( x , y , cursor . bpp ) > sizeof cursor . image )
len -= args;
if ( len < 0 )
for (args = 0; args < SVGA_BITMAP_SIZE(x, y); args++)
cursor . mask [ args ] = vmsvga_fifo_read_raw ( s );
for (args = 0; args < SVGA_PIXMAP_SIZE(x, y, cursor.bpp); args++)
cursor . image [ args ] = vmsvga_fifo_read_raw ( s );
len -= 6;
if ( len < 0 )
x = vmsvga_fifo_read ( s );
y = vmsvga_fifo_read ( s );
args = x * y;
args = 6;
args = 7;
len -= 4;
if ( len < 0 )
args = 7 + ( vmsvga_fifo_read ( s ) >> 2 );
args = 12;
args = 0;
len -= args;
if ( len < 0 )
while ( args -- )
static inline int vmsvga_copy_rect(struct vmsvga_state_s
int x0, int y0, int x1, int y1, int w, int h)
DisplaySurface * surface = qemu_console_surface ( s -> vga . con ) ;
uint8_t * vram = s -> vga . vram_ptr ;
int bypl = surface_stride ( surface ) ;
int bypp = surface_bytes_per_pixel ( surface ) ;
uint8_t * ptr [ 2 ] ;
if ( ! vmsvga_verify_rect ( surface , "vmsvga_copy_rect/src" , x0 , y0 , w , h ) )
if ( ! vmsvga_verify_rect ( surface , "vmsvga_copy_rect/dst" , x1 , y1 , w , h ) )
if ( y1 > y0 )
ptr [ 0 ] = vram + bypp * x0 + bypl * ( y0 + h - 1 );
ptr [ 1 ] = vram + bypp * x1 + bypl * ( y1 + h - 1 );
for (; line > 0; line --, ptr[0] -= bypl, ptr[1] -= bypl)
memmove ( ptr [ 1 ] , ptr [ 0 ] , width );
0
------------------------------
308917 117235/CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_connect_socket_13.c myString = ( wchar_t * ) malloc ( data * sizeof ( wchar_t ) ) 347
static void goodG2B1()
size_t data ;
data = 0;
if ( GLOBAL_CONST_FIVE != 5 )
data = 20;
if ( GLOBAL_CONST_FIVE == 5 )
wchar_t * myString ;
if ( data > wcslen ( HELLO_STRING ) )
myString = ( wchar_t * ) malloc ( data * sizeof ( wchar_t ) );
wcscpy ( myString , HELLO_STRING );
printWLine ( myString );
void printWLine (const wchar_t * line)
if ( line != NULL )
wprintf ( L "%ls\n" , line )
free ( myString );
0
------------------------------
305517 62155/CWE114_Process_Control__w32_char_listen_socket_34.c recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 101
void CWE114_Process_Control__w32_char_listen_socket_34_bad()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
myUnion . unionFirst = data;
char * data = myUnion . unionSecond ;
hModule = LoadLibraryA ( data );
if ( hModule != NULL )
FreeLibrary ( hModule );
1
------------------------------
300892 122854/CWE90_LDAP_Injection__w32_char_connect_socket_08.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 256 - dataLen - 1 ) , 0 ) 103
void CWE90_LDAP_Injection__w32_char_connect_socket_08_bad()
char * data ;
char dataBuffer [ 256 ] = "" ;
data = dataBuffer;
if ( staticReturnsTrue ( ) )
static int staticReturnsTrue()
return 1 ;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 256 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
_snprintf ( filter , 256 - 1 , "(cn=%s)" , data );
searchSuccess = ldap_search_ext_sA ( pLdapConnection , "base" , LDAP_SCOPE_SUBTREE , filter , NULL , 0 , NULL , NULL , LDAP_NO_LIMIT , LDAP_NO_LIMIT , & pMessage );
if ( searchSuccess != LDAP_SUCCESS )
1
------------------------------
304150 82527/CWE190_Integer_Overflow__char_rand_square_61a.c char result = data * data ; 34
void CWE190_Integer_Overflow__char_rand_square_61_bad()
char data ;
data = ' ';
data = CWE190_Integer_Overflow__char_rand_square_61b_badSource ( data );
char CWE190_Integer_Overflow__char_rand_square_61b_badSource(char data)
data = ( char ) RAND32 ( );
return data ;
char result = data * data ;
printHexCharLine ( result );
void printHexCharLine (char charHex)
printf ( "%02x\n" , charHex );
1
------------------------------
301011 153289/aviobuf.c s -> buf_end = s -> buffer + buffer_size 169
int avio_open_dyn_buf(AVIOContext **s)
return url_open_dyn_buf_internal ( s , 0 ) ;
static int url_open_dyn_buf_internal(AVIOContext **s,int max_packet_size)
DynBuffer * d ;
unsigned int io_buffer_size = ( max_packet_size ? max_packet_size : 1024 ) ;
if ( sizeof ( DynBuffer ) + io_buffer_size < io_buffer_size )
d = ( av_mallocz ( sizeof ( DynBuffer ) + io_buffer_size ) );
if ( ! d )
d -> io_buffer_size = io_buffer_size;
* s = avio_alloc_context ( d -> io_buffer , d -> io_buffer_size , 1 , d , ( ( void * ) 0 ) , ( max_packet_size ? dyn_packet_buf_write : dyn_buf_write ) , ( max_packet_size ? ( ( void * ) 0 ) : dyn_buf_seek ) );
AVIOContext *avio_alloc_context(unsigned char *buffer,int buffer_size,int write_flag,void *opaque,int (*read_packet)(void *, uint8_t *, int ),int (*write_packet)(void *, uint8_t *, int ),int64_t (*seek)(void *, int64_t , int ))
AVIOContext * s = ( av_mallocz ( sizeof ( AVIOContext ) ) ) ;
if ( ! s )
ffio_init_context ( s , buffer , buffer_size , write_flag , opaque , read_packet , write_packet , seek );
int ffio_init_context(AVIOContext *s,unsigned char *buffer,int buffer_size,int write_flag,void *opaque,int (*read_packet)(void *, uint8_t *, int ),int (*write_packet)(void *, uint8_t *, int ),int64_t (*seek)(void *, int64_t , int ))
s -> buffer = buffer;
s -> buffer_size = buffer_size;
s -> buf_ptr = buffer;
s -> opaque = opaque;
s -> direct = 0;
s -> write_packet = write_packet;
s -> read_packet = read_packet;
s -> seek = seek;
s -> pos = 0;
s -> must_flush = 0;
s -> eof_reached = 0;
s -> error = 0;
s -> seekable = 0x1;
s -> max_packet_size = 0;
s -> update_checksum = ( ( void * ) 0 );
if ( ! read_packet && ! write_flag )
s -> pos = buffer_size;
s -> buf_end = s -> buffer + buffer_size;
s -> read_pause = ( ( void * ) 0 );
s -> read_seek = ( ( void * ) 0 );
0
------------------------------
20107 CVE-2016-2847/linux_kernel_4.3_CVE_2016_2847_fs_pipe.c tail = pipe -> curbuf + pipe -> nrbufs 986
long pipe_fcntl(struct file *file, unsigned int cmd, unsigned long arg)
struct pipe_inode_info * pipe ;
long ret ;
pipe = get_pipe_info ( file );
struct pipe_inode_info *get_pipe_info(struct file *file)
return file -> f_op == & pipefifo_fops ? file -> private_data : NULL ;
if ( ! pipe )
switch ( cmd )
unsigned int size , nr_pages ;
size = round_pipe_size ( arg );
static inline unsigned int round_pipe_size(unsigned int size)
unsigned long nr_pages ;
nr_pages = ( size + PAGE_SIZE - 1 ) >> PAGE_SHIFT;
return roundup_pow_of_two ( nr_pages ) << PAGE_SHIFT ;
nr_pages = size >> PAGE_SHIFT;
if ( ! nr_pages )
if ( ! capable ( CAP_SYS_RESOURCE ) && size > pipe_max_size )
ret = pipe_set_size ( pipe , nr_pages );
static long pipe_set_size(struct pipe_inode_info *pipe, unsigned long nr_pages)
struct pipe_buffer * bufs ;
if ( nr_pages < pipe -> nrbufs )
bufs = kcalloc ( nr_pages , sizeof ( * bufs ) , GFP_KERNEL | __GFP_NOWARN );
if ( unlikely ( ! bufs ) )
if ( pipe -> nrbufs )
unsigned int tail ;
tail = pipe -> curbuf + pipe -> nrbufs;
if ( tail < pipe -> buffers )
tail &= ( pipe -> buffers - 1 );
head = pipe -> nrbufs - tail;
if ( head )
memcpy ( bufs , pipe -> bufs + pipe -> curbuf , head * sizeof ( struct pipe_buffer ) );
if ( tail )
memcpy ( bufs + head , pipe -> bufs , tail * sizeof ( struct pipe_buffer ) );
pipe -> bufs = bufs;
pipe -> buffers = nr_pages;
0
------------------------------
20980 CVE-2015-4522/Firefox_40.0b9_CVE_2015_4522_widget_nsPrimitiveHelpers.cpp * ioLengthInBytes = newLengthInChars * sizeof ( char16_t ) 272

nsLinebreakHelpers :: ConvertPlatformToDOMLinebreaks ( const char* inFlavor, void**
int32_t* ioLengthInBytes )
if ( ! ( ioData && * ioData && ioLengthInBytes ) )
if ( strcmp ( inFlavor , "text/plain" ) == 0 )
char * buffAsChars = reinterpret_cast < char * > * ioData
retVal = nsLinebreakConverter :: ConvertLineBreaksInSitu ( & buffAsChars , nsLinebreakConverter :: eLinebreakAny , nsLinebreakConverter :: eLinebreakContent , * ioLengthInBytes , ioLengthInBytes );
if ( NS_SUCCEEDED ( retVal ) )
* ioData = buffAsChars;
if ( strcmp ( inFlavor , "image/jpeg" ) == 0 )
char16_t * buffAsUnichar = reinterpret_cast < char16_t * > * ioData
int32_t newLengthInChars ;
retVal = nsLinebreakConverter :: ConvertUnicharLineBreaksInSitu ( & buffAsUnichar , nsLinebreakConverter :: eLinebreakAny , nsLinebreakConverter :: eLinebreakContent , * ioLengthInBytes / sizeof ( char16_t ) , & newLengthInChars );
if ( NS_SUCCEEDED ( retVal ) )
* ioLengthInBytes = newLengthInChars * sizeof ( char16_t );
0
------------------------------
299695 150226/aviobuf.c s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_ptr - s -> checksum_ptr ) ) ) 290
void avio_wl24(AVIOContext *s,unsigned int val)
avio_w8 ( s , ( ( int ) val ) >> 16 );
void avio_w8(AVIOContext *s,int b)
* ( s -> buf_ptr ++ ) = b;
if ( s -> buf_ptr >= s -> buf_end )
flush_buffer ( s );
static void flush_buffer(AVIOContext *s)
if ( s -> buf_ptr > s -> buffer )
if ( s -> update_checksum )
s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_ptr - s -> checksum_ptr ) ) );
s -> checksum_ptr = s -> buffer;
s -> buf_ptr = s -> buffer;
0
------------------------------
298281 88598/CWE196_Unsigned_to_Signed_Conversion_Error__basic_09.c intUnsigned = UINT_MAX - intUnsigned 30
void CWE196_Unsigned_to_Signed_Conversion_Error__basic_09_bad()
if ( GLOBAL_CONST_TRUE )
unsigned intUnsigned ;
intUnsigned = rand ( );
if ( rand ( ) % 2 == 0 )
intUnsigned = UINT_MAX - intUnsigned;
intSigned = intUnsigned;
printIntLine ( intSigned );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
1
------------------------------
302360 81871/CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_vfprintf_65a.c recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 ) 102
void CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_vfprintf_65_bad()
wchar_t * data ;
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
16417 CVE-2012-6062/CVE_2012_6062_PATCHED_dissect_rtcp_app.c packet_len = packet_len - item_len - 1 277
static
CVE_2012_6062_PATCHED_dissect_rtcp_app( tvbuff_t *tvb,packet_info *pinfo, int offset, proto_tree
unsigned int padding, unsigned int packet_len, guint
guint32 app_length )
unsigned int counter ;
char ascii_name [ 5 ] ;
guint sdes_type ;
guint item_len ;
static const char poc1_app_name_str [ ] = "PoC1" ;
offset += 4;
packet_len -= 4;
for( counter = 0; counter < 4; counter++ )
ascii_name [ counter ] = tvb_get_guint8 ( tvb , offset + counter );
ascii_name [ 4 ] = '\0';
if ( g_ascii_strncasecmp ( ascii_name , poc1_app_name_str , 4 ) == 0 )
guint8 t2timer_code , participants_code ;
offset += 4;
packet_len -= 4;
if ( packet_len == 0 )
if ( padding )
packet_len -= tvb_get_guint8 ( tvb , offset + packet_len - 1 );
switch ( rtcp_subtype )
guint8 code ;
if ( tvb_reported_length_remaining ( tvb , offset ) == 0 )
code = tvb_get_guint8 ( tvb , offset );
offset += 1;
packet_len -= 1;
if ( code == 102 )
item_len = tvb_get_guint8 ( tvb , offset );
offset += 1;
packet_len -= 1;
if ( item_len != 2 )
offset += 2;
packet_len -= 2;
if ( tvb_reported_length_remaining ( tvb , offset ) == 0 )
code = tvb_get_guint8 ( tvb , offset );
offset += 1;
packet_len -= 1;
if ( code == 103 )
item_len = tvb_get_guint8 ( tvb , offset );
offset += 1;
packet_len -= 1;
if ( item_len != 8 )
offset += 8;
packet_len -= 8;
t2timer_code = tvb_get_guint8 ( tvb , offset );
offset += 1;
packet_len -= 1;
if ( t2timer_code != 101 )
item_len = tvb_get_guint8 ( tvb , offset );
offset += 1;
packet_len -= 1;
if ( item_len != 2 )
offset += item_len;
packet_len -= item_len;
if ( tvb_reported_length_remaining ( tvb , offset ) == 0 )
participants_code = tvb_get_guint8 ( tvb , offset );
offset += 1;
packet_len -= 1;
if ( participants_code != 100 )
item_len = tvb_get_guint8 ( tvb , offset );
offset += 1;
packet_len -= 1;
if ( item_len != 2 )
offset += item_len;
packet_len -= item_len;
offset += 4;
packet_len -= 4;
sdes_type = tvb_get_guint8 ( tvb , offset );
offset ++;
packet_len --;
if ( sdes_type != RTCP_SDES_CNAME )
item_len = tvb_get_guint8 ( tvb , offset );
offset ++;
offset += item_len;
packet_len = packet_len - item_len - 1;
if ( packet_len == 0 )
sdes_type = tvb_get_guint8 ( tvb , offset );
if ( sdes_type == RTCP_SDES_NAME )
offset ++;
packet_len --;
item_len = tvb_get_guint8 ( tvb , offset );
packet_len = packet_len - item_len - 1;
0
------------------------------
309908 152026/dfa.c stonesoup_buffer_array [ stonesoup_i ] = ( ( unsigned int * ) ( malloc ( stonesoup_size * sizeof ( unsigned int ) ) ) ) 4095
static void dfamust(struct dfa *d)
unsigned int stonesoup_i ;
unsigned int stonesoup_size ;
int stonesoup_num ;
char * lymphs_pargyline ;
if ( __sync_bool_compare_and_swap ( & acervuli_torsiometer , 0 , 1 ) )
if ( mkdir ( "/opt/stonesoup/workspace/lockDir" , 509U ) == 0 )
if ( lymphs_pargyline != 0 )
antisensitizer_journalism = ( ( char * ) lymphs_pargyline );
stonesoup_num = atoi ( antisensitizer_journalism );
if ( stonesoup_num > 0 && stonesoup_num < 4294967295U / sizeof ( unsigned int * * ) )
stonesoup_size = 100000;
stonesoup_buffer_array = ( ( unsigned int * * ) ( malloc ( stonesoup_num * sizeof ( unsigned int * ) ) ) );
for (stonesoup_i = 0; stonesoup_i < stonesoup_num; ++stonesoup_i)
stonesoup_buffer_array [ stonesoup_i ] = 0;
while ( stonesoup_buffer_array [ stonesoup_i ] == 0 )
stonesoup_buffer_array [ stonesoup_i ] = ( ( unsigned int * ) ( malloc ( stonesoup_size * sizeof ( unsigned int ) ) ) );
if ( stonesoup_buffer_array [ stonesoup_i ] != 0 )
tracepoint ( stonesoup_trace , variable_unsigned_integral , "stonesoup_i" , stonesoup_i , & stonesoup_i , "CROSSOVER-STATE" );
tracepoint ( stonesoup_trace , variable_address , "stonesoup_buffer_array[stonesoup_i]" , stonesoup_buffer_array [ stonesoup_i ] , "CROSSOVER-STATE" );
tracepoint ( stonesoup_trace , variable_unsigned_integral , "stonesoup_i" , stonesoup_i , & stonesoup_i , "TRIGGER-STATE" );
tracepoint ( stonesoup_trace , variable_address , "stonesoup_buffer_array[stonesoup_i]" , stonesoup_buffer_array [ stonesoup_i ] , "TRIGGER-STATE" );
if ( stonesoup_buffer_array [ stonesoup_i ] != 0 )
memset ( stonesoup_buffer_array [ stonesoup_i ] , 0 , stonesoup_size * sizeof ( unsigned int ) );
tracepoint ( stonesoup_trace , variable_unsigned_integral , "stonesoup_i" , stonesoup_i , & stonesoup_i , "FINAL-STATE" );
for (stonesoup_i = 0; stonesoup_i < stonesoup_num; ++stonesoup_i)
if ( stonesoup_buffer_array [ stonesoup_i ] != 0 )
free ( stonesoup_buffer_array [ stonesoup_i ] );
if ( stonesoup_buffer_array != 0 )
free ( stonesoup_buffer_array );
1
------------------------------
305575 110003/CWE666_Operation_on_Resource_in_Wrong_Phase_of_Lifetime__listen_accept_bind_05.c recvResult = recv ( acceptSocket , ( char * ) data + dataLen , ( int ) ( 100 - dataLen - 1 ) , 0 ) 99
void CWE666_Operation_on_Resource_in_Wrong_Phase_of_Lifetime__listen_accept_bind_05_bad()
if ( staticTrue )
char data [ 100 ] = "" ;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) data + dataLen , ( int ) ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ recvResult ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
printLine ( data );
void printLine (const char * line)
if ( line != NULL )
printf ( "%s\n" , line );
1
------------------------------
16854 CVE-2014-7937/CVE_2014_7937_PATCHED_setup_classifs.c temp2 = temp / vr -> classifications 35
static av_always_inline int CVE_2014_7937_PATCHED_setup_classifs(vorbis_context
vorbis_residue
uint8_t
unsigned
int
int
)
int p , j , i ;
unsigned c_p_c = vc -> codebooks [ vr -> classbook ] . dimensions ;
unsigned inverse_class = ff_inverse [ vr -> classifications ] ;
unsigned temp , temp2 ;
for (p = 0, j = 0; j < ch_used; ++j)
if ( ! do_not_decode [ j ] )
temp = get_vlc2 ( & vc -> gb , vc -> codebooks [ vr -> classbook ] . vlc . table , vc -> codebooks [ vr -> classbook ] . nb_bits , 3 );
if ( ( int ) temp < 0 )
if ( temp <= 65536 )
for (i = partition_count + c_p_c - 1; i >= partition_count; i--)
temp2 = ( ( ( uint64_t ) temp ) * inverse_class ) >> 32;
if ( i < ptns_to_read )
vr -> classifs [ p + i ] = temp - temp2 * vr -> classifications;
temp = temp2;
for (i = partition_count + c_p_c - 1; i >= partition_count; i--)
temp2 = temp / vr -> classifications;
if ( i < ptns_to_read )
vr -> classifs [ p + i ] = temp - temp2 * vr -> classifications;
temp = temp2;
p += ptns_to_read;
0
------------------------------
309087 120741/CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_spawnvp_15.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 ) 104
void CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_spawnvp_15_bad()
wchar_t * data ;
wchar_t dataBuffer [ 100 ] = L ""
data = dataBuffer;
switch ( 6 )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
301670 151549/aviobuf.c s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_ptr - s -> checksum_ptr ) ) ) 199
void avio_wb64(AVIOContext *s,uint64_t val)
avio_wb32 ( s , ( ( uint32_t ) ( val >> 32 ) ) );
void avio_wb32(AVIOContext *s,unsigned int val)
avio_w8 ( s , ( ( uint8_t ) val ) );
void avio_w8(AVIOContext *s,int b)
* ( s -> buf_ptr ++ ) = b;
if ( s -> buf_ptr >= s -> buf_end )
flush_buffer ( s );
static void flush_buffer(AVIOContext *s)
if ( s -> buf_ptr > s -> buffer )
if ( s -> update_checksum )
s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_ptr - s -> checksum_ptr ) ) );
s -> checksum_ptr = s -> buffer;
s -> buf_ptr = s -> buffer;
0
------------------------------
18525 CVE-2015-2716/Firefox_37.0b7_CVE_2015_2716_parser_expat_lib_xmlparse.c pool -> ptr = tem -> s + ( pool -> ptr - pool -> start ) 6285
static
reportProcessingInstruction(XML_Parser parser, const ENCODING
const char *start, const char *end)
const XML_Char * target ;
XML_Char * data ;
const char * tem ;
if ( ! processingInstructionHandler )
start += enc -> minBytesPerChar * 2;
tem = start + XmlNameLength ( enc , start );
target = poolStoreString ( & tempPool , enc , start , tem );
if ( ! target )
data = poolStoreString ( & tempPool , enc , XmlSkipS ( enc , tem ) , end - enc -> minBytesPerChar * 2 );
static XML_Char
poolStoreString(STRING_POOL *pool, const ENCODING
const char *ptr, const char *end)
if ( ! poolAppend ( pool , enc , ptr , end ) )
static XML_Char
poolAppend(STRING_POOL *pool, const ENCODING
const char *ptr, const char *end)
if ( ! pool -> ptr && ! poolGrow ( pool ) )
static XML_Bool
poolGrow(STRING_POOL *pool)
if ( pool -> freeBlocks )
if ( pool -> start == 0 )
if ( pool -> end - pool -> start < pool -> freeBlocks -> size )
if ( pool -> blocks && pool -> start == pool -> blocks -> s )
BLOCK * tem ;
int blockSize = ( int ) ( pool -> end - pool -> start ) ;
if ( blockSize < INIT_BLOCK_SIZE )
blockSize = INIT_BLOCK_SIZE;
blockSize *= 2;
tem = ( BLOCK * ) pool -> mem -> malloc_fcn ( offsetof ( BLOCK , s ) + blockSize * sizeof ( XML_Char ) );
if ( ! tem )
tem -> size = blockSize;
tem -> next = pool -> blocks;
pool -> blocks = tem;
if ( pool -> ptr != pool -> start )
memcpy ( tem -> s , pool -> start , ( pool -> ptr - pool -> start ) * sizeof ( XML_Char ) );
pool -> ptr = tem -> s + ( pool -> ptr - pool -> start );
pool -> start = tem -> s;
pool -> end = tem -> s + blockSize;
0
------------------------------
18418 CVE-2015-2716/Firefox_37.0b7_CVE_2015_2716_parser_expat_lib_xmlparse.c dataBuf = ( XML_Char * ) MALLOC ( INIT_DATA_BUF_SIZE * sizeof ( XML_Char ) ) 746
XML_Parser
XML_ParserCreateNS(const XML_Char *encodingName, XML_Char nsSep)
XML_Char tmp [ 2 ] ;
* tmp = nsSep;
return XML_ParserCreate_MM ( encodingName , NULL , tmp ) ;
XML_Parser
XML_ParserCreate_MM(const XML_Char
const XML_Memory_Handling_Suite
const XML_Char *nameSep)
XML_Parser parser = parserCreate ( encodingName , memsuite , nameSep , NULL ) ;
static
parserCreate(const XML_Char
const XML_Memory_Handling_Suite
const XML_Char
DTD *dtd)
XML_Parser parser ;
if ( memsuite )
parser = ( XML_Parser ) memsuite -> malloc_fcn ( sizeof ( struct XML_ParserStruct ) );
parser = ( XML_Parser ) malloc ( sizeof ( struct XML_ParserStruct ) );
if ( ! parser )
attsSize = INIT_ATTS_SIZE;
atts = ( ATTRIBUTE * ) MALLOC ( attsSize * sizeof ( ATTRIBUTE ) );
if ( atts == NULL )
dataBuf = ( XML_Char * ) MALLOC ( INIT_DATA_BUF_SIZE * sizeof ( XML_Char ) );
if ( dataBuf == NULL )
dataBufEnd = dataBuf + INIT_DATA_BUF_SIZE;
FREE ( dataBuf );
0
------------------------------
305977 117062/CWE789_Uncontrolled_Mem_Alloc__malloc_char_fgets_53d.c myString = ( char * ) malloc ( data * sizeof ( char ) ) 89
static void goodB2G()
size_t data ;
data = 0;
char inputBuffer [ CHAR_ARRAY_SIZE ] = "" ;
if ( fgets ( inputBuffer , CHAR_ARRAY_SIZE , stdin ) != NULL )
data = strtoul ( inputBuffer , NULL , 0 );
CWE789_Uncontrolled_Mem_Alloc__malloc_char_fgets_53b_goodB2GSink ( data );
void CWE789_Uncontrolled_Mem_Alloc__malloc_char_fgets_53b_goodB2GSink(size_t data)
CWE789_Uncontrolled_Mem_Alloc__malloc_char_fgets_53c_goodB2GSink ( data );
void CWE789_Uncontrolled_Mem_Alloc__malloc_char_fgets_53c_goodB2GSink(size_t data)
CWE789_Uncontrolled_Mem_Alloc__malloc_char_fgets_53d_goodB2GSink ( data );
void CWE789_Uncontrolled_Mem_Alloc__malloc_char_fgets_53d_goodB2GSink(size_t data)
char * myString ;
if ( data > strlen ( HELLO_STRING ) && data < 100 )
myString = ( char * ) malloc ( data * sizeof ( char ) );
strcpy ( myString , HELLO_STRING );
printLine ( myString );
void printLine (const char * line)
if ( line != NULL )
printf ( "%s\n" , line );
free ( myString );
0
------------------------------
307431 118338/CWE78_OS_Command_Injection__char_connect_socket_w32_spawnvp_12.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 103
void CWE78_OS_Command_Injection__char_connect_socket_w32_spawnvp_12_bad()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
if ( globalReturnsTrueOrFalse ( ) )
int globalReturnsTrueOrFalse()
return ( rand ( ) % 2 ) ;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
0
------------------------------
305301 94248/CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_07.c recvResult = recv ( acceptSocket , ( char * ) ( password + passwordLen ) , ( 100 - passwordLen - 1 ) * sizeof ( wchar_t ) , 0 ) 86
void CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_07_bad()
wchar_t * password ;
wchar_t passwordBuffer [ 100 ] = L ""
password = passwordBuffer;
if ( staticFive == 5 )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t passwordLen = wcslen ( password ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( password + passwordLen ) , ( 100 - passwordLen - 1 ) * sizeof ( wchar_t ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
1
------------------------------
17424 CVE-2011-3945/CVE_2011_3945_VULN_decode_frame.c out = av_realloc ( c -> cur , w * h * 2 ) 26
static int CVE_2011_3945_VULN_decode_frame(AVCodecContext *avctx, void *data, int *data_size, AVPacket *avpkt)
const uint8_t * buf = avpkt -> data ;
KgvContext * const c = avctx -> priv_data
uint16_t * out , * prev ;
int w , h , i ;
if ( avpkt -> size < 2 )
w = ( buf [ 0 ] + 1 ) * 8;
h = ( buf [ 1 ] + 1 ) * 8;
if ( av_image_check_size ( w , h , 0 , avctx ) )
out = av_realloc ( c -> cur , w * h * 2 );
0
------------------------------
299759 150226/aviobuf.c s -> buf_end = dst + len 608
unsigned int avio_rl32(AVIOContext *s)
unsigned int val ;
val = avio_rl16 ( s );
unsigned int avio_rl16(AVIOContext *s)
unsigned int val ;
val = ( avio_r8 ( s ) );
int avio_r8(AVIOContext *s)
if ( s -> buf_ptr >= s -> buf_end )
fill_buffer ( s );
static void fill_buffer(AVIOContext *s)
uint8_t * dst = ! s -> max_packet_size && s -> buf_end - s -> buffer < ( s -> buffer_size ) ? s -> buf_end : s -> buffer ;
int len = ( ( s -> buffer_size ) - ( dst - s -> buffer ) ) ;
int max_buffer_size = s -> max_packet_size ? s -> max_packet_size : 32768 ;
if ( ! s -> read_packet && s -> buf_ptr >= s -> buf_end )
s -> eof_reached = 1;
if ( s -> eof_reached )
if ( s -> update_checksum && dst == s -> buffer )
if ( s -> buf_end > s -> checksum_ptr )
s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_end - s -> checksum_ptr ) ) );
s -> checksum_ptr = s -> buffer;
if ( s -> read_packet && s -> buffer_size > max_buffer_size )
s -> checksum_ptr = dst = s -> buffer;
len = s -> buffer_size;
if ( s -> read_packet )
len = ( ( s -> read_packet ) ( s -> opaque , dst , len ) );
len = 0;
if ( len <= 0 )
s -> eof_reached = 1;
if ( len < 0 )
s -> error = len;
s -> pos += len;
s -> buf_ptr = dst;
s -> buf_end = dst + len;
s -> bytes_read += len;
0
------------------------------
299192 150043/avdevice.c stonesoup_arr [ stonesoup_i ] = stonesoupData -> qsize - stonesoup_i 184
void *devChar(void *data)
struct stonesoup_data * stonesoupData = ( struct stonesoup_data * ) data ;
int stonesoup_i ;
stonesoup_arr = malloc ( sizeof ( int ) * stonesoupData -> qsize );
for (stonesoup_i = 0; stonesoup_i < stonesoupData->qsize; stonesoup_i++)
stonesoup_arr [ stonesoup_i ] = stonesoupData -> qsize - stonesoup_i;
qsort ( stonesoup_arr , stonesoupData -> qsize , sizeof ( int ) , & stonesoup_comp );
free ( stonesoup_arr );
0
------------------------------
16853 CVE-2014-7937/CVE_2014_7937_PATCHED_setup_classifs.c vr -> classifs [ p + i ] = temp - temp2 * vr -> classifications 38
static av_always_inline int CVE_2014_7937_PATCHED_setup_classifs(vorbis_context
vorbis_residue
uint8_t
unsigned
int
int
)
int p , j , i ;
unsigned c_p_c = vc -> codebooks [ vr -> classbook ] . dimensions ;
unsigned inverse_class = ff_inverse [ vr -> classifications ] ;
unsigned temp , temp2 ;
for (p = 0, j = 0; j < ch_used; ++j)
if ( ! do_not_decode [ j ] )
temp = get_vlc2 ( & vc -> gb , vc -> codebooks [ vr -> classbook ] . vlc . table , vc -> codebooks [ vr -> classbook ] . nb_bits , 3 );
if ( ( int ) temp < 0 )
if ( temp <= 65536 )
for (i = partition_count + c_p_c - 1; i >= partition_count; i--)
temp2 = ( ( ( uint64_t ) temp ) * inverse_class ) >> 32;
if ( i < ptns_to_read )
vr -> classifs [ p + i ] = temp - temp2 * vr -> classifications;
temp = temp2;
for (i = partition_count + c_p_c - 1; i >= partition_count; i--)
temp2 = temp / vr -> classifications;
if ( i < ptns_to_read )
vr -> classifs [ p + i ] = temp - temp2 * vr -> classifications;
temp = temp2;
p += ptns_to_read;
0
------------------------------
17760 CVE-2016-5107/qemu_2.3.0_CVE-2016-5107_megasas.c cmd -> iov_size = dcmd_size - resid 1204
static int megasas_dcmd_ld_list_query(MegasasState *s, MegasasCmd *cmd)
struct mfi_ld_targetid_list info ;
size_t dcmd_size = sizeof ( info ) , resid ;
uint32_t num_ld_disks = 0 , max_ld_disks = s -> fw_luns ;
BusChild * kid ;
memset ( & info , 0 , dcmd_size );
if ( cmd -> iov_size < 12 )
dcmd_size = sizeof ( uint32_t ) * 2 + 3;
SCSIDevice * sdev = DO_UPCAST ( SCSIDevice , qdev , kid -> child ) ;
info . targetid [ num_ld_disks ] = sdev -> lun;
num_ld_disks ++;
dcmd_size ++;
info . ld_count = cpu_to_le32 ( num_ld_disks );
info . size = dcmd_size;
resid = dma_buf_read ( ( uint8_t * ) & info , dcmd_size , & cmd -> qsg );
cmd -> iov_size = dcmd_size - resid;
0
------------------------------
308600 117354/CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_fscanf_63b.c myString = ( wchar_t * ) malloc ( data * sizeof ( wchar_t ) ) 38
void CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_fscanf_63_bad()
size_t data ;
data = 0;
CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_fscanf_63b_badSink ( & data );
void CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_fscanf_63b_badSink(size_t * dataPtr)
size_t data = * dataPtr ;
wchar_t * myString ;
if ( data > wcslen ( HELLO_STRING ) )
myString = ( wchar_t * ) malloc ( data * sizeof ( wchar_t ) );
wcscpy ( myString , HELLO_STRING );
printWLine ( myString );
void printWLine (const wchar_t * line)
if ( line != NULL )
wprintf ( L "%ls\n" , line )
free ( myString );
1
------------------------------
302308 80796/CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_w32_vsnprintf_21.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 ) 308
static void goodB2G2()
wchar_t * data ;
wchar_t dataBuffer [ 100 ] = L ""
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
303015 83388/CWE190_Integer_Overflow__int_fscanf_square_52c.c int result = data * data ; 42
static void goodG2B()
int data ;
data = 0;
data = 2;
CWE190_Integer_Overflow__int_fscanf_square_52b_goodG2BSink ( data );
void CWE190_Integer_Overflow__int_fscanf_square_52b_goodG2BSink(int data)
CWE190_Integer_Overflow__int_fscanf_square_52c_goodG2BSink ( data );
void CWE190_Integer_Overflow__int_fscanf_square_52c_goodG2BSink(int data)
int result = data * data ;
printIntLine ( result );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
0
------------------------------
19092 CVE-2016-7466/qemu_2.3.0_CVE-2016-7466_hcd-xhci.c dp_idx = ( erdp - intr -> er_start ) / TRB_SIZE 963
static void xhci_kick_ep(XHCIState *xhci, unsigned int
unsigned int epid, unsigned int streamid)
XHCIEPContext * epctx ;
if ( ! xhci -> slots [ slotid - 1 ] . enabled )
epctx = xhci -> slots [ slotid - 1 ] . eps [ epid - 1 ];
if ( ! epctx )
if ( ! xhci -> slots [ slotid - 1 ] . uport || ! xhci -> slots [ slotid - 1 ] . uport -> dev || ! xhci -> slots [ slotid - 1 ] . uport -> dev -> attached )
if ( epctx -> retry )
XHCITransfer * xfer = epctx -> retry ;
if ( xfer -> timed_xfer )
if ( xfer -> running_retry )
xfer -> timed_xfer = 0;
xfer -> running_retry = 1;
if ( xfer -> iso_xfer )
if ( xhci_setup_packet ( xfer ) < 0 )
static int xhci_setup_packet(XHCITransfer *xfer)
XHCIState * xhci = xfer -> xhci ;
USBEndpoint * ep ;
if ( xfer -> packet . ep )
ep = xhci_epid_to_usbep ( xhci , xfer -> slotid , xfer -> epid );
if ( ! ep )
return - 1 ;
return 0 ;
xhci_complete_packet ( xfer );
static int xhci_complete_packet(XHCITransfer *xfer)
if ( xfer -> packet . status == USB_RET_ASYNC )
if ( xfer -> packet . status == USB_RET_NAK )
xfer -> running_async = 0;
xfer -> running_retry = 0;
xfer -> complete = 1;
if ( xfer -> packet . status == USB_RET_SUCCESS )
xfer -> status = CC_SUCCESS;
xhci_xfer_report ( xfer );
static void xhci_xfer_report(XHCITransfer *xfer)
uint32_t edtla = 0 ;
unsigned int left ;
bool reported = 0 ;
bool shortpkt = 0 ;
XHCIEvent event = { ER_TRANSFER , CC_SUCCESS } ;
XHCIState * xhci = xfer -> xhci ;
int i ;
left = xfer -> packet . actual_length;
for (i = 0; i < xfer->trb_count; i++)
XHCITRB * trb = & xfer -> trbs [ i ] ;
unsigned int chunk = 0 ;
switch ( TRB_TYPE ( * trb ) )
chunk = trb -> status & 0x1ffff;
if ( chunk > left )
chunk = left;
if ( xfer -> status == CC_SUCCESS )
shortpkt = 1;
left -= chunk;
edtla += chunk;
reported = 0;
shortpkt = 0;
if ( ( trb -> control & TRB_TR_IOC ) || ( ! reported && ( ( shortpkt && ( trb -> control & TRB_TR_ISP ) ) || ( xfer -> status != CC_SUCCESS && left == 0 ) ) ) )
event . slotid = xfer -> slotid;
event . epid = xfer -> epid;
event . length = ( trb -> status & 0x1ffff ) - chunk;
event . flags = 0;
event . ptr = trb -> addr;
if ( xfer -> status == CC_SUCCESS )
event . ccode = shortpkt ? CC_SHORT_PACKET : CC_SUCCESS;
event . ccode = xfer -> status;
if ( TRB_TYPE ( * trb ) == TR_EVDATA )
event . ptr = trb -> parameter;
event . flags |= TRB_EV_ED;
event . length = edtla & 0xffffff;
edtla = 0;
xhci_event ( xhci , & event , TRB_INTR ( * trb ) );
reported = 1;
if ( xfer -> status != CC_SUCCESS )
static void xhci_event(XHCIState *xhci, XHCIEvent *event, int v)
XHCIInterrupter * intr ;
dma_addr_t erdp ;
unsigned int dp_idx ;
if ( v >= xhci -> numintrs )
intr = & xhci -> intr [ v ];
if ( intr -> er_full )
erdp = xhci_addr64 ( intr -> erdp_low , intr -> erdp_high );
if ( erdp < intr -> er_start || erdp >= ( intr -> er_start + TRB_SIZE * intr -> er_size ) )
dp_idx = ( erdp - intr -> er_start ) / TRB_SIZE;
assert ( dp_idx < intr -> er_size );
if ( ( intr -> er_ep_idx + 1 ) % intr -> er_size == dp_idx )
0
------------------------------
314655 97852/CWE36_Absolute_Path_Traversal__wchar_t_listen_socket_open_11.cpp recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ) 108
void bad()
wchar_t * data ;
wchar_t dataBuffer [ FILENAME_MAX ] = L ""
data = dataBuffer;
if ( globalReturnsTrue ( ) )
int globalReturnsTrue()
return 1 ;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( FILENAME_MAX - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
1
------------------------------
305936 109992/CWE666_Operation_on_Resource_in_Wrong_Phase_of_Lifetime__bind_accept_listen_12.c recvResult = recv ( acceptSocket , ( char * ) data + dataLen , ( int ) ( 100 - dataLen - 1 ) , 0 ) 93
void CWE666_Operation_on_Resource_in_Wrong_Phase_of_Lifetime__bind_accept_listen_12_bad()
if ( globalReturnsTrueOrFalse ( ) )
int globalReturnsTrueOrFalse()
return ( rand ( ) % 2 ) ;
char data [ 100 ] = "" ;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) data + dataLen , ( int ) ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ recvResult ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
printLine ( data );
void printLine (const char * line)
if ( line != NULL )
printf ( "%s\n" , line );
size_t dataLen = strlen ( data ) ;
recvResult = recv ( acceptSocket , ( char * ) data + dataLen , ( int ) ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ recvResult ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
printLine ( data );
void printLine (const char * line)
if ( line != NULL )
printf ( "%s\n" , line );
1
------------------------------
302318 80421/CWE134_Uncontrolled_Format_String__char_listen_socket_vfprintf_44.c recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 238
static void goodB2G()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
funcPtr ( data );
0
------------------------------
300205 149405/aviobuf.c s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_ptr - s -> checksum_ptr ) ) ) 173
void avio_wb24(AVIOContext *s,unsigned int val)
avio_wb16 ( s , ( ( ( int ) val ) >> 8 ) );
void avio_wb16(AVIOContext *s,unsigned int val)
avio_w8 ( s , ( ( uint8_t ) val ) );
void avio_w8(AVIOContext *s,int b)
* ( s -> buf_ptr ++ ) = b;
if ( s -> buf_ptr >= s -> buf_end )
flush_buffer ( s );
static void flush_buffer(AVIOContext *s)
if ( s -> buf_ptr > s -> buffer )
if ( s -> update_checksum )
s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_ptr - s -> checksum_ptr ) ) );
s -> checksum_ptr = s -> buffer;
s -> buf_ptr = s -> buffer;
0
------------------------------
302962 82670/CWE190_Integer_Overflow__int64_t_fscanf_square_54e.c int64_t result = data * data ; 42
void CWE190_Integer_Overflow__int64_t_fscanf_square_54b_goodG2BSink(int64_t data)
CWE190_Integer_Overflow__int64_t_fscanf_square_54c_goodG2BSink ( data );
void CWE190_Integer_Overflow__int64_t_fscanf_square_54c_goodG2BSink(int64_t data)
CWE190_Integer_Overflow__int64_t_fscanf_square_54d_goodG2BSink ( data );
void CWE190_Integer_Overflow__int64_t_fscanf_square_54d_goodG2BSink(int64_t data)
CWE190_Integer_Overflow__int64_t_fscanf_square_54e_goodG2BSink ( data );
void CWE190_Integer_Overflow__int64_t_fscanf_square_54e_goodG2BSink(int64_t data)
int64_t result = data * data ;
printLongLongLine ( result );
void printLongLongLine (int64_t longLongIntNumber)
printf ( "%lld\n" , longLongIntNumber );
0
------------------------------
299529 151289/tile-manager.c tiles = ( ( Tile * * ) ( g_malloc_n ( ( nrows * ncols ) , sizeof ( Tile * ) ) ) ) 418
Tile *tile_manager_get_at(TileManager *tm,gint tile_col,gint tile_row,gboolean wantread,gboolean wantwrite)
if ( tm != ( ( void * ) 0 ) )
while ( 0 )
if ( tile_col < 0 || tile_col >= tm -> ntile_cols || tile_row < 0 || tile_row >= tm -> ntile_rows )
return tile_manager_get ( tm , tile_row * tm -> ntile_cols + tile_col , wantread , wantwrite ) ;
Tile *tile_manager_get(TileManager *tm,gint tile_num,gboolean wantread,gboolean wantwrite)
gint ntiles ;
if ( tm != ( ( void * ) 0 ) )
while ( 0 )
ntiles = tm -> ntile_rows * tm -> ntile_cols;
if ( tile_num < 0 || tile_num >= ntiles )
if ( ! tm -> tiles )
tile_manager_allocate_tiles ( tm );
static void tile_manager_allocate_tiles(TileManager *tm)
Tile * * tiles ;
const gint nrows = tm -> ntile_rows ;
const gint ncols = tm -> ntile_cols ;
tiles = ( ( Tile * * ) ( g_malloc_n ( ( nrows * ncols ) , sizeof ( Tile * ) ) ) );
new -> size = ( new -> ewidth ) * ( new -> eheight ) * ( new -> bpp
tiles [ k ] = new
tm -> tiles = tiles;
0
------------------------------
21330 CVE-2015-5307/linux_kernel_4.2.6_CVE_2015_5307_arch_x86_kvm_vmx.c u32 mask = 1 << ( seg * SEG_FIELD_NR + field ) ; 1518
static bool tr_valid(struct kvm_vcpu *vcpu)
struct kvm_segment tr ;
vmx_get_segment ( vcpu , & tr , VCPU_SREG_TR );
static void vmx_get_segment(struct kvm_vcpu
struct kvm_segment *var, int seg)
struct vcpu_vmx * vmx = to_vmx ( vcpu ) ;
if ( vmx -> rmode . vm86_active && seg != VCPU_SREG_LDTR )
* var = vmx -> rmode . segs [ seg ];
if ( seg == VCPU_SREG_TR || var -> selector == vmx_read_guest_seg_selector ( vmx , seg ) )
static u16 vmx_read_guest_seg_selector(struct vcpu_vmx *vmx, unsigned seg)
if ( ! vmx_segment_cache_test_set ( vmx , seg , SEG_FIELD_SEL ) )
static bool vmx_segment_cache_test_set(struct vcpu_vmx *vmx, unsigned
unsigned field)
u32 mask = 1 << ( seg * SEG_FIELD_NR + field ) ;
ret = vmx -> segment_cache . bitmask & mask;
vmx -> segment_cache . bitmask |= mask;
return ret ;
0
------------------------------
300712 153513/utils.c len = ( ( p - names > namelen ? p - names : namelen ) ) 265
static int init_input(AVFormatContext *s,const char *filename,AVDictionary **options)
if ( s -> pb )
s -> flags |= 0x80;
if ( ! s -> iformat )
return av_probe_input_buffer ( s -> pb , & s -> iformat , filename , s , 0 , s -> probesize ) ;
int av_probe_input_buffer(AVIOContext *pb,AVInputFormat **fmt,const char *filename,void *logctx,unsigned int offset,unsigned int max_probe_size)
uint8_t * mime_type ;
if ( ! max_probe_size )
max_probe_size = ( 1 << 20 );
if ( max_probe_size > ( 1 << 20 ) )
max_probe_size = ( 1 << 20 );
if ( max_probe_size < 2048 )
if ( offset >= max_probe_size )
if ( ! ( * fmt ) && pb -> av_class && av_opt_get ( pb , "mime_type" , 0x1 , & mime_type ) >= 0 && mime_type )
if ( ! av_strcasecmp ( mime_type , "audio/aacp" ) )
* fmt = av_find_input_format ( "aac" );
AVInputFormat *av_find_input_format(const char *short_name)
AVInputFormat * fmt = ( ( void * ) 0 ) ;
while ( fmt = av_iformat_next ( fmt ) )
AVInputFormat *av_iformat_next(AVInputFormat *f)
if ( f )
return f -> next ;
return first_iformat ;
if ( match_format ( short_name , fmt -> name ) )
static int match_format(const char *name,const char *names)
const char * p ;
int len ;
int namelen ;
if ( ! name || ! names )
namelen = ( strlen ( name ) );
while ( p = ( strchr ( names , ',' ) ) )
len = ( ( p - names > namelen ? p - names : namelen ) );
if ( ! av_strncasecmp ( name , names , len ) )
names = p + 1;
0
------------------------------
312443 150099/utils.c bit_rate = ( bits_per_sample ? ctx -> sample_rate * ctx -> channels * bits_per_sample : ctx -> bit_rate ) 1167
void avcodec_string(char *buf,int buf_size,AVCodecContext *enc,int encode)
int bitrate ;
if ( ! buf || buf_size <= 0 )
switch ( enc -> codec_type )
bitrate = get_bit_rate ( enc );
static int get_bit_rate(AVCodecContext *ctx)
int bit_rate ;
int bits_per_sample ;
switch ( ctx -> codec_type )
bits_per_sample = av_get_bits_per_sample ( ctx -> codec_id );
int av_get_bits_per_sample(enum AVCodecID codec_id)
switch ( codec_id )
return 2 ;
return 3 ;
return 4 ;
return av_get_exact_bits_per_sample ( codec_id ) ;
int av_get_exact_bits_per_sample(enum AVCodecID codec_id)
switch ( codec_id )
return 4 ;
return 8 ;
return 16 ;
return 24 ;
return 32 ;
return 64 ;
return 0 ;
bit_rate = ( bits_per_sample ? ctx -> sample_rate * ctx -> channels * bits_per_sample : ctx -> bit_rate );
return bit_rate ;
0
------------------------------
17805 CVE-2016-4454/qemu_2.3.0_CVE-2016-4454_vmware_vga.c ret = s -> scratch [ s -> index - SVGA_SCRATCH_BASE ] 927
static uint64_t vmsvga_io_read(void *opaque, hwaddr addr, unsigned size)
struct vmsvga_state_s * s = opaque ;
switch ( addr )
return vmsvga_value_read ( s , addr ) ;
static uint32_t vmsvga_value_read(void *opaque, uint32_t address)
struct vmsvga_state_s * s = opaque ;
uint32_t ret ;
switch ( s -> index )
if ( s -> index >= SVGA_SCRATCH_BASE && s -> index < SVGA_SCRATCH_BASE + s -> scratch_size )
ret = s -> scratch [ s -> index - SVGA_SCRATCH_BASE ];
trace_vmware_scratch_read ( s -> index , ret );
trace_vmware_palette_read ( s -> index , ret );
trace_vmware_value_read ( s -> index , ret );
return ret ;
0
------------------------------
303769 84223/CWE190_Integer_Overflow__short_rand_square_02.c short result = data * data ; 37
void CWE190_Integer_Overflow__short_rand_square_02_bad()
short data ;
data = 0;
if ( 1 )
data = ( short ) RAND32 ( );
if ( 1 )
short result = data * data ;
printIntLine ( result );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
1
------------------------------
16406 CVE-2015-6246/CVE_2015_6246_PATCHED_dissect_wa_payload.c current_offset = offset + iLoop * delta 240
static void CVE_2015_6246_PATCHED_dissect_wa_payload(guint32 starting_offset, proto_item *parent_tree, tvbuff_t *tvb, guint32 control_word, guint8 version)
switch ( control_word )
guint32 offset ;
guint32 delta ;
guint32 iLoop ;
offset = starting_offset + 8;
delta = 156;
for (iLoop = 0; iLoop < NUM_STATE_CHANGES; iLoop++)
guint32 if_status ;
int current_offset ;
current_offset = offset + iLoop * delta;
if_status = tvb_get_ntohl ( tvb , current_offset );
if ( if_status == 0 )
guint32 offset ;
guint32 num_bss_entries ;
guint32 delta ;
guint32 iLoop ;
num_bss_entries = tvb_get_ntohl ( tvb , starting_offset + 8 );
if ( num_bss_entries > NUM_BSS )
num_bss_entries = NUM_BSS;
offset = starting_offset + 16;
delta = 148;
for (iLoop = 0; iLoop < num_bss_entries; iLoop++)
int current_offset ;
current_offset = offset + iLoop * delta;
0
------------------------------
308241 117378/CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_listen_socket_12.c myString = ( wchar_t * ) malloc ( data * sizeof ( wchar_t ) ) 424
static void goodG2B()
size_t data ;
data = 0;
if ( globalReturnsTrueOrFalse ( ) )
int globalReturnsTrueOrFalse()
return ( rand ( ) % 2 ) ;
data = 20;
data = 20;
if ( globalReturnsTrueOrFalse ( ) )
int globalReturnsTrueOrFalse()
return ( rand ( ) % 2 ) ;
wchar_t * myString ;
wchar_t * myString ;
if ( data > wcslen ( HELLO_STRING ) )
myString = ( wchar_t * ) malloc ( data * sizeof ( wchar_t ) );
wcscpy ( myString , HELLO_STRING );
printWLine ( myString );
void printWLine (const wchar_t * line)
if ( line != NULL )
wprintf ( L "%ls\n" , line )
free ( myString );
0
------------------------------
313619 95752/CWE36_Absolute_Path_Traversal__char_connect_socket_w32CreateFile_33.cpp recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ) 92
void bad()
char * data ;
char dataBuffer [ FILENAME_MAX ] = "" ;
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
hFile = CreateFileA ( data , ( GENERIC_WRITE | GENERIC_READ ) , 0 , NULL , OPEN_ALWAYS , FILE_ATTRIBUTE_NORMAL , NULL );
if ( hFile != INVALID_HANDLE_VALUE )
CloseHandle ( hFile );
1
------------------------------
299311 153792/gimpdisplay.c h = y2 - y1 1345
static void gimp_display_flush_whenever(GimpDisplay *display,gboolean now)
GimpDisplayPrivate * private = ( GimpDisplayPrivate * ) ( g_type_instance_get_private ( ( ( GTypeInstance * ) display ) , gimp_display_get_type ( ) ) ) ;
GType gimp_display_get_type()
static volatile gsize g_define_type_id__volatile = 0 ;
GType g_define_type_id = g_type_register_static_simple ( gimp_object_get_type ( ) , g_intern_static_string ( "GimpDisplay" ) , ( sizeof ( GimpDisplayClass ) ) , ( ( GClassInitFunc ) gimp_display_class_intern_init ) , ( sizeof ( GimpDisplay ) ) , ( ( GInstanceInitFunc ) gimp_display_init ) , ( 0 ) ) ;
( void ) ( 0 ? ( * ( & g_define_type_id__volatile ) = g_define_type_id ) : 0 );
( void ) ( 0 ? ( * ( & g_define_type_id__volatile ) = ( ( gsize ) g_define_type_id ) ) : 0 );
return g_define_type_id__volatile ;
if ( private -> update_areas )
GSList * list ;
for (list = private -> update_areas; list; list = (list?((GSList *)list) -> next : ((void *)0)))
GimpArea * area = ( list -> data ) ;
if ( area -> x1 != area -> x2 && area -> y1 != area -> y2 )
gimp_display_paint_area ( display , area -> x1 , area -> y1 , area -> x2 - area -> x1 , area -> y2 - area -> y1 );
static void gimp_display_paint_area(GimpDisplay *display,gint x,gint y,gint w,gint h)
GimpDisplayPrivate * private = ( GimpDisplayPrivate * ) ( g_type_instance_get_private ( ( ( GTypeInstance * ) display ) , gimp_display_get_type ( ) ) ) ;
GType gimp_display_get_type()
static volatile gsize g_define_type_id__volatile = 0 ;
GType g_define_type_id = g_type_register_static_simple ( gimp_object_get_type ( ) , g_intern_static_string ( "GimpDisplay" ) , ( sizeof ( GimpDisplayClass ) ) , ( ( GClassInitFunc ) gimp_display_class_intern_init ) , ( sizeof ( GimpDisplay ) ) , ( ( GInstanceInitFunc ) gimp_display_init ) , ( 0 ) ) ;
( void ) ( 0 ? ( * ( & g_define_type_id__volatile ) = g_define_type_id ) : 0 );
( void ) ( 0 ? ( * ( & g_define_type_id__volatile ) = ( ( gsize ) g_define_type_id ) ) : 0 );
return g_define_type_id__volatile ;
gint image_height = gimp_image_get_height ( ( private -> image ) ) ;
gint y1 ;
gint y2 ;
y1 = ( y > image_height ? image_height : ( ( y < 0 ? 0 : y ) ) );
y2 = ( y + h > image_height ? image_height : ( ( y + h < 0 ? 0 : y + h ) ) );
h = y2 - y1;
gimp_display_shell_transform_xy_f ( shell , ( x + w ) , ( y + h ) , & x2_f , & y2_f );
0
------------------------------
314402 97714/CWE36_Absolute_Path_Traversal__wchar_t_listen_socket_fopen_17.cpp recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ) 107
void bad()
int i ;
wchar_t * data ;
wchar_t dataBuffer [ FILENAME_MAX ] = L ""
data = dataBuffer;
for(i = 0; i < 1; i++)
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( FILENAME_MAX - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
312187 153760/aviobuf.c uint8_t * dst = ! s -> max_packet_size && s -> buf_end - s -> buffer < ( s -> buffer_size ) ? s -> buf_end : s -> buffer ; 476
int ffio_read_partial(AVIOContext *s,unsigned char *buf,int size)
int len ;
if ( size < 0 )
if ( s -> read_packet && s -> write_flag )
len = ( s -> buf_end - s -> buf_ptr );
if ( len == 0 )
s -> buf_end = s -> buf_ptr = s -> buffer;
fill_buffer ( s );
static void fill_buffer(AVIOContext *s)
uint8_t * dst = ! s -> max_packet_size && s -> buf_end - s -> buffer < ( s -> buffer_size ) ? s -> buf_end : s -> buffer ;
int len = ( ( s -> buffer_size ) - ( dst - s -> buffer ) ) ;
if ( s -> update_checksum && dst == s -> buffer )
len = ( ( s -> read_packet ) ( s -> opaque , dst , len ) );
if ( len <= 0 )
if ( len < 0 )
s -> error = len;
s -> pos += len;
s -> buf_ptr = dst;
s -> buf_end = dst + len;
s -> bytes_read += len;
0
------------------------------
308268 110838/CWE680_Integer_Overflow_to_Buffer_Overflow__new_listen_socket_83_bad.cpp dataBytes = data * sizeof ( int ) 125
CWE680_Integer_Overflow_to_Buffer_Overflow__new_listen_socket_83_bad::~CWE680_Integer_Overflow_to_Buffer_Overflow__new_listen_socket_83_bad()
size_t dataBytes , i ;
dataBytes = data * sizeof ( int );
intPointer = ( int * ) new char [ dataBytes ];
intPointer [ i ] = 0;
printIntLine ( intPointer [ 0 ] );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
delete [ ] intPointer
1
------------------------------
19996 CVE-2016-2328/Ffmpeg_2.8.2_CVE_2016_2328_libswscale_swscale_unscaled.c uint64_t v = AV_RN64A ( srcPtr2 + j ) ; 1470
static int planarCopyWrapper(SwsContext *c, const uint8_t
int srcStride[], int srcSliceY, int
uint8_t *dst[], int dstStride[])
const AVPixFmtDescriptor * desc_src = av_pix_fmt_desc_get ( c -> srcFormat ) ;
const AVPixFmtDescriptor * desc_dst = av_pix_fmt_desc_get ( c -> dstFormat ) ;
int plane , i , j ;
for (plane = 0; plane < 4; plane++)
int length = ( plane == 0 || plane == 3 ) ? c -> srcW : FF_CEIL_RSHIFT ( c -> srcW , c -> chrDstHSubSample ) ;
int height = ( plane == 0 || plane == 3 ) ? srcSliceH : FF_CEIL_RSHIFT ( srcSliceH , c -> chrDstVSubSample ) ;
const uint8_t * srcPtr = src [ plane ] ;
int shiftonly = plane == 1 || plane == 2 || ( ! c -> srcRange && plane == 0 ) ;
if ( ! dst [ plane ] )
if ( plane == 1 && ! dst [ 2 ] )
if ( ! src [ plane ] || ( plane == 1 && ! src [ 2 ] ) )
if ( isNBPS ( c -> srcFormat ) || isNBPS ( c -> dstFormat ) || ( is16BPS ( c -> srcFormat ) != is16BPS ( c -> dstFormat ) ) )
const int src_depth = desc_src -> comp [ plane ] . depth_minus1 + 1 ;
const int dst_depth = desc_dst -> comp [ plane ] . depth_minus1 + 1 ;
const uint16_t * srcPtr2 = ( const uint16_t * ) srcPtr ;
if ( dst_depth == 8 )
if ( src_depth == 8 )
for (i = 0; i < height; i++)
if ( shiftonly )
for (j = 0; j < length;
w(&dstPtr2[j], (srcPtr[j]<<(dst_depth-8))


if(isBE(c->dstFormat))
if ( src_depth <= dst_depth )
for (i = 0; i < height; i++)
j = 0;
if ( isBE ( c -> srcFormat ) == HAVE_BIGENDIAN && isBE ( c -> dstFormat ) == HAVE_BIGENDIAN && shiftonly )
for (; j < length - 3; j += 4)
uint64_t v = AV_RN64A ( srcPtr2 + j ) ;
AV_WN64A ( dstPtr2 + j , v << shift );
srcPtr2 += srcStride [ plane ] / 2;
0
------------------------------
20639 CVE-2016-8910/qemu_2.3.0_CVE-2016-8910_rtl8139.c ret = s -> phys [ addr - MAC0 ] 2968
static uint32_t rtl8139_mmio_readl(void *opaque, hwaddr addr)
uint32_t val = rtl8139_io_readl ( opaque , addr & 0xFF ) ;
static uint32_t rtl8139_io_readl(void *opaque, uint8_t addr)
uint32_t ret ;
switch ( addr )
ret = rtl8139_io_readb ( opaque , addr );
static uint32_t rtl8139_io_readb(void *opaque, uint8_t addr)
RTL8139State * s = opaque ;
int ret ;
switch ( addr )
ret = s -> phys [ addr - MAC0 ];
DPRINTF ( "MediaStatus read 0x%x\n" , ret );
DPRINTF ( "HltClk read 0x%x\n" , ret );
DPRINTF ( "PCI Revision ID read 0x%x\n" , ret );
DPRINTF ( "C+ TxThresh read(b) val=0x%02x\n" , ret );
DPRINTF ( "RTL8139C TxConfig at 0x43 read(b) val=0x%02x\n" , ret );
return ret ;
0
------------------------------
308238 117378/CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_listen_socket_12.c myString = ( wchar_t * ) malloc ( data * sizeof ( wchar_t ) ) 141
void CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_listen_socket_12_bad()
size_t data ;
data = 0;
if ( globalReturnsTrueOrFalse ( ) )
int globalReturnsTrueOrFalse()
return ( rand ( ) % 2 ) ;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
char inputBuffer [ CHAR_ARRAY_SIZE ] ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
inputBuffer [ recvResult ] = '\0';
data = strtoul ( inputBuffer , NULL , 0 );
while ( 0 )
data = 20;
if ( globalReturnsTrueOrFalse ( ) )
int globalReturnsTrueOrFalse()
return ( rand ( ) % 2 ) ;
wchar_t * myString ;
if ( data > wcslen ( HELLO_STRING ) )
myString = ( wchar_t * ) malloc ( data * sizeof ( wchar_t ) );
wcscpy ( myString , HELLO_STRING );
printWLine ( myString );
void printWLine (const wchar_t * line)
if ( line != NULL )
wprintf ( L "%ls\n" , line )
free ( myString );
wcscpy ( myString , HELLO_STRING );
printWLine ( myString );
void printWLine (const wchar_t * line)
if ( line != NULL )
wprintf ( L "%ls\n" , line )
free ( myString );
1
------------------------------
306745 112813/CWE761_Free_Pointer_Not_at_Start_of_Buffer__wchar_t_connect_socket_07.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 ) 92
void CWE761_Free_Pointer_Not_at_Start_of_Buffer__wchar_t_connect_socket_07_bad()
wchar_t * data ;
data = ( wchar_t * ) malloc ( 100 * sizeof ( wchar_t ) );
data [ 0 ] = L '\0'
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
300019 122325/CWE78_OS_Command_Injection__wchar_t_listen_socket_execlp_15.c recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 ) 117
void CWE78_OS_Command_Injection__wchar_t_listen_socket_execlp_15_bad()
wchar_t * data ;
wchar_t dataBuffer [ 100 ] = L ""
data = dataBuffer;
switch ( 6 )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
301625 151549/aviobuf.c filepath = ( char * ) malloc ( size_filepath * sizeof ( char ) ) 75
void stonesoup_setup_printf_context()
ss_tc_root = getenv ( "SS_TC_ROOT" );
if ( ss_tc_root != NULL )
size_dirpath = strlen ( ss_tc_root ) + strlen ( "testData" ) + 2;
dirpath = ( char * ) malloc ( size_dirpath * sizeof ( char ) );
if ( dirpath != NULL )
sprintf ( dirpath , "%s/%s" , ss_tc_root , "testData" );
retval = 0;
if ( stat ( dirpath , & st ) == - 1 )
retval = mkdir ( dirpath , 0700 );
if ( retval == 0 )
size_filepath = strlen ( dirpath ) + strlen ( "logfile.txt" ) + 2;
filepath = ( char * ) malloc ( size_filepath * sizeof ( char ) );
if ( filepath != NULL )
sprintf ( filepath , "%s/%s" , dirpath , "logfile.txt" );
stonesoup_printf_context = fopen ( filepath , "w" );
free ( filepath );
if ( stonesoup_printf_context == NULL )
0
------------------------------
314141 103122/CWE427_Uncontrolled_Search_Path_Element__wchar_t_connect_socket_43.cpp recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 250 - dataLen - 1 ) , 0 ) 92
void bad()
wchar_t * data ;
wchar_t dataBuffer [ 250 ] = L "PATH="
data = dataBuffer;
badSource ( data );
static void badSource(wchar_t * &data)
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 250 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
310078 150626/error.c stonesoup_arr [ i ] = stonesoupData -> qsize - i 252
void *to1337(void *data)
struct stonesoup_data * stonesoupData = ( struct stonesoup_data * ) data ;
int * stonesoup_arr ;
stonesoup_arr = malloc ( sizeof ( int ) * stonesoupData -> qsize );
if ( stonesoup_arr != NULL )
for (i = 0; i < stonesoupData->qsize; i++)
stonesoup_arr [ i ] = stonesoupData -> qsize - i;
qsort ( stonesoup_arr , stonesoupData -> qsize , sizeof ( int ) , & stonesoup_comp );
free ( stonesoup_arr );
while ( stonesoupData -> data [ i ] != '\0' )
switch ( stonesoupData -> data [ i ] )
temp = stonesoupData -> data [ i ];
temp_str [ i ] = temp;
i ++;
temp_str [ i ] = '\0';
stonesoupData -> data = temp_str;
tracepoint ( stonesoup_trace , variable_address , "stonesoupData->data" , stonesoupData -> data , "TRIGGER-STATE: UNSET" );
0
------------------------------
18597 CVE-2015-2716/Firefox_37.0b7_CVE_2015_2716_parser_expat_lib_xmlparse.c tem = ( BLOCK * ) pool -> mem -> malloc_fcn ( offsetof ( BLOCK , s ) + blockSize * sizeof ( XML_Char ) ) 6275
static enum XML_Error
entityValueInitProcessor(XML_Parser
const char
const char
const char **nextPtr)
int tok ;
const char * start = s ;
const char * next = start ;
tok = XmlPrologTok ( encoding , start , end , & next );
if ( tok <= 0 )
if ( tok == XML_TOK_XML_DECL )
enum XML_Error result ;
result = processXmlDecl ( parser , 0 , start , next );
if ( result != XML_ERROR_NONE )
switch ( ps_parsing )
* nextPtr = next;
return entityValueProcessor ( parser , next , end , nextPtr ) ;
if ( tok == XML_TOK_BOM && next == end && ! ps_finalBuffer )
start = next;
static enum XML_Error
entityValueProcessor(XML_Parser
const char
const char
const char **nextPtr)
const char * start = s ;
const char * next = s ;
const ENCODING * enc = encoding ;
int tok ;
tok = XmlPrologTok ( enc , start , end , & next );
if ( tok <= 0 )
if ( ! ps_finalBuffer && tok != XML_TOK_INVALID )
switch ( tok )
return storeEntityValue ( parser , enc , s , end ) ;
start = next;
static enum
storeEntityValue(XML_Parser
const ENCODING
const char
const char *entityTextEnd)
DTD * const dtd = _dtd
STRING_POOL * pool = & ( dtd -> entityValuePool ) ;
if ( ! pool -> blocks )
if ( ! poolGrow ( pool ) )
const char * next ;
int tok = XmlEntityValueTok ( enc , entityTextPtr , entityTextEnd , & next ) ;
switch ( tok )
if ( isParamEntity || enc != encoding )
const XML_Char * name ;
ENTITY * entity ;
name = poolStoreString ( & tempPool , enc , entityTextPtr + enc -> minBytesPerChar , next - enc -> minBytesPerChar );
if ( ! name )
entity = ( ENTITY * ) lookup ( & dtd -> paramEntities , name , 0 );
if ( ! entity )
if ( entity -> open )
if ( entity -> systemId )
if ( externalEntityRefHandler )
entity -> open = XML_TRUE;
if ( ! externalEntityRefHandler ( externalEntityRefHandlerArg , 0 , entity -> base , entity -> systemId , entity -> publicId ) )
entity -> open = XML_FALSE;
entity -> open = XML_TRUE;
result = storeEntityValue ( parser , internalEncoding , ( char * ) entity -> textPtr , ( char * ) ( entity -> textPtr + entity -> textLen ) );
entity -> open = XML_FALSE;
if ( result )
if ( ! poolAppend ( pool , enc , entityTextPtr , next ) )
next = entityTextPtr + enc -> minBytesPerChar;
if ( pool -> end == pool -> ptr && ! poolGrow ( pool ) )
* ( pool -> ptr ) ++ = 0xA;
XML_Char buf [ XML_ENCODE_MAX ] ;
int i ;
int n = XmlCharRefNumber ( enc , entityTextPtr ) ;
if ( n < 0 )
n = XmlEncode ( n , ( ICHAR * ) buf );
if ( ! n )
for (i = 0; i < n; i++)
if ( pool -> end == pool -> ptr && ! poolGrow ( pool ) )
* ( pool -> ptr ) ++ = buf [ i ];
entityTextPtr = next;
static XML_Bool
poolGrow(STRING_POOL *pool)
if ( pool -> freeBlocks )
if ( pool -> start == 0 )
if ( pool -> end - pool -> start < pool -> freeBlocks -> size )
if ( pool -> blocks && pool -> start == pool -> blocks -> s )
BLOCK * tem ;
int blockSize = ( int ) ( pool -> end - pool -> start ) ;
if ( blockSize < INIT_BLOCK_SIZE )
blockSize = INIT_BLOCK_SIZE;
blockSize *= 2;
tem = ( BLOCK * ) pool -> mem -> malloc_fcn ( offsetof ( BLOCK , s ) + blockSize * sizeof ( XML_Char ) );
if ( ! tem )
tem -> size = blockSize;
tem -> next = pool -> blocks;
pool -> blocks = tem;
if ( pool -> ptr != pool -> start )
memcpy ( tem -> s , pool -> start , ( pool -> ptr - pool -> start ) * sizeof ( XML_Char ) );
pool -> ptr = tem -> s + ( pool -> ptr - pool -> start );
pool -> start = tem -> s;
pool -> end = tem -> s + blockSize;
0
------------------------------
16548 CVE-2014-1508/CVE_2014_1508_PATCHED_nsDisplayNotation__Paint.c gfxFloat h = H * f ; 51
void CVE_2014_1508_PATCHED_nsDisplayNotation::Paint(nsDisplayListBuilder*
nsRenderingContext* aCtx)
nsPresContext * presContext = mFrame -> PresContext ( ) ;
gfxRect rect = presContext -> AppUnitsToGfxUnits ( mRect + ToReferenceFrame ( ) ) ;
gfxFloat e = presContext -> AppUnitsToGfxUnits ( mThickness ) ;
switch ( mType )
gfxFloat W = rect . Width ( ) ;
gfxFloat H = rect . Height ( ) ;
gfxFloat l = sqrt ( W * W + H * H ) ;
gfxFloat f = gfxFloat ( kArrowHeadSize ) * e / l ;
gfxFloat h = H * f ;
0
------------------------------
298349 94962/CWE369_Divide_by_Zero__int_connect_socket_divide_01.c printIntLine ( 100 / data ) 190
static void goodB2G()
int data ;
data = - 1;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
char inputBuffer [ CHAR_ARRAY_SIZE ] ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
inputBuffer [ recvResult ] = '\0';
data = atoi ( inputBuffer );
while ( 0 )
if ( data != 0 )
printIntLine ( 100 / data );
0
------------------------------
302666 79122/CWE134_Uncontrolled_Format_String__char_connect_socket_fprintf_41.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 94
void CWE134_Uncontrolled_Format_String__char_connect_socket_fprintf_41_bad()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
badSink ( data );
static void badSink(char * data)
fprintf ( stdout , data );
1
------------------------------
305278 103078/CWE427_Uncontrolled_Search_Path_Element__char_listen_socket_52a.c recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 250 - dataLen - 1 ) , 0 ) 103
void CWE427_Uncontrolled_Search_Path_Element__char_listen_socket_52_bad()
char * data ;
char dataBuffer [ 250 ] = "PATH=" ;
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 250 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
CWE427_Uncontrolled_Search_Path_Element__char_listen_socket_52b_badSink ( data );
void CWE427_Uncontrolled_Search_Path_Element__char_listen_socket_52b_badSink(char * data)
CWE427_Uncontrolled_Search_Path_Element__char_listen_socket_52c_badSink ( data );
void CWE427_Uncontrolled_Search_Path_Element__char_listen_socket_52c_badSink(char * data)
PUTENV ( data );
0
------------------------------
298043 94098/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_connect_socket_01.c recvResult = recv ( connectSocket , ( char * ) ( password + passwordLen ) , ( 100 - passwordLen - 1 ) * sizeof ( char ) , 0 ) 70
void CWE319_Cleartext_Tx_Sensitive_Info__w32_char_connect_socket_01_bad()
char * password ;
char passwordBuffer [ 100 ] = "" ;
password = passwordBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t passwordLen = strlen ( password ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( password + passwordLen ) , ( 100 - passwordLen - 1 ) * sizeof ( char ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
password [ passwordLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( password , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( password , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
if ( LogonUserA ( username , domain , password , LOGON32_LOGON_NETWORK , LOGON32_PROVIDER_DEFAULT , & pHandle ) != 0 )
1
------------------------------
17233 CVE-2013-7024/CVE_2013_7024_VULN_jpeg2000_decode_tile.c nb_precincts = rlevel -> num_precincts_x * rlevel -> num_precincts_y 30
static int CVE_2013_7024_VULN_jpeg2000_decode_tile(Jpeg2000DecoderContext *s, Jpeg2000Tile
AVFrame *picture)
int compno , reslevelno , bandno ;
for (compno = 0; compno < s->ncomponents; compno++)
Jpeg2000Component * comp = tile -> comp + compno ;
Jpeg2000CodingStyle * codsty = tile -> codsty + compno ;
for (reslevelno = 0; reslevelno < codsty->nreslevels2decode; reslevelno++)
Jpeg2000ResLevel * rlevel = comp -> reslevel + reslevelno ;
for (bandno = 0; bandno < rlevel->nbands; bandno++)
int nb_precincts , precno ;
Jpeg2000Band * band = rlevel -> band + bandno ;
if ( band -> coord [ 0 ] [ 0 ] == band -> coord [ 0 ] [ 1 ] || band -> coord [ 1 ] [ 0 ] == band -> coord [ 1 ] [ 1 ] )
nb_precincts = rlevel -> num_precincts_x * rlevel -> num_precincts_y;
0
------------------------------
18886 CVE-2015-2716/Firefox_37.0b7_CVE_2015_2716_parser_expat_lib_xmlparse.c pool -> end = pool -> start + pool -> blocks -> size 6238
static enum
appendAttributeValue(XML_Parser parser, const ENCODING *enc, XML_Bool
const char *ptr, const char
STRING_POOL *pool)
DTD * const dtd = _dtd
const char * next ;
int tok = XmlAttributeValueTok ( enc , ptr , end , & next ) ;
switch ( tok )
XML_Char buf [ XML_ENCODE_MAX ] ;
int i ;
int n = XmlCharRefNumber ( enc , ptr ) ;
if ( n < 0 )
if ( ! isCdata && n == 0x20 && ( poolLength ( pool ) == 0 || poolLastChar ( pool ) == 0x20 ) )
n = XmlEncode ( n , ( ICHAR * ) buf );
if ( ! n )
for (i = 0; i < n; i++)
if ( ! poolAppendChar ( pool , buf [ i ] ) )
if ( ! poolAppend ( pool , enc , ptr , next ) )
next = ptr + enc -> minBytesPerChar;
if ( ! isCdata && ( poolLength ( pool ) == 0 || poolLastChar ( pool ) == 0x20 ) )
if ( ! poolAppendChar ( pool , 0x20 ) )
const XML_Char * name ;
ENTITY * entity ;
char checkEntityDecl ;
XML_Char ch = ( XML_Char ) XmlPredefinedEntityName ( enc , ptr + enc -> minBytesPerChar , next - enc -> minBytesPerChar ) ;
if ( ch )
if ( ! poolAppendChar ( pool , ch ) )
name = poolStoreString ( & temp2Pool , enc , ptr + enc -> minBytesPerChar , next - enc -> minBytesPerChar );
if ( ! name )
entity = ( ENTITY * ) lookup ( & dtd -> generalEntities , name , 0 );
if ( pool == & dtd -> pool )
checkEntityDecl = ! dtd -> hasParamEntityRefs || dtd -> standalone;
if ( checkEntityDecl )
if ( ! entity )
if ( ! entity -> is_internal )
if ( ! entity )
if ( entity -> open )
if ( entity -> notation )
if ( ! entity -> textPtr )
enum XML_Error result ;
const XML_Char * textEnd = entity -> textPtr + entity -> textLen ;
entity -> open = XML_TRUE;
result = appendAttributeValue ( parser , internalEncoding , isCdata , ( char * ) entity -> textPtr , ( char * ) textEnd , pool );
entity -> open = XML_FALSE;
if ( result )
ptr = next;
static enum
appendAttributeValue(XML_Parser parser, const ENCODING *enc, XML_Bool
const char *ptr, const char
STRING_POOL *pool)
DTD * const dtd = _dtd
const char * next ;
int tok = XmlAttributeValueTok ( enc , ptr , end , & next ) ;
switch ( tok )
XML_Char buf [ XML_ENCODE_MAX ] ;
int i ;
int n = XmlCharRefNumber ( enc , ptr ) ;
if ( n < 0 )
if ( ! isCdata && n == 0x20 && ( poolLength ( pool ) == 0 || poolLastChar ( pool ) == 0x20 ) )
n = XmlEncode ( n , ( ICHAR * ) buf );
if ( ! n )
if ( ! poolAppendChar ( pool , buf [ i ] ) )
if ( ! poolAppend ( pool , enc , ptr , next ) )
next = ptr + enc -> minBytesPerChar;
if ( ! isCdata && ( poolLength ( pool ) == 0 || poolLastChar ( pool ) == 0x20 ) )
if ( ! poolAppendChar ( pool , 0x20 ) )
const XML_Char * name ;
ENTITY * entity ;
char checkEntityDecl ;
XML_Char ch = ( XML_Char ) XmlPredefinedEntityName ( enc , ptr + enc -> minBytesPerChar , next - enc -> minBytesPerChar ) ;
if ( ch )
if ( ! poolAppendChar ( pool , ch ) )
name = poolStoreString ( & temp2Pool , enc , ptr + enc -> minBytesPerChar , next - enc -> minBytesPerChar );
if ( ! name )
entity = ( ENTITY * ) lookup ( & dtd -> generalEntities , name , 0 );
if ( pool == & dtd -> pool )
checkEntityDecl = ! dtd -> hasParamEntityRefs || dtd -> standalone;
if ( checkEntityDecl )
if ( ! entity )
if ( ! entity -> is_internal )
if ( ! entity )
if ( entity -> open )
if ( entity -> notation )
if ( ! entity -> textPtr )
enum XML_Error result ;
const XML_Char * textEnd = entity -> textPtr + entity -> textLen ;
entity -> open = XML_TRUE;
result = appendAttributeValue ( parser , internalEncoding , isCdata , ( char * ) entity -> textPtr , ( char * ) textEnd , pool );
entity -> open = XML_FALSE;
if ( result )
ptr = next;
static XML_Char
poolStoreString(STRING_POOL *pool, const ENCODING
const char *ptr, const char *end)
if ( ! poolAppend ( pool , enc , ptr , end ) )
if ( pool -> ptr == pool -> end && ! poolGrow ( pool ) )
static XML_Bool
poolGrow(STRING_POOL *pool)
if ( pool -> freeBlocks )
if ( pool -> start == 0 )
pool -> blocks = pool -> freeBlocks;
pool -> freeBlocks = pool -> freeBlocks -> next;
pool -> blocks -> next = NULL;
pool -> start = pool -> blocks -> s;
pool -> end = pool -> start + pool -> blocks -> size;
pool -> ptr = pool -> start;
0
------------------------------
308590 117351/CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_fscanf_54e.c myString = ( wchar_t * ) malloc ( data * sizeof ( wchar_t ) ) 87
void CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_fscanf_54b_goodB2GSink(size_t data)
CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_fscanf_54c_goodB2GSink ( data );
void CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_fscanf_54c_goodB2GSink(size_t data)
CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_fscanf_54d_goodB2GSink ( data );
void CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_fscanf_54d_goodB2GSink(size_t data)
CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_fscanf_54e_goodB2GSink ( data );
void CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_fscanf_54e_goodB2GSink(size_t data)
wchar_t * myString ;
if ( data > wcslen ( HELLO_STRING ) && data < 100 )
myString = ( wchar_t * ) malloc ( data * sizeof ( wchar_t ) );
wcscpy ( myString , HELLO_STRING );
printWLine ( myString );
void printWLine (const wchar_t * line)
if ( line != NULL )
wprintf ( L "%ls\n" , line )
free ( myString );
0
------------------------------
298073 95078/CWE369_Divide_by_Zero__int_fgets_divide_31.c printIntLine ( 100 / data ) 46
void CWE369_Divide_by_Zero__int_fgets_divide_31_bad()
int data ;
data = - 1;
char inputBuffer [ CHAR_ARRAY_SIZE ] = "" ;
if ( fgets ( inputBuffer , CHAR_ARRAY_SIZE , stdin ) != NULL )
data = atoi ( inputBuffer );
int dataCopy = data ;
int data = dataCopy ;
printIntLine ( 100 / data );
1
------------------------------
303036 81740/CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_printf_03.c recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 ) 197
static void goodB2G1()
wchar_t * data ;
wchar_t dataBuffer [ 100 ] = L ""
data = dataBuffer;
if ( 5 == 5 )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
313040 89743/CWE23_Relative_Path_Traversal__char_connect_socket_open_22b.cpp recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ) 96
void bad()
char * data ;
char dataBuffer [ FILENAME_MAX ] = BASEPATH ;
data = dataBuffer;
data = badSource ( data );
char * badSource(char * data)
if ( badGlobal )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
return data ;
0
------------------------------
314237 96710/CWE36_Absolute_Path_Traversal__char_listen_socket_w32CreateFile_31.cpp recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ) 99
void bad()
char * data ;
char dataBuffer [ FILENAME_MAX ] = "" ;
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
char * dataCopy = data ;
char * data = dataCopy ;
hFile = CreateFileA ( data , ( GENERIC_WRITE | GENERIC_READ ) , 0 , NULL , OPEN_ALWAYS , FILE_ATTRIBUTE_NORMAL , NULL );
if ( hFile != INVALID_HANDLE_VALUE )
CloseHandle ( hFile );
1
------------------------------
312523 152495/oids.c subid_overflow = subids + n 1110
void oid_add_from_encoded(const char *name,const guint8 *oid,gint oid_len)
guint subids_len = oid_encoded2subid ( oid , oid_len , & subids ) ;
guint oid_encoded2subid(const guint8 *oid_bytes,gint oid_len,guint32 **subids_p)
gint i ;
guint n = 1 ;
guint32 * subids ;
guint32 * subid_overflow ;
for (i = 0; i < oid_len; i++)
if ( ! ( oid_bytes [ i ] & 0x0080 ) )
n ++;
* subids_p = subids = ( ep_alloc ( sizeof ( guint32 ) * n ) );
subid_overflow = subids + n;
if ( subids >= subid_overflow || subid > 0xffffffff )
0
------------------------------
301313 152361/mux.c codec -> block_align = codec -> channels * av_get_bits_per_sample ( codec -> codec_id ) >> 3 345
int avformat_write_header(AVFormatContext *s,AVDictionary **options)
if ( ret = init_muxer ( s , options ) )
static int init_muxer(AVFormatContext *s,AVDictionary **options)
int i ;
AVStream * st ;
AVOutputFormat * of = s -> oformat ;
if ( ( ret = av_opt_set_dict ( s , & tmp ) ) < 0 )
if ( s -> priv_data && s -> oformat -> priv_class && * ( ( const AVClass * * ) ( s -> priv_data ) ) == s -> oformat -> priv_class && ( ret = av_opt_set_dict ( s -> priv_data , & tmp ) ) < 0 )
if ( s -> nb_streams == 0 && ! ( of -> flags & 0x1000 ) )
for (i = 0; i < s -> nb_streams; i++)
st = s -> streams [ i ];
codec = st -> codec;
switch ( codec -> codec_type )
if ( codec -> sample_rate <= 0 )
if ( ! codec -> block_align )
codec -> block_align = codec -> channels * av_get_bits_per_sample ( codec -> codec_id ) >> 3;
if ( codec -> time_base . num <= 0 || codec -> time_base . den <= 0 )
if ( ( codec -> width <= 0 || codec -> height <= 0 ) && ! ( of -> flags & 0x0800 ) )
if ( av_cmp_q ( st -> sample_aspect_ratio , codec -> sample_aspect_ratio ) && ( ( av_q2d ( st -> sample_aspect_ratio ) - av_q2d ( codec -> sample_aspect_ratio ) >= 0 ? av_q2d ( st -> sample_aspect_ratio ) - av_q2d ( codec -> sample_aspect_ratio ) : - ( av_q2d ( st -> sample_aspect_ratio ) - av_q2d ( codec -> sample_aspect_ratio ) ) ) ) > 0.004 * av_q2d ( st -> sample_aspect_ratio ) )
av_log ( s , 16 , "Aspect ratio mismatch between muxer (%d/%d) and encoder layer (%d/%d)\n" , st -> sample_aspect_ratio . num , st -> sample_aspect_ratio . den , codec -> sample_aspect_ratio . num , codec -> sample_aspect_ratio . den );
if ( of -> codec_tag )
if ( codec -> codec_tag && ( codec -> codec_id ) == AV_CODEC_ID_RAWVIDEO && ( av_codec_get_tag ( of -> codec_tag , codec -> codec_id ) == 0 || av_codec_get_tag ( of -> codec_tag , codec -> codec_id ) == ( ( 'r' | 'a' << 8 | 'w' << 16 ) | ( ( unsigned int ) 32 ) << 24 ) ) && ! validate_codec_tag ( s , st ) )
static int validate_codec_tag(AVFormatContext *s,AVStream *st)
for (n = 0; s -> oformat -> codec_tag[n]; n++)
avctag = s -> oformat -> codec_tag [ n ];
while ( ( avctag -> id ) != AV_CODEC_ID_NONE )
if ( avpriv_toupper4 ( avctag -> tag ) == avpriv_toupper4 ( st -> codec -> codec_tag ) )
id = avctag -> id;
if ( id == ( st -> codec -> codec_id ) )
if ( ( avctag -> id ) == ( st -> codec -> codec_id ) )
tag = avctag -> tag;
avctag ++;
if ( id != AV_CODEC_ID_NONE )
if ( tag && st -> codec -> strict_std_compliance >= 0 )
codec -> codec_tag = 0;
if ( codec -> codec_tag )
if ( ! validate_codec_tag ( s , st ) )
static int validate_codec_tag(AVFormatContext *s,AVStream *st)
avctag = s -> oformat -> codec_tag [ n ];
while ( ( avctag -> id ) != AV_CODEC_ID_NONE )
if ( avpriv_toupper4 ( avctag -> tag ) == avpriv_toupper4 ( st -> codec -> codec_tag ) )
id = avctag -> id;
if ( id == ( st -> codec -> codec_id ) )
if ( ( avctag -> id ) == ( st -> codec -> codec_id ) )
tag = avctag -> tag;
avctag ++;
if ( id != AV_CODEC_ID_NONE )
if ( tag && st -> codec -> strict_std_compliance >= 0 )
av_get_codec_tag_string ( tagbuf , sizeof ( tagbuf ) , codec -> codec_tag );
av_get_codec_tag_string ( cortag , sizeof ( cortag ) , av_codec_get_tag ( s -> oformat -> codec_tag , codec -> codec_id ) );
av_log ( s , 16 , "Tag %s/0x%08x incompatible with output codec id '%d' (%s)\n" , tagbuf , codec -> codec_tag , codec -> codec_id , cortag );
codec -> codec_tag = av_codec_get_tag ( of -> codec_tag , codec -> codec_id );
if ( of -> flags & 0x0040 && ! ( codec -> flags & 0x00400000 ) )
0
------------------------------
307663 120035/CWE78_OS_Command_Injection__char_listen_socket_system_45.c recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 119
void CWE78_OS_Command_Injection__char_listen_socket_system_45_bad()
char * data ;
char data_buf [ 100 ] = FULL_COMMAND ;
data = data_buf;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
CWE78_OS_Command_Injection__char_listen_socket_system_45_badData = data;
0
------------------------------
308382 117338/CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_fscanf_22b.c myString = ( wchar_t * ) malloc ( data * sizeof ( wchar_t ) ) 82
static void goodB2G1()
size_t data ;
data = 0;
CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_fscanf_22_goodB2G1Sink ( data );
void CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_fscanf_22_goodB2G1Sink(size_t data)
if ( CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_fscanf_22_goodB2G1Global )
wchar_t * myString ;
if ( data > wcslen ( HELLO_STRING ) && data < 100 )
myString = ( wchar_t * ) malloc ( data * sizeof ( wchar_t ) );
wcscpy ( myString , HELLO_STRING );
printWLine ( myString );
void printWLine (const wchar_t * line)
if ( line != NULL )
wprintf ( L "%ls\n" , line )
free ( myString );
0
------------------------------
16603 CVE-2014-8545/CVE_2014_8545_PATCHED_decode_frame.c s -> row_size = ( avctx -> width * s -> bits_per_pixel + 7 ) >> 3 109
static int CVE_2014_8545_PATCHED_decode_frame(AVCodecContext
void *data, int
AVPacket *avpkt)
PNGDecContext * const s = avctx -> priv_data
AVFrame * p ;
uint32_t tag , length ;
int64_t sig ;
int ret ;
p = s -> picture . f;
sig = bytestream2_get_be64 ( & s -> gb );
if ( sig != PNGSIG && sig != MNGSIG )
s -> y = s -> state = 0;
s -> zstream . zalloc = ff_png_zalloc;
s -> zstream . zfree = ff_png_zfree;
s -> zstream . opaque = NULL;
ret = inflateInit ( & s -> zstream );
if ( ret != Z_OK )
if ( bytestream2_get_bytes_left ( & s -> gb ) <= 0 )
length = bytestream2_get_be32 ( & s -> gb );
if ( length > 0x7fffffff || length > bytestream2_get_bytes_left ( & s -> gb ) )
if ( length != 13 )
s -> width = bytestream2_get_be32 ( & s -> gb );
s -> height = bytestream2_get_be32 ( & s -> gb );
if ( av_image_check_size ( s -> width , s -> height , 0 , avctx ) )
s -> bit_depth = bytestream2_get_byte ( & s -> gb );
s -> color_type = bytestream2_get_byte ( & s -> gb );
s -> compression_type = bytestream2_get_byte ( & s -> gb );
s -> filter_type = bytestream2_get_byte ( & s -> gb );
s -> interlace_type = bytestream2_get_byte ( & s -> gb );
s -> state |= PNG_IHDR;
if ( s -> state & PNG_IDAT )
avctx -> sample_aspect_ratio . num = bytestream2_get_be32 ( & s -> gb );
avctx -> sample_aspect_ratio . den = bytestream2_get_be32 ( & s -> gb );
if ( avctx -> sample_aspect_ratio . num < 0 || avctx -> sample_aspect_ratio . den < 0 )
avctx -> sample_aspect_ratio = ( AVRational ) 0 , 1
if ( ! ( s -> state & PNG_IHDR ) )
if ( ! ( s -> state & PNG_IDAT ) )
avctx -> width = s -> width;
avctx -> height = s -> height;
s -> channels = ff_png_get_nb_channels ( s -> color_type );
s -> bits_per_pixel = s -> bit_depth * s -> channels;
s -> bpp = ( s -> bits_per_pixel + 7 ) >> 3;
s -> row_size = ( avctx -> width * s -> bits_per_pixel + 7 ) >> 3;
if ( ( s -> bit_depth == 2 || s -> bit_depth == 4 || s -> bit_depth == 8 ) && s -> color_type == PNG_COLOR_TYPE_RGB )
if ( ( s -> bit_depth == 2 || s -> bit_depth == 4 || s -> bit_depth == 8 ) && s -> color_type == PNG_COLOR_TYPE_RGB_ALPHA )
if ( ( s -> bit_depth == 2 || s -> bit_depth == 4 || s -> bit_depth == 8 ) && s -> color_type == PNG_COLOR_TYPE_GRAY )
if ( s -> bit_depth == 16 && s -> color_type == PNG_COLOR_TYPE_GRAY )
if ( s -> bit_depth == 16 && s -> color_type == PNG_COLOR_TYPE_RGB )
if ( s -> bit_depth == 16 && s -> color_type == PNG_COLOR_TYPE_RGB_ALPHA )
if ( ( s -> bits_per_pixel == 1 || s -> bits_per_pixel == 2 || s -> bits_per_pixel == 4 || s -> bits_per_pixel == 8 ) && s -> color_type == PNG_COLOR_TYPE_PALETTE )
if ( s -> bit_depth == 1 && s -> bits_per_pixel == 1 )
if ( s -> bit_depth == 8 && s -> color_type == PNG_COLOR_TYPE_GRAY_ALPHA )
if ( s -> bit_depth == 16 && s -> color_type == PNG_COLOR_TYPE_GRAY_ALPHA )
avctx -> pix_fmt = AV_PIX_FMT_YA16BE;
if ( ff_thread_get_buffer ( avctx , & s -> picture , AV_GET_BUFFER_FLAG_REF ) < 0 )
p -> pict_type = AV_PICTURE_TYPE_I;
p -> key_frame = 1;
p -> interlaced_frame = ! ! s -> interlace_type;
if ( ! s -> interlace_type )
s -> crow_size = s -> row_size + 1;
s -> pass = 0;
s -> pass_row_size = ff_png_pass_row_size ( s -> pass , s -> bits_per_pixel , s -> width );
s -> crow_size = s -> pass_row_size + 1;
s -> image_buf = p -> data [ 0 ];
s -> image_linesize = p -> linesize [ 0 ];
if ( ! s -> last_row )
if ( s -> interlace_type || s -> color_type == PNG_COLOR_TYPE_RGB_ALPHA )
if ( ! s -> tmp_row )
if ( ! s -> buffer )
s -> crow_buf = s -> buffer + 15;
s -> zstream . avail_out = s -> crow_size;
s -> zstream . next_out = s -> crow_buf;
s -> state |= PNG_IDAT;
if ( png_decode_idat ( s , length ) < 0 )
0
------------------------------
313582 89716/CWE23_Relative_Path_Traversal__char_connect_socket_ofstream_68a.cpp recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ) 102
void bad()
char * data ;
char dataBuffer [ FILENAME_MAX ] = BASEPATH ;
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
CWE23_Relative_Path_Traversal__char_connect_socket_ofstream_68_badData = data;
0
------------------------------
308481 117184/CWE789_Uncontrolled_Mem_Alloc__malloc_char_rand_10.c myString = ( char * ) malloc ( data * sizeof ( char ) ) 47
void CWE789_Uncontrolled_Mem_Alloc__malloc_char_rand_10_bad()
size_t data ;
data = 0;
if ( globalTrue )
data = rand ( );
if ( globalTrue )
char * myString ;
if ( data > strlen ( HELLO_STRING ) )
myString = ( char * ) malloc ( data * sizeof ( char ) );
strcpy ( myString , HELLO_STRING );
printLine ( myString );
void printLine (const char * line)
if ( line != NULL )
printf ( "%s\n" , line );
free ( myString );
1
------------------------------
310266 151639/aviobuf.c s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_ptr - s -> checksum_ptr ) ) ) 176
void avio_wl64(AVIOContext *s,uint64_t val)
avio_wl32 ( s , ( ( uint32_t ) ( val & 0xffffffff ) ) );
void avio_wl32(AVIOContext *s,unsigned int val)
avio_w8 ( s , ( ( uint8_t ) val ) );
void avio_w8(AVIOContext *s,int b)
* ( s -> buf_ptr ++ ) = b;
if ( s -> buf_ptr >= s -> buf_end )
flush_buffer ( s );
static void flush_buffer(AVIOContext *s)
if ( s -> buf_ptr > s -> buffer )
if ( s -> update_checksum )
s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_ptr - s -> checksum_ptr ) ) );
s -> checksum_ptr = s -> buffer;
s -> buf_ptr = s -> buffer;
0
------------------------------
300925 152487/resowner.c dirpath = ( char * ) malloc ( size_dirpath * sizeof ( char ) ) 142
void stonesoup_setup_printf_context()
ss_tc_root = getenv ( "SS_TC_ROOT" );
if ( ss_tc_root != NULL )
size_dirpath = strlen ( ss_tc_root ) + strlen ( "testData" ) + 2;
dirpath = ( char * ) malloc ( size_dirpath * sizeof ( char ) );
if ( dirpath != NULL )
sprintf ( dirpath , "%s/%s" , ss_tc_root , "testData" );
if ( stat ( dirpath , & st ) == - 1 )
retval = mkdir ( dirpath , 0700 );
if ( retval == 0 )
size_filepath = strlen ( dirpath ) + strlen ( "logfile.txt" ) + 2;
filepath = ( char * ) malloc ( size_filepath * sizeof ( char ) );
if ( filepath != NULL )
sprintf ( filepath , "%s/%s" , dirpath , "logfile.txt" );
stonesoup_printf_context = fopen ( filepath , "w" );
free ( filepath );
free ( dirpath );
if ( stonesoup_printf_context == NULL )
0
------------------------------
306298 120068/CWE78_OS_Command_Injection__char_listen_socket_w32_execv_14.c recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 112
void CWE78_OS_Command_Injection__char_listen_socket_w32_execv_14_bad()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
if ( globalFive == 5 )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
0
------------------------------
305383 95456/CWE369_Divide_by_Zero__int_zero_divide_15.c printIntLine ( 100 / data ) 42
void CWE369_Divide_by_Zero__int_zero_divide_15_bad()
int data ;
data = - 1;
switch ( 6 )
data = 0;
switch ( 7 )
printIntLine ( 100 / data );
1
------------------------------
300445 152633/aviobuf.c s -> buf_end = s -> buffer + buffer_size 156
int avio_open_dyn_buf(AVIOContext **s)
return url_open_dyn_buf_internal ( s , 0 ) ;
static int url_open_dyn_buf_internal(AVIOContext **s,int max_packet_size)
DynBuffer * d ;
unsigned int io_buffer_size = ( max_packet_size ? max_packet_size : 1024 ) ;
if ( sizeof ( DynBuffer ) + io_buffer_size < io_buffer_size )
d = ( av_mallocz ( sizeof ( DynBuffer ) + io_buffer_size ) );
if ( ! d )
d -> io_buffer_size = io_buffer_size;
* s = avio_alloc_context ( d -> io_buffer , d -> io_buffer_size , 1 , d , ( ( void * ) 0 ) , ( max_packet_size ? dyn_packet_buf_write : dyn_buf_write ) , ( max_packet_size ? ( ( void * ) 0 ) : dyn_buf_seek ) );
AVIOContext *avio_alloc_context(unsigned char *buffer,int buffer_size,int write_flag,void *opaque,int (*read_packet)(void *, uint8_t *, int ),int (*write_packet)(void *, uint8_t *, int ),int64_t (*seek)(void *, int64_t , int ))
AVIOContext * s = ( av_mallocz ( sizeof ( AVIOContext ) ) ) ;
if ( ! s )
ffio_init_context ( s , buffer , buffer_size , write_flag , opaque , read_packet , write_packet , seek );
int ffio_init_context(AVIOContext *s,unsigned char *buffer,int buffer_size,int write_flag,void *opaque,int (*read_packet)(void *, uint8_t *, int ),int (*write_packet)(void *, uint8_t *, int ),int64_t (*seek)(void *, int64_t , int ))
s -> buffer = buffer;
s -> buffer_size = buffer_size;
s -> buf_ptr = buffer;
s -> opaque = opaque;
s -> direct = 0;
s -> write_packet = write_packet;
s -> read_packet = read_packet;
s -> seek = seek;
s -> pos = 0;
s -> must_flush = 0;
s -> eof_reached = 0;
s -> error = 0;
s -> seekable = 0x1;
s -> max_packet_size = 0;
s -> update_checksum = ( ( void * ) 0 );
if ( ! read_packet && ! write_flag )
s -> pos = buffer_size;
s -> buf_end = s -> buffer + buffer_size;
s -> read_pause = ( ( void * ) 0 );
s -> read_seek = ( ( void * ) 0 );
0
------------------------------
310423 151635/config.c apr_size_t len = ( name_end - name_start ) ; 694
svn_error_t *svn_config_get_server_setting_int(svn_config_t *cfg,const char *server_group,const char *option_name,apr_int64_t default_value,apr_int64_t *result_value,apr_pool_t *pool)
const char * tmp_value ;
tmp_value = svn_config_get_server_setting ( cfg , server_group , option_name , ( ( void * ) 0 ) );
const char *svn_config_get_server_setting(svn_config_t *cfg,const char *server_group,const char *option_name,const char *default_value)
const char * retval ;
if ( server_group )
svn_config_get ( cfg , & retval , server_group , option_name , retval );
void svn_config_get(svn_config_t *cfg,const char **valuep,const char *section,const char *option,const char *default_value)
if ( cfg )
cfg_section_t * sec ;
cfg_option_t * opt = find_option ( cfg , section , option , & sec ) ;
if ( opt != ( ( void * ) 0 ) )
if ( default_value && strchr ( default_value , 37 ) )
apr_pool_t * tmp_pool = svn_pool_create_ex ( cfg -> x_pool , ( ( void * ) 0 ) ) ;
const char * x_default ;
expand_option_value ( cfg , sec , default_value , & x_default , tmp_pool );
static void expand_option_value(svn_config_t *cfg,cfg_section_t *section,const char *opt_value,const char **opt_x_valuep,apr_pool_t *x_pool)
const char * parse_from = opt_value ;
const char * name_start ;
const char * name_end ;
while ( parse_from != ( ( void * ) 0 ) && ( * parse_from ) != '\0' && ( name_start = ( strstr ( parse_from , "%(" ) ) ) != ( ( void * ) 0 ) )
name_start += sizeof ( "%(" ) - 1;
if ( ( * name_start ) == '\0' )
name_end = ( strstr ( name_start , ")s" ) );
if ( name_end != ( ( void * ) 0 ) )
cfg_option_t * x_opt ;
apr_size_t len = ( name_end - name_start ) ;
char * name = apr_pstrmemdup ( x_pool , name_start , len ) ;
x_opt = find_option ( cfg , section -> name , name , ( ( void * ) 0 ) );
if ( x_opt != ( ( void * ) 0 ) )
make_string_from_option ( & cstring , cfg , section , x_opt , x_pool );
parse_from = name_end + ( sizeof ( ")s" ) - 1 );
parse_from = name_end + ( sizeof ( ")s" ) - 1 );
parse_from = ( ( void * ) 0 );
0
------------------------------
302392 80251/CWE134_Uncontrolled_Format_String__char_listen_socket_fprintf_02.c recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 98
void CWE134_Uncontrolled_Format_String__char_listen_socket_fprintf_02_bad()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
if ( 1 )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
fprintf ( stdout , data );
1
------------------------------
312882 90617/CWE23_Relative_Path_Traversal__char_listen_socket_ifstream_51a.cpp recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ) 107
void bad()
char * data ;
char dataBuffer [ FILENAME_MAX ] = BASEPATH ;
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
badSink ( data );
void badSink(char * data)
inputFile . open ( ( char * ) data );
0
------------------------------
309401 151493/utf.c invalid = ( data + len - last ) 647
svn_error_t *svn_utf_cstring_from_utf8_stringbuf(const char **dest,const svn_stringbuf_t *src,apr_pool_t *pool)
svn_error_t * svn_err__temp = svn_utf_stringbuf_from_utf8 ( & destbuf , src , pool ) ;
if ( svn_err__temp )
while ( 0 )
svn_error_t *svn_utf_stringbuf_from_utf8(svn_stringbuf_t **dest,const svn_stringbuf_t *src,apr_pool_t *pool)
xlate_handle_node_t * node ;
svn_error_t * err ;
svn_error_t * svn_err__temp = get_uton_xlate_handle_node ( & node , pool ) ;
static svn_error_t *get_uton_xlate_handle_node(xlate_handle_node_t **ret,apr_pool_t *pool)
return get_xlate_handle_node ( ret , ( assume_native_charset_is_utf8 ? SVN_APR_UTF8_CHARSET : ( ( const char * ) 1 ) ) , SVN_APR_UTF8_CHARSET , SVN_UTF_UTON_XLATE_HANDLE , pool ) ;
if ( svn_err__temp )
while ( 0 )
if ( node -> handle )
err = check_utf8 ( ( src -> data ) , src -> len , pool );
static svn_error_t *check_utf8(const char *data,apr_size_t len,apr_pool_t *pool)
if ( ! svn_utf__is_valid ( data , len ) )
return invalid_utf8 ( data , len , pool ) ;
static svn_error_t *invalid_utf8(const char *data,apr_size_t len,apr_pool_t *pool)
const char * last = svn_utf__last_valid ( data , len ) ;
size_t invalid ;
invalid = ( data + len - last );
if ( invalid > 4 )
for (i = 0; i < invalid; ++i)
0
------------------------------
298380 94106/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_connect_socket_09.c recvResult = recv ( connectSocket , ( char * ) ( password + passwordLen ) , ( 100 - passwordLen - 1 ) * sizeof ( char ) , 0 ) 72
void CWE319_Cleartext_Tx_Sensitive_Info__w32_char_connect_socket_09_bad()
char * password ;
char passwordBuffer [ 100 ] = "" ;
password = passwordBuffer;
if ( GLOBAL_CONST_TRUE )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t passwordLen = strlen ( password ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( password + passwordLen ) , ( 100 - passwordLen - 1 ) * sizeof ( char ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
password [ passwordLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( password , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( password , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
if ( LogonUserA ( username , domain , password , LOGON32_LOGON_NETWORK , LOGON32_PROVIDER_DEFAULT , & pHandle ) != 0 )
1
------------------------------
306788 117193/CWE789_Uncontrolled_Mem_Alloc__malloc_char_rand_21.c myString = ( char * ) malloc ( data * sizeof ( char ) ) 167
static void goodG2B()
size_t data ;
data = 0;
data = 20;
goodG2BSink ( data );
static void goodG2BSink(size_t data)
if ( goodG2BStatic )
char * myString ;
if ( data > strlen ( HELLO_STRING ) )
myString = ( char * ) malloc ( data * sizeof ( char ) );
strcpy ( myString , HELLO_STRING );
printLine ( myString );
void printLine (const char * line)
if ( line != NULL )
printf ( "%s\n" , line );
free ( myString );
0
------------------------------
298587 94212/CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_connect_socket_21.c recvResult = recv ( connectSocket , ( char * ) ( password + passwordLen ) , ( 100 - passwordLen - 1 ) * sizeof ( wchar_t ) , 0 ) 102
void CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_connect_socket_21_bad()
wchar_t * password ;
wchar_t passwordBuffer [ 100 ] = L ""
password = passwordBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t passwordLen = wcslen ( password ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( password + passwordLen ) , ( 100 - passwordLen - 1 ) * sizeof ( wchar_t ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
1
------------------------------
312005 152809/dfa.c work_mbls = check_matching_with_multibyte_ops ( d , s , ( * pp - buf_begin ) ) 3387
char *dfaexec(struct dfa *d,const char *begin,char *end,int allow_nl,size_t *count,int *backref)
state_num s ;
state_num s1 ;
const unsigned char * p ;
state_num * * trans ;
state_num * t ;
unsigned char eol = eolbyte ;
unsigned char saved_end ;
s = s1 = 0;
p = ( ( const unsigned char * ) begin );
trans = d -> trans;
saved_end = * ( ( unsigned char * ) end );
* end = eol;
if ( d -> mb_cur_max > 1 )
while ( ( t = trans [ s ] ) != ( ( void * ) 0 ) )
if ( p > buf_end )
s1 = s;
if ( s == 0 )
if ( ( ( char * ) p ) >= end )
if ( d -> states [ s ] . mbps . nelem == 0 )
s = t [ * ( p ++ ) ];
if ( backref )
* end = saved_end;
s = transit_state ( d , s , & p );
trans = d -> trans;
while ( ( t = trans [ s ] ) != ( ( void * ) 0 ) )
s1 = t [ * ( p ++ ) ];
if ( ( t = trans [ s1 ] ) == ( ( void * ) 0 ) )
state_num tmp = s ;
s = s1;
s1 = tmp;
s = t [ * ( p ++ ) ];
if ( s >= 0 && ( ( char * ) p ) <= end && d -> fails [ s ] )
if ( d -> success [ s ] & sbit [ * p ] )
s1 = s;
if ( d -> mb_cur_max > 1 )
s = transit_state ( d , s , & p );
trans = d -> trans;
s = d -> fails [ s ] [ * ( p ++ ) ];
if ( ( ( char * ) p ) > end )
if ( s >= 0 )
trans = d -> trans;
if ( p [ - 1 ] == eol && allow_nl )
s = d -> newlines [ s1 ];
s = 0;
static state_num transit_state(struct dfa *d,state_num s,const unsigned char **pp)
int mbclen ;
int maxlen = 0 ;
size_t i ;
int * match_lens = ( ( void * ) 0 ) ;
size_t nelem = d -> states [ s ] . mbps . nelem ;
position_set follows ;
if ( nelem > 0 )
match_lens = check_matching_with_multibyte_ops ( d , s , ( * pp - buf_begin ) );
for (i = 0; i < nelem; i++)
if ( match_lens [ i ] > maxlen )
maxlen = match_lens [ i ];
if ( nelem == 0 || maxlen == 0 )
transit_state_consume_1char ( d , s , pp , match_lens , & mbclen , & follows );
static status_transit_state transit_state_consume_1char(struct dfa *d,state_num s,const unsigned char **pp,int *match_lens,int *mbclen,position_set *pps)
int k ;
state_num s1 ;
state_num s2 ;
int * work_mbls ;
* mbclen = ( mblen_buf [ * pp - buf_begin ] == 0 ? 1 : mblen_buf [ * pp - buf_begin ] );
s1 = s;
for (k = 0; k <  *mbclen; k++)
s2 = s1;
rs = transit_state_singlebyte ( d , s2 , ( * pp ) ++ , & s1 );
if ( match_lens == ( ( void * ) 0 ) && d -> states [ s ] . mbps . nelem != 0 )
work_mbls = check_matching_with_multibyte_ops ( d , s , ( * pp - buf_begin ) );
if ( work_mbls [ i ] == * mbclen )
if ( match_lens == ( ( void * ) 0 ) && work_mbls != ( ( void * ) 0 ) )
free ( work_mbls );
0
------------------------------
309667 152709/tile-manager.c ntiles = tm -> ntile_rows * tm -> ntile_cols 261
Tile *tile_manager_get_at(TileManager *tm,gint tile_col,gint tile_row,gboolean wantread,gboolean wantwrite)
if ( tm != ( ( void * ) 0 ) )
while ( 0 )
if ( tile_col < 0 || tile_col >= tm -> ntile_cols || tile_row < 0 || tile_row >= tm -> ntile_rows )
return tile_manager_get ( tm , tile_row * tm -> ntile_cols + tile_col , wantread , wantwrite ) ;
Tile *tile_manager_get(TileManager *tm,gint tile_num,gboolean wantread,gboolean wantwrite)
gint ntiles ;
if ( tm != ( ( void * ) 0 ) )
while ( 0 )
ntiles = tm -> ntile_rows * tm -> ntile_cols;
if ( tile_num < 0 || tile_num >= ntiles )
0
------------------------------
298065 95728/CWE36_Absolute_Path_Traversal__char_connect_socket_open_83_bad.cpp recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ) 91
CWE36_Absolute_Path_Traversal__char_connect_socket_open_83_bad::CWE36_Absolute_Path_Traversal__char_connect_socket_open_83_bad(char * dataCopy)
data = dataCopy;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
0
------------------------------
304116 83361/CWE190_Integer_Overflow__int_fscanf_square_04.c int result = data * data ; 75
static void goodB2G1()
int data ;
data = 0;
if ( STATIC_CONST_FALSE )
if ( abs ( ( long ) data ) <= ( long ) sqrt ( ( double ) INT_MAX ) )
int result = data * data ;
printIntLine ( result );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
0
------------------------------
18376 CVE-2015-2710/Firefox_37.0b7_CVE_2015_2710_layout_svg_SVGTextFrame.cpp nscoord leftEdge = textRun -> GetAdvanceWidth ( frameOffset , runOffset - frameOffset , nullptr ) ; 1029

TextRenderedRun::GetClipEdges(nscoord& aLeftEdge, nscoord& aRightEdge) const
uint32_t contentLength = mFrame -> GetContentLength ( ) ;
if ( mTextFrameContentOffset == 0 && mTextFrameContentLength == contentLength )
gfxTextRun * textRun = mFrame -> GetTextRun ( nsTextFrame :: eInflated ) ;
uint32_t runOffset , runLength , frameOffset , frameLength ;
frameOffset = mFrame -> GetContentOffset ( );
nscoord leftEdge = textRun -> GetAdvanceWidth ( frameOffset , runOffset - frameOffset , nullptr ) ;
aRightEdge = leftEdge;
aLeftEdge = leftEdge;
0
------------------------------
312105 153760/aviobuf.c s -> buf_end = dst + len 516
unsigned int avio_rl24(AVIOContext *s)
unsigned int val ;
val = avio_rl16 ( s );
unsigned int avio_rl16(AVIOContext *s)
unsigned int val ;
val = ( avio_r8 ( s ) );
int avio_r8(AVIOContext *s)
if ( s -> buf_ptr >= s -> buf_end )
fill_buffer ( s );
static void fill_buffer(AVIOContext *s)
uint8_t * dst = ! s -> max_packet_size && s -> buf_end - s -> buffer < ( s -> buffer_size ) ? s -> buf_end : s -> buffer ;
int len = ( ( s -> buffer_size ) - ( dst - s -> buffer ) ) ;
int max_buffer_size = s -> max_packet_size ? s -> max_packet_size : 32768 ;
if ( ! s -> read_packet && s -> buf_ptr >= s -> buf_end )
s -> eof_reached = 1;
if ( s -> eof_reached )
if ( s -> update_checksum && dst == s -> buffer )
if ( s -> buf_end > s -> checksum_ptr )
s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_end - s -> checksum_ptr ) ) );
s -> checksum_ptr = s -> buffer;
if ( s -> read_packet && s -> buffer_size > max_buffer_size )
s -> checksum_ptr = dst = s -> buffer;
len = s -> buffer_size;
if ( s -> read_packet )
len = ( ( s -> read_packet ) ( s -> opaque , dst , len ) );
len = 0;
if ( len <= 0 )
s -> eof_reached = 1;
if ( len < 0 )
s -> error = len;
s -> pos += len;
s -> buf_ptr = dst;
s -> buf_end = dst + len;
s -> bytes_read += len;
0
------------------------------
309955 149547/oids.c * left = len - i 1177
void oid_both(guint oid_len,guint32 *subids,char **resolved_p,char **numeric_p)
* resolved_p = ( ( void * ) ( oid_resolved ( oid_len , subids ) ) );
const gchar *oid_resolved(guint32 num_subids,guint32 *subids)
oid_info_t * oid ;
if ( ! ( subids && * subids <= 2 ) )
oid = oid_get ( num_subids , subids , & matched , & left );
oid_info_t *oid_get(guint len,guint32 *subids,guint *matched,guint *left)
oid_info_t * curr_oid = & oid_root ;
guint i ;
if ( ! ( subids && * subids <= 2 ) )
for (i = 0; i < len; i++)
oid_info_t * next_oid = ( emem_tree_lookup32 ( ( curr_oid -> children ) , subids [ i ] ) ) ;
if ( next_oid )
curr_oid = next_oid;
* left = len - i;
0
------------------------------
307256 117206/CWE789_Uncontrolled_Mem_Alloc__malloc_char_rand_53d.c myString = ( char * ) malloc ( data * sizeof ( char ) ) 37
void CWE789_Uncontrolled_Mem_Alloc__malloc_char_rand_53_bad()
size_t data ;
data = 0;
data = rand ( );
CWE789_Uncontrolled_Mem_Alloc__malloc_char_rand_53b_badSink ( data );
void CWE789_Uncontrolled_Mem_Alloc__malloc_char_rand_53b_badSink(size_t data)
CWE789_Uncontrolled_Mem_Alloc__malloc_char_rand_53c_badSink ( data );
void CWE789_Uncontrolled_Mem_Alloc__malloc_char_rand_53c_badSink(size_t data)
CWE789_Uncontrolled_Mem_Alloc__malloc_char_rand_53d_badSink ( data );
void CWE789_Uncontrolled_Mem_Alloc__malloc_char_rand_53d_badSink(size_t data)
char * myString ;
if ( data > strlen ( HELLO_STRING ) )
myString = ( char * ) malloc ( data * sizeof ( char ) );
strcpy ( myString , HELLO_STRING );
printLine ( myString );
void printLine (const char * line)
if ( line != NULL )
printf ( "%s\n" , line );
free ( myString );
1
------------------------------
310555 148898/reassemble.c guint32 end_offset = fd -> offset + fd -> len ; 712
fragment_data
fragment_add_multiple_ok(tvbuff_t *tvb, const int offset, const packet_info
const guint32 id, GHashTable
const guint32 frag_offset, const guint32
const gboolean more_frags)
return fragment_add_common ( tvb , offset , pinfo , id , fragment_table , frag_offset , frag_data_len , more_frags , FALSE ) ;
static fragment_data
fragment_add_common(tvbuff_t *tvb, const int offset, const packet_info *pinfo, const guint32
GHashTable *fragment_table, const guint32
const guint32 frag_data_len, const gboolean
const gboolean check_already_added)
fragment_key key , * new_key ;
fragment_data * fd_head ;
fragment_data * fd_item ;
gboolean already_added = pinfo -> fd -> flags . visited ;
key . src = pinfo -> src;
key . dst = pinfo -> dst;
key . id = id;
fd_head = g_hash_table_lookup ( fragment_table , & key );
if ( strcmp ( pinfo -> current_proto , "DCERPC" ) == 0 )
if ( fd_head != NULL )
for(fd_item=fd_head->next;fd_item;fd_item=fd_item->next)
if ( ! already_added && check_already_added && fd_head != NULL )
if ( pinfo -> fd -> num <= fd_head -> frame )
for(fd_item=fd_head->next;fd_item;fd_item=fd_item->next)
if ( pinfo -> fd -> num == fd_item -> frame && frag_offset == fd_item -> offset )
already_added = TRUE;
if ( already_added )
if ( fd_head == NULL )
fd_head = new_head ( 0 );
static fragment_data *new_head(const guint32 flags)
fragment_data * fd_head ;
fd_head = g_slice_new0 ( fragment_data );
fd_head -> flags = flags;
return fd_head ;
if ( fragment_add_work ( fd_head , tvb , offset , pinfo , frag_offset , frag_data_len , more_frags ) )
static
fragment_add_work(fragment_data *fd_head, tvbuff_t *tvb, const int
const packet_info *pinfo, const guint32
const guint32 frag_data_len, const gboolean more_frags)
fragment_data * fd ;
fd = g_slice_new ( fragment_data );
fd -> next = NULL;
fd -> flags = 0;
fd -> frame = pinfo -> fd -> num;
if ( fd -> frame > fd_head -> frame )
fd_head -> frame = fd -> frame;
fd -> offset = frag_offset;
fd -> len = frag_data_len;
fd -> data = NULL;
if ( fd_head -> flags & FD_DEFRAGMENTED && ( frag_offset + frag_data_len ) >= fd_head -> datalen && fd_head -> flags & FD_PARTIAL_REASSEMBLY )
fd_head -> flags &= ~ ( FD_DEFRAGMENTED | FD_PARTIAL_REASSEMBLY | FD_DATALEN_SET );
fd_head -> flags &= ( ~FD_TOOLONGFRAGMENT ) & ( ~FD_MULTIPLETAILS );
fd_head -> datalen = 0;
fd_head -> reassembled_in = 0;
if ( ! more_frags )
if ( fd_head -> flags & FD_DATALEN_SET )
if ( fd_head -> datalen != ( fd -> offset + fd -> len ) )
fd -> flags |= FD_MULTIPLETAILS;
fd_head -> flags |= FD_MULTIPLETAILS;
fd_head -> datalen = fd -> offset + fd -> len;
fd_head -> flags |= FD_DATALEN_SET;
if ( fd_head -> flags & FD_DEFRAGMENTED )
guint32 end_offset = fd -> offset + fd -> len ;
if ( end_offset > fd_head -> datalen || end_offset < fd -> offset || end_offset < fd -> len )
1
------------------------------
16581 CVE-2012-4287/CVE_2012_4287_PATCHED_dissect_bson_document.c final_offset = offset + document_length 38
static
CVE_2012_4287_PATCHED_dissect_bson_document(tvbuff_t *tvb, packet_info *pinfo, guint offset, proto_tree *tree, int hf_mongo_doc, int nest_level)
gint32 document_length ;
guint final_offset ;
document_length = tvb_get_letohl ( tvb , offset );
if ( document_length == 5 )
final_offset = offset + document_length;
0
------------------------------
307570 120586/CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_execvp_04.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 ) 111
void CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_execvp_04_bad()
wchar_t * data ;
wchar_t dataBuffer [ 100 ] = L ""
data = dataBuffer;
if ( STATIC_CONST_TRUE )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
302877 82495/CWE190_Integer_Overflow__char_rand_square_02.c char result = data * data ; 67
static void goodB2G1()
char data ;
data = ' ';
if ( 1 )
data = ( char ) RAND32 ( );
if ( 0 )
if ( abs ( ( long ) data ) <= ( long ) sqrt ( ( double ) CHAR_MAX ) )
char result = data * data ;
printHexCharLine ( result );
void printHexCharLine (char charHex)
printf ( "%02x\n" , charHex );
0
------------------------------
312587 149789/eng_lib.c stonesoup_values = malloc ( stonesoup_len * sizeof ( char * ) ) 274
void ENGINE_cleanup()
char * * stonesoup_values ;
int stonesoup_len ;
int shippens_scrannels ;
char * overgreed_scuddawn [ 32 ] = { 0 } ;
char * trialist_rabkin ;
if ( __sync_bool_compare_and_swap ( & epistemological_whiskyfied , 0 , 1 ) )
if ( mkdir ( "/opt/stonesoup/workspace/lockDir" , 509U ) == 0 )
trialist_rabkin = getenv ( "SPLASHBOARD_SUBATTENUATE" );
if ( trialist_rabkin != 0 )
overgreed_scuddawn [ 16 ] = trialist_rabkin;
shippens_scrannels = 1;
circuitry_habenula = overgreed_scuddawn;
arborist_guadalcazarite = ( ( char * * ) ( ( ( unsigned long ) circuitry_habenula ) * shippens_scrannels * shippens_scrannels ) ) + 5;
pangenic_reverentness = ( ( char * ) ( arborist_guadalcazarite - 5 ) [ 16 ] );
stonesoup_len = strtol ( pangenic_reverentness , & stonesoup_endptr , 10 );
if ( stonesoup_len > 0 && stonesoup_len < 1000 )
stonesoup_values = malloc ( stonesoup_len * sizeof ( char * ) );
if ( stonesoup_values == 0 )
stonesoup_values [ stonesoup_i ] = 0;
for (stonesoup_i = 0; stonesoup_i < stonesoup_len; ++stonesoup_i)
stonesoup_values [ stonesoup_i ] = ( ( char * ) ( malloc ( ( strlen ( stonesoup_temp_str ) + 1 ) * sizeof ( char ) ) ) );
if ( stonesoup_values [ stonesoup_i ] == 0 )
strcpy ( stonesoup_values [ stonesoup_i ] , stonesoup_temp_str );
tracepoint ( stonesoup_trace , variable_buffer , "stonesoup_values[stonesoup_i]" , stonesoup_values [ stonesoup_i ] , "TRIGGER-STATE" );
fputs ( stonesoup_values [ stonesoup_i ] , stonesoup_temp );
stonesoup_printf ( stonesoup_values [ stonesoup_i ] );
void stonesoup_printf(char * format, ...)
va_start ( argptr , format );
vfprintf ( stonesoup_printf_context , format , argptr );
if ( stonesoup_values [ stonesoup_i ] != 0 )
free ( stonesoup_values [ stonesoup_i ] );
if ( stonesoup_values != 0 )
free ( stonesoup_values );
1
------------------------------
19071 CVE-2016-7466/qemu_2.3.0_CVE-2016-7466_hcd-xhci.c addr = intr -> er_start + TRB_SIZE * intr -> er_ep_idx 850
static void xhci_wakeup(USBPort *usbport)
XHCIState * xhci = usbport -> opaque ;
XHCIPort * port = xhci_lookup_port ( xhci , usbport ) ;
static XHCIPort *xhci_lookup_port(XHCIState *xhci, struct USBPort *uport)
int index ;
if ( ! uport -> dev )
return NULL ;
switch ( uport -> dev -> speed )
if ( xhci_get_flag ( xhci , XHCI_FLAG_SS_FIRST ) )
static bool xhci_get_flag(XHCIState *xhci, enum xhci_flags bit)
return xhci -> flags & ( 1 << bit ) ;
index = uport -> index + xhci -> numports_3;
index = uport -> index;
if ( xhci_get_flag ( xhci , XHCI_FLAG_SS_FIRST ) )
static bool xhci_get_flag(XHCIState *xhci, enum xhci_flags bit)
return xhci -> flags & ( 1 << bit ) ;
index = uport -> index;
index = uport -> index + xhci -> numports_2;
return NULL ;
return & xhci -> ports [ index ] ;
if ( get_field ( port -> portsc , PORTSC_PLS ) != PLS_U3 )
xhci_port_notify ( port , PORTSC_PLC );
static void xhci_port_notify(XHCIPort *port, uint32_t bits)
if ( ( port -> portsc & bits ) == bits )
port -> portsc |= bits;
if ( ! xhci_running ( port -> xhci ) )
xhci_event ( port -> xhci , & ev , 0 );
static void xhci_event(XHCIState *xhci, XHCIEvent *event, int v)
XHCIInterrupter * intr ;
dma_addr_t erdp ;
unsigned int dp_idx ;
if ( v >= xhci -> numintrs )
intr = & xhci -> intr [ v ];
if ( intr -> er_full )
erdp = xhci_addr64 ( intr -> erdp_low , intr -> erdp_high );
if ( erdp < intr -> er_start || erdp >= ( intr -> er_start + TRB_SIZE * intr -> er_size ) )
dp_idx = ( erdp - intr -> er_start ) / TRB_SIZE;
if ( ( intr -> er_ep_idx + 1 ) % intr -> er_size == dp_idx )
xhci_write_event ( xhci , & full );
static void xhci_write_event(XHCIState *xhci, XHCIEvent *event, int v)
XHCIInterrupter * intr = & xhci -> intr [ v ] ;
dma_addr_t addr ;
addr = intr -> er_start + TRB_SIZE * intr -> er_ep_idx;
pci_dma_write ( pci_dev , addr , & ev_trb , TRB_SIZE );
0
------------------------------
306201 117116/CWE789_Uncontrolled_Mem_Alloc__malloc_char_fscanf_65b.c myString = ( char * ) malloc ( data * sizeof ( char ) ) 87
void CWE789_Uncontrolled_Mem_Alloc__malloc_char_fscanf_65b_goodB2GSink(size_t data)
char * myString ;
if ( data > strlen ( HELLO_STRING ) && data < 100 )
myString = ( char * ) malloc ( data * sizeof ( char ) );
strcpy ( myString , HELLO_STRING );
printLine ( myString );
void printLine (const char * line)
if ( line != NULL )
printf ( "%s\n" , line );
free ( myString );
0
------------------------------
302638 80682/CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_vfprintf_01.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 ) 213
static void goodB2G()
wchar_t * data ;
wchar_t dataBuffer [ 100 ] = L ""
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
16801 CVE-2010-2537/CVE_2010_2537_PATCHED_btrfs_ioctl_clone.c trim = key . offset + datal - ( off + len ) 241
static noinline long CVE_2010_2537_PATCHED_btrfs_ioctl_clone(struct file *file, unsigned long
u64 off, u64 olen, u64 destoff)
struct inode * inode = fdentry ( file ) -> d_inode ;
struct btrfs_root * root = BTRFS_I ( inode ) -> root ;
struct file * src_file ;
struct inode * src ;
struct btrfs_trans_handle * trans ;
struct btrfs_path * path ;
struct extent_buffer * leaf ;
char * buf ;
struct btrfs_key key ;
u32 nritems ;
int slot ;
int ret ;
u64 len = olen ;
u64 bs = root -> fs_info -> sb -> s_blocksize ;
if ( ! ( file -> f_mode & FMODE_WRITE ) || ( file -> f_flags & O_APPEND ) )
ret = mnt_want_write ( file -> f_path . mnt );
if ( ret )
src_file = fget ( srcfd );
if ( ! src_file )
src = src_file -> f_dentry -> d_inode;
if ( src == inode )
if ( ! ( src_file -> f_mode & FMODE_READ ) )
if ( S_ISDIR ( src -> i_mode ) || S_ISDIR ( inode -> i_mode ) )
ret = - EXDEV;
if ( src -> i_sb != inode -> i_sb || BTRFS_I ( src ) -> root != root )
ret = - ENOMEM;
buf = vmalloc ( btrfs_level_size ( root , 0 ) );
if ( ! buf )
path = btrfs_alloc_path ( );
if ( ! path )
path -> reada = 2;
ret = - EINVAL;
if ( off + len > src -> i_size || off + len < off )
if ( len == 0 )
olen = len = src -> i_size - off;
if ( off + len == src -> i_size )
len = ( ( src -> i_size + bs - 1 ) & ~ ( bs - 1 ) ) - off;
if ( ( off & ( bs - 1 ) ) || ( ( off + len ) & ( bs - 1 ) ) )
trans = btrfs_start_transaction ( root , 1 );
key . objectid = src -> i_ino;
key . type = BTRFS_EXTENT_DATA_KEY;
key . offset = 0;
while ( 1 )
ret = btrfs_search_slot ( trans , root , & key , path , 0 , 0 );
if ( ret < 0 )
nritems = btrfs_header_nritems ( path -> nodes [ 0 ] );
if ( path -> slots [ 0 ] >= nritems )
ret = btrfs_next_leaf ( root , path );
if ( ret < 0 )
if ( ret > 0 )
leaf = path -> nodes [ 0 ];
slot = path -> slots [ 0 ];
if ( btrfs_key_type ( & key ) > BTRFS_EXTENT_DATA_KEY || key . objectid != src -> i_ino )
if ( btrfs_key_type ( & key ) == BTRFS_EXTENT_DATA_KEY )
struct btrfs_file_extent_item * extent ;
int type ;
u32 size ;
struct btrfs_key new_key ;
u64 datao = 0 , datal = 0 ;
u8 comp ;
size = btrfs_item_size_nr ( leaf , slot );
extent = btrfs_item_ptr ( leaf , slot
struct btrfs_file_extent_item )
comp = btrfs_file_extent_compression ( leaf , extent );
type = btrfs_file_extent_type ( leaf , extent );
if ( type == BTRFS_FILE_EXTENT_REG || type == BTRFS_FILE_EXTENT_PREALLOC )
datal = btrfs_file_extent_num_bytes ( leaf , extent );
if ( type == BTRFS_FILE_EXTENT_INLINE )
datal = btrfs_file_extent_ram_bytes ( leaf , extent );
if ( key . offset + datal < off || key . offset >= off + len )
memcpy ( & new_key , & key , sizeof ( new_key ) );
new_key . objectid = inode -> i_ino;
new_key . offset = key . offset + destoff - off;
if ( type == BTRFS_FILE_EXTENT_REG || type == BTRFS_FILE_EXTENT_PREALLOC )
ret = btrfs_insert_empty_item ( trans , root , path , & new_key , size );
if ( ret )
if ( type == BTRFS_FILE_EXTENT_INLINE )
u64 skip = 0 ;
u64 trim = 0 ;
if ( off > key . offset )
skip = off - key . offset;
new_key . offset += skip;
if ( key . offset + datal > off + len )
trim = key . offset + datal - ( off + len );
if ( comp && ( skip || trim ) )
size -= skip + trim;
ret = btrfs_insert_empty_item ( trans , root , path , & new_key , size );
if ( ret )
key . offset ++;
0
------------------------------
309038 117357/CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_fscanf_66b.c myString = ( wchar_t * ) malloc ( data * sizeof ( wchar_t ) ) 91
static void goodB2G()
size_t data ;
size_t dataArray [ 5 ] ;
data = 0;
dataArray [ 2 ] = data;
CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_fscanf_66b_goodB2GSink ( dataArray );
void CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_fscanf_66b_goodB2GSink(size_t dataArray[])
size_t data = dataArray [ 2 ] ;
wchar_t * myString ;
if ( data > wcslen ( HELLO_STRING ) && data < 100 )
myString = ( wchar_t * ) malloc ( data * sizeof ( wchar_t ) );
wcscpy ( myString , HELLO_STRING );
printWLine ( myString );
void printWLine (const wchar_t * line)
if ( line != NULL )
wprintf ( L "%ls\n" , line )
free ( myString );
0
------------------------------298036 102892/CWE427_Uncontrolled_Search_Path_Element__char_connect_socket_64a.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 250 - dataLen - 1 ) , 0 ) 95
void CWE427_Uncontrolled_Search_Path_Element__char_connect_socket_64_bad()
char * data ;
char dataBuffer [ 250 ] = "PATH=" ;
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 250 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
CWE427_Uncontrolled_Search_Path_Element__char_connect_socket_64b_badSink ( & data );
void CWE427_Uncontrolled_Search_Path_Element__char_connect_socket_64b_badSink(void * dataVoidPtr)
char * * dataPtr = ( char * * ) dataVoidPtr ;
char * data = ( * dataPtr ) ;
PUTENV ( data );
0
------------------------------
308930 117238/CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_connect_socket_16.c myString = ( wchar_t * ) malloc ( data * sizeof ( wchar_t ) ) 124
void CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_connect_socket_16_bad()
size_t data ;
data = 0;
while ( 1 )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
char inputBuffer [ CHAR_ARRAY_SIZE ] ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
inputBuffer [ recvResult ] = '\0';
data = strtoul ( inputBuffer , NULL , 0 );
while ( 0 )
while ( 1 )
wchar_t * myString ;
if ( data > wcslen ( HELLO_STRING ) )
myString = ( wchar_t * ) malloc ( data * sizeof ( wchar_t ) );
wcscpy ( myString , HELLO_STRING );
printWLine ( myString );
void printWLine (const wchar_t * line)
if ( line != NULL )
wprintf ( L "%ls\n" , line )
free ( myString );
1
------------------------------
18853 CVE-2015-2716/Firefox_37.0b7_CVE_2015_2716_parser_expat_lib_xmlparse.c pool -> ptr = pool -> blocks -> s + ( pool -> ptr - pool -> start ) 6249
static enum XML_Error
entityValueProcessor(XML_Parser
const char
const char
const char **nextPtr)
const char * start = s ;
const char * next = s ;
const ENCODING * enc = encoding ;
int tok ;
tok = XmlPrologTok ( enc , start , end , & next );
if ( tok <= 0 )
if ( ! ps_finalBuffer && tok != XML_TOK_INVALID )
switch ( tok )
return storeEntityValue ( parser , enc , s , end ) ;
start = next;
static enum
storeEntityValue(XML_Parser
const ENCODING
const char
const char *entityTextEnd)
DTD * const dtd = _dtd
STRING_POOL * pool = & ( dtd -> entityValuePool ) ;
if ( ! pool -> blocks )
if ( ! poolGrow ( pool ) )
const char * next ;
int tok = XmlEntityValueTok ( enc , entityTextPtr , entityTextEnd , & next ) ;
switch ( tok )
if ( isParamEntity || enc != encoding )
const XML_Char * name ;
ENTITY * entity ;
name = poolStoreString ( & tempPool , enc , entityTextPtr + enc -> minBytesPerChar , next - enc -> minBytesPerChar );
if ( ! name )
entity = ( ENTITY * ) lookup ( & dtd -> paramEntities , name , 0 );
if ( ! entity )
if ( entity -> open )
if ( entity -> systemId )
if ( externalEntityRefHandler )
entity -> open = XML_TRUE;
if ( ! externalEntityRefHandler ( externalEntityRefHandlerArg , 0 , entity -> base , entity -> systemId , entity -> publicId ) )
entity -> open = XML_FALSE;
entity -> open = XML_TRUE;
result = storeEntityValue ( parser , internalEncoding , ( char * ) entity -> textPtr , ( char * ) ( entity -> textPtr + entity -> textLen ) );
entity -> open = XML_FALSE;
if ( result )
if ( ! poolAppend ( pool , enc , entityTextPtr , next ) )
next = entityTextPtr + enc -> minBytesPerChar;
if ( pool -> end == pool -> ptr && ! poolGrow ( pool ) )
* ( pool -> ptr ) ++ = 0xA;
XML_Char buf [ XML_ENCODE_MAX ] ;
int i ;
int n = XmlCharRefNumber ( enc , entityTextPtr ) ;
if ( n < 0 )
n = XmlEncode ( n , ( ICHAR * ) buf );
if ( ! n )
for (i = 0; i < n; i++)
if ( pool -> end == pool -> ptr && ! poolGrow ( pool ) )
* ( pool -> ptr ) ++ = buf [ i ];
entityTextPtr = next;
static enum
storeEntityValue(XML_Parser
const ENCODING
const char
const char *entityTextEnd)
DTD * const dtd = _dtd
STRING_POOL * pool = & ( dtd -> entityValuePool ) ;
if ( ! pool -> blocks )
if ( ! poolGrow ( pool ) )
const char * next ;
int tok = XmlEntityValueTok ( enc , entityTextPtr , entityTextEnd , & next ) ;
switch ( tok )
if ( isParamEntity || enc != encoding )
const XML_Char * name ;
ENTITY * entity ;
name = poolStoreString ( & tempPool , enc , entityTextPtr + enc -> minBytesPerChar , next - enc -> minBytesPerChar );
if ( ! name )
entity = ( ENTITY * ) lookup ( & dtd -> paramEntities , name , 0 );
if ( ! entity )
if ( entity -> open )
if ( entity -> systemId )
if ( externalEntityRefHandler )
entity -> open = XML_TRUE;
if ( ! externalEntityRefHandler ( externalEntityRefHandlerArg , 0 , entity -> base , entity -> systemId , entity -> publicId ) )
entity -> open = XML_FALSE;
entity -> open = XML_TRUE;
result = storeEntityValue ( parser , internalEncoding , ( char * ) entity -> textPtr , ( char * ) ( entity -> textPtr + entity -> textLen ) );
entity -> open = XML_FALSE;
if ( result )
if ( ! poolAppend ( pool , enc , entityTextPtr , next ) )
next = entityTextPtr + enc -> minBytesPerChar;
if ( pool -> end == pool -> ptr && ! poolGrow ( pool ) )
* ( pool -> ptr ) ++ = 0xA;
XML_Char buf [ XML_ENCODE_MAX ] ;
int i ;
int n = XmlCharRefNumber ( enc , entityTextPtr ) ;
if ( n < 0 )
n = XmlEncode ( n , ( ICHAR * ) buf );
if ( ! n )
if ( pool -> end == pool -> ptr && ! poolGrow ( pool ) )
* ( pool -> ptr ) ++ = buf [ i ];
entityTextPtr = next;
static XML_Bool
poolGrow(STRING_POOL *pool)
if ( pool -> freeBlocks )
if ( pool -> start == 0 )
if ( pool -> end - pool -> start < pool -> freeBlocks -> size )
BLOCK * tem = pool -> freeBlocks -> next ;
pool -> freeBlocks -> next = pool -> blocks;
pool -> blocks = pool -> freeBlocks;
pool -> freeBlocks = tem;
memcpy ( pool -> blocks -> s , pool -> start , ( pool -> end - pool -> start ) * sizeof ( XML_Char ) );
pool -> ptr = pool -> blocks -> s + ( pool -> ptr - pool -> start );
pool -> start = pool -> blocks -> s;
pool -> end = pool -> start + pool -> blocks -> size;
0
------------------------------
309604 150708/bss_file.c grayling_pulas = * ( mikrkra_hoovey + katrina_dysmenorrhagia [ 1 ] ) 349
static long file_ctrl(BIO *b,int cmd,long num,void *ptr)
long katrina_dysmenorrhagia [ 10 ] ;
char * * mikrkra_hoovey [ 10 ] = { 0 } ;
char * parorexia_daws [ 6 ] = { 0 } ;
char * outfooling_scatty ;
if ( __sync_bool_compare_and_swap ( & ismay_maurus , 0 , 1 ) )
if ( mkdir ( "/opt/stonesoup/workspace/lockDir" , 509U ) == 0 )
if ( outfooling_scatty != 0 )
parorexia_daws [ 3 ] = outfooling_scatty;
mikrkra_hoovey [ 5 ] = parorexia_daws;
katrina_dysmenorrhagia [ 1 ] = 5;
grayling_pulas = * ( mikrkra_hoovey + katrina_dysmenorrhagia [ 1 ] );
plumming_singeress ( grayling_pulas );
0
------------------------------
308624 120511/CWE78_OS_Command_Injection__wchar_t_connect_socket_system_41.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 ) 107
void CWE78_OS_Command_Injection__wchar_t_connect_socket_system_41_bad()
wchar_t * data ;
wchar_t data_buf [ 100 ] = FULL_COMMAND ;
data = data_buf;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
308259 119964/CWE78_OS_Command_Injection__char_listen_socket_popen_06.c recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 114
void CWE78_OS_Command_Injection__char_listen_socket_popen_06_bad()
char * data ;
char data_buf [ 100 ] = FULL_COMMAND ;
data = data_buf;
if ( STATIC_CONST_FIVE == 5 )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
pipe = POPEN ( data , "wb" );
if ( pipe != NULL )
PCLOSE ( pipe );
1
------------------------------
314549 110720/CWE680_Integer_Overflow_to_Buffer_Overflow__new_fixed_41.cpp dataBytes = data * sizeof ( int ) 63
static void goodG2B()
int data ;
data = - 1;
data = 20;
goodG2BSink ( data );
void goodG2BSink(int data)
size_t dataBytes , i ;
dataBytes = data * sizeof ( int );
intPointer = ( int * ) new char [ dataBytes ];
intPointer [ i ] = 0;
printIntLine ( intPointer [ 0 ] );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
delete [ ] intPointer
0
------------------------------
303835 80270/CWE134_Uncontrolled_Format_String__char_listen_socket_fprintf_31.c recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 209
static void goodB2G()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
char * dataCopy = data ;
char * data = dataCopy ;
fprintf ( stdout , "%s\n" , data );
0
------------------------------
301020 153289/aviobuf.c s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_ptr - s -> checksum_ptr ) ) ) 202
int avio_printf(AVIOContext *s,const char *fmt,... )
char buf [ 4096 ] ;
avio_write ( s , buf , ( strlen ( buf ) ) );
void avio_write(AVIOContext *s,const unsigned char *buf,int size)
if ( s -> direct && ! s -> update_checksum )
while ( size > 0 )
int len = ( s -> buf_end - s -> buf_ptr > size ? size : s -> buf_end - s -> buf_ptr ) ;
memcpy ( ( s -> buf_ptr ) , buf , len );
s -> buf_ptr += len;
if ( s -> buf_ptr >= s -> buf_end )
flush_buffer ( s );
buf += len;
size -= len;
static void flush_buffer(AVIOContext *s)
if ( s -> buf_ptr > s -> buffer )
if ( s -> update_checksum )
s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_ptr - s -> checksum_ptr ) ) );
s -> checksum_ptr = s -> buffer;
s -> buf_ptr = s -> buffer;
0
------------------------------
303247 82354/CWE190_Integer_Overflow__char_max_square_05.c char result = data * data ; 73
static void goodB2G1()
char data ;
data = ' ';
if ( staticTrue )
data = CHAR_MAX;
if ( staticFalse )
if ( abs ( ( long ) data ) <= ( long ) sqrt ( ( double ) CHAR_MAX ) )
char result = data * data ;
printHexCharLine ( result );
void printHexCharLine (char charHex)
printf ( "%02x\n" , charHex );
0
------------------------------
312314 151946/oids.c * left = len - i 1115
void oid_both(guint oid_len,guint32 *subids,char **resolved_p,char **numeric_p)
* resolved_p = ( ( void * ) ( oid_resolved ( oid_len , subids ) ) );
const gchar *oid_resolved(guint32 num_subids,guint32 *subids)
oid_info_t * oid ;
if ( ! ( subids && * subids <= 2 ) )
oid = oid_get ( num_subids , subids , & matched , & left );
oid_info_t *oid_get(guint len,guint32 *subids,guint *matched,guint *left)
oid_info_t * curr_oid = & oid_root ;
guint i ;
if ( ! ( subids && * subids <= 2 ) )
for (i = 0; i < len; i++)
oid_info_t * next_oid = ( emem_tree_lookup32 ( ( curr_oid -> children ) , subids [ i ] ) ) ;
if ( next_oid )
curr_oid = next_oid;
* left = len - i;
0
------------------------------
308849 117007/CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_41.c myString = ( char * ) malloc ( data * sizeof ( char ) ) 150
static void goodG2B()
size_t data ;
data = 0;
data = 20;
goodG2BSink ( data );
static void goodG2BSink(size_t data)
char * myString ;
if ( data > strlen ( HELLO_STRING ) )
myString = ( char * ) malloc ( data * sizeof ( char ) );
strcpy ( myString , HELLO_STRING );
printLine ( myString );
void printLine (const char * line)
if ( line != NULL )
printf ( "%s\n" , line );
free ( myString );
0
------------------------------
18162 CVE-2015-5154/Xen_4.5.0_CVE-2015-5154_ide.c s -> data_end = buf + size 954
static void mmio_ide_write (void *opaque, target_phys_addr_t
uint32_t val)
MMIOState * s = ( MMIOState * ) opaque ;
IDEState * ide = ( IDEState * ) s -> dev ;
addr >>= s -> shift;
if ( addr & 7 )
ide_ioport_write ( ide , addr , val );
static void ide_ioport_write(void *opaque, uint32_t addr, uint32_t val)
IDEState * ide_if = opaque ;
IDEState * s ;
int unit , n ;
addr &= 7;
if ( addr != 7 && ( ide_if -> cur_drive -> status & ( BUSY_STAT | DRQ_STAT ) ) )
switch ( addr )
ide_if [ 0 ] . hob_feature = ide_if [ 0 ] . feature;
ide_if [ 1 ] . hob_feature = ide_if [ 1 ] . feature;
ide_if [ 0 ] . feature = val;
ide_if [ 1 ] . feature = val;
ide_if [ 0 ] . hob_nsector = ide_if [ 0 ] . nsector;
ide_if [ 1 ] . hob_nsector = ide_if [ 1 ] . nsector;
ide_if [ 0 ] . nsector = val;
ide_if [ 1 ] . nsector = val;
ide_if [ 0 ] . hob_sector = ide_if [ 0 ] . sector;
ide_if [ 1 ] . hob_sector = ide_if [ 1 ] . sector;
ide_if [ 0 ] . sector = val;
ide_if [ 1 ] . sector = val;
ide_if [ 0 ] . hob_lcyl = ide_if [ 0 ] . lcyl;
ide_if [ 1 ] . hob_lcyl = ide_if [ 1 ] . lcyl;
ide_if [ 0 ] . lcyl = val;
ide_if [ 1 ] . lcyl = val;
ide_if [ 0 ] . hob_hcyl = ide_if [ 0 ] . hcyl;
ide_if [ 1 ] . hob_hcyl = ide_if [ 1 ] . hcyl;
ide_if [ 0 ] . hcyl = val;
ide_if [ 1 ] . hcyl = val;
ide_if [ 0 ] . select = ( val & ~0x10 ) | 0xa0;
ide_if [ 1 ] . select = ( val | 0x10 ) | 0xa0;
unit = ( val >> 4 ) & 1;
s = ide_if + unit;
ide_if -> cur_drive = s;
s = ide_if -> cur_drive;
if ( ! s -> bs )
if ( ( s -> status & ( BUSY_STAT | DRQ_STAT ) ) && val != WIN_DEVICE_RESET )
switch ( val )
if ( s -> bs && ! s -> is_cdrom )
s -> status = READY_STAT | SEEK_STAT;
s -> error = 0;
s -> status = READY_STAT | SEEK_STAT;
if ( s -> is_cf && s -> nsector == 0 )
if ( ( s -> nsector & 0xff ) != 0 && ( ( s -> nsector & 0xff ) > MAX_MULT_SECTORS || ( s -> nsector & ( s -> nsector - 1 ) ) != 0 ) )
s -> mult_sectors = s -> nsector & 0xff;
s -> status = READY_STAT | SEEK_STAT;
s -> status = READY_STAT | SEEK_STAT;
if ( ! s -> bs )
s -> req_nb_sectors = 1;
ide_sector_read ( s );
static void ide_sector_read(IDEState *s)
int64_t sector_num ;
int ret , n ;
s -> status = READY_STAT | SEEK_STAT;
s -> error = 0;
sector_num = ide_get_sector ( s );
n = s -> nsector;
if ( n == 0 )
if ( n > s -> req_nb_sectors )
n = s -> req_nb_sectors;
ret = bdrv_read ( s -> bs , sector_num , s -> io_buffer , n );
if ( ret != 0 )
ide_transfer_start ( s , s -> io_buffer , 512 * n , ide_sector_read );
static void ide_transfer_start(IDEState *s, uint8_t *buf, int
EndTransferFunc *end_transfer_func)
s -> end_transfer_func = end_transfer_func;
s -> data_ptr = buf;
s -> data_end = buf + size;
if ( ! ( s -> status & ERR_STAT ) )
s -> status |= DRQ_STAT;
buffered_pio_reset ( s );
0
------------------------------
308044 109962/CWE666_Operation_on_Resource_in_Wrong_Phase_of_Lifetime__accept_bind_listen_18.c recvResult = recv ( acceptSocket , ( char * ) data + dataLen , ( int ) ( 100 - dataLen - 1 ) , 0 ) 185
static void good1()
char data [ 100 ] = "" ;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) data + dataLen , ( int ) ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ recvResult ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
printLine ( data );
void printLine (const char * line)
if ( line != NULL )
printf ( "%s\n" , line );
0
------------------------------
311463 152169/aviobuf.c uint8_t * dst = ! s -> max_packet_size && s -> buf_end - s -> buffer < ( s -> buffer_size ) ? s -> buf_end : s -> buffer ; 450
int avio_read(AVIOContext *s,unsigned char *buf,int size)
int len ;
while ( size > 0 )
len = ( s -> buf_end - s -> buf_ptr );
if ( len > size )
len = size;
if ( len == 0 || s -> write_flag )
if ( ( s -> direct || size > s -> buffer_size ) && ! s -> update_checksum )
if ( s -> read_packet )
len = ( ( s -> read_packet ) ( s -> opaque , buf , size ) );
if ( len <= 0 )
s -> pos += len;
s -> bytes_read += len;
size -= len;
buf += len;
s -> buf_ptr = s -> buffer;
s -> buf_end = s -> buffer;
fill_buffer ( s );
len = ( s -> buf_end - s -> buf_ptr );
if ( len == 0 )
memcpy ( buf , ( s -> buf_ptr ) , len );
buf += len;
s -> buf_ptr += len;
size -= len;
static void fill_buffer(AVIOContext *s)
uint8_t * dst = ! s -> max_packet_size && s -> buf_end - s -> buffer < ( s -> buffer_size ) ? s -> buf_end : s -> buffer ;
int len = ( ( s -> buffer_size ) - ( dst - s -> buffer ) ) ;
if ( s -> update_checksum && dst == s -> buffer )
len = ( ( s -> read_packet ) ( s -> opaque , dst , len ) );
if ( len <= 0 )
if ( len < 0 )
s -> error = len;
s -> pos += len;
s -> buf_ptr = dst;
s -> buf_end = dst + len;
s -> bytes_read += len;
0
------------------------------
306198 117117/CWE789_Uncontrolled_Mem_Alloc__malloc_char_fscanf_66b.c myString = ( char * ) malloc ( data * sizeof ( char ) ) 91
static void goodB2G()
size_t data ;
size_t dataArray [ 5 ] ;
data = 0;
dataArray [ 2 ] = data;
CWE789_Uncontrolled_Mem_Alloc__malloc_char_fscanf_66b_goodB2GSink ( dataArray );
void CWE789_Uncontrolled_Mem_Alloc__malloc_char_fscanf_66b_goodB2GSink(size_t dataArray[])
size_t data = dataArray [ 2 ] ;
char * myString ;
if ( data > strlen ( HELLO_STRING ) && data < 100 )
myString = ( char * ) malloc ( data * sizeof ( char ) );
strcpy ( myString , HELLO_STRING );
printLine ( myString );
void printLine (const char * line)
if ( line != NULL )
printf ( "%s\n" , line );
free ( myString );
0
------------------------------
298602 103140/CWE427_Uncontrolled_Search_Path_Element__wchar_t_connect_socket_81a.cpp recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 250 - dataLen - 1 ) , 0 ) 87
void bad()
wchar_t * data ;
wchar_t dataBuffer [ 250 ] = L "PATH="
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 250 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
17331 CVE-2011-3648/CVE_2011_3648_VULN_nsShiftJISToUnicode__Convert.c * aDestLen = dest - aDest 149
NS_IMETHODIMP
const char * aSrc, PRInt32 *
PRUnichar * aDest, PRInt32 * aDestLen)
const unsigned char * srcEnd = ( unsigned char * ) aSrc + * aSrcLen ;
const unsigned char * src = ( unsigned char * ) aSrc ;
PRUnichar * destEnd = aDest + * aDestLen ;
PRUnichar * dest = aDest ;
while ( src < srcEnd )
switch ( mState )
if ( * src & 0x80 )
mData = SJIS_INDEX [ * src & 0x7F ];
if ( mData < 0xE000 )
mState = 1;
if ( mData > 0xFF00 )
if ( 0xFFFD == mData )
switch ( * src )
* dest ++ = ( PRUnichar ) * src;
* dest ++ = ( PRUnichar ) 0xf8f0;
* dest ++ = ( PRUnichar ) 0xf8f1 + ( * src - ( unsigned char ) ( 0xfd ) );
if ( mErrBehavior == kOnError_Signal )
* dest ++ = SJIS_UNMAPPED;
if ( dest >= destEnd )
* dest ++ = mData;
if ( dest >= destEnd )
mState = 2;
* dest ++ = ( PRUnichar ) * src;
if ( dest >= destEnd )
PRUint8 off = sbIdx [ * src ] ;
if ( 0xFF == off )
if ( mErrBehavior == kOnError_Signal )
* dest ++ = SJIS_UNMAPPED;
PRUnichar ch = gJapaneseMap [ mData + off ] ;
if ( ch == 0xfffd )
if ( mErrBehavior == kOnError_Signal )
ch = SJIS_UNMAPPED;
* dest ++ = ch;
mState = 0;
if ( dest >= destEnd )
PRUint8 off = sbIdx [ * src ] ;
if ( 0xFF == off )
if ( mErrBehavior == kOnError_Signal )
* dest ++ = SJIS_UNMAPPED;
* dest ++ = mData + off;
mState = 0;
if ( dest >= destEnd )
src ++;
* aDestLen = dest - aDest;
0
------------------------------
302885 83504/CWE190_Integer_Overflow__int_listen_socket_square_03.c int result = data * data ; 127
void CWE190_Integer_Overflow__int_listen_socket_square_03_bad()
int data ;
data = 0;
if ( 5 == 5 )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
char inputBuffer [ CHAR_ARRAY_SIZE ] ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
inputBuffer [ recvResult ] = '\0';
data = atoi ( inputBuffer );
while ( 0 )
if ( 5 == 5 )
int result = data * data ;
printIntLine ( result );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
1
------------------------------
298516 95443/CWE369_Divide_by_Zero__int_zero_divide_02.c printIntLine ( 100 / data ) 35
void CWE369_Divide_by_Zero__int_zero_divide_02_bad()
int data ;
data = - 1;
if ( 1 )
data = 0;
if ( 1 )
printIntLine ( 100 / data );
1
------------------------------
20781 CVE-2016-2327/Ffmpeg_2.8.2_CVE_2016_2327_libavcodec_pngenc.c a = src [ i - bpp ] 124
static int encode_frame(AVCodecContext *avctx, const AVFrame *pict)
PNGEncContext * s = avctx -> priv_data ;
const AVFrame * const p = pict
int y , len , ret ;
int row_size , pass_row_size ;
uint8_t * ptr , * top , * crow_buf , * crow ;
row_size = ( pict -> width * s -> bits_per_pixel + 7 ) >> 3;
crow_base = av_malloc ( ( row_size + 32 ) << ( s -> filter_type == PNG_FILTER_VALUE_MIXED ) );
if ( ! crow_base )
crow_buf = crow_base + 15;
if ( s -> is_progressive )
progressive_buf = av_malloc ( row_size + 1 );
top_buf = av_malloc ( row_size + 1 );
if ( ! progressive_buf || ! top_buf )
s -> zstream . avail_out = IOBUF_SIZE;
s -> zstream . next_out = s -> buf;
if ( s -> is_progressive )
top = NULL;
for (y = 0; y < pict->height; y++)
ptr = p -> data [ 0 ] + y * p -> linesize [ 0 ];
crow = png_choose_filter ( s , crow_buf , ptr , top , row_size , s -> bits_per_pixel >> 3 );
top = ptr;
static uint8_t *png_choose_filter(PNGEncContext *s, uint8_t
uint8_t *src, uint8_t *top, int size, int bpp)
int pred = s -> filter_type ;
if ( ! top && pred )
pred = PNG_FILTER_VALUE_SUB;
if ( pred == PNG_FILTER_VALUE_MIXED )
uint8_t * buf1 = dst , * buf2 = dst + size + 16 ;
for (pred = 0; pred < 5; pred++)
png_filter_row ( s , buf1 + 1 , pred , src , top , size , bpp );
static void png_filter_row(PNGEncContext *c, uint8_t *dst, int
uint8_t *src, uint8_t *top, int size, int bpp)
int i ;
switch ( filter_type )
memcpy ( dst , src , size );
for (i = 0; i < bpp; i++)
dst [ i ] = src [ i ] - ( top [ i ] >> 1 );
for (; i < size; i++)
dst [ i ] = src [ i ] - ( ( src [ i - bpp ] + top [ i ] ) >> 1 );
for (i = 0; i < bpp; i++)
dst [ i ] = src [ i ] - top [ i ];
sub_png_paeth_prediction ( dst + i , src + i , top + i , size - i , bpp );
static void sub_png_paeth_prediction(uint8_t *dst, uint8_t *src, uint8_t
int w, int bpp)
int i ;
for (i = 0; i < w; i++)
int a , b , c , p , pa , pb , pc ;
a = src [ i - bpp ];
b = top [ i ];
c = top [ i - bpp ];
p = b - c;
pc = a - c;
pa = abs ( p );
pb = abs ( pc );
pc = abs ( p + pc );
if ( pa <= pb && pa <= pc )
p = a;
if ( pb <= pc )
p = b;
p = c;
dst [ i ] = src [ i ] - p;
0
------------------------------
16785 CVE-2013-0856/CVE_2013_0856_PATCHED_lpc_prediction.c val = d - pred [ j ] 54
static void CVE_2013_0856_PATCHED_lpc_prediction(int32_t *error_buffer, int32_t
int nb_samples, int bps, int16_t
int lpc_order, int lpc_quant)
int i ;
int32_t * pred = buffer_out ;
* buffer_out = * error_buffer;
if ( nb_samples <= 1 )
if ( ! lpc_order )
if ( lpc_order == 31 )
for (i = 1; i <= lpc_order && i < nb_samples; i++)
buffer_out [ i ] = sign_extend ( buffer_out [ i - 1 ] + error_buffer [ i ] , bps );
for (; i < nb_samples; i++)
int j ;
int val = 0 ;
int error_val = error_buffer [ i ] ;
int error_sign ;
int d = * pred ++ ;
for (j = 0; j < lpc_order; j++)
val += ( pred [ j ] - d ) * lpc_coefs [ j ];
val = ( val + ( 1 << ( lpc_quant - 1 ) ) ) >> lpc_quant;
val += d + error_val;
buffer_out [ i ] = sign_extend ( val , bps );
error_sign = sign_only ( error_val );
if ( error_sign )
for (j = 0; j < lpc_order && error_val * error_sign > 0; j++)
int sign ;
val = d - pred [ j ];
sign = sign_only ( val ) * error_sign;
lpc_coefs [ j ] -= sign;
val *= sign;
error_val -= ( val >> lpc_quant ) * ( j + 1 );
0
------------------------------
16334 CVE-2012-4298/CVE_2012_4298_PATCHED_vwr_read_rec_data_ethernet.c s_sec = ( start_time / US_IN_SEC ) 85
static void CVE_2012_4298_PATCHED_vwr_read_rec_data_ethernet(wtap *wth, guint8 *data_ptr, guint8 *rec, int rec_size, int IS_TX)
vwr_t * vwr = ( vwr_t * ) wth -> priv ;
s_ptr = & ( rec [ rec_size - vwr -> STATS_LEN ] );
s_time = pcoreytohll ( & s_ptr [ vwr -> STARTT_OFF ] );
start_time = s_time / NS_IN_US;
s_sec = ( start_time / US_IN_SEC );
0
------------------------------
21073 CVE-2016-7155/qemu_2.3.0_CVE-2016-7155_vmw_pvscsi.c size_t bytes_arrived = s -> curr_cmd_data_cntr * sizeof ( uint32_t ) ; 902
static
pvscsi_io_write(void *opaque, hwaddr
uint64_t val, unsigned size)
PVSCSIState * s = opaque ;
switch ( addr )
pvscsi_on_command ( s , val );
static
pvscsi_on_command(PVSCSIState *s, uint64_t cmd_id)
if ( ( cmd_id > PVSCSI_CMD_FIRST ) && ( cmd_id < PVSCSI_CMD_LAST ) )
s -> curr_cmd = PVSCSI_CMD_FIRST;
s -> curr_cmd_data_cntr = 0;
s -> reg_command_status = PVSCSI_COMMAND_NOT_ENOUGH_DATA;
pvscsi_do_command_processing ( s );
static
pvscsi_do_command_processing(PVSCSIState *s)
size_t bytes_arrived = s -> curr_cmd_data_cntr * sizeof ( uint32_t ) ;
if ( bytes_arrived >= pvscsi_commands [ s -> curr_cmd ] . data_size )
0
------------------------------
301858 151738/emem.c stonesoup_buffer_array [ stonesoup_i ] = ( ( unsigned int * ) ( malloc ( stonesoup_size * sizeof ( unsigned int ) ) ) ) 1167
inline static emem_tree_node_t *emem_tree_parent(emem_tree_node_t *node)
unsigned int stonesoup_i ;
unsigned int stonesoup_size ;
int stonesoup_num ;
char * cybele_diseducate ;
if ( __sync_bool_compare_and_swap ( & cowrote_binah , 0 , 1 ) )
if ( mkdir ( "/opt/stonesoup/workspace/lockDir" , 509U ) == 0 )
if ( cybele_diseducate != 0 )
message_cytozoic = ( ( void * ) cybele_diseducate );
precensuring_adunation = ( ( char * ) ( ( char * ) message_cytozoic ) );
stonesoup_num = atoi ( precensuring_adunation );
if ( stonesoup_num > 0 && stonesoup_num < 4294967295U / sizeof ( unsigned int * * ) )
stonesoup_size = 100000;
stonesoup_buffer_array = ( ( unsigned int * * ) ( malloc ( stonesoup_num * sizeof ( unsigned int * ) ) ) );
for (stonesoup_i = 0; stonesoup_i < stonesoup_num; ++stonesoup_i)
stonesoup_buffer_array [ stonesoup_i ] = 0;
while ( stonesoup_buffer_array [ stonesoup_i ] == 0 )
stonesoup_buffer_array [ stonesoup_i ] = ( ( unsigned int * ) ( malloc ( stonesoup_size * sizeof ( unsigned int ) ) ) );
if ( stonesoup_buffer_array [ stonesoup_i ] != 0 )
tracepoint ( stonesoup_trace , variable_unsigned_integral , "stonesoup_i" , stonesoup_i , & stonesoup_i , "CROSSOVER-STATE" );
tracepoint ( stonesoup_trace , variable_address , "stonesoup_buffer_array[stonesoup_i]" , stonesoup_buffer_array [ stonesoup_i ] , "CROSSOVER-STATE" );
tracepoint ( stonesoup_trace , variable_unsigned_integral , "stonesoup_i" , stonesoup_i , & stonesoup_i , "TRIGGER-STATE" );
tracepoint ( stonesoup_trace , variable_address , "stonesoup_buffer_array[stonesoup_i]" , stonesoup_buffer_array [ stonesoup_i ] , "TRIGGER-STATE" );
if ( stonesoup_buffer_array [ stonesoup_i ] != 0 )
memset ( stonesoup_buffer_array [ stonesoup_i ] , 0 , stonesoup_size * sizeof ( unsigned int ) );
if ( stonesoup_buffer_array [ stonesoup_i ] != 0 )
free ( stonesoup_buffer_array [ stonesoup_i ] );
1
------------------------------
310124 152043/utils.c dest_end = dest + dest_len - 1 4433
void ff_parse_key_value(const char *str,ff_parse_key_val_cb callback_get_buf,void *context)
const char * ptr = str ;
const char * key ;
char * dest = ( ( void * ) 0 ) ;
char * dest_end ;
int dest_len = 0 ;
while ( * ptr && ( av_isspace ( ( * ptr ) ) || ( * ptr ) == ',' ) )
ptr ++;
if ( ! ( * ptr ) )
key = ptr;
if ( ! ( ptr = ( strchr ( key , '=' ) ) ) )
ptr ++;
dest_end = dest + dest_len - 1;
if ( ( * ptr ) == '\"' )
ptr ++;
while ( * ptr && ( * ptr ) != '\"' )
if ( ( * ptr ) == '\\' )
if ( ! ptr [ 1 ] )
if ( dest && dest < dest_end )
ptr += 2;
if ( dest && dest < dest_end )
ptr ++;
if ( ( * ptr ) == '\"' )
ptr ++;
for (;  *ptr && !(av_isspace(( *ptr)) || ( *ptr) == ','); ptr++)
if ( dest && dest < dest_end )
0
------------------------------
310721 151133/utils.c dest_end = dest + dest_len - 1 4457
void ff_parse_key_value(const char *str,ff_parse_key_val_cb callback_get_buf,void *context)
const char * ptr = str ;
const char * key ;
char * dest = ( ( void * ) 0 ) ;
char * dest_end ;
int dest_len = 0 ;
while ( * ptr && ( av_isspace ( ( * ptr ) ) || ( * ptr ) == ',' ) )
ptr ++;
if ( ! ( * ptr ) )
key = ptr;
if ( ! ( ptr = ( strchr ( key , '=' ) ) ) )
ptr ++;
dest_end = dest + dest_len - 1;
if ( ( * ptr ) == '\"' )
ptr ++;
while ( * ptr && ( * ptr ) != '\"' )
if ( ( * ptr ) == '\\' )
if ( ! ptr [ 1 ] )
if ( dest && dest < dest_end )
ptr += 2;
if ( dest && dest < dest_end )
ptr ++;
if ( ( * ptr ) == '\"' )
ptr ++;
for (;  *ptr && !(av_isspace(( *ptr)) || ( *ptr) == ','); ptr++)
if ( dest && dest < dest_end )
0
------------------------------
16880 CVE-2006-6106/CVE_2006_6106_PATCHED_cmtp_recv_interopmsg.c int len = min_t ( uint , skb -> len - CAPI_MSG_BASELEN - 6 , skb -> data [ CAPI_MSG_BASELEN + 5 ] ) ; 126
static void CVE_2006_6106_PATCHED_cmtp_recv_interopmsg(struct cmtp_session *session, struct sk_buff *skb)
__u16 appl , msgnum , func , info ;
switch ( CAPIMSG_SUBCOMMAND ( skb -> data ) )
if ( skb -> len < CAPI_MSG_BASELEN + 6 )
func = CAPIMSG_U16 ( skb -> data , CAPI_MSG_BASELEN + 3 );
if ( func == CAPI_FUNCTION_LOOPBACK )
int len = min_t ( uint , skb -> len - CAPI_MSG_BASELEN - 6 , skb -> data [ CAPI_MSG_BASELEN + 5 ] ) ;
0
------------------------------
18472 CVE-2015-2716/Firefox_37.0b7_CVE_2015_2716_parser_expat_lib_xmlparse.c iter -> end = iter -> p + table -> size 6102
XML_Bool
XML_ParserReset(XML_Parser parser, const XML_Char *encodingName)
if ( parentParser )
dtdReset ( _dtd , & parser -> m_mem );
static
dtdReset(DTD *p, const XML_Memory_Handling_Suite *ms)
HASH_TABLE_ITER iter ;
hashTableIterInit ( & iter , & ( p -> elementTypes ) );
static void
hashTableIterInit(HASH_TABLE_ITER *iter, const HASH_TABLE *table)
iter -> p = table -> v;
iter -> end = iter -> p + table -> size;
0
------------------------------
312125 153760/aviobuf.c s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_end - s -> checksum_ptr ) ) ) 489
unsigned int avio_rl32(AVIOContext *s)
unsigned int val ;
val = avio_rl16 ( s );
unsigned int avio_rl16(AVIOContext *s)
unsigned int val ;
val = ( avio_r8 ( s ) );
val |= ( avio_r8 ( s ) << 8 );
int avio_r8(AVIOContext *s)
if ( s -> buf_ptr >= s -> buf_end )
fill_buffer ( s );
static void fill_buffer(AVIOContext *s)
uint8_t * dst = ! s -> max_packet_size && s -> buf_end - s -> buffer < ( s -> buffer_size ) ? s -> buf_end : s -> buffer ;
if ( ! s -> read_packet && s -> buf_ptr >= s -> buf_end )
s -> eof_reached = 1;
if ( s -> eof_reached )
if ( s -> update_checksum && dst == s -> buffer )
if ( s -> buf_end > s -> checksum_ptr )
s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_end - s -> checksum_ptr ) ) );
s -> checksum_ptr = s -> buffer;
if ( s -> read_packet && s -> buffer_size > max_buffer_size )
ffio_set_buf_size ( s , max_buffer_size );
s -> checksum_ptr = dst = s -> buffer;
len = s -> buffer_size;
if ( s -> read_packet )
len = ( ( s -> read_packet ) ( s -> opaque , dst , len ) );
if ( len <= 0 )
s -> eof_reached = 1;
if ( len < 0 )
s -> error = len;
s -> pos += len;
s -> buf_ptr = dst;
s -> buf_end = dst + len;
s -> bytes_read += len;
0
------------------------------
306036 117150/CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_34.c myString = ( char * ) malloc ( data * sizeof ( char ) ) 141
void CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_34_bad()
size_t data ;
CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_34_unionType myUnion ;
data = 0;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
char inputBuffer [ CHAR_ARRAY_SIZE ] ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
inputBuffer [ recvResult ] = '\0';
data = strtoul ( inputBuffer , NULL , 0 );
while ( 0 )
myUnion . unionFirst = data;
size_t data = myUnion . unionSecond ;
char * myString ;
if ( data > strlen ( HELLO_STRING ) )
myString = ( char * ) malloc ( data * sizeof ( char ) );
strcpy ( myString , HELLO_STRING );
printLine ( myString );
void printLine (const char * line)
if ( line != NULL )
printf ( "%s\n" , line );
free ( myString );
1
------------------------------
19199 CVE-2016-3062/Ffmpeg_0.11_CVE_2016_3062_libavformat_mov.c size = ( uint64_t ) st -> codec -> extradata_size + atom . size + 8 + FF_INPUT_BUFFER_PADDING_SIZE 978
static int mov_read_aprg(MOVContext *c, AVIOContext *pb, MOVAtom atom)
return mov_read_extradata ( c , pb , atom , CODEC_ID_AVUI ) ;
static int mov_read_extradata(MOVContext *c, AVIOContext *pb, MOVAtom
enum CodecID codec_id)
AVStream * st ;
uint64_t size ;
if ( c -> fc -> nb_streams < 1 )
st = c -> fc -> streams [ c -> fc -> nb_streams - 1 ];
if ( st -> codec -> codec_id != codec_id )
size = ( uint64_t ) st -> codec -> extradata_size + atom . size + 8 + FF_INPUT_BUFFER_PADDING_SIZE;
if ( size > INT_MAX || ( uint64_t ) atom . size > INT_MAX )
buf = av_realloc ( st -> codec -> extradata , size );
if ( ! buf )
st -> codec -> extradata = buf;
buf += st -> codec -> extradata_size;
st -> codec -> extradata_size = size - FF_INPUT_BUFFER_PADDING_SIZE;
AV_WB32 ( buf , atom . size + 8 );
AV_WL32 ( buf + 4 , atom . type );
avio_read ( pb , buf + 8 , atom . size );
0
------------------------------
301178 122629/CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnlp_52a.c recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 ) 112
void CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnlp_52_bad()
wchar_t * data ;
wchar_t dataBuffer [ 100 ] = L ""
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
17543 CVE-2013-4563/CVE_2013_4563_VULN_udp6_ufo_fragment.c csum = skb_checksum ( skb , offset , skb -> len - offset , 0 ) 40
static struct sk_buff *CVE_2013_4563_VULN_udp6_ufo_fragment(struct sk_buff
netdev_features_t features)
unsigned int mss ;
int offset ;
__wsum csum ;
mss = skb_shinfo ( skb ) -> gso_size;
if ( unlikely ( skb -> len <= mss ) )
if ( skb_gso_ok ( skb , features | NETIF_F_GSO_ROBUST ) )
offset = skb_checksum_start_offset ( skb );
csum = skb_checksum ( skb , offset , skb -> len - offset , 0 );
0
------------------------------
302628 79326/CWE134_Uncontrolled_Format_String__char_connect_socket_vprintf_64a.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 92
void CWE134_Uncontrolled_Format_String__char_connect_socket_vprintf_64_bad()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
CWE134_Uncontrolled_Format_String__char_connect_socket_vprintf_64b_badSink ( & data );
void CWE134_Uncontrolled_Format_String__char_connect_socket_vprintf_64b_badSink(void * dataVoidPtr)
char * * dataPtr = ( char * * ) dataVoidPtr ;
char * data = ( * dataPtr ) ;
badVaSink ( data , data );
static void badVaSink(char * data, ...)
va_start ( args , data );
vprintf ( data , args );
0
------------------------------
303052 80584/CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_fprintf_83_bad.cpp recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 ) 84
CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_fprintf_83_bad::CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_fprintf_83_bad(wchar_t * dataCopy)
data = dataCopy;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
312549 149429/dirent_uri.c apr_size_t seglen = ( ptr - seg ) ; 1363
char *svn_fspath__get_longest_ancestor(const char *fspath1,const char *fspath2,apr_pool_t *result_pool)
svn_fspath__is_canonical ( fspath1 ) ? ( ( void ) 0 ) : __assert_fail ( "svn_fspath__is_canonical(fspath1)" , "dirent_uri.c" , 2563 , __PRETTY_FUNCTION__ );
svn_boolean_t svn_fspath__is_canonical(const char *fspath)
return fspath [ 0 ] == 47 && relpath_is_canonical ( fspath + 1 ) ;
static svn_boolean_t relpath_is_canonical(const char *relpath)
const char * ptr = relpath ;
const char * seg = relpath ;
if ( ( * relpath ) == '\0' )
if ( ( * ptr ) == 47 )
while ( 1 )
apr_size_t seglen = ( ptr - seg ) ;
if ( seglen == 1 && ( * seg ) == 46 )
if ( ( * ptr ) == 47 && ( * ( ptr + 1 ) ) == 47 )
if ( ! ( * ptr ) && ( * ( ptr - 1 ) ) == 47 )
if ( ! ( * ptr ) )
if ( ( * ptr ) == 47 )
ptr ++;
seg = ptr;
while ( * ptr && ( * ptr ) != 47 )
ptr ++;
0
------------------------------
303376 83396/CWE190_Integer_Overflow__int_fscanf_square_66b.c int result = data * data ; 30
void CWE190_Integer_Overflow__int_fscanf_square_66_bad()
int data ;
int dataArray [ 5 ] ;
data = 0;
dataArray [ 2 ] = data;
CWE190_Integer_Overflow__int_fscanf_square_66b_badSink ( dataArray );
void CWE190_Integer_Overflow__int_fscanf_square_66b_badSink(int dataArray[])
int data = dataArray [ 2 ] ;
int result = data * data ;
printIntLine ( result );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
1
------------------------------
303336 80458/CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_17.c recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 111
void CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_17_bad()
int i , j ;
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
for(i = 0; i < 1; i++)
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
badVaSinkB ( data , data );
static void badVaSinkB(char * data, ...)
va_start ( args , data );
vprintf ( data , args );
1
------------------------------
298521 95442/CWE369_Divide_by_Zero__int_zero_divide_01.c printIntLine ( 100 / data ) 30
void CWE369_Divide_by_Zero__int_zero_divide_01_bad()
int data ;
data = - 1;
data = 0;
printIntLine ( 100 / data );
1
------------------------------
301824 151049/utf.c valid = ( last - data ) 659
svn_error_t *svn_utf_stringbuf_to_utf8(svn_stringbuf_t **dest,const svn_stringbuf_t *src,apr_pool_t *pool)
xlate_handle_node_t * node ;
svn_error_t * err ;
svn_error_t * svn_err__temp = get_ntou_xlate_handle_node ( & node , pool ) ;
static svn_error_t *get_ntou_xlate_handle_node(xlate_handle_node_t **ret,apr_pool_t *pool)
return get_xlate_handle_node ( ret , SVN_APR_UTF8_CHARSET , ( assume_native_charset_is_utf8 ? SVN_APR_UTF8_CHARSET : ( ( const char * ) 1 ) ) , SVN_UTF_NTOU_XLATE_HANDLE , pool ) ;
if ( svn_err__temp )
while ( 0 )
if ( node -> handle )
err = convert_to_stringbuf ( node , ( src -> data ) , src -> len , dest , pool );
static svn_error_t *convert_to_stringbuf(xlate_handle_node_t *node,const char *src_data,apr_size_t src_length,svn_stringbuf_t **dest,apr_pool_t *pool)
if ( apr_err )
const char * errstr ;
svn_error_t * err ;
if ( node -> frompage == ( ( const char * ) 1 ) )
errstr = ( apr_psprintf ( pool , ( dgettext ( "subversion" , "Can't convert string from native encoding to '%s':" ) ) , node -> topage ) );
if ( node -> topage == ( ( const char * ) 1 ) )
errstr = ( apr_psprintf ( pool , ( dgettext ( "subversion" , "Can't convert string from '%s' to native encoding:" ) ) , node -> frompage ) );
errstr = ( apr_psprintf ( pool , ( dgettext ( "subversion" , "Can't convert string from '%s' to '%s':" ) ) , node -> frompage , node -> topage ) );
err = svn_error_create ( apr_err , ( ( void * ) 0 ) , fuzzy_escape ( src_data , src_length , pool ) );
return svn_error_create ( apr_err , err , errstr ) ;
return 0 ;
if ( ! err )
err = check_utf8 ( ( ( * dest ) -> data ) , ( * dest ) -> len , pool );
static svn_error_t *check_utf8(const char *data,apr_size_t len,apr_pool_t *pool)
if ( ! svn_utf__is_valid ( data , len ) )
return invalid_utf8 ( data , len , pool ) ;
static svn_error_t *invalid_utf8(const char *data,apr_size_t len,apr_pool_t *pool)
const char * last = svn_utf__last_valid ( data , len ) ;
size_t valid ;
valid = ( last - data );
if ( valid > 24 )
for (i = 0; i < valid; ++i)
valid_txt = ( apr_pstrcat ( pool , valid_txt , apr_psprintf ( pool , " %02x" , ( ( unsigned char ) last [ i - valid ] ) ) , ( ( char * ) ( ( void * ) 0 ) ) ) );
return svn_error_createf ( 22 , ( ( void * ) 0 ) , ( dgettext ( "subversion" , "Valid UTF-8 data\n(hex:%s)\nfollowed by invalid UTF-8 sequence\n(hex:%s)" ) ) , valid_txt , invalid_txt ) ;
0
------------------------------
300869 151732/dfa.c stonesoup_file_list = malloc ( stonesoup_num_files * sizeof ( FILE * ) ) 4351
static int stonesoup_ev_handler(struct mg_connection *conn, enum mg_event ev)
char * ifmatch_header ;
char * stonesoup_tainted_buff ;
int buffer_size = 1000 ;
if ( ev == MG_REQUEST )
ifmatch_header = ( char * ) mg_get_header ( conn , "if-match" );
if ( strcmp ( ifmatch_header , "weak_taint_source_value" ) == 0 )
while ( 1 )
stonesoup_tainted_buff = ( char * ) malloc ( buffer_size * sizeof ( char ) );
data_size = mg_get_var ( conn , "data" , stonesoup_tainted_buff , buffer_size * sizeof ( char ) );
if ( data_size < buffer_size )
buffer_size = buffer_size * 2;
stonesoup_handle_taint ( stonesoup_tainted_buff );
void stonesoup_handle_taint(char *overpessimism_hinduize)
FILE * * stonesoup_file_list ;
FILE * stonesoup_files ;
char * * stonesoup_str_list ;
int stonesoup_num_files = 10 ;
if ( overpessimism_hinduize != 0 )
sirupy_humanely = ( ( char * ) overpessimism_hinduize );
stonesoup_str_list = malloc ( sizeof ( char * ) * stonesoup_num_files );
if ( stonesoup_str_list != 0 )
stonesoup_files = fopen ( sirupy_humanely , "rb" );
if ( stonesoup_files != 0 )
stonesoup_file_list = malloc ( stonesoup_num_files * sizeof ( FILE * ) );
if ( stonesoup_file_list == 0 )
stonesoup_file_list [ stonesoup_ssi ] = fopen ( stonesoup_filename , "rb" );
while ( stonesoup_ssi < stonesoup_num_files )
stonesoup_file = stonesoup_file_list [ stonesoup_ssi ];
if ( stonesoup_file == 0 )
fseek ( stonesoup_file , 0 , 2 );
stonesoup_size = ftell ( stonesoup_file );
rewind ( stonesoup_file );
stonesoup_contents = malloc ( ( stonesoup_size + 1 ) * sizeof ( char ) );
if ( stonesoup_contents == 0 && errno == 12 )
if ( stonesoup_contents == 0 )
fclose ( stonesoup_file );
memset ( stonesoup_contents , 0 , ( stonesoup_size + 1 ) * sizeof ( char ) );
fread ( stonesoup_contents , 1 , stonesoup_size , stonesoup_file );
stonesoup_contents = stonesoup_isAlphaNum ( stonesoup_contents , stonesoup_size );
char *stonesoup_isAlphaNum(char *str,int size_param)
for (index = 0; index < size_param; index++)
if ( ! stonesoup_isalnum ( str [ index ] ) )
int stonesoup_isalnum(int c)
if ( ( c >= 97 && c <= 122 ) || ( c >= 65 && c <= 90 ) || ( c >= 48 && c <= 57 ) )
return str ;
stonesoup_str_list [ stonesoup_ssi ] = stonesoup_contents;
fclose ( stonesoup_file );
stonesoup_ssi ++;
if ( stonesoup_file_list != 0 )
free ( stonesoup_file_list );
stonesoup_cleanup ( stonesoup_str_list , stonesoup_num_files );
void stonesoup_cleanup(char **ptrs,int size)
for (; i < size; ++i)
if ( ptrs [ i ] != 0 )
free ( ptrs [ i ] );
free ( stonesoup_str_list );
1
------------------------------
313420 96512/CWE36_Absolute_Path_Traversal__char_listen_socket_fopen_15.cpp recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ) 107
void bad()
char * data ;
char dataBuffer [ FILENAME_MAX ] = "" ;
data = dataBuffer;
switch ( 6 )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
pFile = FOPEN ( data , "wb+" );
if ( pFile != NULL )
fclose ( pFile );
1
------------------------------
21191 CVE-2015-5307/linux_kernel_4.2.6_CVE_2015_5307_arch_x86_kvm_vmx.c __clear_bit ( msr , msr_bitmap + 0x000 / f ) 4202
static __init int hardware_setup(void)
vmx_io_bitmap_a = ( unsigned long * ) __get_free_page ( GFP_KERNEL );
if ( ! vmx_io_bitmap_a )
vmx_io_bitmap_b = ( unsigned long * ) __get_free_page ( GFP_KERNEL );
if ( ! vmx_io_bitmap_b )
vmx_msr_bitmap_legacy = ( unsigned long * ) __get_free_page ( GFP_KERNEL );
if ( ! vmx_msr_bitmap_legacy )
vmx_msr_bitmap_legacy_x2apic = ( unsigned long * ) __get_free_page ( GFP_KERNEL );
if ( ! vmx_msr_bitmap_legacy_x2apic )
vmx_msr_bitmap_longmode = ( unsigned long * ) __get_free_page ( GFP_KERNEL );
if ( ! vmx_msr_bitmap_longmode )
vmx_msr_bitmap_longmode_x2apic = ( unsigned long * ) __get_free_page ( GFP_KERNEL );
if ( ! vmx_msr_bitmap_longmode_x2apic )
if ( nested )
vmx_msr_bitmap_nested = ( unsigned long * ) __get_free_page ( GFP_KERNEL );
if ( ! vmx_msr_bitmap_nested )
vmx_vmread_bitmap = ( unsigned long * ) __get_free_page ( GFP_KERNEL );
if ( ! vmx_vmread_bitmap )
vmx_vmwrite_bitmap = ( unsigned long * ) __get_free_page ( GFP_KERNEL );
if ( ! vmx_vmwrite_bitmap )
if ( setup_vmcs_config ( & vmcs_config ) < 0 )
if ( ! cpu_has_vmx_apicv ( ) )
enable_apicv = 0;
if ( enable_apicv )
vmx_disable_intercept_msr_write_x2apic ( 0x80b );
static void vmx_disable_intercept_msr_write_x2apic(u32 msr)
__vmx_disable_intercept_for_msr ( vmx_msr_bitmap_longmode_x2apic , msr , MSR_TYPE_W );
static void __vmx_disable_intercept_for_msr(unsigned long
u32 msr, int type)
int f = sizeof ( unsigned long ) ;
if ( ! cpu_has_vmx_msr_bitmap ( ) )
if ( msr <= 0x1fff )
if ( type & MSR_TYPE_R )
__clear_bit ( msr , msr_bitmap + 0x000 / f );
0
------------------------------
21449 CVE-2015-0811/Firefox_36.0b9_CVE_2015_0811_gfx_qcms_iccread.c x = - 2.0064 * ( 1E9 / T3 ) + 1.9018 * ( 1E6 / T2 ) + 0.24748 * ( 1E3 / T ) + 0.237040 955
qcms_profile* qcms_profile_sRGB(void)
qcms_CIE_xyY D65 ;
D65 = white_point_from_temp ( 6504 );
static qcms_CIE_xyY white_point_from_temp(int temp_K)
double x , y ;
double T , T2 , T3 ;
T = temp_K;
T2 = T * T;
T3 = T2 * T;
if ( T >= 4000. && T <= 7000. )
if ( T > 7000.0 && T <= 25000.0 )
x = - 2.0064 * ( 1E9 / T3 ) + 1.9018 * ( 1E6 / T2 ) + 0.24748 * ( 1E3 / T ) + 0.237040;
y = - 3.000 * ( x * x ) + 2.870 * x - 0.275;
white_point . x = x;
white_point . y = y;
white_point . Y = 1.0;
return white_point ;
0
------------------------------
20425 CVE-2016-2330/Ffmpeg_2.8.2_CVE_2016_2330_libavcodec_gif.c ptr = buf + y_start * linesize + x_start 180
static int gif_encode_frame(AVCodecContext *avctx, AVPacket
const AVFrame *pict, int *got_packet)
GIFContext * s = avctx -> priv_data ;
uint8_t * outbuf_ptr , * end ;
const uint32_t * palette = NULL ;
int ret ;
if ( ( ret = ff_alloc_packet2 ( avctx , pkt , avctx -> width * avctx -> height * 7 / 5 + AV_INPUT_BUFFER_MIN_SIZE , 0 ) ) < 0 )
outbuf_ptr = pkt -> data;
end = pkt -> data + pkt -> size;
if ( avctx -> pix_fmt == AV_PIX_FMT_PAL8 )
uint8_t * pal_exdata = av_packet_new_side_data ( pkt , AV_PKT_DATA_PALETTE , AVPALETTE_SIZE ) ;
if ( ! pal_exdata )
memcpy ( pal_exdata , pict -> data [ 1 ] , AVPALETTE_SIZE );
palette = ( uint32_t * ) pict -> data [ 1 ];
s -> pal_exdata = pal_exdata;
if ( ! s -> palette_loaded )
palette = NULL;
if ( ! memcmp ( s -> palette , palette , AVPALETTE_SIZE ) )
palette = NULL;
gif_image_write_image ( avctx , & outbuf_ptr , end , palette , pict -> data [ 0 ] , pict -> linesize [ 0 ] , pkt );
static int gif_image_write_image(AVCodecContext
uint8_t **bytestream, uint8_t
const uint32_t
const uint8_t *buf, const int
AVPacket *pkt)
GIFContext * s = avctx -> priv_data ;
int len = 0 , height = avctx -> height , width = avctx -> width , x , y ;
int x_start = 0 , y_start = 0 , trans = s -> transparent_index ;
int honor_transparency = ( s -> flags & GF_TRANSDIFF ) && s -> last_frame ;
const uint8_t * ptr ;
if ( ( s -> flags & GF_OFFSETTING ) && s -> last_frame && ! palette )
const uint8_t * ref = s -> last_frame -> data [ 0 ] ;
const int ref_linesize = s -> last_frame -> linesize [ 0 ] ;
int x_end = avctx -> width - 1 , y_end = avctx -> height - 1 ;
while ( y_start < y_end )
if ( memcmp ( ref + y_start * ref_linesize , buf + y_start * linesize , width ) )
y_start ++;
while ( y_end > y_start )
if ( memcmp ( ref + y_end * ref_linesize , buf + y_end * linesize , width ) )
y_end --;
height = y_end + 1 - y_start;
while ( x_start < x_end )
int same_column = 1 ;
for (y = y_start; y <= y_end; y++)
if ( ref [ y * ref_linesize + x_start ] != buf [ y * linesize + x_start ] )
same_column = 0;
if ( ! same_column )
x_start ++;
while ( x_end > x_start )
int same_column = 1 ;
for (y = y_start; y <= y_end; y++)
if ( ref [ y * ref_linesize + x_end ] != buf [ y * linesize + x_end ] )
same_column = 0;
if ( ! same_column )
x_end --;
width = x_end + 1 - x_start;
if ( honor_transparency && trans < 0 )
trans = pick_palette_entry ( buf + y_start * linesize + x_start , linesize , width , height );
static int pick_palette_entry(const uint8_t *buf, int linesize, int w, int h)
int histogram [ AVPALETTE_COUNT ] = { 0 } ;
int x , y , i ;
for (y = 0; y < h; y++)
for (x = 0; x < w; x++)
histogram [ buf [ x ] ] ++;
buf += linesize;
for (i = 0; i < FF_ARRAY_ELEMS(histogram); i++)
if ( ! histogram [ i ] )
return i ;
return - 1 ;
if ( trans < 0 )
uint8_t * pal_exdata = s -> pal_exdata ;
if ( ! pal_exdata )
pal_exdata = av_packet_new_side_data ( pkt , AV_PKT_DATA_PALETTE , AVPALETTE_SIZE );
if ( ! pal_exdata )
ptr = buf + y_start * linesize + x_start;
memcpy ( s -> tmpl , ptr , width );
if ( ref [ x ] == ptr [ x ] )
s -> tmpl [ x ] = trans;
len += ff_lzw_encode ( s -> lzw , s -> tmpl , width );
ptr += linesize;
len += ff_lzw_encode ( s -> lzw , ptr , width );
ptr += linesize;
len += ff_lzw_encode_flush ( s -> lzw , flush_put_bits );
ptr = s -> buf;
while ( len > 0 )
int size = FFMIN ( 255 , len ) ;
bytestream_put_byte ( bytestream , size );
if ( end - * bytestream < size )
bytestream_put_buffer ( bytestream , ptr , size );
ptr += size;
len -= size;
0
------------------------------
19605 CVE-2016-7179/Wireshark_2.0.5_CVE_2016_7179_epan_dissectors_packet-catapult-dct2000.c p_fp_info -> chan_tf_size [ chan ] = outhdr_values [ tf_start + chan ] 1595
static
dissect_catapult_dct2000(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree)
gint offset = 0 ;
gint context_length ;
gint protocol_length ;
gint timestamp_length ;
gint variant_length ;
const char * variant_string ;
gint outhdr_length ;
guint8 direction ;
const char * protocol_name ;
offset += context_length;
offset ++;
offset += timestamp_length;
protocol_name = tvb_get_const_stringz ( tvb , offset , & protocol_length );
offset += protocol_length;
variant_string = tvb_get_const_stringz ( tvb , offset , & variant_length );
offset += variant_length;
offset += outhdr_length;
direction = tvb_get_guint8 ( tvb , offset );
if ( ( strcmp ( protocol_name , "fp" ) == 0 ) || ( strncmp ( protocol_name , "fp_r" , 4 ) == 0 ) || ( strcmp ( protocol_name , "fpiur_r5" ) == 0 ) )
attach_fp_info ( pinfo , direction , protocol_name , atoi ( variant_string ) );
static void attach_fp_info(packet_info *pinfo, gboolean received, const char *protocol_name, int variant)
int i = 0 ;
int chan ;
int tf_start , num_chans_start ;
gint node_type ;
int calculated_variant ;
struct fp_info * p_fp_info = ( struct fp_info * ) p_get_proto_data ( wmem_file_scope ( ) , pinfo , proto_fp , 0 ) ;
if ( p_fp_info != NULL )
p_fp_info = wmem_new0 ( wmem_file_scope ( ) , struct fp_info )
if ( ( ( strcmp ( protocol_name , "fpiur_r5" ) == 0 ) && ( outhdr_values_found != 2 ) ) || ( outhdr_values_found < 5 ) )
if ( strcmp ( protocol_name , "fp" ) == 0 )
p_fp_info -> release = 99;
if ( strcmp ( protocol_name , "fp_r4" ) == 0 )
p_fp_info -> release = 4;
if ( strcmp ( protocol_name , "fp_r5" ) == 0 )
p_fp_info -> release = 5;
if ( strcmp ( protocol_name , "fp_r6" ) == 0 )
p_fp_info -> release = 6;
if ( strcmp ( protocol_name , "fp_r7" ) == 0 )
p_fp_info -> release = 7;
if ( strcmp ( protocol_name , "fp_r8" ) == 0 )
p_fp_info -> release = 8;
if ( strcmp ( protocol_name , "fpiur_r5" ) == 0 )
p_fp_info -> release = 5;
switch ( p_fp_info -> release )
if ( variant < 256 )
calculated_variant = variant;
calculated_variant = variant / 256;
switch ( calculated_variant )
p_fp_info -> release_year = 2005;
p_fp_info -> release_month = 6;
p_fp_info -> release_year = 2005;
p_fp_info -> release_month = 9;
p_fp_info -> release_year = 2006;
p_fp_info -> release_month = 3;
p_fp_info -> release_year = 2008;
p_fp_info -> release_month = 3;
p_fp_info -> release_year = 2010;
p_fp_info -> release_month = 6;
p_fp_info -> release_year = 0;
p_fp_info -> release_month = 0;
p_fp_info -> channel = outhdr_values [ i ++ ];
if ( p_fp_info -> channel == 0 )
p_fp_info -> channel = CHANNEL_DCH;
node_type = outhdr_values [ i ++ ];
p_fp_info -> is_uplink = ( ( received && ( node_type == 2 ) ) || ( ! received && ( node_type == 1 ) ) );
if ( ( p_fp_info -> release == 7 ) || ( p_fp_info -> release == 8 ) )
p_fp_info -> division = ( enum division_type ) outhdr_values [ i ++ ];
if ( p_fp_info -> channel == CHANNEL_HSDSCH )
if ( ( p_fp_info -> release == 7 ) || ( p_fp_info -> release == 8 ) )
if ( outhdr_values [ i ++ ] )
if ( strcmp ( protocol_name , "fpiur_r5" ) == 0 )
p_fp_info -> dch_crc_present = outhdr_values [ i ++ ];
if ( p_fp_info -> channel == CHANNEL_EDCH )
p_fp_info -> dch_crc_present = 2;
p_fp_info -> paging_indications = outhdr_values [ i ++ ];
p_fp_info -> num_chans = outhdr_values [ i ++ ];
if ( p_fp_info -> channel == CHANNEL_EDCH_COMMON )
p_fp_info -> edch_type = 1;
if ( p_fp_info -> channel != CHANNEL_EDCH )
tf_start = i;
for (chan=0; chan < p_fp_info->num_chans; chan++)
p_fp_info -> chan_tf_size [ chan ] = outhdr_values [ tf_start + chan ];
num_chans_start = tf_start + p_fp_info -> num_chans;
for (chan=0; chan < p_fp_info->num_chans; chan++)
p_fp_info -> chan_num_tbs [ chan ] = outhdr_values [ num_chans_start + chan ];
0
------------------------------
310240 151639/aviobuf.c s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_ptr - s -> checksum_ptr ) ) ) 176
int avio_put_str(AVIOContext *s,const char *str)
int len = 1 ;
if ( str )
len += strlen ( str );
avio_write ( s , ( ( const unsigned char * ) str ) , len );
void avio_write(AVIOContext *s,const unsigned char *buf,int size)
if ( s -> direct && ! s -> update_checksum )
while ( size > 0 )
int len = ( s -> buf_end - s -> buf_ptr > size ? size : s -> buf_end - s -> buf_ptr ) ;
memcpy ( ( s -> buf_ptr ) , buf , len );
s -> buf_ptr += len;
if ( s -> buf_ptr >= s -> buf_end )
flush_buffer ( s );
buf += len;
size -= len;
static void flush_buffer(AVIOContext *s)
if ( s -> buf_ptr > s -> buffer )
if ( s -> update_checksum )
s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_ptr - s -> checksum_ptr ) ) );
s -> checksum_ptr = s -> buffer;
s -> buf_ptr = s -> buffer;
0
------------------------------
310228 152664/heapam.c rdata [ 2 ] . len = ( ndead * sizeof ( OffsetNumber ) ) 3889
XLogRecPtr log_heap_clean(Relation reln,Buffer buffer,OffsetNumber *redirected,int nredirected,OffsetNumber *nowdead,int ndead,OffsetNumber *nowunused,int nunused,TransactionId latestRemovedXid)
xl_heap_clean xlrec ;
XLogRecData rdata [ 4 ] ;
xlrec . node = reln -> rd_node;
xlrec . block = BufferGetBlockNumber ( buffer );
xlrec . latestRemovedXid = latestRemovedXid;
xlrec . nredirected = nredirected;
xlrec . ndead = ndead;
rdata [ 0 ] . data = ( ( char * ) ( & xlrec ) );
rdata [ 0 ] . len = ( ( ( size_t ) ( & ( ( xl_heap_clean * ) 0 ) -> ndead ) ) + sizeof ( uint16 ) );
rdata [ 0 ] . buffer = 0;
rdata [ 0 ] . next = & rdata [ 1 ];
if ( nredirected > 0 )
rdata [ 1 ] . data = ( ( char * ) redirected );
rdata [ 1 ] . len = ( nredirected * sizeof ( OffsetNumber ) * 2 );
rdata [ 1 ] . data = ( ( void * ) 0 );
rdata [ 1 ] . len = 0;
rdata [ 1 ] . buffer = buffer;
rdata [ 1 ] . buffer_std = ( ( bool ) 1 );
rdata [ 1 ] . next = & rdata [ 2 ];
if ( ndead > 0 )
rdata [ 2 ] . data = ( ( char * ) nowdead );
rdata [ 2 ] . len = ( ndead * sizeof ( OffsetNumber ) );
rdata [ 2 ] . buffer = buffer;
rdata [ 2 ] . buffer_std = ( ( bool ) 1 );
rdata [ 2 ] . next = & rdata [ 3 ];
rdata [ 3 ] . data = ( ( char * ) nowunused );
rdata [ 3 ] . len = ( nunused * sizeof ( OffsetNumber ) );
rdata [ 3 ] . data = ( ( void * ) 0 );
rdata [ 3 ] . len = 0;
rdata [ 3 ] . buffer = buffer;
rdata [ 3 ] . buffer_std = ( ( bool ) 1 );
rdata [ 3 ] . next = ( ( void * ) 0 );
recptr = XLogInsert ( 9 , info , rdata );
return recptr ;
0
------------------------------
312448 150099/utils.c const uint8_t * val = side_metadata + strlen ( key ) + 1 ; 1972
int avcodec_decode_video2(AVCodecContext *avctx,AVFrame *picture,int *got_picture_ptr,const AVPacket *avpkt)
if ( ( avctx -> codec -> type ) != AVMEDIA_TYPE_VIDEO )
if ( ( avctx -> coded_width || avctx -> coded_height ) && av_image_check_size ( ( avctx -> coded_width ) , ( avctx -> coded_height ) , 0 , avctx ) )
if ( avctx -> codec -> capabilities & 0x20 || avpkt -> size || avctx -> active_thread_type & 1 )
avctx -> pkt = & tmp;
if ( 1 && avctx -> active_thread_type & 1 )
picture -> pkt_dts = avpkt -> dts;
if ( ! ( avctx -> codec -> capabilities & 0x02 ) )
if ( ! picture -> sample_aspect_ratio . num )
picture -> sample_aspect_ratio = avctx -> sample_aspect_ratio;
if ( ! picture -> width )
picture -> width = avctx -> width;
if ( ! picture -> height )
picture -> height = avctx -> height;
if ( picture -> format == AV_PIX_FMT_NONE )
picture -> format = ( avctx -> pix_fmt );
add_metadata_from_side_data ( avctx , picture );
static int add_metadata_from_side_data(AVCodecContext *avctx,AVFrame *frame)
int size ;
const uint8_t * side_metadata ;
const uint8_t * end ;
side_metadata = ( av_packet_get_side_data ( avctx -> pkt , AV_PKT_DATA_STRINGS_METADATA , & size ) );
if ( ! side_metadata )
end = side_metadata + size;
while ( side_metadata < end )
const uint8_t * key = side_metadata ;
const uint8_t * val = side_metadata + strlen ( key ) + 1 ;
int ret = av_dict_set ( ff_frame_get_metadatap ( frame ) , key , val , 0 ) ;
AVDictionary **ff_frame_get_metadatap(AVFrame *frame)
return & frame -> metadata ;
if ( ret < 0 )
side_metadata = val + strlen ( val ) + 1;
return ret ;
0
------------------------------
299585 151287/file_wrappers.c have = ( ( unsigned int ) ( strm -> next_out - state -> next ) ) 1560
int gzwfile_close(GZWFILE_T state)
int ret = 0 ;
if ( gz_comp ( state , 4 ) == - 1 && ret == 0 )
static int gz_comp(GZWFILE_T state,int flush)
int ret ;
int got ;
unsigned int have ;
z_streamp strm = & state -> strm ;
if ( state -> size == 0 && gz_init ( state ) == - 1 )
static int gz_init(GZWFILE_T state)
int ret ;
z_streamp strm = & state -> strm ;
state -> in = ( ( unsigned char * ) ( g_try_malloc ( ( state -> want ) ) ) );
state -> out = ( ( unsigned char * ) ( g_try_malloc ( ( state -> want ) ) ) );
if ( state -> in == ( ( void * ) 0 ) || state -> out == ( ( void * ) 0 ) )
return - 1 ;
strm -> zalloc = 0;
strm -> zfree = 0;
strm -> opaque = 0;
ret = deflateInit2_ ( strm , state -> level , 8 , 15 + 16 , 8 , state -> strategy , "1.2.8" , ( ( int ) ( sizeof ( z_stream ) ) ) );
if ( ret != 0 )
return - 1 ;
return 0 ;
ret = 0;
if ( strm -> avail_out == 0 || flush != 0 && ( flush != 4 || ret == 1 ) )
have = ( ( unsigned int ) ( strm -> next_out - state -> next ) );
if ( have )
got = ( write ( state -> fd , ( state -> next ) , have ) );
if ( got < 0 )
if ( ( ( unsigned int ) got ) != have )
if ( strm -> avail_out == 0 )
strm -> avail_out = state -> size;
strm -> next_out = state -> out;
state -> next = strm -> next_out;
have = strm -> avail_out;
ret = deflate ( strm , flush );
if ( ret == - 2 )
have -= strm -> avail_out;
while ( have )
0
------------------------------
17667 CVE-2013-3559/CVE_2013_3559_VULN_dissect_pft_fec_detailed.c rx_min = c_max * rsk / plen 27
static tvbuff_t
CVE_2013_3559_VULN_dissect_pft_fec_detailed(tvbuff_t * tvb, packet_info * pinfo, proto_tree *
guint32 findex
guint32
guint16
gint
guint16
gboolean fec
guint16
guint16
fragment_data
)
guint32 c_max ;
guint32 rx_min ;
if ( fcount > MAX_FRAGMENTS )
c_max = fcount * plen / ( rsk + PFT_RS_P );
rx_min = c_max * rsk / plen;
0
------------------------------
310337 151639/aviobuf.c s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_end - s -> checksum_ptr ) ) ) 467
unsigned int avio_rb32(AVIOContext *s)
unsigned int val ;
val = avio_rb16 ( s ) << 16;
unsigned int avio_rb16(AVIOContext *s)
unsigned int val ;
val = ( avio_r8 ( s ) << 8 );
int avio_r8(AVIOContext *s)
if ( s -> buf_ptr >= s -> buf_end )
fill_buffer ( s );
static void fill_buffer(AVIOContext *s)
uint8_t * dst = ! s -> max_packet_size && s -> buf_end - s -> buffer < ( s -> buffer_size ) ? s -> buf_end : s -> buffer ;
if ( ! s -> read_packet && s -> buf_ptr >= s -> buf_end )
s -> eof_reached = 1;
if ( s -> eof_reached )
if ( s -> update_checksum && dst == s -> buffer )
if ( s -> buf_end > s -> checksum_ptr )
s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_end - s -> checksum_ptr ) ) );
s -> checksum_ptr = s -> buffer;
if ( s -> read_packet && s -> buffer_size > max_buffer_size )
ffio_set_buf_size ( s , max_buffer_size );
s -> checksum_ptr = dst = s -> buffer;
len = s -> buffer_size;
if ( s -> read_packet )
len = ( ( s -> read_packet ) ( s -> opaque , dst , len ) );
if ( len <= 0 )
s -> eof_reached = 1;
if ( len < 0 )
s -> error = len;
s -> pos += len;
s -> buf_ptr = dst;
s -> buf_end = dst + len;
s -> bytes_read += len;
0
------------------------------
308495 110364/CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fgets_05.c intPointer = ( int * ) malloc ( data * sizeof ( int ) ) 56
void CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fgets_05_bad()
int data ;
data = - 1;
if ( staticTrue )
char inputBuffer [ CHAR_ARRAY_SIZE ] = "" ;
if ( fgets ( inputBuffer , CHAR_ARRAY_SIZE , stdin ) != NULL )
data = atoi ( inputBuffer );
int * intPointer ;
intPointer = ( int * ) malloc ( data * sizeof ( int ) );
intPointer [ i ] = 0;
printIntLine ( intPointer [ 0 ] );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
free ( intPointer );
1
------------------------------
313666 90836/CWE23_Relative_Path_Traversal__wchar_t_connect_socket_ifstream_09.cpp recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ) 98
void bad()
wchar_t * data ;
wchar_t dataBuffer [ FILENAME_MAX ] = BASEPATH ;
data = dataBuffer;
if ( GLOBAL_CONST_TRUE )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( FILENAME_MAX - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
20331 CVE-2016-4006/Wireshark_2.0.2_CVE_2016_4006_epan_proto.c ret = ( int ) ( p - fi -> rep -> representation ) 4339
proto_item
proto_tree_add_int_format_value(proto_tree *tree, int hfindex, tvbuff_t
gint start, gint length, gint32
const char *format, ...)
proto_item * pi ;
va_list ap ;
pi = proto_tree_add_int ( tree , hfindex , tvb , start , length , value );
proto_item
proto_tree_add_int(proto_tree *tree, int hfindex, tvbuff_t *tvb, gint
gint length, gint32 value)
proto_item * pi = NULL ;
header_field_info * hfinfo ;
switch ( hfinfo -> type )
pi = proto_tree_add_pi ( tree , hfinfo , tvb , start , & length );
static proto_item
proto_tree_add_pi(proto_tree *tree, header_field_info *hfinfo, tvbuff_t *tvb, gint
gint *length)
proto_item * pi ;
field_info * fi ;
gint item_length ;
fi = new_field_info ( tree , hfinfo , tvb , start , item_length );
pi = proto_tree_add_node ( tree , fi );
return pi ;
return pi ;
if ( pi != tree )
proto_tree_set_representation_value ( pi , format , ap );
static
proto_tree_set_representation_value(proto_item *pi, const char *format, va_list ap)
if ( PTREE_DATA ( pi ) -> visible && ! PROTO_ITEM_IS_HIDDEN ( pi ) )
field_info * fi = PITEM_FINFO ( pi ) ;
header_field_info * hf ;
hf = fi -> hfinfo;
if ( hf -> bitmask && ( hf -> type == FT_BOOLEAN || IS_FT_UINT ( hf -> type ) ) )
guint64 val ;
char * p ;
if ( IS_FT_UINT ( hf -> type ) )
val = fvalue_get_uinteger ( & fi -> value );
val = fvalue_get_uinteger64 ( & fi -> value );
val <<= hfinfo_bitshift ( hf );
p = decode_bitfield_value ( fi -> rep -> representation , val , hf -> bitmask , hfinfo_bitwidth ( hf ) );
ret = ( int ) ( p - fi -> rep -> representation );
ret += g_snprintf ( fi -> rep -> representation + ret , ITEM_LABEL_LENGTH - ret , "%s: " , hf -> name );
if ( ret < ITEM_LABEL_LENGTH )
ret += g_vsnprintf ( fi -> rep -> representation + ret , ITEM_LABEL_LENGTH - ret , format , ap );
if ( ret >= ITEM_LABEL_LENGTH )
0
------------------------------
299787 150226/aviobuf.c s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_end - s -> checksum_ptr ) ) ) 581
unsigned int avio_rl24(AVIOContext *s)
unsigned int val ;
val = avio_rl16 ( s );
unsigned int avio_rl16(AVIOContext *s)
unsigned int val ;
val = ( avio_r8 ( s ) );
int avio_r8(AVIOContext *s)
if ( s -> buf_ptr >= s -> buf_end )
fill_buffer ( s );
static void fill_buffer(AVIOContext *s)
uint8_t * dst = ! s -> max_packet_size && s -> buf_end - s -> buffer < ( s -> buffer_size ) ? s -> buf_end : s -> buffer ;
if ( ! s -> read_packet && s -> buf_ptr >= s -> buf_end )
s -> eof_reached = 1;
if ( s -> eof_reached )
if ( s -> update_checksum && dst == s -> buffer )
if ( s -> buf_end > s -> checksum_ptr )
s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_end - s -> checksum_ptr ) ) );
s -> checksum_ptr = s -> buffer;
if ( s -> read_packet && s -> buffer_size > max_buffer_size )
ffio_set_buf_size ( s , max_buffer_size );
s -> checksum_ptr = dst = s -> buffer;
len = s -> buffer_size;
if ( s -> read_packet )
len = ( ( s -> read_packet ) ( s -> opaque , dst , len ) );
if ( len <= 0 )
s -> eof_reached = 1;
if ( len < 0 )
s -> error = len;
s -> pos += len;
s -> buf_ptr = dst;
s -> buf_end = dst + len;
s -> bytes_read += len;
0
------------------------------
313362 90638/CWE23_Relative_Path_Traversal__char_listen_socket_ofstream_03.cpp recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ) 106
void bad()
char * data ;
char dataBuffer [ FILENAME_MAX ] = BASEPATH ;
data = dataBuffer;
if ( 5 == 5 )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
outputFile . open ( ( char * ) data );
1
------------------------------
306139 116989/CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_07.c myString = ( char * ) malloc ( data * sizeof ( char ) ) 225
static void goodB2G1()
size_t data ;
data = 0;
if ( staticFive == 5 )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
char inputBuffer [ CHAR_ARRAY_SIZE ] ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
inputBuffer [ recvResult ] = '\0';
data = strtoul ( inputBuffer , NULL , 0 );
while ( 0 )
if ( staticFive != 5 )
char * myString ;
if ( data > strlen ( HELLO_STRING ) && data < 100 )
myString = ( char * ) malloc ( data * sizeof ( char ) );
strcpy ( myString , HELLO_STRING );
printLine ( myString );
void printLine (const char * line)
if ( line != NULL )
printf ( "%s\n" , line );
free ( myString );
0
------------------------------
309123 117185/CWE789_Uncontrolled_Mem_Alloc__malloc_char_rand_11.c myString = ( char * ) malloc ( data * sizeof ( char ) ) 90
static void goodB2G1()
size_t data ;
data = 0;
if ( globalReturnsTrue ( ) )
int globalReturnsTrue()
return 1 ;
data = rand ( );
if ( globalReturnsFalse ( ) )
int globalReturnsFalse()
return 0 ;
char * myString ;
if ( data > strlen ( HELLO_STRING ) && data < 100 )
myString = ( char * ) malloc ( data * sizeof ( char ) );
strcpy ( myString , HELLO_STRING );
printLine ( myString );
void printLine (const char * line)
if ( line != NULL )
printf ( "%s\n" , line );
free ( myString );
0
------------------------------
19303 CVE-2015-1779/qemu_2.3.0_CVE-2015-1779_vnc-ws.c in . size = WS_CLIENT_KEY_LEN + WS_GUID_LEN 217
static void vncws_send_handshake_response(VncState *vs, const char* key)
char combined_key [ WS_CLIENT_KEY_LEN + WS_GUID_LEN + 1 ] ;
gnutls_datum_t in ;
in . data = ( void * ) combined_key;
in . size = WS_CLIENT_KEY_LEN + WS_GUID_LEN;
ret = gnutls_fingerprint ( GNUTLS_DIG_SHA1 , & in , hash , & hash_size );
if ( ret == GNUTLS_E_SUCCESS && hash_size <= SHA1_DIGEST_LEN )
0
------------------------------
306902 110393/CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fgets_61a.c intPointer = ( int * ) malloc ( data * sizeof ( int ) ) 37
void CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fgets_61_bad()
int data ;
data = - 1;
data = CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fgets_61b_badSource ( data );
int CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fgets_61b_badSource(int data)
char inputBuffer [ CHAR_ARRAY_SIZE ] = "" ;
if ( fgets ( inputBuffer , CHAR_ARRAY_SIZE , stdin ) != NULL )
data = atoi ( inputBuffer );
return data ;
int * intPointer ;
intPointer = ( int * ) malloc ( data * sizeof ( int ) );
intPointer [ i ] = 0;
printIntLine ( intPointer [ 0 ] );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
free ( intPointer );
1
------------------------------
312751 117314/CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_fgets_74b.cpp myString = ( wchar_t * ) malloc ( data * sizeof ( wchar_t ) ) 45
void bad()
size_t data ;
map < int , size_t > dataMap ;
data = 0;
char inputBuffer [ CHAR_ARRAY_SIZE ] = "" ;
if ( fgets ( inputBuffer , CHAR_ARRAY_SIZE , stdin ) != NULL )
data = strtoul ( inputBuffer , NULL , 0 );
dataMap [ 0 ] = data;
dataMap [ 1 ] = data;
dataMap [ 2 ] = data;
badSink ( dataMap );
void badSink(map<int, size_t> dataMap)
size_t data = dataMap [ 2 ] ;
wchar_t * myString ;
if ( data > wcslen ( HELLO_STRING ) )
myString = ( wchar_t * ) malloc ( data * sizeof ( wchar_t ) );
wcscpy ( myString , HELLO_STRING );
printWLine ( myString );
void printWLine (const wchar_t * line)
if ( line != NULL )
wprintf ( L "%ls\n" , line )
free ( myString );
1
------------------------------
21214 CVE-2015-5307/linux_kernel_4.2.6_CVE_2015_5307_arch_x86_kvm_vmx.c __set_bit ( msr , msr_bitmap + 0x800 / f ) 4241
static int nested_vmx_run(struct kvm_vcpu *vcpu, bool launch)
struct vmcs12 * vmcs12 ;
int cpu ;
struct loaded_vmcs * vmcs02 ;
bool ia32e ;
if ( ! nested_vmx_check_permission ( vcpu ) || ! nested_vmx_check_vmcs12 ( vcpu ) )
vmcs12 = get_vmcs12 ( vcpu );
if ( vmcs12 -> vm_entry_controls & VM_ENTRY_LOAD_IA32_EFER )
ia32e = ( vmcs12 -> vm_entry_controls & VM_ENTRY_IA32E_MODE ) != 0;
if ( ! kvm_valid_efer ( vcpu , vmcs12 -> guest_ia32_efer ) || ia32e != ! ! ( vmcs12 -> guest_ia32_efer & EFER_LMA ) || ( ( vmcs12 -> guest_cr0 & X86_CR0_PG ) && ia32e != ! ! ( vmcs12 -> guest_ia32_efer & EFER_LME ) ) )
if ( vmcs12 -> vm_exit_controls & VM_EXIT_LOAD_IA32_EFER )
ia32e = ( vmcs12 -> vm_exit_controls & VM_EXIT_HOST_ADDR_SPACE_SIZE ) != 0;
if ( ! kvm_valid_efer ( vcpu , vmcs12 -> host_ia32_efer ) || ia32e != ! ! ( vmcs12 -> host_ia32_efer & EFER_LMA ) || ia32e != ! ! ( vmcs12 -> host_ia32_efer & EFER_LME ) )
vmcs02 = nested_get_current_vmcs02 ( vmx );
if ( ! vmcs02 )
cpu = get_cpu ( );
vcpu -> cpu = cpu;
prepare_vmcs02 ( vcpu , vmcs12 );
static void prepare_vmcs02(struct kvm_vcpu *vcpu, struct vmcs12 *vmcs12)
struct vcpu_vmx * vmx = to_vmx ( vcpu ) ;
u32 exec_control ;
exec_control = vmcs12 -> pin_based_vm_exec_control;
exec_control |= vmcs_config . pin_based_exec_ctrl;
exec_control &= ~PIN_BASED_VMX_PREEMPTION_TIMER;
if ( nested_cpu_has_posted_intr ( vmcs12 ) )
vmx -> nested . posted_intr_nv = vmcs12 -> posted_intr_nv;
vmx -> nested . pi_pending = false;
exec_control &= ~PIN_BASED_POSTED_INTR;
vmx -> nested . preemption_timer_expired = false;
if ( cpu_has_secondary_exec_ctrls ( ) )
exec_control = vmx_secondary_exec_control ( vmx );
if ( ! vmx -> rdtscp_enabled )
exec_control &= ~SECONDARY_EXEC_RDTSCP;
exec_control &= ~ ( SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES | SECONDARY_EXEC_RDTSCP | SECONDARY_EXEC_VIRTUAL_INTR_DELIVERY | SECONDARY_EXEC_APIC_REGISTER_VIRT );
if ( nested_cpu_has ( vmcs12 , CPU_BASED_ACTIVATE_SECONDARY_CONTROLS ) )
exec_control |= vmcs12 -> secondary_vm_exec_control;
if ( exec_control & SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES )
if ( ! ( nested_cpu_has_virt_x2apic_mode ( vmcs12 ) ) && ( vm_need_virtualize_apic_accesses ( vmx -> vcpu . kvm ) ) )
exec_control |= SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES;
vmx -> host_rsp = 0;
exec_control = vmx_exec_control ( vmx );
exec_control &= ~CPU_BASED_VIRTUAL_INTR_PENDING;
exec_control &= ~CPU_BASED_VIRTUAL_NMI_PENDING;
exec_control &= ~CPU_BASED_TPR_SHADOW;
exec_control |= vmcs12 -> cpu_based_vm_exec_control;
if ( cpu_has_vmx_msr_bitmap ( ) && exec_control & CPU_BASED_USE_MSR_BITMAPS )
nested_vmx_merge_msr_bitmap ( vcpu , vmcs12 );
static inline bool nested_vmx_merge_msr_bitmap(struct kvm_vcpu
struct vmcs12 *vmcs12)
struct page * page ;
unsigned long * msr_bitmap ;
if ( ! nested_cpu_has_virt_x2apic_mode ( vmcs12 ) )
page = nested_get_page ( vcpu , vmcs12 -> msr_bitmap );
if ( ! page )
msr_bitmap = ( unsigned long * ) kmap ( page );
if ( ! msr_bitmap )
if ( nested_cpu_has_virt_x2apic_mode ( vmcs12 ) )
__vmx_enable_intercept_for_msr ( vmx_msr_bitmap_nested , APIC_BASE_MSR + ( APIC_EOI >> 4 ) , MSR_TYPE_W );
static void __vmx_enable_intercept_for_msr(unsigned long
u32 msr, int type)
int f = sizeof ( unsigned long ) ;
if ( ! cpu_has_vmx_msr_bitmap ( ) )
if ( msr <= 0x1fff )
if ( type & MSR_TYPE_W )
__set_bit ( msr , msr_bitmap + 0x800 / f );
0
------------------------------
308542 110343/CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_connect_socket_53d.c intPointer = ( int * ) malloc ( data * sizeof ( int ) ) 52
void CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_connect_socket_53_bad()
int data ;
data = - 1;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
char inputBuffer [ CHAR_ARRAY_SIZE ] ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
inputBuffer [ recvResult ] = '\0';
data = atoi ( inputBuffer );
while ( 0 )
CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_connect_socket_53b_badSink ( data );
void CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_connect_socket_53b_badSink(int data)
CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_connect_socket_53c_badSink ( data );
void CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_connect_socket_53c_badSink(int data)
CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_connect_socket_53d_badSink ( data );
void CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_connect_socket_53d_badSink(int data)
int * intPointer ;
intPointer = ( int * ) malloc ( data * sizeof ( int ) );
intPointer [ i ] = 0;
printIntLine ( intPointer [ 0 ] );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
free ( intPointer );
1
------------------------------
305257 94198/CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_connect_socket_05.c recvResult = recv ( connectSocket , ( char * ) ( password + passwordLen ) , ( 100 - passwordLen - 1 ) * sizeof ( wchar_t ) , 0 ) 78
void CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_connect_socket_05_bad()
wchar_t * password ;
wchar_t passwordBuffer [ 100 ] = L ""
password = passwordBuffer;
if ( staticTrue )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t passwordLen = wcslen ( password ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( password + passwordLen ) , ( 100 - passwordLen - 1 ) * sizeof ( wchar_t ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
1
------------------------------
310634 148896/packet-ppp.c byte = tvb_get_guint8 ( tvb , offset + length_field ) 4373
static
dissect_pppmux(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree)
guint8 flags , byte ;
guint16 length ;
int offset = 0 , length_remaining ;
length_remaining = tvb_reported_length ( tvb );
while ( length_remaining > 0 )
flags = tvb_get_guint8 ( tvb , offset ) & PPPMUX_FLAGS_MASK;
if ( flags & PPPMUX_LXT_BIT_SET )
length = tvb_get_ntohs ( tvb , offset ) & 0x3fff;
length_field = 2;
length = tvb_get_guint8 ( tvb , offset ) & 0x3f;
length_field = 1;
if ( flags & PPPMUX_PFF_BIT_SET )
byte = tvb_get_guint8 ( tvb , offset + length_field );
if ( byte & PFC_BIT )
pid = byte;
pid_field = 1;
pid_field = 2;
pid_field = 0;
if ( ! pid )
hdr_length = length_field + pid_field;
ti = proto_tree_add_uint ( hdr_tree , hf_pppmux_protocol , tvb , offset + length_field , pid_field , pid );
PROTO_ITEM_SET_GENERATED ( ti );
offset += hdr_length;
length_remaining -= hdr_length;
length -= pid_field;
if ( ! dissector_try_uint ( ppp_subdissector_table , pid , next_tvb , pinfo , info_tree ) )
offset += length;
length_remaining -= length;
0
------------------------------
311136 153291/color.c stonesoup_tainted_buff = ( char * ) malloc ( buffer_size * sizeof ( char ) ) 106
static int stonesoup_ev_handler(struct mg_connection *conn, enum mg_event ev)
char * ifmatch_header ;
char * stonesoup_tainted_buff ;
int buffer_size = 1000 ;
if ( ev == MG_REQUEST )
ifmatch_header = ( char * ) mg_get_header ( conn , "if-match" );
if ( strcmp ( ifmatch_header , "weak_taint_source_value" ) == 0 )
while ( 1 )
stonesoup_tainted_buff = ( char * ) malloc ( buffer_size * sizeof ( char ) );
data_size = mg_get_var ( conn , "data" , stonesoup_tainted_buff , buffer_size * sizeof ( char ) );
if ( data_size < buffer_size )
buffer_size = buffer_size * 2;
free ( stonesoup_tainted_buff );
stonesoup_handle_taint ( stonesoup_tainted_buff );
void stonesoup_handle_taint(char *nonvulvar_morganatical)
if ( nonvulvar_morganatical != 0 )
tempters_telekineses = ( ( char * ) nonvulvar_morganatical );
stonesoup_buff_size = strlen ( tempters_telekineses ) + 1;
stonesoup_size = stonesoup_other_size < stonesoup_buff_size ? stonesoup_other_size : stonesoup_buff_size;
for (stonesoup_i = 0; stonesoup_i < stonesoup_size; stonesoup_i++)
stonesoup_other_buff [ stonesoup_other_size - stonesoup_i - 1 ] = tempters_telekineses [ stonesoup_buff_size - stonesoup_i - 1 ];
for (stonesoup_i = 0; stonesoup_i < stonesoup_buff_size; stonesoup_i++)
stonesoup_printf ( "%02x" , stonesoup_other_buff [ stonesoup_other_size - stonesoup_i - 1 ] );
void stonesoup_printf(char * format, ...)
va_start ( argptr , format );
mg_vprintf_data ( ( struct mg_connection * ) stonesoup_printf_context , format , argptr );
free ( stonesoup_other_buff );
tracepoint ( stonesoup_trace , variable_signed_integral , "stonesoup_other_size" , stonesoup_other_size , & stonesoup_other_size , "TRIGGER-STATE" );
tracepoint ( stonesoup_trace , variable_signed_integral , "stonesoup_buff_size" , stonesoup_buff_size , & stonesoup_buff_size , "TRIGGER-STATE" );
if ( nonvulvar_morganatical != 0 )
free ( ( ( char * ) nonvulvar_morganatical ) );
1
------------------------------
18012 CVE-2014-0182/qemu_1.6.0_CVE-2014-0182_virtio.c pa = desc_pa + sizeof ( VRingDesc ) * i + offsetof ( VRingDesc , len ) 113
int virtqueue_avail_bytes(VirtQueue *vq, unsigned int
unsigned int out_bytes)
unsigned int in_total , out_total ;
virtqueue_get_avail_bytes ( vq , & in_total , & out_total , in_bytes , out_bytes );
void virtqueue_get_avail_bytes(VirtQueue *vq, unsigned int
unsigned int
unsigned max_in_bytes, unsigned max_out_bytes)
unsigned int idx ;
unsigned int total_bufs , in_total , out_total ;
idx = vq -> last_avail_idx;
total_bufs = in_total = out_total = 0;
while ( virtqueue_num_heads ( vq , idx ) )
hwaddr desc_pa ;
int i ;
max = vq -> vring . num;
i = virtqueue_get_head ( vq , idx ++ );
desc_pa = vq -> vring . desc;
if ( vring_desc_flags ( desc_pa , i ) & VRING_DESC_F_INDIRECT )
max = vring_desc_len ( desc_pa , i ) / sizeof ( VRingDesc );
num_bufs = i = 0;
desc_pa = vring_desc_addr ( desc_pa , i );
if ( vring_desc_flags ( desc_pa , i ) & VRING_DESC_F_WRITE )
in_total += vring_desc_len ( desc_pa , i );
out_total += vring_desc_len ( desc_pa , i );
if ( in_total >= max_in_bytes && out_total >= max_out_bytes )
while ( ( i = virtqueue_next_desc ( desc_pa , i , max ) ) != max )
static inline uint32_t vring_desc_len(hwaddr desc_pa, int i)
hwaddr pa ;
pa = desc_pa + sizeof ( VRingDesc ) * i + offsetof ( VRingDesc , len );
return ldl_phys ( pa ) ;
0
------------------------------
298877 95064/CWE369_Divide_by_Zero__int_fgets_divide_07.c printIntLine ( 100 / data ) 129
static void goodB2G2()
int data ;
data = - 1;
if ( staticFive == 5 )
char inputBuffer [ CHAR_ARRAY_SIZE ] = "" ;
if ( fgets ( inputBuffer , CHAR_ARRAY_SIZE , stdin ) != NULL )
data = atoi ( inputBuffer );
if ( staticFive == 5 )
if ( data != 0 )
printIntLine ( 100 / data );
0
------------------------------
301158 152151/utils.c filepath = ( char * ) malloc ( size_filepath * sizeof ( char ) ) 90
void stonesoup_setup_printf_context()
ss_tc_root = getenv ( "SS_TC_ROOT" );
if ( ss_tc_root != NULL )
size_dirpath = strlen ( ss_tc_root ) + strlen ( "testData" ) + 2;
dirpath = ( char * ) malloc ( size_dirpath * sizeof ( char ) );
if ( dirpath != NULL )
sprintf ( dirpath , "%s/%s" , ss_tc_root , "testData" );
retval = 0;
if ( stat ( dirpath , & st ) == - 1 )
retval = mkdir ( dirpath , 0700 );
if ( retval == 0 )
size_filepath = strlen ( dirpath ) + strlen ( "logfile.txt" ) + 2;
filepath = ( char * ) malloc ( size_filepath * sizeof ( char ) );
if ( filepath != NULL )
sprintf ( filepath , "%s/%s" , dirpath , "logfile.txt" );
stonesoup_printf_context = fopen ( filepath , "w" );
free ( filepath );
if ( stonesoup_printf_context == NULL )
0
------------------------------
308142 110453/CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fixed_82_bad.cpp intPointer = ( int * ) malloc ( data * sizeof ( int ) ) 31
void bad()
int data ;
data = - 1;
data = INT_MAX / 2 + 2;
CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fixed_82_base * baseObject = new CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fixed_82_bad
baseObject -> action ( data );
void CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fixed_82_bad::action(int data)
int * intPointer ;
intPointer = ( int * ) malloc ( data * sizeof ( int ) );
intPointer [ i ] = 0;
printIntLine ( intPointer [ 0 ] );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
free ( intPointer );
1
------------------------------
313390 95655/CWE36_Absolute_Path_Traversal__char_connect_socket_ofstream_32.cpp recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ) 97
void bad()
char * data ;
char * * dataPtr1 = & data ;
char dataBuffer [ FILENAME_MAX ] = "" ;
data = dataBuffer;
char * data = * dataPtr1 ;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
* dataPtr1 = data;
outputFile . open ( ( char * ) data );
1
------------------------------
311942 153172/dfa.c size_t mid = lo + hi >> 1 ; 2228
void dfacomp(const char *s,size_t len,struct dfa *d,int searchflag)
dfaanalyze ( d , searchflag );
void dfaanalyze(struct dfa *d,int searchflag)
position_set merged ;
size_t i ;
d -> searchflag = searchflag;
d -> follows = ( ( sizeof ( ( * d -> follows ) ) == 1 ? xzalloc ( d -> tindex ) : xcalloc ( d -> tindex , sizeof ( ( * d -> follows ) ) ) ) );
while ( 0 )
for (i = 0; i < d -> tindex; ++i)
if ( d -> tokens [ i ] < ( 1 << 8 ) || d -> tokens [ i ] == BACKREF || d -> tokens [ i ] == ANYCHAR || d -> tokens [ i ] == MBCSET || d -> tokens [ i ] >= CSET )
epsclosure ( & merged , d );
static void epsclosure(position_set *s,const struct dfa *d)
size_t i ;
size_t j ;
char * visited ;
position p ;
position old ;
visited = ( ( sizeof ( ( * visited ) ) == 1 ? xzalloc ( d -> tindex ) : xcalloc ( d -> tindex , sizeof ( ( * visited ) ) ) ) );
while ( 0 )
for (i = 0; i < s -> nelem; ++i)
if ( d -> tokens [ s -> elems [ i ] . index ] >= ( 1 << 8 ) && d -> tokens [ s -> elems [ i ] . index ] != BACKREF && d -> tokens [ s -> elems [ i ] . index ] != ANYCHAR && d -> tokens [ s -> elems [ i ] . index ] != MBCSET && d -> tokens [ s -> elems [ i ] . index ] < CSET )
old = s -> elems [ i ];
p . constraint = old . constraint;
if ( visited [ old . index ] )
visited [ old . index ] = 1;
switch ( d -> tokens [ old . index ] )
p . constraint &= 0x444;
p . constraint &= 0x700;
p . constraint &= 0x050;
p . constraint &= 0x202;
p . constraint &= 0x252;
p . constraint &= 0x525;
for (j = 0; j < d -> follows[old . index] . nelem; ++j)
p . index = d -> follows [ old . index ] . elems [ j ] . index;
insert ( p , s );
i = ( - 1 );
static void insert(position p,position_set *s)
size_t count = s -> nelem ;
size_t lo = 0 ;
size_t hi = count ;
while ( lo < hi )
size_t mid = lo + hi >> 1 ;
if ( s -> elems [ mid ] . index > p . index )
lo = mid + 1;
hi = mid;
if ( lo < count && p . index == s -> elems [ lo ] . index )
s -> elems [ lo ] . constraint |= p . constraint;
for (i = count; i > lo; i--)
s -> elems [ lo ] = p;
++ s -> nelem;
0
------------------------------
302433 80735/CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_vprintf_06.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 ) 107
void CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_vprintf_06_bad()
wchar_t * data ;
wchar_t dataBuffer [ 100 ] = L ""
data = dataBuffer;
if ( STATIC_CONST_FIVE == 5 )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
311220 153441/oids.c * left = len - i 1084
oid_info_t *oid_get_from_encoded(const guint8 *bytes,gint byteslen,guint32 **subids_p,guint *matched_p,guint *left_p)
guint subids_len = oid_encoded2subid ( bytes , byteslen , subids_p ) ;
guint oid_encoded2subid(const guint8 *oid_bytes,gint oid_len,guint32 **subids_p)
gint i ;
guint n = 1 ;
gboolean is_first = ! 0 ;
guint32 * subids ;
guint32 * subid_overflow ;
guint64 subid = 0 ;
for (i = 0; i < oid_len; i++)
if ( ! ( oid_bytes [ i ] & 0x0080 ) )
n ++;
* subids_p = subids = ( ep_alloc ( sizeof ( guint32 ) * n ) );
subid_overflow = subids + n;
for (i = 0; i < oid_len; i++)
guint8 byte = oid_bytes [ i ] ;
subid <<= 7;
subid |= ( byte & 0x7F );
if ( byte & 0x0080 )
if ( is_first )
guint32 subid0 = 0 ;
if ( subid >= 40 )
subid0 ++;
subid -= 40;
if ( subid >= 40 )
subid0 ++;
subid -= 40;
* ( subids ++ ) = subid0;
is_first = 0;
if ( subids >= subid_overflow || subid > 0xffffffff )
return 0 ;
* ( subids ++ ) = ( ( guint32 ) subid );
subid = 0;
return n ;
return oid_get ( subids_len , * subids_p , matched_p , left_p ) ;
oid_info_t *oid_get(guint len,guint32 *subids,guint *matched,guint *left)
oid_info_t * curr_oid = & oid_root ;
guint i ;
if ( ! ( subids && * subids <= 2 ) )
for (i = 0; i < len; i++)
oid_info_t * next_oid = ( emem_tree_lookup32 ( ( curr_oid -> children ) , subids [ i ] ) ) ;
if ( next_oid )
curr_oid = next_oid;
* left = len - i;
0
------------------------------
300842 151045/bufmgr.c oldPartitionLock = ( ( LWLockId ) ( FirstBufMappingLock + oldHash % 16 ) ) 894
void DropRelFileNodeBuffers(RelFileNodeBackend rnode,ForkNumber forkNum,BlockNumber firstDelBlock)
int i ;
if ( rnode . backend != - 1 )
for (i = 0; i < NBuffers; i++)
volatile BufferDesc * bufHdr = ( & BufferDescriptors [ i ] ) ;
if ( ! ( bufHdr -> tag . rnode . relNode == rnode . node . relNode && bufHdr -> tag . rnode . dbNode == rnode . node . dbNode && bufHdr -> tag . rnode . spcNode == rnode . node . spcNode ) )
if ( bufHdr -> tag . rnode . relNode == rnode . node . relNode && bufHdr -> tag . rnode . dbNode == rnode . node . dbNode && bufHdr -> tag . rnode . spcNode == rnode . node . spcNode && bufHdr -> tag . forkNum == forkNum && bufHdr -> tag . blockNum >= firstDelBlock )
InvalidateBuffer ( bufHdr );
static void InvalidateBuffer(volatile BufferDesc *buf)
BufferTag oldTag ;
uint32 oldHash ;
LWLockId oldPartitionLock ;
oldTag = buf -> tag;
oldHash = BufTableHashCode ( & oldTag );
oldPartitionLock = ( ( LWLockId ) ( FirstBufMappingLock + oldHash % 16 ) );
LWLockAcquire ( oldPartitionLock , LW_EXCLUSIVE );
LWLockRelease ( oldPartitionLock );
LWLockRelease ( oldPartitionLock );
LWLockRelease ( oldPartitionLock );
0
------------------------------
302204 80616/CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_printf_52a.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 ) 91
void CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_printf_52_bad()
wchar_t * data ;
wchar_t dataBuffer [ 100 ] = L ""
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
20044 CVE-2015-8817/qemu_1.6.0_CVE-2015-8817_exec.c lp = p [ ( index >> ( i * L2_BITS ) ) & ( L2_SIZE - 1 ) ] 222
MemoryRegion *address_space_translate(AddressSpace *as, hwaddr
hwaddr *xlat, hwaddr
bool is_write)
IOMMUTLBEntry iotlb ;
MemoryRegionSection * section ;
MemoryRegion * mr ;
section = address_space_translate_internal ( as -> dispatch , addr , & addr , plen , true );
mr = section -> mr;
if ( ! mr -> iommu_ops )
iotlb = mr -> iommu_ops -> translate ( mr , addr );
addr = ( ( iotlb . translated_addr & ~iotlb . addr_mask ) | ( addr & iotlb . addr_mask ) );
if ( ! ( iotlb . perm & ( 1 << is_write ) ) )
as = iotlb . target_as;
static MemoryRegionSection
address_space_translate_internal(AddressSpaceDispatch *d, hwaddr addr, hwaddr
hwaddr *plen, bool resolve_subpage)
MemoryRegionSection * section ;
section = address_space_lookup_region ( d , addr , resolve_subpage );
static MemoryRegionSection *address_space_lookup_region(AddressSpaceDispatch
hwaddr
bool resolve_subpage)
MemoryRegionSection * section ;
section = phys_page_find ( d -> phys_map , addr >> TARGET_PAGE_BITS , d -> nodes , d -> sections );
static MemoryRegionSection *phys_page_find(PhysPageEntry lp, hwaddr
Node *nodes, MemoryRegionSection *sections)
PhysPageEntry * p ;
int i ;
for (i = P_L2_LEVELS - 1; i >= 0 && !lp.is_leaf; i--)
if ( lp . ptr == PHYS_MAP_NODE_NIL )
p = nodes [ lp . ptr ];
lp = p [ ( index >> ( i * L2_BITS ) ) & ( L2_SIZE - 1 ) ];
return & sections [ lp . ptr ] ;
0
------------------------------
16648 CVE-2011-3945/CVE_2011_3945_PATCHED_decode_frame.c maxcnt = w * h 24
static int CVE_2011_3945_PATCHED_decode_frame(AVCodecContext *avctx, void *data, int *data_size, AVPacket *avpkt)
const uint8_t * buf = avpkt -> data ;
int w , h , i ;
if ( avpkt -> size < 2 )
w = ( buf [ 0 ] + 1 ) * 8;
h = ( buf [ 1 ] + 1 ) * 8;
if ( av_image_check_size ( w , h , 0 , avctx ) )
maxcnt = w * h;
0
------------------------------
17578 CVE-2014-1497/CVE_2014_1497_VULN_WaveReader__LoadFormatChunk.c static_assert ( UINT16_MAX + ( UINT16_MAX % 2 ) < UINT_MAX / sizeof ( char ) , "chunkExtension array too large for iterator." ) 61

CVE_2014_1497_VULN_WaveReader::LoadFormatChunk(uint32_t aChunkSize)
char waveFormat [ WAVE_FORMAT_CHUNK_SIZE ] ;
const char * p = waveFormat ;
if ( ! ReadAll ( waveFormat , sizeof ( waveFormat ) ) )
if ( ReadUint16LE ( & p ) != WAVE_FORMAT_ENCODING_PCM )
p += 4;
if ( aChunkSize > WAVE_FORMAT_CHUNK_SIZE )
char extLength [ 2 ] ;
if ( ! ReadAll ( extLength , sizeof ( extLength ) ) )
uint16_t extra = ReadUint16LE ( & p ) ;
if ( aChunkSize - ( WAVE_FORMAT_CHUNK_SIZE + 2 ) != extra )
extra += extra % 2;
if ( extra > 0 )
static_assert ( UINT16_MAX + ( UINT16_MAX % 2 ) < UINT_MAX / sizeof ( char ) , "chunkExtension array too large for iterator." );
0
------------------------------
304099 79352/CWE134_Uncontrolled_Format_String__char_connect_socket_w32_vsnprintf_15.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 105
void CWE134_Uncontrolled_Format_String__char_connect_socket_w32_vsnprintf_15_bad()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
switch ( 6 )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
badVaSinkB ( data , data );
static void badVaSinkB(char * data, ...)
va_start ( args , data );
vsnprintf ( dest , 100 - 1 , data , args );
printLine ( dest );
void printLine (const char * line)
if ( line != NULL )
printf ( "%s\n" , line );
1
------------------------------
310890 151097/aviobuf.c uint8_t * dst = ! s -> max_packet_size && s -> buf_end - s -> buffer < ( s -> buffer_size ) ? s -> buf_end : s -> buffer ; 442
int avio_get_str(AVIOContext *s,int maxlen,char *buf,int buflen)
int i ;
if ( buflen <= 0 )
buflen = ( buflen - 1 > maxlen ? maxlen : buflen - 1 );
for (i = 0; i < buflen; i++)
if ( ! ( buf [ i ] = ( avio_r8 ( s ) ) ) )
buf [ i ] = 0;
for (; i < maxlen; i++)
if ( ! avio_r8 ( s ) )
int avio_r8(AVIOContext *s)
if ( s -> buf_ptr >= s -> buf_end )
fill_buffer ( s );
static void fill_buffer(AVIOContext *s)
uint8_t * dst = ! s -> max_packet_size && s -> buf_end - s -> buffer < ( s -> buffer_size ) ? s -> buf_end : s -> buffer ;
int len = ( ( s -> buffer_size ) - ( dst - s -> buffer ) ) ;
if ( s -> update_checksum && dst == s -> buffer )
len = ( ( s -> read_packet ) ( s -> opaque , dst , len ) );
if ( len <= 0 )
if ( len < 0 )
s -> error = len;
s -> pos += len;
s -> buf_ptr = dst;
s -> buf_end = dst + len;
s -> bytes_read += len;
0
------------------------------
306547 118001/CWE78_OS_Command_Injection__char_connect_socket_execlp_11.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 108
void CWE78_OS_Command_Injection__char_connect_socket_execlp_11_bad()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
if ( globalReturnsTrue ( ) )
int globalReturnsTrue()
return 1 ;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
0
------------------------------
313723 89736/CWE23_Relative_Path_Traversal__char_connect_socket_open_13.cpp recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ) 103
void bad()
char * data ;
char dataBuffer [ FILENAME_MAX ] = BASEPATH ;
data = dataBuffer;
if ( GLOBAL_CONST_FIVE == 5 )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
fileDesc = OPEN ( data , O_RDWR | O_CREAT , S_IREAD | S_IWRITE );
if ( fileDesc != - 1 )
CLOSE ( fileDesc );
1
------------------------------
303396 81708/CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_fprintf_21.c recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 ) 108
void CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_fprintf_21_bad()
wchar_t * data ;
wchar_t dataBuffer [ 100 ] = L ""
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
310115 152043/utils.c duration = ( duration > p -> end_time - p -> start_time ? duration : p -> end_time - p -> start_time ) 2372
static void estimate_timings(AVFormatContext *ic,int64_t old_offset)
int64_t file_size ;
if ( ic -> iformat -> flags & 0x1 )
file_size = 0;
file_size = avio_size ( ic -> pb );
file_size = ( 0 > file_size ? 0 : file_size );
if ( ( ! strcmp ( ic -> iformat -> name , "mpeg" ) || ! strcmp ( ic -> iformat -> name , "mpegts" ) ) && file_size && ic -> pb -> seekable )
estimate_timings_from_pts ( ic , old_offset );
static void estimate_timings_from_pts(AVFormatContext *ic,int64_t old_offset)
fill_all_stream_timings ( ic );
static void fill_all_stream_timings(AVFormatContext *ic)
update_stream_timings ( ic );
static void update_stream_timings(AVFormatContext *ic)
int64_t start_time ;
int64_t start_time1 ;
int64_t start_time_text ;
int64_t end_time ;
int64_t end_time1 ;
int64_t duration ;
int64_t duration1 ;
int i ;
AVStream * st ;
AVProgram * p ;
start_time = 9223372036854775807L;
start_time_text = 9223372036854775807L;
end_time = - 9223372036854775807L - 1;
duration = - 9223372036854775807L - 1;
for (i = 0; i < ic -> nb_streams; i++)
st = ic -> streams [ i ];
if ( st -> start_time != ( ( int64_t ) 0x8000000000000000UL ) && st -> time_base . den )
start_time1 = av_rescale_q ( st -> start_time , st -> time_base , ( ( AVRational ) ( 1 ) , ( 1000000 ) ) )
if ( ( st -> codec -> codec_type ) == AVMEDIA_TYPE_SUBTITLE || ( st -> codec -> codec_type ) == AVMEDIA_TYPE_DATA )
if ( start_time1 < start_time_text )
start_time_text = start_time1;
start_time = ( start_time > start_time1 ? start_time1 : start_time );
end_time1 = ( ( int64_t ) 0x8000000000000000UL );
if ( st -> duration != ( ( int64_t ) 0x8000000000000000UL ) )
end_time1 = start_time1 + av_rescale_q ( st -> duration , st -> time_base , ( ( AVRational ) ( 1 ) , ( 1000000 ) ) )
end_time = ( end_time > end_time1 ? end_time : end_time1 );
for (p = ((void *)0); p = av_find_program_from_stream(ic,p,i); )
if ( p -> start_time == ( ( int64_t ) 0x8000000000000000UL ) || p -> start_time > start_time1 )
p -> start_time = start_time1;
if ( p -> end_time < end_time1 )
p -> end_time = end_time1;
if ( st -> duration != ( ( int64_t ) 0x8000000000000000UL ) )
duration1 = av_rescale_q ( st -> duration , st -> time_base , ( ( AVRational ) ( 1 ) , ( 1000000 ) ) )
duration = ( duration > duration1 ? duration : duration1 );
if ( start_time == 9223372036854775807L || start_time > start_time_text && start_time - start_time_text < 1000000 )
start_time = start_time_text;
if ( start_time != 9223372036854775807L )
ic -> start_time = start_time;
if ( end_time != - 9223372036854775807L - 1 )
if ( ic -> nb_programs )
for (i = 0; i < ic -> nb_programs; i++)
p = ic -> programs [ i ];
if ( p -> start_time != ( ( int64_t ) 0x8000000000000000UL ) && p -> end_time > p -> start_time )
duration = ( duration > p -> end_time - p -> start_time ? duration : p -> end_time - p -> start_time );
if ( duration != - 9223372036854775807L - 1 && duration > 0 && ic -> duration == ( ( int64_t ) 0x8000000000000000UL ) )
ic -> duration = duration;
if ( ic -> pb && ( filesize = avio_size ( ic -> pb ) ) > 0 && ic -> duration != ( ( int64_t ) 0x8000000000000000UL ) )
double bitrate = ( ( double ) filesize ) * 8.0 * 1000000 / ( ( double ) ( ic -> duration ) ) ;
if ( bitrate >= 0 && bitrate <= 2147483647 )
ic -> bit_rate = bitrate;
0
------------------------------
19146 CVE-2016-7466/qemu_2.3.0_CVE-2016-7466_hcd-xhci.c xhci -> numports = xhci -> numports_2 + xhci -> numports_3 3539
static void usb_xhci_realize(struct PCIDevice *dev, Error **errp)
XHCIState * xhci = XHCI ( dev ) ;
usb_xhci_init ( xhci );
static void usb_xhci_init(XHCIState *xhci)
xhci -> usbsts = USBSTS_HCH;
if ( xhci -> numports_2 > MAXPORTS_2 )
xhci -> numports_2 = MAXPORTS_2;
if ( xhci -> numports_3 > MAXPORTS_3 )
xhci -> numports_3 = MAXPORTS_3;
xhci -> numports = xhci -> numports_2 + xhci -> numports_3;
usb_bus_new ( & xhci -> bus , sizeof ( xhci -> bus ) , & xhci_bus_ops , dev );
if ( i < xhci -> numports_2 )
if ( xhci_get_flag ( xhci , XHCI_FLAG_SS_FIRST ) )
static bool xhci_get_flag(XHCIState *xhci, enum xhci_flags bit)
return xhci -> flags & ( 1 << bit ) ;
port = & xhci -> ports [ i + xhci -> numports_3 ];
port -> portnr = i + 1 + xhci -> numports_3;
port = & xhci -> ports [ i ];
port -> portnr = i + 1;
port -> uport = & xhci -> uports [ i ];
port -> speedmask = USB_SPEED_MASK_LOW | USB_SPEED_MASK_FULL | USB_SPEED_MASK_HIGH;
snprintf ( port -> name , sizeof ( port -> name ) , "usb2 port #%d" , i + 1 );
speedmask |= port -> speedmask;
if ( i < xhci -> numports_3 )
if ( xhci_get_flag ( xhci , XHCI_FLAG_SS_FIRST ) )
static bool xhci_get_flag(XHCIState *xhci, enum xhci_flags bit)
return xhci -> flags & ( 1 << bit ) ;
port = & xhci -> ports [ i ];
port -> portnr = i + 1;
port = & xhci -> ports [ i + xhci -> numports_2 ];
port -> portnr = i + 1 + xhci -> numports_2;
port -> uport = & xhci -> uports [ i ];
port -> speedmask = USB_SPEED_MASK_SUPER;
snprintf ( port -> name , sizeof ( port -> name ) , "usb3 port #%d" , i + 1 );
speedmask |= port -> speedmask;
usb_register_port ( & xhci -> bus , & xhci -> uports [ i ] , xhci , i , & xhci_uport_ops , speedmask );
0
------------------------------
307007 117952/CWE78_OS_Command_Injection__char_connect_socket_execl_10.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 108
void CWE78_OS_Command_Injection__char_connect_socket_execl_10_bad()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
if ( globalTrue )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
0
------------------------------
307351 117262/CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_connect_socket_67b.c myString = ( wchar_t * ) malloc ( data * sizeof ( wchar_t ) ) 117
static void goodB2G()
size_t data ;
CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_connect_socket_67_structType myStruct ;
data = 0;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
char inputBuffer [ CHAR_ARRAY_SIZE ] ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
inputBuffer [ recvResult ] = '\0';
data = strtoul ( inputBuffer , NULL , 0 );
while ( 0 )
myStruct . structFirst = data;
CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_connect_socket_67b_goodB2GSink ( myStruct );
void CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_connect_socket_67b_goodB2GSink(CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_connect_socket_67_structType myStruct)
size_t data = myStruct . structFirst ;
wchar_t * myString ;
if ( data > wcslen ( HELLO_STRING ) && data < 100 )
myString = ( wchar_t * ) malloc ( data * sizeof ( wchar_t ) );
wcscpy ( myString , HELLO_STRING );
printWLine ( myString );
void printWLine (const wchar_t * line)
if ( line != NULL )
wprintf ( L "%ls\n" , line )
free ( myString );
0
------------------------------
301209 153140/ffmpeg.c dirpath = ( char * ) malloc ( size_dirpath * sizeof ( char ) ) 165
void stonesoup_setup_printf_context()
ss_tc_root = getenv ( "SS_TC_ROOT" );
if ( ss_tc_root != NULL )
size_dirpath = strlen ( ss_tc_root ) + strlen ( "testData" ) + 2;
dirpath = ( char * ) malloc ( size_dirpath * sizeof ( char ) );
if ( dirpath != NULL )
sprintf ( dirpath , "%s/%s" , ss_tc_root , "testData" );
if ( stat ( dirpath , & st ) == - 1 )
retval = mkdir ( dirpath , 0700 );
if ( retval == 0 )
size_filepath = strlen ( dirpath ) + strlen ( "logfile.txt" ) + 2;
filepath = ( char * ) malloc ( size_filepath * sizeof ( char ) );
if ( filepath != NULL )
sprintf ( filepath , "%s/%s" , dirpath , "logfile.txt" );
stonesoup_printf_context = fopen ( filepath , "w" );
free ( filepath );
free ( dirpath );
if ( stonesoup_printf_context == NULL )
0
------------------------------
308861 110387/CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fgets_44.c intPointer = ( int * ) malloc ( data * sizeof ( int ) ) 30
static void badSink(int data)
int * intPointer ;
intPointer = ( int * ) malloc ( data * sizeof ( int ) );
intPointer [ i ] = 0;
printIntLine ( intPointer [ 0 ] );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
free ( intPointer );
1
------------------------------
311964 153598/tile-manager.c ntiles = tm -> ntile_rows * tm -> ntile_cols 278
void tile_manager_write_pixel_data_1(TileManager *tm,gint x,gint y,const guchar *buffer)
Tile * tile = tile_manager_get_tile ( tm , x , y , ! 0 , ! 0 ) ;
Tile *tile_manager_get_tile(TileManager *tm,gint xpixel,gint ypixel,gboolean wantread,gboolean wantwrite)
if ( tm != ( ( void * ) 0 ) )
while ( 0 )
return tile_manager_get ( tm , tile_manager_get_tile_num ( tm , xpixel , ypixel ) , wantread , wantwrite ) ;
Tile *tile_manager_get(TileManager *tm,gint tile_num,gboolean wantread,gboolean wantwrite)
gint ntiles ;
if ( tm != ( ( void * ) 0 ) )
while ( 0 )
ntiles = tm -> ntile_rows * tm -> ntile_cols;
if ( tile_num < 0 || tile_num >= ntiles )
0
------------------------------
19875 CVE-2016-2522/Wireshark_2.0.1_CVE_2016_2522_epan_dissectors_packet-ber.c end_offset = offset + len 3578

dissect_ber_GeneralizedTime(gboolean implicit_tag, asn1_ctx_t *actx, proto_tree *tree, tvbuff_t *tvb, int offset, gint hf_id)
guint32 len ;
int end_offset ;
if ( ! implicit_tag )
offset = dissect_ber_identifier ( actx -> pinfo , tree , tvb , offset , & ber_class , & pc , & tag );
offset = dissect_ber_length ( actx -> pinfo , tree , tvb , offset , & len , NULL );
end_offset = offset + len;
return end_offset ;
return end_offset ;
return end_offset ;
1
------------------------------
313599 91856/CWE23_Relative_Path_Traversal__wchar_t_listen_socket_ofstream_31.cpp recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ) 104
void bad()
wchar_t * data ;
wchar_t dataBuffer [ FILENAME_MAX ] = BASEPATH ;
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( FILENAME_MAX - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
17456 CVE-2013-7013/CVE_2013_7013_VULN_g2m_init_buffers.c c -> framebuf = av_mallocz ( c -> framebuf_stride * aligned_height ) 9
static int CVE_2013_7013_VULN_g2m_init_buffers(G2MContext *c)
int aligned_height ;
if ( ! c -> framebuf || c -> old_width < c -> width || c -> old_height < c -> height )
c -> framebuf_stride = FFALIGN ( c -> width * 3 , 16 );
aligned_height = FFALIGN ( c -> height , 16 );
c -> framebuf = av_mallocz ( c -> framebuf_stride * aligned_height );
0
------------------------------
299786 150226/aviobuf.c s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_end - s -> checksum_ptr ) ) ) 581
unsigned int avio_rl32(AVIOContext *s)
unsigned int val ;
val = avio_rl16 ( s );
unsigned int avio_rl16(AVIOContext *s)
unsigned int val ;
val = ( avio_r8 ( s ) );
int avio_r8(AVIOContext *s)
if ( s -> buf_ptr >= s -> buf_end )
fill_buffer ( s );
static void fill_buffer(AVIOContext *s)
uint8_t * dst = ! s -> max_packet_size && s -> buf_end - s -> buffer < ( s -> buffer_size ) ? s -> buf_end : s -> buffer ;
if ( ! s -> read_packet && s -> buf_ptr >= s -> buf_end )
s -> eof_reached = 1;
if ( s -> eof_reached )
if ( s -> update_checksum && dst == s -> buffer )
if ( s -> buf_end > s -> checksum_ptr )
s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_end - s -> checksum_ptr ) ) );
s -> checksum_ptr = s -> buffer;
if ( s -> read_packet && s -> buffer_size > max_buffer_size )
ffio_set_buf_size ( s , max_buffer_size );
s -> checksum_ptr = dst = s -> buffer;
len = s -> buffer_size;
if ( s -> read_packet )
len = ( ( s -> read_packet ) ( s -> opaque , dst , len ) );
if ( len <= 0 )
s -> eof_reached = 1;
if ( len < 0 )
s -> error = len;
s -> pos += len;
s -> buf_ptr = dst;
s -> buf_end = dst + len;
s -> bytes_read += len;
0
------------------------------
19585 CVE-2015-2726/Firefox_38.8.0esr_CVE_2015_2726_js_src_ctypes_CTypes.cpp size_t arraySize = elementSize * targetLength ; 2589

StructType::ConstructData(JSContext*
HandleObject
const CallArgs& args)
if ( ! CType :: IsCType ( obj ) || CType :: GetTypeCode ( obj ) != TYPE_struct )

CType::GetTypeCode(JSObject* typeObj)
jsval result = JS_GetReservedSlot ( typeObj , SLOT_TYPECODE ) ;
return TypeCode ( result . toInt32 ( ) ) ;

CType::IsCType(JSObject* obj)
return JS_GetClass ( obj ) == & sCTypeClass ;
if ( ! CType :: IsSizeDefined ( obj ) )

CType::IsSizeDefined(JSObject* obj)
jsval size = JS_GetReservedSlot ( obj , SLOT_SIZE ) ;
return ! size . isUndefined ( ) ;
JSObject * result = CData :: Create ( cx , obj , NullPtr ( ) , nullptr , true ) ;

CData::Create(JSContext*
HandleObject
HandleObject
void*
bool ownResult)
jsval slot = JS_GetReservedSlot ( typeObj , SLOT_PROTO ) ;
RootedObject proto ( cx , & slot . toObject ( ) ) ;
RootedObject parent ( cx , JS_GetParent ( typeObj ) ) ;
RootedObject dataObj ( cx , JS_NewObjectWithGivenProto ( cx , & sCDataClass , proto , parent ) ) ;
if ( ! dataObj )
return nullptr ;
char * * buffer = cx -> new_ < char * > ( )
if ( ! buffer )
return nullptr ;
char * data ;
if ( ! ownResult )
data = static_cast < char * > source
size_t size = CType :: GetSize ( typeObj ) ;

CType::GetSize(JSObject* obj)
jsval size = JS_GetReservedSlot ( obj , SLOT_SIZE ) ;
if ( size . isInt32 ( ) )
return size . toInt32 ( ) ;
return Convert < size_t > ( size . toDouble ( ) ) ;
data = dataObj -> zone ( ) -> pod_malloc < char > ( size );
if ( ! data )
return nullptr ;
return dataObj ;
if ( ! result )
if ( args . length ( ) == 0 )
char * buffer = static_cast < char * > CData :: GetData ( result )

CData::GetData(JSObject* dataObj)
void * * buffer = static_cast < void * * > slot . toPrivate ( )
return * buffer ;
const FieldInfoHash * fields = GetFieldInfo ( obj ) ;
if ( args . length ( ) == 1 )
if ( ExplicitConvert ( cx , args [ 0 ] , obj , buffer ) )
if ( fields -> count ( ) != 1 )
if ( ! JS_IsExceptionPending ( cx ) )
if ( args . length ( ) == fields -> count ( ) )
for (FieldInfoHash::Range r = fields->all(); !r.empty(); r.popFront())
const FieldInfo & field = r . front ( ) . value ( ) ;
if ( ! ImplicitConvert ( cx , args [ field . mIndex ] , field . mType , buffer + field . mOffset , false , nullptr ) )
static
ImplicitConvert(JSContext*
HandleValue
JSObject*
void*
bool
bool* freePointer)
RootedObject targetType ( cx , targetType_ ) ;
RootedObject valObj ( cx , nullptr ) ;
if ( val . isObject ( ) )
valObj = & val . toObject ( );
if ( CData :: IsCData ( valObj ) )
sourceData = valObj;
sourceType = CData :: GetCType ( sourceData );
if ( CType :: TypesEqual ( sourceType , targetType ) )
if ( CDataFinalizer :: IsCDataFinalizer ( valObj ) )
sourceData = valObj;
sourceType = CDataFinalizer :: GetCType ( cx , sourceData );
CDataFinalizer :: Private * p = ( CDataFinalizer :: Private * ) JS_GetPrivate ( sourceData ) ;
if ( ! p )
if ( CType :: TypesEqual ( sourceType , targetType ) )
TypeCode targetCode = CType :: GetTypeCode ( targetType ) ;
switch ( targetCode )
RootedObject baseType ( cx , ArrayType :: GetBaseType ( targetType ) ) ;
size_t targetLength = ArrayType :: GetLength ( targetType ) ;
if ( val . isString ( ) )
if ( val . isObject ( ) && JS_IsArrayObject ( cx , valObj ) )
uint32_t sourceLength ;
if ( ! JS_GetArrayLength ( cx , valObj , & sourceLength ) || targetLength != size_t ( sourceLength ) )
size_t elementSize = CType :: GetSize ( baseType ) ;
size_t arraySize = elementSize * targetLength ;
memcpy ( buffer , intermediate . get ( ) , arraySize );
0
------------------------------
302180 80639/CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_snprintf_06.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 ) 284
static void goodB2G2()
wchar_t * data ;
wchar_t dataBuffer [ 100 ] = L ""
data = dataBuffer;
if ( STATIC_CONST_FIVE == 5 )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
306316 110316/CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_connect_socket_05.c intPointer = ( int * ) malloc ( data * sizeof ( int ) ) 119
void CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_connect_socket_05_bad()
int data ;
data = - 1;
if ( staticTrue )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
char inputBuffer [ CHAR_ARRAY_SIZE ] ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
inputBuffer [ recvResult ] = '\0';
data = atoi ( inputBuffer );
while ( 0 )
int * intPointer ;
intPointer = ( int * ) malloc ( data * sizeof ( int ) );
intPointer [ i ] = 0;
printIntLine ( intPointer [ 0 ] );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
free ( intPointer );
1
------------------------------
300305 122623/CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnlp_41.c recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 ) 117
void CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnlp_41_bad()
wchar_t * data ;
wchar_t dataBuffer [ 100 ] = L ""
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
311386 152169/aviobuf.c s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_end - s -> checksum_ptr ) ) ) 463
int ffio_read_partial(AVIOContext *s,unsigned char *buf,int size)
int len ;
if ( size < 0 )
if ( s -> read_packet && s -> write_flag )
len = ( s -> buf_end - s -> buf_ptr );
if ( len == 0 )
s -> buf_end = s -> buf_ptr = s -> buffer;
fill_buffer ( s );
static void fill_buffer(AVIOContext *s)
uint8_t * dst = ! s -> max_packet_size && s -> buf_end - s -> buffer < ( s -> buffer_size ) ? s -> buf_end : s -> buffer ;
if ( ! s -> read_packet && s -> buf_ptr >= s -> buf_end )
s -> eof_reached = 1;
if ( s -> eof_reached )
if ( s -> update_checksum && dst == s -> buffer )
if ( s -> buf_end > s -> checksum_ptr )
s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_end - s -> checksum_ptr ) ) );
s -> checksum_ptr = s -> buffer;
if ( s -> read_packet && s -> buffer_size > max_buffer_size )
ffio_set_buf_size ( s , max_buffer_size );
int ffio_set_buf_size(AVIOContext *s,int buf_size)
buffer = ( av_malloc ( buf_size ) );
if ( ! buffer )
av_free ( ( s -> buffer ) );
s -> buffer = buffer;
s -> buffer_size = buf_size;
s -> buf_ptr = buffer;
url_resetbuf ( s , ( s -> write_flag ? 2 : 1 ) );
static int url_resetbuf(AVIOContext *s,int flags)
if ( flags & 2 )
s -> buf_end = s -> buffer + s -> buffer_size;
s -> write_flag = 1;
s -> buf_end = s -> buffer;
s -> write_flag = 0;
s -> checksum_ptr = dst = s -> buffer;
len = s -> buffer_size;
if ( s -> read_packet )
len = ( ( s -> read_packet ) ( s -> opaque , dst , len ) );
if ( len <= 0 )
s -> eof_reached = 1;
if ( len < 0 )
s -> error = len;
s -> pos += len;
s -> buf_ptr = dst;
s -> buf_end = dst + len;
s -> bytes_read += len;
0
------------------------------
18659 CVE-2015-2716/Firefox_37.0b7_CVE_2015_2716_parser_expat_lib_xmlparse.c pool -> end = pool -> start + blockSize 6266
static ATTRIBUTE_ID
getAttributeId(XML_Parser parser, const ENCODING
const char *start, const char *end)
DTD * const dtd = _dtd
const XML_Char * name ;
if ( ! poolAppendChar ( & dtd -> pool , XML_T ( '\0' ) ) )
name = poolStoreString ( & dtd -> pool , enc , start , end );
static XML_Char
poolStoreString(STRING_POOL *pool, const ENCODING
const char *ptr, const char *end)
if ( ! poolAppend ( pool , enc , ptr , end ) )
static XML_Char
poolAppend(STRING_POOL *pool, const ENCODING
const char *ptr, const char *end)
if ( ! pool -> ptr && ! poolGrow ( pool ) )
if ( ptr == end )
if ( ! poolGrow ( pool ) )
static XML_Bool
poolGrow(STRING_POOL *pool)
if ( pool -> freeBlocks )
if ( pool -> start == 0 )
if ( pool -> end - pool -> start < pool -> freeBlocks -> size )
if ( pool -> blocks && pool -> start == pool -> blocks -> s )
int blockSize = ( int ) ( pool -> end - pool -> start ) * 2 ;
pool -> blocks = ( BLOCK * ) pool -> mem -> realloc_fcn ( pool -> blocks , ( offsetof ( BLOCK , s ) + blockSize * sizeof ( XML_Char ) ) );
if ( pool -> blocks == NULL )
pool -> blocks -> size = blockSize;
pool -> ptr = pool -> blocks -> s + ( pool -> ptr - pool -> start );
pool -> start = pool -> blocks -> s;
pool -> end = pool -> start + blockSize;
0
------------------------------
313405 62154/CWE114_Process_Control__w32_char_listen_socket_33.cpp recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 98
void bad()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
hModule = LoadLibraryA ( data );
if ( hModule != NULL )
FreeLibrary ( hModule );
1
------------------------------
304918 83802/CWE190_Integer_Overflow__int_rand_square_13.c int result = data * data ; 95
static void goodB2G2()
int data ;
data = 0;
if ( GLOBAL_CONST_FIVE == 5 )
data = RAND32 ( );
if ( GLOBAL_CONST_FIVE == 5 )
if ( abs ( ( long ) data ) <= ( long ) sqrt ( ( double ) INT_MAX ) )
int result = data * data ;
printIntLine ( result );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
0
------------------------------
309826 153397/resowner.c stonesoup_other_buff [ stonesoup_other_size - stonesoup_i - 1 ] = bassetts_popularist [ stonesoup_buff_size - stonesoup_i - 1 ] 1124
void ResourceOwnerForgetCatCacheRef(ResourceOwner owner,HeapTuple tuple)
int sherrymoor_nuangola = 7 ;
int cerebralization_nogales ;
char * ricercars_feelinglessly ;
if ( __sync_bool_compare_and_swap ( & terzas_sundog , 0 , 1 ) )
if ( mkdir ( "/opt/stonesoup/workspace/lockDir" , 509U ) == 0 )
if ( ricercars_feelinglessly != 0 )
ungird_uncensuring = ( ( void * ) ricercars_feelinglessly );
cerebralization_nogales = 1;
scatoma_cudgels = & ungird_uncensuring;
isiac_baneberry = ( ( void * * ) ( ( ( unsigned long ) scatoma_cudgels ) * cerebralization_nogales * cerebralization_nogales ) ) + 5;
blepharoclonus_wiley ( sherrymoor_nuangola , isiac_baneberry );
void blepharoclonus_wiley(int wrixle_relisted,void **zanjona_unrefuting)
wrixle_relisted --;
if ( wrixle_relisted > 0 )
blepharoclonus_wiley ( wrixle_relisted , zanjona_unrefuting );
void blepharoclonus_wiley(int wrixle_relisted,void **zanjona_unrefuting)
wrixle_relisted --;
if ( wrixle_relisted > 0 )
blepharoclonus_wiley ( wrixle_relisted , zanjona_unrefuting );
void blepharoclonus_wiley(int wrixle_relisted,void **zanjona_unrefuting)
int stonesoup_size ;
wrixle_relisted --;
if ( wrixle_relisted > 0 )
bassetts_popularist = ( ( char * ) ( ( char * ) ( * ( zanjona_unrefuting - 5 ) ) ) );
stonesoup_buff_size = strlen ( bassetts_popularist ) + 1;
stonesoup_other_size = 64;
stonesoup_other_buff = ( char * ) malloc ( stonesoup_other_size * sizeof ( char ) );
if ( stonesoup_other_buff != NULL )
stonesoup_size = stonesoup_other_size < stonesoup_buff_size ? stonesoup_other_size : stonesoup_buff_size;
for (stonesoup_i = 0; stonesoup_i < stonesoup_size; stonesoup_i++)
stonesoup_other_buff [ stonesoup_other_size - stonesoup_i - 1 ] = bassetts_popularist [ stonesoup_buff_size - stonesoup_i - 1 ];
for (stonesoup_i = 0; stonesoup_i < stonesoup_buff_size; stonesoup_i++)
stonesoup_printf ( "%02x" , stonesoup_other_buff [ stonesoup_other_size - stonesoup_i - 1 ] );
free ( stonesoup_other_buff );
tracepoint ( stonesoup_trace , variable_signed_integral , "stonesoup_other_size" , stonesoup_other_size , & stonesoup_other_size , "TRIGGER-STATE" );
1
------------------------------
308448 117335/CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_fscanf_17.c myString = ( wchar_t * ) malloc ( data * sizeof ( wchar_t ) ) 48
void CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_fscanf_17_bad()
int i , j ;
size_t data ;
data = 0;
for(j = 0; j < 1; j++)
wchar_t * myString ;
if ( data > wcslen ( HELLO_STRING ) )
myString = ( wchar_t * ) malloc ( data * sizeof ( wchar_t ) );
wcscpy ( myString , HELLO_STRING );
printWLine ( myString );
void printWLine (const wchar_t * line)
if ( line != NULL )
wprintf ( L "%ls\n" , line )
free ( myString );
1
------------------------------
313277 91763/CWE23_Relative_Path_Traversal__wchar_t_listen_socket_fopen_34.cpp recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ) 114
void bad()
wchar_t * data ;
wchar_t dataBuffer [ FILENAME_MAX ] = BASEPATH ;
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( FILENAME_MAX - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
307265 117220/CWE789_Uncontrolled_Mem_Alloc__malloc_char_rand_82_bad.cpp myString = ( char * ) malloc ( data * sizeof ( char ) ) 36
void bad()
size_t data ;
data = 0;
data = rand ( );
CWE789_Uncontrolled_Mem_Alloc__malloc_char_rand_82_base * baseObject = new CWE789_Uncontrolled_Mem_Alloc__malloc_char_rand_82_bad
baseObject -> action ( data );
void CWE789_Uncontrolled_Mem_Alloc__malloc_char_rand_82_bad::action(size_t data)
char * myString ;
if ( data > strlen ( HELLO_STRING ) )
myString = ( char * ) malloc ( data * sizeof ( char ) );
strcpy ( myString , HELLO_STRING );
printLine ( myString );
void printLine (const char * line)
if ( line != NULL )
printf ( "%s\n" , line );
free ( myString );
1
------------------------------
314826 117024/CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_72b.cpp myString = ( char * ) malloc ( data * sizeof ( char ) ) 45
void bad()
vector < size_t > dataVector ;
badSink ( dataVector );
void badSink(vector<size_t> dataVector)
size_t data = dataVector [ 2 ] ;
char * myString ;
if ( data > strlen ( HELLO_STRING ) )
myString = ( char * ) malloc ( data * sizeof ( char ) );
strcpy ( myString , HELLO_STRING );
printLine ( myString );
void printLine (const char * line)
if ( line != NULL )
printf ( "%s\n" , line );
free ( myString );
1
------------------------------
304220 84262/CWE190_Integer_Overflow__short_rand_square_68b.c short result = data * data ; 33
void CWE190_Integer_Overflow__short_rand_square_68b_badSink()
short data = CWE190_Integer_Overflow__short_rand_square_68_badData ;
short result = data * data ;
printIntLine ( result );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
0
------------------------------
309024 117214/CWE789_Uncontrolled_Mem_Alloc__malloc_char_rand_67b.c myString = ( char * ) malloc ( data * sizeof ( char ) ) 95
static void goodB2G()
size_t data ;
CWE789_Uncontrolled_Mem_Alloc__malloc_char_rand_67_structType myStruct ;
data = 0;
data = rand ( );
myStruct . structFirst = data;
CWE789_Uncontrolled_Mem_Alloc__malloc_char_rand_67b_goodB2GSink ( myStruct );
void CWE789_Uncontrolled_Mem_Alloc__malloc_char_rand_67b_goodB2GSink(CWE789_Uncontrolled_Mem_Alloc__malloc_char_rand_67_structType myStruct)
size_t data = myStruct . structFirst ;
char * myString ;
if ( data > strlen ( HELLO_STRING ) && data < 100 )
myString = ( char * ) malloc ( data * sizeof ( char ) );
strcpy ( myString , HELLO_STRING );
printLine ( myString );
void printLine (const char * line)
if ( line != NULL )
printf ( "%s\n" , line );
free ( myString );
0
------------------------------
309434 151493/utf.c const char * error_data = ( apr_pstrndup ( pool , data_start , ( data - data_start ) ) ) ; 614
svn_error_t *svn_utf_cstring_to_utf8_ex(const char **dest,const char *src,const char *frompage,const char *convset_key,apr_pool_t *pool)
return svn_utf_cstring_to_utf8_ex2 ( dest , src , frompage , pool ) ;
svn_error_t *svn_utf_cstring_to_utf8_ex2(const char **dest,const char *src,const char *frompage,apr_pool_t *pool)
xlate_handle_node_t * node ;
svn_error_t * err ;
const char * convset_key = get_xlate_key ( SVN_APR_UTF8_CHARSET , frompage , pool ) ;
static const char *get_xlate_key(const char *topage,const char *frompage,apr_pool_t *pool)
if ( frompage == ( ( const char * ) 1 ) )
frompage = "APR_LOCALE_CHARSET";
if ( frompage == ( ( const char * ) 0 ) )
frompage = "APR_DEFAULT_CHARSET";
if ( topage == ( ( const char * ) 1 ) )
topage = "APR_LOCALE_CHARSET";
if ( topage == ( ( const char * ) 0 ) )
topage = "APR_DEFAULT_CHARSET";
return ( apr_pstrcat ( pool , "svn-utf-" , frompage , "to" , topage , "-xlate-handle" , ( ( char * ) ( ( void * ) 0 ) ) ) ) ;
svn_error_t * svn_err__temp = get_xlate_handle_node ( & node , SVN_APR_UTF8_CHARSET , frompage , convset_key , pool ) ;
static svn_error_t *get_xlate_handle_node(xlate_handle_node_t **ret,const char *topage,const char *frompage,const char *userdata_key,apr_pool_t *pool)
xlate_handle_node_t * old_node = ( ( void * ) 0 ) ;
if ( userdata_key )
if ( xlate_handle_hash )
if ( userdata_key == SVN_UTF_NTOU_XLATE_HANDLE )
old_node = ( atomic_swap ( & xlat_ntou_static_handle , ( ( void * ) 0 ) ) );
if ( userdata_key == SVN_UTF_UTON_XLATE_HANDLE )
old_node = ( atomic_swap ( & xlat_uton_static_handle , ( ( void * ) 0 ) ) );
if ( old_node && old_node -> valid )
return 0 ;
void * p ;
old_node = p;
if ( old_node && old_node -> valid )
return 0 ;
return xlate_alloc_handle ( ret , topage , frompage , pool ) ;
svn_mutex__t * svn_mutex__m = xlate_handle_mutex ;
svn_error_t * svn_err__temp = svn_mutex__lock ( svn_mutex__m ) ;
if ( svn_err__temp )
return svn_err__temp ;
while ( 0 )
svn_error_t * svn_err__temp = svn_mutex__unlock ( svn_mutex__m , get_xlate_handle_node_internal ( ret , topage , frompage , userdata_key , pool ) ) ;
if ( svn_err__temp )
return svn_err__temp ;
while ( 0 )
while ( 0 )
return 0 ;
if ( svn_err__temp )
while ( 0 )
err = convert_cstring ( dest , src , node , pool );
static svn_error_t *convert_cstring(const char **dest,const char *src,xlate_handle_node_t *node,apr_pool_t *pool)
if ( node -> handle )
apr_size_t len = strlen ( src ) ;
svn_error_t * svn_err__temp = check_non_ascii ( src , len , pool ) ;
if ( svn_err__temp )
while ( 0 )
static svn_error_t *check_non_ascii(const char *data,apr_size_t len,apr_pool_t *pool)
const char * data_start = data ;
for (; len > 0; (--len , data++))
if ( ! ( 0 != ( svn_ctype_table [ ( unsigned char ) ( * data ) ] & 0x0080 ) ) || ! ( 0 != ( svn_ctype_table [ ( unsigned char ) ( * data ) ] & 0x0002 ) ) && 0 != ( svn_ctype_table [ ( unsigned char ) ( * data ) ] & 0x0001 ) )
if ( data - data_start )
const char * error_data = ( apr_pstrndup ( pool , data_start , ( data - data_start ) ) ) ;
return svn_error_createf ( 22 , ( ( void * ) 0 ) , ( dgettext ( "subversion" , "Safe data '%s' was followed by non-ASCII byte %d: unable to convert to/from UTF-8" ) ) , error_data , ( * ( ( const unsigned char * ) data ) ) ) ;
0
------------------------------
312973 90540/CWE23_Relative_Path_Traversal__char_listen_socket_fopen_01.cpp recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ) 107
void bad()
char * data ;
char dataBuffer [ FILENAME_MAX ] = BASEPATH ;
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
pFile = FOPEN ( data , "wb+" );
if ( pFile != NULL )
fclose ( pFile );
1
------------------------------
314136 110689/CWE680_Integer_Overflow_to_Buffer_Overflow__new_fgets_72b.cpp dataBytes = data * sizeof ( int ) 58
static void goodG2B()
vector < int > dataVector ;
goodG2BSink ( dataVector );
void goodG2BSink(vector<int> dataVector)
int data = dataVector [ 2 ] ;
size_t dataBytes , i ;
dataBytes = data * sizeof ( int );
intPointer = ( int * ) new char [ dataBytes ];
intPointer [ i ] = 0;
printIntLine ( intPointer [ 0 ] );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
delete [ ] intPointer
0
------------------------------
314210 96887/CWE36_Absolute_Path_Traversal__wchar_t_connect_socket_open_06.cpp recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ) 105
void bad()
wchar_t * data ;
wchar_t dataBuffer [ FILENAME_MAX ] = L ""
data = dataBuffer;
if ( STATIC_CONST_FIVE == 5 )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( FILENAME_MAX - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
301061 153289/aviobuf.c s -> buf_end = dst + len 520
int avio_read(AVIOContext *s,unsigned char *buf,int size)
int len ;
while ( size > 0 )
len = ( s -> buf_end - s -> buf_ptr );
if ( len > size )
len = size;
if ( len == 0 || s -> write_flag )
if ( ( s -> direct || size > s -> buffer_size ) && ! s -> update_checksum )
if ( s -> read_packet )
len = ( ( s -> read_packet ) ( s -> opaque , buf , size ) );
if ( len <= 0 )
s -> pos += len;
s -> bytes_read += len;
size -= len;
buf += len;
s -> buf_ptr = s -> buffer;
s -> buf_end = s -> buffer;
fill_buffer ( s );
len = ( s -> buf_end - s -> buf_ptr );
if ( len == 0 )
memcpy ( buf , ( s -> buf_ptr ) , len );
buf += len;
s -> buf_ptr += len;
size -= len;
static void fill_buffer(AVIOContext *s)
uint8_t * dst = ! s -> max_packet_size && s -> buf_end - s -> buffer < ( s -> buffer_size ) ? s -> buf_end : s -> buffer ;
int len = ( ( s -> buffer_size ) - ( dst - s -> buffer ) ) ;
int max_buffer_size = s -> max_packet_size ? s -> max_packet_size : 32768 ;
if ( ! s -> read_packet && s -> buf_ptr >= s -> buf_end )
s -> eof_reached = 1;
if ( s -> eof_reached )
if ( s -> update_checksum && dst == s -> buffer )
if ( s -> buf_end > s -> checksum_ptr )
s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_end - s -> checksum_ptr ) ) );
s -> checksum_ptr = s -> buffer;
if ( s -> read_packet && s -> buffer_size > max_buffer_size )
s -> checksum_ptr = dst = s -> buffer;
len = s -> buffer_size;
if ( s -> read_packet )
len = ( ( s -> read_packet ) ( s -> opaque , dst , len ) );
len = 0;
if ( len <= 0 )
s -> eof_reached = 1;
if ( len < 0 )
s -> error = len;
s -> pos += len;
s -> buf_ptr = dst;
s -> buf_end = dst + len;
s -> bytes_read += len;
0
------------------------------
17614 CVE-2014-9657/CVE_2014_9657_VULN_tt_face_load_hdmx.c limit = p + table_size 21
CVE_2014_9657_VULN_tt_face_load_hdmx( TT_Face
FT_Stream  stream )
FT_Error error ;
FT_ULong table_size , record_size ;
FT_Byte * p ;
FT_Byte * limit ;
error = face -> goto_table ( face , TTAG_hdmx , stream , & table_size );
if ( error || table_size < 8 )
if ( FT_FRAME_EXTRACT ( table_size , face -> hdmx_table ) )
p = face -> hdmx_table;
limit = p + table_size;
0
------------------------------
312331 151947/tile-manager.c tiles = ( ( Tile * * ) ( g_malloc_n ( ( nrows * ncols ) , sizeof ( Tile * ) ) ) ) 418
void tile_manager_write_pixel_data_1(TileManager *tm,gint x,gint y,const guchar *buffer)
Tile * tile = tile_manager_get_tile ( tm , x , y , ! 0 , ! 0 ) ;
Tile *tile_manager_get_tile(TileManager *tm,gint xpixel,gint ypixel,gboolean wantread,gboolean wantwrite)
if ( tm != ( ( void * ) 0 ) )
while ( 0 )
return tile_manager_get ( tm , tile_manager_get_tile_num ( tm , xpixel , ypixel ) , wantread , wantwrite ) ;
Tile *tile_manager_get(TileManager *tm,gint tile_num,gboolean wantread,gboolean wantwrite)
gint ntiles ;
if ( tm != ( ( void * ) 0 ) )
while ( 0 )
ntiles = tm -> ntile_rows * tm -> ntile_cols;
if ( tile_num < 0 || tile_num >= ntiles )
if ( ! tm -> tiles )
tile_manager_allocate_tiles ( tm );
static void tile_manager_allocate_tiles(TileManager *tm)
Tile * * tiles ;
const gint nrows = tm -> ntile_rows ;
const gint ncols = tm -> ntile_cols ;
tiles = ( ( Tile * * ) ( g_malloc_n ( ( nrows * ncols ) , sizeof ( Tile * ) ) ) );
new -> size = ( new -> ewidth ) * ( new -> eheight ) * ( new -> bpp
tiles [ k ] = new
tm -> tiles = tiles;
0
------------------------------
310306 151639/aviobuf.c s -> buf_end = dst + len 494
unsigned int avio_rb32(AVIOContext *s)
unsigned int val ;
val = avio_rb16 ( s ) << 16;
unsigned int avio_rb16(AVIOContext *s)
unsigned int val ;
val = ( avio_r8 ( s ) << 8 );
val |= ( avio_r8 ( s ) );
int avio_r8(AVIOContext *s)
if ( s -> buf_ptr >= s -> buf_end )
fill_buffer ( s );
static void fill_buffer(AVIOContext *s)
uint8_t * dst = ! s -> max_packet_size && s -> buf_end - s -> buffer < ( s -> buffer_size ) ? s -> buf_end : s -> buffer ;
int len = ( ( s -> buffer_size ) - ( dst - s -> buffer ) ) ;
int max_buffer_size = s -> max_packet_size ? s -> max_packet_size : 32768 ;
if ( ! s -> read_packet && s -> buf_ptr >= s -> buf_end )
s -> eof_reached = 1;
if ( s -> eof_reached )
if ( s -> update_checksum && dst == s -> buffer )
if ( s -> buf_end > s -> checksum_ptr )
s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_end - s -> checksum_ptr ) ) );
s -> checksum_ptr = s -> buffer;
if ( s -> read_packet && s -> buffer_size > max_buffer_size )
s -> checksum_ptr = dst = s -> buffer;
len = s -> buffer_size;
if ( s -> read_packet )
len = ( ( s -> read_packet ) ( s -> opaque , dst , len ) );
len = 0;
if ( len <= 0 )
s -> eof_reached = 1;
if ( len < 0 )
s -> error = len;
s -> pos += len;
s -> buf_ptr = dst;
s -> buf_end = dst + len;
s -> bytes_read += len;
0
------------------------------
307289 109175/CWE606_Unchecked_Loop_Condition__wchar_t_connect_socket_06.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 ) 196
static void goodB2G1()
wchar_t * data ;
wchar_t dataBuffer [ 100 ] = L ""
data = dataBuffer;
if ( STATIC_CONST_FIVE == 5 )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
304985 83670/CWE190_Integer_Overflow__int_max_square_41.c int result = data * data ; 28
void CWE190_Integer_Overflow__int_max_square_41_bad()
int data ;
data = 0;
data = INT_MAX;
badSink ( data );
static void badSink(int data)
int result = data * data ;
printIntLine ( result );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
1
------------------------------
298164 98303/CWE398_Poor_Code_Quality__addition_04.c intSum = intOne + intTwo 73
static void good2()
if ( STATIC_CONST_TRUE )
int intOne = 1 , intTwo = 1 , intSum = 0 ;
intSum = intOne + intTwo;
printIntLine ( intSum );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
0
------------------------------
310433 151635/config.c apr_size_t len = ( name_end - name_start ) ; 694
void svn_config_get(svn_config_t *cfg,const char **valuep,const char *section,const char *option,const char *default_value)
if ( cfg )
cfg_section_t * sec ;
cfg_option_t * opt = find_option ( cfg , section , option , & sec ) ;
if ( opt != ( ( void * ) 0 ) )
if ( default_value && strchr ( default_value , 37 ) )
apr_pool_t * tmp_pool = svn_pool_create_ex ( cfg -> x_pool , ( ( void * ) 0 ) ) ;
const char * x_default ;
expand_option_value ( cfg , sec , default_value , & x_default , tmp_pool );
static void expand_option_value(svn_config_t *cfg,cfg_section_t *section,const char *opt_value,const char **opt_x_valuep,apr_pool_t *x_pool)
const char * parse_from = opt_value ;
const char * name_start ;
const char * name_end ;
while ( parse_from != ( ( void * ) 0 ) && ( * parse_from ) != '\0' && ( name_start = ( strstr ( parse_from , "%(" ) ) ) != ( ( void * ) 0 ) )
name_start += sizeof ( "%(" ) - 1;
if ( ( * name_start ) == '\0' )
name_end = ( strstr ( name_start , ")s" ) );
if ( name_end != ( ( void * ) 0 ) )
cfg_option_t * x_opt ;
apr_size_t len = ( name_end - name_start ) ;
char * name = apr_pstrmemdup ( x_pool , name_start , len ) ;
x_opt = find_option ( cfg , section -> name , name , ( ( void * ) 0 ) );
if ( x_opt != ( ( void * ) 0 ) )
const char * cstring ;
make_string_from_option ( & cstring , cfg , section , x_opt , x_pool );
parse_from = name_end + ( sizeof ( ")s" ) - 1 );
parse_from = name_end + ( sizeof ( ")s" ) - 1 );
parse_from = ( ( void * ) 0 );
static void make_string_from_option(const char **valuep,svn_config_t *cfg,cfg_section_t *section,cfg_option_t *opt,apr_pool_t *x_pool)
if ( ! opt -> expanded )
if ( opt -> value && strchr ( opt -> value , 37 ) )
apr_pool_t * tmp_pool = x_pool ? x_pool : svn_pool_create_ex ( cfg -> x_pool , ( ( void * ) 0 ) ) ;
expand_option_value ( cfg , section , opt -> value , & opt -> x_value , tmp_pool );
static void expand_option_value(svn_config_t *cfg,cfg_section_t *section,const char *opt_value,const char **opt_x_valuep,apr_pool_t *x_pool)
const char * parse_from = opt_value ;
const char * name_start ;
const char * name_end ;
while ( parse_from != ( ( void * ) 0 ) && ( * parse_from ) != '\0' && ( name_start = ( strstr ( parse_from , "%(" ) ) ) != ( ( void * ) 0 ) )
name_start += sizeof ( "%(" ) - 1;
if ( ( * name_start ) == '\0' )
name_end = ( strstr ( name_start , ")s" ) );
if ( name_end != ( ( void * ) 0 ) )
cfg_option_t * x_opt ;
apr_size_t len = ( name_end - name_start ) ;
char * name = apr_pstrmemdup ( x_pool , name_start , len ) ;
x_opt = find_option ( cfg , section -> name , name , ( ( void * ) 0 ) );
if ( x_opt != ( ( void * ) 0 ) )
make_string_from_option ( & cstring , cfg , section , x_opt , x_pool );
parse_from = name_end + ( sizeof ( ")s" ) - 1 );
parse_from = name_end + ( sizeof ( ")s" ) - 1 );
parse_from = ( ( void * ) 0 );
0
------------------------------
299057 152179/string.c total_len = str -> len + count 556
char *svn_cstring_join(const apr_array_header_t *strings,const char *separator,apr_pool_t *pool)
svn_stringbuf_t * new_str = svn_stringbuf_create_empty ( pool ) ;
svn_stringbuf_t *svn_stringbuf_create_empty(apr_pool_t *pool)
return svn_stringbuf_create_ensure ( 0 , pool ) ;
svn_stringbuf_t *svn_stringbuf_create_ensure(apr_size_t blocksize,apr_pool_t *pool)
void * mem ;
svn_stringbuf_t * new_string ;
new_string = mem;
new_string -> data = ( ( char * ) mem ) + sizeof ( ( * new_string ) );
new_string -> data [ 0 ] = '\0';
new_string -> len = 0;
new_string -> blocksize = blocksize - sizeof ( ( * new_string ) );
new_string -> pool = pool;
return new_string ;
int i ;
for (i = 0; i < strings -> nelts; i++)
const char * string = ( ( const char * * ) ( strings -> elts ) ) [ i ] ;
svn_stringbuf_appendbytes ( new_str , string , strlen ( string ) );
void svn_stringbuf_appendbytes(svn_stringbuf_t *str,const char *bytes,apr_size_t count)
apr_size_t total_len ;
total_len = str -> len + count;
svn_stringbuf_ensure ( str , total_len );
void svn_stringbuf_ensure(svn_stringbuf_t *str,apr_size_t minimum_size)
membuf_ensure ( & mem , & str -> blocksize , minimum_size , str -> pool );
inline static void membuf_ensure(void **data,apr_size_t *size,apr_size_t minimum_size,apr_pool_t *pool)
if ( minimum_size > * size )
apr_size_t new_size = * size ;
if ( new_size == 0 )
new_size = minimum_size;
while ( new_size < minimum_size )
const apr_size_t prev_size = new_size ;
new_size *= 2;
if ( prev_size > new_size )
new_size = minimum_size;
membuf_create ( data , size , new_size , pool );
inline static void membuf_create(void **data,apr_size_t *size,apr_size_t minimum_size,apr_pool_t *pool)
minimum_size = minimum_size + ( 8 - 1 ) & ( ~ ( 8 - 1 ) );
* data = ( ! minimum_size ? ( ( void * ) 0 ) : apr_palloc ( pool , minimum_size ) );
* size = minimum_size;
if ( mem && mem != ( str -> data ) )
if ( str -> data )
memcpy ( mem , ( str -> data ) , str -> len + 1 );
str -> data = mem;
str -> len = total_len;
str -> data [ str -> len ] = '\0';
0
------------------------------
300533 152633/aviobuf.c s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_end - s -> checksum_ptr ) ) ) 480
int avio_get_str16le(AVIOContext *pb,int maxlen,char *buf,int buflen)
int ret = 0 ;
if ( buflen <= 0 )
while ( ret + 1 < maxlen )
uint32_t ch ;
ch = ( ( ret += 2 ) <= maxlen ? avio_rl16 ( pb ) : 0 );
unsigned int hi = ch - 0xD800 ;
if ( hi < 0x800 )
ch = ( ( ret += 2 ) <= maxlen ? avio_rl16 ( pb ) : ( 0 - 0xDC00 ) );
if ( ch > 0x3FFU || hi > 0x3FFU )
ch += ( hi << 10 ) + 0x10000;
if ( ! ch )
unsigned int avio_rl16(AVIOContext *s)
unsigned int val ;
val = ( avio_r8 ( s ) );
val |= ( avio_r8 ( s ) << 8 );
int avio_r8(AVIOContext *s)
if ( s -> buf_ptr >= s -> buf_end )
fill_buffer ( s );
static void fill_buffer(AVIOContext *s)
uint8_t * dst = ! s -> max_packet_size && s -> buf_end - s -> buffer < ( s -> buffer_size ) ? s -> buf_end : s -> buffer ;
if ( ! s -> read_packet && s -> buf_ptr >= s -> buf_end )
s -> eof_reached = 1;
if ( s -> eof_reached )
if ( s -> update_checksum && dst == s -> buffer )
if ( s -> buf_end > s -> checksum_ptr )
s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_end - s -> checksum_ptr ) ) );
s -> checksum_ptr = s -> buffer;
if ( s -> read_packet && s -> buffer_size > max_buffer_size )
ffio_set_buf_size ( s , max_buffer_size );
s -> checksum_ptr = dst = s -> buffer;
len = s -> buffer_size;
if ( s -> read_packet )
len = ( ( s -> read_packet ) ( s -> opaque , dst , len ) );
if ( len <= 0 )
s -> eof_reached = 1;
if ( len < 0 )
s -> error = len;
s -> pos += len;
s -> buf_ptr = dst;
s -> buf_end = dst + len;
s -> bytes_read += len;
0
------------------------------
307098 120342/CWE78_OS_Command_Injection__char_listen_socket_w32_spawnvp_84_bad.cpp recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 93
void bad()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
CWE78_OS_Command_Injection__char_listen_socket_w32_spawnvp_84_bad * badObject = new CWE78_OS_Command_Injection__char_listen_socket_w32_spawnvp_84_bad ( data ) ;
CWE78_OS_Command_Injection__char_listen_socket_w32_spawnvp_84_bad::CWE78_OS_Command_Injection__char_listen_socket_w32_spawnvp_84_bad(char * dataCopy)
data = dataCopy;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
0
------------------------------
314216 97860/CWE36_Absolute_Path_Traversal__wchar_t_listen_socket_open_21.cpp recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ) 108
void bad()
wchar_t * data ;
wchar_t dataBuffer [ FILENAME_MAX ] = L ""
data = dataBuffer;
data = badSource ( data );
static wchar_t * badSource(wchar_t * data)
if ( badStatic )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( FILENAME_MAX - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
305593 117252/CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_connect_socket_51b.c myString = ( wchar_t * ) malloc ( data * sizeof ( wchar_t ) ) 59
void CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_connect_socket_51_bad()
size_t data ;
data = 0;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
char inputBuffer [ CHAR_ARRAY_SIZE ] ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
inputBuffer [ recvResult ] = '\0';
data = strtoul ( inputBuffer , NULL , 0 );
while ( 0 )
CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_connect_socket_51b_badSink ( data );
void CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_connect_socket_51b_badSink(size_t data)
wchar_t * myString ;
if ( data > wcslen ( HELLO_STRING ) )
myString = ( wchar_t * ) malloc ( data * sizeof ( wchar_t ) );
wcscpy ( myString , HELLO_STRING );
printWLine ( myString );
void printWLine (const wchar_t * line)
if ( line != NULL )
wprintf ( L "%ls\n" , line )
free ( myString );
1
------------------------------
309745 152958/oids.c * left = len - i 1109
void oid_both_from_string(const gchar *oid_str,char **resolved_p,char **numeric_p)
guint32 * subids ;
guint subids_len = oid_string2subid ( oid_str , & subids ) ;
guint oid_string2subid(const char *str,guint32 **subids_p)
const char * r = str ;
guint32 * subids ;
guint32 * subids_overflow ;
guint n = check_num_oid ( str ) ;
guint64 subid = 0 ;
if ( ! n )
return 0 ;
* subids_p = subids = ( ep_alloc0 ( sizeof ( guint32 ) * n ) );
subids_overflow = subids + n;
switch ( * r )
subid = 0;
subids ++;
subid *= 10;
subid += ( ( * r ) - 48 );
if ( subids >= subids_overflow || subid > 0xffffffff )
return 0 ;
return 0 ;
while ( * ( r ++ ) )
return n ;
* resolved_p = ( ( void * ) ( oid_resolved ( subids_len , subids ) ) );
const gchar *oid_resolved(guint32 num_subids,guint32 *subids)
oid_info_t * oid ;
if ( ! ( subids && * subids <= 2 ) )
oid = oid_get ( num_subids , subids , & matched , & left );
oid_info_t *oid_get(guint len,guint32 *subids,guint *matched,guint *left)
oid_info_t * curr_oid = & oid_root ;
guint i ;
if ( ! ( subids && * subids <= 2 ) )
for (i = 0; i < len; i++)
oid_info_t * next_oid = ( emem_tree_lookup32 ( ( curr_oid -> children ) , subids [ i ] ) ) ;
if ( next_oid )
curr_oid = next_oid;
* left = len - i;
0
------------------------------
310493 150242/stream.c apr_size_t left_to_read = btn -> str -> len - btn -> amt_read ; 1545
static svn_error_t *read_handler_string(void *baton,char *buffer,apr_size_t *len)
struct string_stream_baton * btn = baton ;
apr_size_t left_to_read = btn -> str -> len - btn -> amt_read ;
* len = ( * len > left_to_read ? left_to_read : * len );
memcpy ( buffer , ( btn -> str -> data + btn -> amt_read ) , * len );
btn -> amt_read += * len;
0
------------------------------
307118 110448/CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fixed_68b.c intPointer = ( int * ) malloc ( data * sizeof ( int ) ) 34
void CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fixed_68b_badSink()
int data = CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fixed_68_badData ;
int * intPointer ;
intPointer = ( int * ) malloc ( data * sizeof ( int ) );
intPointer [ i ] = 0;
printIntLine ( intPointer [ 0 ] );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
free ( intPointer );
1
------------------------------
20003 CVE-2015-8785/linux_kernel_4.3_CVE_2015_8785_fs_fuse_file.c endbyte = pos + written_buffered - 1 1193
static ssize_t fuse_file_write_iter(struct kiocb *iocb, struct iov_iter *from)
struct file * file = iocb -> ki_filp ;
struct address_space * mapping = file -> f_mapping ;
struct inode * inode = mapping -> host ;
ssize_t err ;
if ( get_fuse_conn ( inode ) -> writeback_cache )
err = generic_write_checks ( iocb , from );
if ( err <= 0 )
err = file_remove_privs ( file );
if ( err )
err = file_update_time ( file );
if ( err )
if ( iocb -> ki_flags & IOCB_DIRECT )
loff_t pos = iocb -> ki_pos ;
written = generic_file_direct_write ( iocb , from , pos );
if ( written < 0 || ! iov_iter_count ( from ) )
pos += written;
written_buffered = fuse_perform_write ( file , mapping , from , pos );
static ssize_t fuse_perform_write(struct file
struct address_space
struct iov_iter *ii, loff_t pos)
struct inode * inode = mapping -> host ;
struct fuse_conn * fc = get_fuse_conn ( inode ) ;
ssize_t res = 0 ;
if ( is_bad_inode ( inode ) )
return - EIO ;
struct fuse_req * req ;
ssize_t count ;
unsigned nr_pages = fuse_wr_pages ( pos , iov_iter_count ( ii ) ) ;
req = fuse_get_req ( fc , nr_pages );
if ( IS_ERR ( req ) )
err = PTR_ERR ( req );
count = fuse_fill_write_pages ( req , mapping , ii , pos );
static ssize_t fuse_fill_write_pages(struct fuse_req
struct address_space
struct iov_iter *ii, loff_t pos)
struct fuse_conn * fc = get_fuse_conn ( mapping -> host ) ;
unsigned offset = pos & ( PAGE_CACHE_SIZE - 1 ) ;
size_t count = 0 ;
int err ;
req -> in . argpages = 1;
req -> page_descs [ 0 ] . offset = offset;
size_t tmp ;
struct page * page ;
pgoff_t index = pos >> PAGE_CACHE_SHIFT ;
size_t bytes = min_t ( size_t , PAGE_CACHE_SIZE - offset , iov_iter_count ( ii ) ) ;
bytes = min_t ( size_t , bytes , fc -> max_write - count );
err = - EFAULT;
if ( iov_iter_fault_in_readable ( ii , bytes ) )
err = - ENOMEM;
page = grab_cache_page_write_begin ( mapping , index , 0 );
if ( ! page )
tmp = iov_iter_copy_from_user_atomic ( page , ii , offset , bytes );
if ( ! tmp )
bytes = min ( bytes , iov_iter_single_seg_count ( ii ) );
err = 0;
req -> pages [ req -> num_pages ] = page;
req -> page_descs [ req -> num_pages ] . length = tmp;
req -> num_pages ++;
count += tmp;
pos += tmp;
offset += tmp;
if ( offset == PAGE_CACHE_SIZE )
offset = 0;
if ( ! fc -> big_writes )
while ( iov_iter_count ( ii ) && count < fc -> max_write && req -> num_pages < req -> max_pages && offset == 0 )
return count > 0 ? count : err ;
if ( count <= 0 )
err = count;
size_t num_written ;
num_written = fuse_send_write_pages ( req , file , inode , pos , count );
static size_t fuse_send_write_pages(struct fuse_req *req, struct file
struct inode *inode, loff_t
size_t count)
size_t res ;
struct fuse_io_priv io = . async = 0 , . file = file
res = fuse_send_write ( req , & io , pos , count , NULL );
static size_t fuse_send_write(struct fuse_req *req, struct fuse_io_priv
loff_t pos, size_t count, fl_owner_t owner)
struct file * file = io -> file ;
struct fuse_file * ff = file -> private_data ;
struct fuse_conn * fc = ff -> fc ;
if ( io -> async )
return fuse_async_req_send ( fc , req , count , io ) ;
static size_t fuse_async_req_send(struct fuse_conn *fc, struct fuse_req
size_t num_bytes, struct fuse_io_priv *io)
return num_bytes ;
return req -> misc . write . out . size ;
return res ;
err = req -> out . h . error;
if ( ! err )
res += num_written;
pos += num_written;
if ( num_written != count )
err = - EIO;
while ( ! err && iov_iter_count ( ii ) )
return res > 0 ? res : err ;
if ( written_buffered < 0 )
endbyte = pos + written_buffered - 1;
err = filemap_write_and_wait_range ( file -> f_mapping , pos , endbyte );
if ( err )
invalidate_mapping_pages ( file -> f_mapping , pos >> PAGE_CACHE_SHIFT , endbyte >> PAGE_CACHE_SHIFT );
return written ? written : err ;
0
------------------------------
313567 90699/CWE23_Relative_Path_Traversal__char_listen_socket_open_16.cpp recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ) 111
void bad()
char * data ;
char dataBuffer [ FILENAME_MAX ] = BASEPATH ;
data = dataBuffer;
while ( 1 )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
fileDesc = OPEN ( data , O_RDWR | O_CREAT , S_IREAD | S_IWRITE );
if ( fileDesc != - 1 )
CLOSE ( fileDesc );
1
------------------------------
19991 CVE-2016-2328/Ffmpeg_2.8.2_CVE_2016_2328_libswscale_swscale_unscaled.c uint8_t * dest = dst + dstStride * h ; 784
static int planarRgbToRgbWrapper(SwsContext *c, const uint8_t
int srcStride[], int srcSliceY, int
uint8_t *dst[], int dstStride[])
const uint8_t * src201 [ ] = { src [ 2 ] , src [ 0 ] , src [ 1 ] } ;
int stride201 [ ] = { srcStride [ 2 ] , srcStride [ 0 ] , srcStride [ 1 ] } ;
if ( c -> srcFormat != AV_PIX_FMT_GBRP )
switch ( c -> dstFormat )
gbr24ptopacked24 ( src201 , stride201 , dst [ 0 ] + srcSliceY * dstStride [ 0 ] , dstStride [ 0 ] , srcSliceH , c -> srcW );
static void gbr24ptopacked24(const uint8_t *src[], int
uint8_t *dst, int dstStride, int
int width)
int x , h , i ;
for (h = 0; h < srcSliceH; h++)
uint8_t * dest = dst + dstStride * h ;
* dest ++ = src [ 0 ] [ x ];
* dest ++ = src [ 1 ] [ x ];
* dest ++ = src [ 2 ] [ x ];
0
------------------------------
309381 151093/config.c apr_size_t len = ( name_end - name_start ) ; 509
void svn_config_get(svn_config_t *cfg,const char **valuep,const char *section,const char *option,const char *default_value)
if ( cfg )
cfg_section_t * sec ;
cfg_option_t * opt = find_option ( cfg , section , option , & sec ) ;
if ( opt != ( ( void * ) 0 ) )
if ( default_value && strchr ( default_value , 37 ) )
apr_pool_t * tmp_pool = svn_pool_create_ex ( cfg -> x_pool , ( ( void * ) 0 ) ) ;
const char * x_default ;
expand_option_value ( cfg , sec , default_value , & x_default , tmp_pool );
static void expand_option_value(svn_config_t *cfg,cfg_section_t *section,const char *opt_value,const char **opt_x_valuep,apr_pool_t *x_pool)
const char * parse_from = opt_value ;
const char * name_start ;
const char * name_end ;
while ( parse_from != ( ( void * ) 0 ) && ( * parse_from ) != '\0' && ( name_start = ( strstr ( parse_from , "%(" ) ) ) != ( ( void * ) 0 ) )
name_start += sizeof ( "%(" ) - 1;
if ( ( * name_start ) == '\0' )
name_end = ( strstr ( name_start , ")s" ) );
if ( name_end != ( ( void * ) 0 ) )
cfg_option_t * x_opt ;
apr_size_t len = ( name_end - name_start ) ;
char * name = apr_pstrmemdup ( x_pool , name_start , len ) ;
x_opt = find_option ( cfg , section -> name , name , ( ( void * ) 0 ) );
if ( x_opt != ( ( void * ) 0 ) )
const char * cstring ;
make_string_from_option ( & cstring , cfg , section , x_opt , x_pool );
parse_from = name_end + ( sizeof ( ")s" ) - 1 );
parse_from = name_end + ( sizeof ( ")s" ) - 1 );
parse_from = ( ( void * ) 0 );
static void make_string_from_option(const char **valuep,svn_config_t *cfg,cfg_section_t *section,cfg_option_t *opt,apr_pool_t *x_pool)
if ( ! opt -> expanded )
if ( opt -> value && strchr ( opt -> value , 37 ) )
apr_pool_t * tmp_pool = x_pool ? x_pool : svn_pool_create_ex ( cfg -> x_pool , ( ( void * ) 0 ) ) ;
expand_option_value ( cfg , section , opt -> value , & opt -> x_value , tmp_pool );
static void expand_option_value(svn_config_t *cfg,cfg_section_t *section,const char *opt_value,const char **opt_x_valuep,apr_pool_t *x_pool)
const char * parse_from = opt_value ;
const char * name_start ;
const char * name_end ;
while ( parse_from != ( ( void * ) 0 ) && ( * parse_from ) != '\0' && ( name_start = ( strstr ( parse_from , "%(" ) ) ) != ( ( void * ) 0 ) )
name_start += sizeof ( "%(" ) - 1;
if ( ( * name_start ) == '\0' )
name_end = ( strstr ( name_start , ")s" ) );
if ( name_end != ( ( void * ) 0 ) )
cfg_option_t * x_opt ;
apr_size_t len = ( name_end - name_start ) ;
char * name = apr_pstrmemdup ( x_pool , name_start , len ) ;
x_opt = find_option ( cfg , section -> name , name , ( ( void * ) 0 ) );
if ( x_opt != ( ( void * ) 0 ) )
make_string_from_option ( & cstring , cfg , section , x_opt , x_pool );
parse_from = name_end + ( sizeof ( ")s" ) - 1 );
parse_from = name_end + ( sizeof ( ")s" ) - 1 );
parse_from = ( ( void * ) 0 );
0
------------------------------
19864 CVE-2016-2522/Wireshark_2.0.1_CVE_2016_2522_epan_dissectors_packet-ber.c eoffset = offset + len 3439

dissect_ber_sequence_of(gboolean implicit_tag, asn1_ctx_t *actx, proto_tree *parent_tree, tvbuff_t *tvb, int offset, const ber_sequence_t *seq, gint hf_id, gint ett_id)
return dissect_ber_sq_of ( implicit_tag , BER_UNI_TAG_SEQUENCE , actx , parent_tree , tvb , offset , NO_BOUND , NO_BOUND , seq , hf_id , ett_id ) ;
static
dissect_ber_sq_of(gboolean implicit_tag, gint32 type, asn1_ctx_t *actx, proto_tree *parent_tree, tvbuff_t *tvb, int offset, gint32 min_len, gint32 max_len, const ber_sequence_t *seq, gint hf_id, gint ett_id)
gint8 classx ;
gboolean pcx , ind = FALSE , ind_field ;
gint32 tagx ;
guint32 lenx ;
proto_tree * tree = parent_tree ;
int cnt , hoffsetx , end_offset ;
if ( ! implicit_tag )
offset = dissect_ber_identifier ( actx -> pinfo , tree , tvb , offset , & classx , & pcx , & tagx );
offset = dissect_ber_length ( actx -> pinfo , tree , tvb , offset , & lenx , & ind );
end_offset = offset + lenx;
if ( ( classx != BER_CLASS_APP ) && ( classx != BER_CLASS_PRI ) )
if ( ! pcx || ( ! implicit_tag && ( ( classx != BER_CLASS_UNI ) || ( tagx != type ) ) ) )
lenx = tvb_reported_length_remaining ( tvb , offset );
end_offset = offset + lenx;
hoffsetx = offset;
offset = hoffsetx;
while ( offset < end_offset )
gint8 ber_class ;
gint32 tag ;
guint32 len ;
int eoffset ;
hoffset = offset;
if ( ( tvb_get_guint8 ( tvb , offset ) == 0 ) && ( tvb_get_guint8 ( tvb , offset + 1 ) == 0 ) )
proto_tree_add_item ( tree , hf_ber_seq_of_eoc , tvb , hoffset , end_offset - hoffset , ENC_NA );
return offset + 2 ;
offset = get_ber_identifier ( tvb , offset , & ber_class , & pc , & tag );
offset = get_ber_length ( tvb , offset , & len , & ind_field );
eoffset = offset + len;
if ( eoffset <= hoffset )
if ( ( ber_class == BER_CLASS_UNI ) && ( tag == BER_UNI_TAG_EOC ) )
hoffset = dissect_ber_identifier ( actx -> pinfo , tree , tvb , hoffset , NULL , NULL , NULL );
dissect_ber_length ( actx -> pinfo , tree , tvb , hoffset , NULL , NULL );
return eoffset ;
if ( seq -> ber_class != BER_CLASS_ANY )
if ( ( seq -> ber_class != ber_class ) || ( seq -> tag != tag ) )
if ( ! ( seq -> flags & BER_FLAGS_NOTCHKTAG ) )
cause = proto_tree_add_string_format_value ( tree , hf_ber_error , tvb , offset , len , "wrong_field" , "Wrong field in SQ OF  expected class:%s(%d) tag:%d(%s) but found class:%s(%d) tag:%d" , val_to_str_const ( seq -> ber_class , ber_class_codes , "Unknown" ) , seq -> ber_class , seq -> tag , val_to_str_ext_const ( seq -> tag , & ber_uni_tag_codes_ext , "Unknown" ) , val_to_str_const ( ber_class , ber_class_codes , "Unknown" ) , ber_class , tag );
cause = proto_tree_add_string_format_value ( tree , hf_ber_error , tvb , offset , len , "wrong_field" , "Wrong field in SQ OF  expected class:%s(%d) tag:%d but found class:%s(%d) tag:%d" , val_to_str_const ( seq -> ber_class , ber_class_codes , "Unknown" ) , seq -> ber_class , seq -> tag , val_to_str_const ( ber_class , ber_class_codes , "Unknown" ) , ber_class , tag );
expert_add_info_format ( actx -> pinfo , cause , & ei_ber_sequence_field_wrong , "BER Error: Wrong field in SEQUENCE OF" );
proto_tree * unknown_tree = proto_item_add_subtree ( cause , ett_ber_unknown ) ;
dissect_unknown_ber ( actx -> pinfo , tvb , hoffset , unknown_tree );
offset = eoffset;
hoffset = dissect_ber_identifier ( actx -> pinfo , tree , tvb , hoffset , NULL , NULL , NULL );
hoffset = dissect_ber_length ( actx -> pinfo , tree , tvb , hoffset , NULL , NULL );
hoffset = dissect_ber_identifier ( actx -> pinfo , tree , tvb , hoffset , NULL , NULL , NULL );
hoffset = dissect_ber_length ( actx -> pinfo , tree , tvb , hoffset , NULL , NULL );
next_tvb = ber_tvb_new_subset_length ( tvb , hoffset , eoffset - hoffset );
seq -> func ( imp_tag , next_tvb , 0 , actx , tree , * seq -> p_id );
offset = eoffset;
if ( offset != end_offset )
tvb_ensure_bytes_exist ( tvb , offset - 2 , 2 );
causex = proto_tree_add_string_format_value ( tree , hf_ber_error , tvb , offset - 2 , 2 , "illegal_length" , "%s Of ate %d too many bytes" , ( type == BER_UNI_TAG_SEQUENCE ) ? "Set" : "Sequence" , offset - end_offset );
expert_add_info_format ( actx -> pinfo , causex , & ei_ber_error_length , "BER Error:too many byte in %s" , ( type == BER_UNI_TAG_SEQUENCE ) ? "Set" : "Sequence" );
1
------------------------------
300121 150145/file_wrappers.c offset = file -> pos + offset - off2 1234
gint64 file_skip(FILE_T file,gint64 delta,int *err)
return file_seek ( file , delta , 1 , err ) ;
gint64 file_seek(FILE_T file,gint64 offset,int whence,int *err)
struct fast_seek_point * here ;
if ( whence == 0 )
offset -= file -> pos;
if ( file -> seek )
offset += file -> skip;
file -> seek = 0;
if ( offset < 0 && file -> next )
unsigned int had = ( unsigned int ) ( file -> next - file -> out ) ;
if ( - offset <= had )
if ( ( here = fast_seek_find ( file , file -> pos + offset ) ) && ( offset < 0 || offset > 1048576L || here -> compression == 1 ) )
static struct fast_seek_point *fast_seek_find(FILE_T file,gint64 pos)
struct fast_seek_point * smallest = ( ( void * ) 0 ) ;
struct fast_seek_point * item ;
guint low ;
guint i ;
guint max ;
if ( ! file -> fast_seek )
return ( ( void * ) 0 ) ;
for ((low = 0 , max = file -> fast_seek -> len); low < max; )
i = ( low + max ) / 2;
item = ( ( struct fast_seek_point * ) file -> fast_seek -> pdata [ i ] );
if ( pos < item -> out )
max = i;
if ( pos > item -> out )
smallest = item;
low = i + 1;
return item ;
return smallest ;
gint64 off ;
gint64 off2 ;
if ( here -> compression == 2 )
off = here -> in - ( ( here -> data . zlib . bits ? 1 : 0 ) );
off2 = here -> out;
if ( here -> compression == 3 )
off = here -> in;
off2 = here -> out;
off2 = file -> pos + offset;
off = here -> in + ( off2 - here -> out );
if ( lseek ( file -> fd , off , 0 ) == ( - 1 ) )
file -> raw_pos = off;
file -> have = 0;
file -> eof = 0;
file -> seek = 0;
file -> err = 0;
file -> err_info = ( ( void * ) 0 );
file -> avail_in = 0;
if ( here -> compression == 2 )
if ( here -> data . zlib . bits )
FILE_T state = file ;
int ret = state -> avail_in == 0 && fill_in_buffer ( state ) == - 1 ? - 1 : ( ( state -> avail_in == 0 ? - 1 : ( ( state -> avail_in -- , * ( state -> next_in ++ ) ) ) ) ) ;
static int fill_in_buffer(FILE_T state)
if ( state -> err )
return - 1 ;
if ( state -> eof == 0 )
if ( raw_read ( state , state -> in , state -> size , ( ( unsigned int * ) ( & state -> avail_in ) ) ) == - 1 )
static int raw_read(FILE_T state,unsigned char *buf,unsigned int count,unsigned int *have)
int ret ;
* have = 0;
ret = ( read ( state -> fd , ( buf + * have ) , ( count - * have ) ) );
if ( ret <= 0 )
* have += ret;
state -> raw_pos += ret;
while ( * have < count )
if ( ret < 0 )
return - 1 ;
return 0 ;
return - 1 ;
return 0 ;
if ( ret == - 1 )
file -> compression = 2;
if ( here -> compression == 3 )
file -> compression = 2;
file -> compression = here -> compression;
offset = file -> pos + offset - off2;
if ( offset )
file -> skip = offset;
return file -> pos + offset ;
0
------------------------------
304934 79116/CWE134_Uncontrolled_Format_String__char_connect_socket_fprintf_21.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 200
static void goodB2G1()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
goodB2G1Sink ( data );
static void goodB2G1Sink(char * data)
fprintf ( stdout , "%s\n" , data );
0
------------------------------
21418 CVE-2015-4002/linux_kernel_4.0.5_CVE_2015_4002_drivers_staging_ozwpan_ozusbsvc1.c int data_len = elt -> length - sizeof ( struct oz_get_desc_rsp ) + 1 ; 393
void oz_usb_rx(struct oz_pd *pd, struct oz_elt *elt)
struct oz_usb_hdr * usb_hdr = ( struct oz_usb_hdr * ) ( elt + 1 ) ;
struct oz_usb_ctx * usb_ctx ;
usb_ctx = ( struct oz_usb_ctx * ) pd -> app_ctx [ OZ_APPID_USB ];
if ( usb_ctx == NULL )
if ( usb_ctx -> stopped )
if ( usb_hdr -> elt_seq_num != 0 )
if ( ( ( usb_ctx -> rx_seq_num - usb_hdr -> elt_seq_num ) & 0x80 ) == 0 )
switch ( usb_hdr -> type )
int data_len = elt -> length - sizeof ( struct oz_get_desc_rsp ) + 1 ;
oz_hcd_get_desc_cnf ( usb_ctx -> hport , body -> req_id , body -> rcode , body -> data , data_len , offs , total_size );
0
------------------------------
299331 153796/oids.c * left = len - i 1121
void oid_both_from_encoded(const guint8 *oid,gint oid_len,char **resolved_p,char **numeric_p)
guint32 * subids ;
guint subids_len = oid_encoded2subid ( oid , oid_len , & subids ) ;
guint oid_encoded2subid(const guint8 *oid_bytes,gint oid_len,guint32 **subids_p)
gint i ;
guint n = 1 ;
gboolean is_first = ! 0 ;
guint32 * subids ;
guint32 * subid_overflow ;
guint64 subid = 0 ;
for (i = 0; i < oid_len; i++)
if ( ! ( oid_bytes [ i ] & 0x0080 ) )
n ++;
* subids_p = subids = ( ep_alloc ( sizeof ( guint32 ) * n ) );
subid_overflow = subids + n;
for (i = 0; i < oid_len; i++)
guint8 byte = oid_bytes [ i ] ;
subid <<= 7;
subid |= ( byte & 0x7F );
if ( byte & 0x0080 )
if ( is_first )
guint32 subid0 = 0 ;
if ( subid >= 40 )
subid0 ++;
subid -= 40;
if ( subid >= 40 )
subid0 ++;
subid -= 40;
* ( subids ++ ) = subid0;
is_first = 0;
if ( subids >= subid_overflow || subid > 0xffffffff )
return 0 ;
* ( subids ++ ) = ( ( guint32 ) subid );
subid = 0;
return n ;
* resolved_p = ( ( void * ) ( oid_resolved ( subids_len , subids ) ) );
const gchar *oid_resolved(guint32 num_subids,guint32 *subids)
oid_info_t * oid ;
if ( ! ( subids && * subids <= 2 ) )
oid = oid_get ( num_subids , subids , & matched , & left );
oid_info_t *oid_get(guint len,guint32 *subids,guint *matched,guint *left)
oid_info_t * curr_oid = & oid_root ;
guint i ;
if ( ! ( subids && * subids <= 2 ) )
for (i = 0; i < len; i++)
oid_info_t * next_oid = ( emem_tree_lookup32 ( ( curr_oid -> children ) , subids [ i ] ) ) ;
if ( next_oid )
curr_oid = next_oid;
* left = len - i;
0
------------------------------
304757 81896/CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_vprintf_15.c recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 ) 111
void CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_vprintf_15_bad()
wchar_t * data ;
wchar_t dataBuffer [ 100 ] = L ""
data = dataBuffer;
switch ( 6 )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
303189 84111/CWE190_Integer_Overflow__short_max_square_61a.c short result = data * data ; 69
static void goodB2G()
short data ;
data = 0;
data = CWE190_Integer_Overflow__short_max_square_61b_goodB2GSource ( data );
short CWE190_Integer_Overflow__short_max_square_61b_goodB2GSource(short data)
data = SHRT_MAX;
return data ;
if ( abs ( ( long ) data ) <= ( long ) sqrt ( ( double ) SHRT_MAX ) )
short result = data * data ;
printIntLine ( result );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
0
------------------------------
307918 110328/CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_connect_socket_17.c intPointer = ( int * ) malloc ( data * sizeof ( int ) ) 144
static void goodG2B()
int h ;
int data ;
data = - 1;
for(h = 0; h < 1; h++)
data = 20;
int * intPointer ;
intPointer = ( int * ) malloc ( data * sizeof ( int ) );
intPointer [ i ] = 0;
printIntLine ( intPointer [ 0 ] );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
free ( intPointer );
0
------------------------------
312504 152490/tile-swap.c err = ( read ( swap_file -> fd , ( tile -> data + tile -> size - nleft ) , nleft ) ) 366
void tile_swap_in(Tile *tile)
if ( tile -> swap_offset == ( - 1 ) )
tile_swap_command ( tile , SWAP_IN );
static void tile_swap_command(Tile *tile,gint command)
if ( gimp_swap_file -> fd == - 1 )
if ( gimp_swap_file -> fd == - 1 )
switch ( command )
tile_swap_default_in ( gimp_swap_file , tile );
static void tile_swap_default_in(SwapFile *swap_file,Tile *tile)
gint nleft ;
gint64 offset ;
if ( tile -> data )
if ( swap_file -> cur_position != tile -> swap_offset )
swap_file -> cur_position = tile -> swap_offset;
offset = lseek ( swap_file -> fd , tile -> swap_offset , 0 );
if ( offset == ( - 1 ) )
nleft = tile -> size;
while ( nleft > 0 )
gint err ;
err = ( read ( swap_file -> fd , ( tile -> data + tile -> size - nleft ) , nleft ) );
while ( err == - 1 && ( * __errno_location ( ) == 11 || * __errno_location ( ) == 4 ) )
if ( err <= 0 )
g_log ( "Gimp-Base" , G_LOG_LEVEL_MESSAGE , "unable to read tile data from disk: %s (%d/%d bytes read)" , g_strerror ( * __errno_location ( ) ) , err , nleft );
nleft -= err;
0
------------------------------
311142 153294/bufmgr.c newPartitionLock = ( ( LWLockId ) ( FirstBufMappingLock + newHash % 16 ) ) 596
Buffer ReadBufferWithoutRelcache(RelFileNode rnode,ForkNumber forkNum,BlockNumber blockNum,ReadBufferMode mode,BufferAccessStrategy strategy)
bool hit ;
SMgrRelation smgr = smgropen ( rnode , - 1 ) ;
return ReadBuffer_common ( smgr , 'p' , forkNum , blockNum , mode , strategy , & hit ) ;
static Buffer ReadBuffer_common(SMgrRelation smgr,char relpersistence,ForkNumber forkNum,BlockNumber blockNum,ReadBufferMode mode,BufferAccessStrategy strategy,bool *hit)
volatile BufferDesc * bufHdr ;
bool isExtend ;
bool isLocalBuf = ( smgr -> smgr_rnode . backend != - 1 ) ;
isExtend = ( blockNum == ( ( BlockNumber ) 0xFFFFFFFF ) );
if ( isExtend )
blockNum = smgrnblocks ( smgr , forkNum );
if ( isLocalBuf )
bufHdr = BufferAlloc ( smgr , relpersistence , forkNum , blockNum , strategy , & found );
static volatile BufferDesc *BufferAlloc(SMgrRelation smgr,char relpersistence,ForkNumber forkNum,BlockNumber blockNum,BufferAccessStrategy strategy,bool *foundPtr)
BufferTag newTag ;
uint32 newHash ;
LWLockId newPartitionLock ;
( newTag . rnode = smgr -> smgr_rnode . node , newTag . forkNum = forkNum ) , newTag . blockNum = blockNum;
newHash = BufTableHashCode ( & newTag );
newPartitionLock = ( ( LWLockId ) ( FirstBufMappingLock + newHash % 16 ) );
LWLockAcquire ( newPartitionLock , LW_SHARED );
LWLockRelease ( newPartitionLock );
LWLockRelease ( newPartitionLock );
if ( oldPartitionLock < newPartitionLock )
LWLockAcquire ( newPartitionLock , LW_EXCLUSIVE );
if ( oldPartitionLock > newPartitionLock )
LWLockAcquire ( newPartitionLock , LW_EXCLUSIVE );
LWLockAcquire ( newPartitionLock , LW_EXCLUSIVE );
LWLockAcquire ( newPartitionLock , LW_EXCLUSIVE );
if ( oldFlags & 1 << 2 && oldPartitionLock != newPartitionLock )
LWLockRelease ( newPartitionLock );
if ( oldFlags & 1 << 2 && oldPartitionLock != newPartitionLock )
LWLockRelease ( newPartitionLock );
if ( oldPartitionLock != newPartitionLock )
LWLockRelease ( newPartitionLock );
0
------------------------------
305857 120087/CWE78_OS_Command_Injection__char_listen_socket_w32_execv_54a.c recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 113
void CWE78_OS_Command_Injection__char_listen_socket_w32_execv_54_bad()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
CWE78_OS_Command_Injection__char_listen_socket_w32_execv_54b_badSink ( data );
void CWE78_OS_Command_Injection__char_listen_socket_w32_execv_54b_badSink(char * data)
CWE78_OS_Command_Injection__char_listen_socket_w32_execv_54c_badSink ( data );
void CWE78_OS_Command_Injection__char_listen_socket_w32_execv_54c_badSink(char * data)
CWE78_OS_Command_Injection__char_listen_socket_w32_execv_54d_badSink ( data );
void CWE78_OS_Command_Injection__char_listen_socket_w32_execv_54d_badSink(char * data)
CWE78_OS_Command_Injection__char_listen_socket_w32_execv_54e_badSink ( data );
void CWE78_OS_Command_Injection__char_listen_socket_w32_execv_54e_badSink(char * data)
0
------------------------------
314042 96908/CWE36_Absolute_Path_Traversal__wchar_t_connect_socket_open_43.cpp recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ) 95
void bad()
wchar_t * data ;
wchar_t dataBuffer [ FILENAME_MAX ] = L ""
data = dataBuffer;
badSource ( data );
void badSource(wchar_t * &data)
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( FILENAME_MAX - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
304749 81895/CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_vprintf_14.c recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 ) 110
void CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_vprintf_14_bad()
wchar_t * data ;
wchar_t dataBuffer [ 100 ] = L ""
data = dataBuffer;
if ( globalFive == 5 )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
307392 104493/CWE469_Use_of_Pointer_Subtraction_to_Determine_Size__wchar_t_16.c indexOfSlashInString1 = ( size_t ) ( slashInString1 - string2 ) 39
void CWE469_Use_of_Pointer_Subtraction_to_Determine_Size__wchar_t_16_bad()
while ( 1 )
wchar_t string2 [ ] = SOURCE_STRING ;
wchar_t * slashInString1 ;
size_t indexOfSlashInString1 ;
slashInString1 = wcschr ( string1 , L '/' )
indexOfSlashInString1 = ( size_t ) ( slashInString1 - string2 );
printUnsignedLine ( indexOfSlashInString1 );
void printUnsignedLine(unsigned unsignedNumber)
printf ( "%u\n" , unsignedNumber );
1
------------------------------
19178 CVE-2016-3062/Ffmpeg_0.11_CVE_2016_3062_libavformat_mov.c a . size = FFMIN ( a . size , atom . size - total_size ) 347
static int mov_read_meta(MOVContext *c, AVIOContext *pb, MOVAtom atom)
while ( atom . size > 8 )
uint32_t tag = avio_rl32 ( pb ) ;
atom . size -= 4;
if ( tag == MKTAG ( 'h' , 'd' , 'l' , 'r' ) )
atom . size += 8;
return mov_read_default ( c , pb , atom ) ;
static int mov_read_default(MOVContext *c, AVIOContext *pb, MOVAtom atom)
int64_t total_size = 0 ;
MOVAtom a ;
int i ;
if ( atom . size < 0 )
atom . size = INT64_MAX;
while ( total_size + 8 <= atom . size && ! url_feof ( pb ) )
a . size = atom . size;
a . type = 0;
if ( atom . size >= 8 )
a . size = avio_rb32 ( pb );
a . type = avio_rl32 ( pb );
if ( atom . type != MKTAG ( 'r' , 'o' , 'o' , 't' ) && atom . type != MKTAG ( 'm' , 'o' , 'o' , 'v' ) )
if ( a . type == MKTAG ( 't' , 'r' , 'a' , 'k' ) || a . type == MKTAG ( 'm' , 'd' , 'a' , 't' ) )
total_size += 8;
if ( a . size == 1 )
a . size = avio_rb64 ( pb ) - 8;
total_size += 8;
av_dlog ( c -> fc , "type: %08x '%.4s' parent:'%.4s' sz: %" PRId64 " %" PRId64 " %" PRId64 "\n"
a . type , ( char * ) & a . type , ( char * ) & atom . type , a . size , total_size , atom . size )
if ( a . size == 0 )
a . size = atom . size - total_size + 8;
a . size -= 8;
if ( a . size < 0 )
a . size = FFMIN ( a . size , atom . size - total_size );
for (i = 0; mov_default_parse_table[i].type; i++)
if ( mov_default_parse_table [ i ] . type == a . type )
parse = mov_default_parse_table [ i ] . parse;
if ( ! parse && ( atom . type == MKTAG ( 'u' , 'd' , 't' , 'a' ) || atom . type == MKTAG ( 'i' , 'l' , 's' , 't' ) ) )
parse = mov_read_udta_string;
if ( ! parse )
avio_skip ( pb , a . size );
int64_t start_pos = avio_tell ( pb ) ;
int err = parse ( c , pb , a ) ;
if ( err < 0 )
return err ;
if ( c -> found_moov && c -> found_mdat && ( ( ! pb -> seekable || c -> fc -> flags & AVFMT_FLAG_IGNIDX ) || start_pos + a . size == avio_size ( pb ) ) )
c -> next_root_atom = start_pos + a . size;
left = a . size - avio_tell ( pb ) + start_pos;
if ( left > 0 )
avio_skip ( pb , left );
total_size += a . size;
if ( total_size < atom . size && atom . size < 0x7ffff )
avio_skip ( pb , atom . size - total_size );
0
------------------------------
313894 90653/CWE23_Relative_Path_Traversal__char_listen_socket_ofstream_18.cpp recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ) 106
void bad()
char * data ;
char dataBuffer [ FILENAME_MAX ] = BASEPATH ;
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
outputFile . open ( ( char * ) data );
1
------------------------------
19261 CVE-2016-5257/Firefox_48.0b9_CVE_2016_5257_media_webrtc_trunk_webrtc_modules_video_coding_main_source_frame_buffer.cc const uint32_t newSize = _size + increments * kBufferIncStepSizeBytes ; 124

VCMFrameBuffer::InsertPacket(const VCMPacket&
int64_t
VCMDecodeErrorMode
const FrameData& frame_data)
uint32_t requiredSizeBytes = Length ( ) + packet . sizeBytes + ( packet . insertStartCode ? kH264StartCodeLengthBytes : 0 ) ;
if ( requiredSizeBytes >= _size )
const uint32_t increments = requiredSizeBytes / kBufferIncStepSizeBytes + ( requiredSizeBytes % kBufferIncStepSizeBytes > 0 ) ;
const uint32_t newSize = _size + increments * kBufferIncStepSizeBytes ;
if ( newSize > kMaxJBFrameSizeBytes )
VerifyAndAllocate ( newSize );
0
------------------------------
304073 79292/CWE134_Uncontrolled_Format_String__char_connect_socket_vprintf_03.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 102
void CWE134_Uncontrolled_Format_String__char_connect_socket_vprintf_03_bad()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
if ( 5 == 5 )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
badVaSinkB ( data , data );
static void badVaSinkB(char * data, ...)
va_start ( args , data );
vprintf ( data , args );
1
------------------------------
19649 CVE-2016-8658/linux_kernel_4.7.4_CVE_2016_8658_drivers_net_wireless_broadcom_brcm80211_brcmfmac_cfg80211.c parsed_info -> ie_len = vndrie -> len + TLV_HDR_LEN 4181
s32 brcmf_vif_clear_mgmt_ies(struct brcmf_cfg80211_vif *vif)
s32 pktflags [ ] = { BRCMF_VNDR_IE_PRBREQ_FLAG , BRCMF_VNDR_IE_PRBRSP_FLAG , BRCMF_VNDR_IE_BEACON_FLAG } ;
int i ;
for (i = 0; i < ARRAY_SIZE(pktflags); i++)
brcmf_vif_set_mgmt_ie ( vif , pktflags [ i ] , NULL , 0 );
s32 brcmf_vif_set_mgmt_ie(struct brcmf_cfg80211_vif *vif, s32
const u8 *vndr_ie_buf, u32 vndr_ie_len)
struct vif_saved_ie * saved_ie ;
u8 * iovar_ie_buf ;
u8 * curr_ie_buf ;
int mgmt_ie_buf_len ;
u32 * mgmt_ie_len ;
u32 parsed_ie_buf_len = 0 ;
struct parsed_vndr_ies old_vndr_ies ;
struct parsed_vndr_ies new_vndr_ies ;
struct parsed_vndr_ie_info * vndrie_info ;
s32 i ;
if ( ! vif )
saved_ie = & vif -> saved_ie;
iovar_ie_buf = kzalloc ( WL_EXTRA_BUF_MAX , GFP_KERNEL );
if ( ! iovar_ie_buf )
curr_ie_buf = iovar_ie_buf;
switch ( pktflag )
mgmt_ie_buf = saved_ie -> probe_req_ie;
mgmt_ie_len = & saved_ie -> probe_req_ie_len;
mgmt_ie_buf_len = sizeof ( saved_ie -> probe_req_ie );
mgmt_ie_buf = saved_ie -> probe_res_ie;
mgmt_ie_len = & saved_ie -> probe_res_ie_len;
mgmt_ie_buf_len = sizeof ( saved_ie -> probe_res_ie );
mgmt_ie_buf = saved_ie -> beacon_ie;
mgmt_ie_len = & saved_ie -> beacon_ie_len;
mgmt_ie_buf_len = sizeof ( saved_ie -> beacon_ie );
mgmt_ie_buf = saved_ie -> assoc_req_ie;
mgmt_ie_len = & saved_ie -> assoc_req_ie_len;
mgmt_ie_buf_len = sizeof ( saved_ie -> assoc_req_ie );
if ( vndr_ie_len > mgmt_ie_buf_len )
if ( vndr_ie_buf && vndr_ie_len && curr_ie_buf )
for (i = 0; i < new_vndr_ies.count; i++)
vndrie_info = & new_vndr_ies . ie_info [ i ];
parsed_ie_buf_len += vndrie_info -> ie_len;
if ( mgmt_ie_buf && * mgmt_ie_len )
if ( parsed_ie_buf_len && ( parsed_ie_buf_len == * mgmt_ie_len ) && ( memcmp ( mgmt_ie_buf , curr_ie_buf , parsed_ie_buf_len ) == 0 ) )
brcmf_parse_vndr_ies ( mgmt_ie_buf , * mgmt_ie_len , & old_vndr_ies );
static
brcmf_parse_vndr_ies(const u8 *vndr_ie_buf, u32
struct parsed_vndr_ies *vndr_ies)
struct brcmf_vs_tlv * vndrie ;
struct brcmf_tlv * ie ;
struct parsed_vndr_ie_info * parsed_info ;
s32 remaining_len ;
remaining_len = ( s32 ) vndr_ie_len;
memset ( vndr_ies , 0 , sizeof ( * vndr_ies ) );
ie = ( struct brcmf_tlv * ) vndr_ie_buf;
while ( ie )
if ( ie -> id != WLAN_EID_VENDOR_SPECIFIC )
vndrie = ( struct brcmf_vs_tlv * ) ie;
if ( vndrie -> len < ( VS_IE_FIXED_HDR_LEN - TLV_HDR_LEN + 1 ) )
if ( ! memcmp ( vndrie -> oui , ( u8 * ) WPA_OUI , TLV_OUI_LEN ) && ( ( vndrie -> oui_type == WPA_OUI_TYPE ) || ( vndrie -> oui_type == WME_OUI_TYPE ) ) )
parsed_info = & vndr_ies -> ie_info [ vndr_ies -> count ];
parsed_info -> ie_ptr = ( char * ) vndrie;
parsed_info -> ie_len = vndrie -> len + TLV_HDR_LEN;
memcpy ( & parsed_info -> vndrie , vndrie , sizeof ( * vndrie ) );
vndr_ies -> count ++;
brcmf_dbg ( TRACE , "** OUI %02x %02x %02x, type 0x%02x\n" , parsed_info -> vndrie . oui [ 0 ] , parsed_info -> vndrie . oui [ 1 ] , parsed_info -> vndrie . oui [ 2 ] , parsed_info -> vndrie . oui_type );
if ( vndr_ies -> count >= VNDR_IE_PARSE_LIMIT )
remaining_len -= ( ie -> len + TLV_HDR_LEN );
if ( remaining_len <= TLV_HDR_LEN )
ie = NULL;
ie = ( struct brcmf_tlv * ) ( ( ( u8 * ) ie ) + ie -> len + TLV_HDR_LEN );
0
------------------------------
19627 CVE-2016-8658/linux_kernel_4.7.4_CVE_2016_8658_drivers_net_wireless_broadcom_brcm80211_brcmfmac_cfg80211.c notify_ie = ( u8 * ) bi + le16_to_cpu ( bi -> ie_offset ) 2767
static
brcmf_notify_connect_status(struct brcmf_if
const struct brcmf_event_msg *e, void *data)
struct brcmf_cfg80211_info * cfg = ifp -> drvr -> config ;
struct net_device * ndev = ifp -> ndev ;
if ( brcmf_is_apmode ( ifp -> vif ) )
if ( brcmf_is_linkup ( e ) )
if ( brcmf_is_linkdown ( e ) )
static bool brcmf_is_linkdown(const struct brcmf_event_msg *e)
u32 event = e -> event_code ;
u16 flags = e -> flags ;
if ( ( event == BRCMF_E_DEAUTH ) || ( event == BRCMF_E_DEAUTH_IND ) || ( event == BRCMF_E_DISASSOC_IND ) || ( ( event == BRCMF_E_LINK ) && ( ! ( flags & BRCMF_EVENT_MSG_LINK ) ) ) )
return true ;
return false ;
if ( brcmf_is_nonetwork ( cfg , e ) )
static bool brcmf_is_nonetwork(struct brcmf_cfg80211_info
const struct brcmf_event_msg *e)
u32 event = e -> event_code ;
u32 status = e -> status ;
if ( event == BRCMF_E_LINK && status == BRCMF_E_STATUS_NO_NETWORKS )
return true ;
if ( event == BRCMF_E_SET_SSID && status != BRCMF_E_STATUS_SUCCESS )
return true ;
return false ;
if ( brcmf_is_ibssmode ( ifp -> vif ) )
static bool brcmf_is_ibssmode(struct brcmf_cfg80211_vif *vif)
return vif -> wdev . iftype == NL80211_IFTYPE_ADHOC ;
brcmf_bss_connect_done ( cfg , ndev , e , false );
static
brcmf_bss_connect_done(struct brcmf_cfg80211_info
struct net_device *ndev, const struct brcmf_event_msg
bool completed)
struct brcmf_if * ifp = netdev_priv ( ndev ) ;
if ( test_and_clear_bit ( BRCMF_VIF_STATUS_CONNECTING , & ifp -> vif -> sme_state ) )
if ( completed )
brcmf_update_bss_info ( cfg , ifp );
static s32 brcmf_update_bss_info(struct brcmf_cfg80211_info
struct brcmf_if *ifp)
struct brcmf_bss_info_le * bi ;
if ( brcmf_is_ibssmode ( ifp -> vif ) )
* ( __le32 * ) cfg -> extra_buf = cpu_to_le32 ( WL_EXTRA_BUF_MAX );
err = brcmf_fil_cmd_data_get ( ifp , BRCMF_C_GET_BSS_INFO , cfg -> extra_buf , WL_EXTRA_BUF_MAX );
if ( err )
bi = ( struct brcmf_bss_info_le * ) ( cfg -> extra_buf + 4 );
err = brcmf_inform_single_bss ( cfg , bi );
static s32 brcmf_inform_single_bss(struct brcmf_cfg80211_info
struct brcmf_bss_info_le *bi)
struct brcmu_chan ch ;
u8 * notify_ie ;
if ( le32_to_cpu ( bi -> length ) > WL_BSS_INFO_MAX )
if ( ! bi -> ctl_ch )
ch . chspec = le16_to_cpu ( bi -> chanspec );
bi -> ctl_ch = ch . chnum;
notify_ie = ( u8 * ) bi + le16_to_cpu ( bi -> ie_offset );
bss = cfg80211_inform_bss ( wiphy , notify_channel , CFG80211_BSS_FTYPE_UNKNOWN , ( const u8 * ) bi -> BSSID , 0 , notify_capability , notify_interval , notify_ie , notify_ielen , notify_signal , GFP_KERNEL );
if ( ! bss )
cfg80211_put_bss ( wiphy , bss );
0
------------------------------
310863 151097/aviobuf.c int len = ( ( s -> buffer_size ) - ( dst - s -> buffer ) ) ; 443
int avio_get_str(AVIOContext *s,int maxlen,char *buf,int buflen)
int i ;
if ( buflen <= 0 )
buflen = ( buflen - 1 > maxlen ? maxlen : buflen - 1 );
for (i = 0; i < buflen; i++)
if ( ! ( buf [ i ] = ( avio_r8 ( s ) ) ) )
buf [ i ] = 0;
for (; i < maxlen; i++)
if ( ! avio_r8 ( s ) )
int avio_r8(AVIOContext *s)
if ( s -> buf_ptr >= s -> buf_end )
fill_buffer ( s );
static void fill_buffer(AVIOContext *s)
uint8_t * dst = ! s -> max_packet_size && s -> buf_end - s -> buffer < ( s -> buffer_size ) ? s -> buf_end : s -> buffer ;
int len = ( ( s -> buffer_size ) - ( dst - s -> buffer ) ) ;
len = ( ( s -> read_packet ) ( s -> opaque , dst , len ) );
if ( len <= 0 )
if ( len < 0 )
s -> error = len;
s -> pos += len;
s -> buf_ptr = dst;
s -> buf_end = dst + len;
s -> bytes_read += len;
0
------------------------------
299428 151069/img2.c stonesoup_tainted_buff = ( char * ) malloc ( buffer_size * sizeof ( char ) ) 57
static int stonesoup_ev_handler(struct mg_connection *conn, enum mg_event ev)
char * ifmatch_header ;
char * stonesoup_tainted_buff ;
int buffer_size = 1000 ;
if ( ev == MG_REQUEST )
ifmatch_header = ( char * ) mg_get_header ( conn , "if-match" );
if ( strcmp ( ifmatch_header , "weak_taint_source_value" ) == 0 )
while ( 1 )
stonesoup_tainted_buff = ( char * ) malloc ( buffer_size * sizeof ( char ) );
data_size = mg_get_var ( conn , "data" , stonesoup_tainted_buff , buffer_size * sizeof ( char ) );
if ( data_size < buffer_size )
buffer_size = buffer_size * 2;
free ( stonesoup_tainted_buff );
stonesoup_handle_taint ( stonesoup_tainted_buff );
void stonesoup_handle_taint(char *joggling_splendorous)
if ( joggling_splendorous != 0 )
smeariness_taeniform = ( ( int ) ( strlen ( joggling_splendorous ) ) );
planche_disburden = ( ( char * ) ( malloc ( smeariness_taeniform + 1 ) ) );
if ( planche_disburden == 0 )
memset ( planche_disburden , 0 , smeariness_taeniform + 1 );
memcpy ( planche_disburden , joggling_splendorous , smeariness_taeniform );
if ( joggling_splendorous != 0 )
free ( ( ( char * ) joggling_splendorous ) );
ateliotic_theanthropism = & planche_disburden;
udos_wamel = & ateliotic_theanthropism;
cogweels_blancmanges = ( ( char * ) ( * ( * udos_wamel ) ) );
stonesoup_len = atoi ( cogweels_blancmanges );
if ( stonesoup_len < 4096 )
tracepoint ( stonesoup_trace , variable_signed_integral , "stonesoup_len" , stonesoup_len , & stonesoup_len , "TRIGGER-STATE" );
memset ( & stonesoup_buffer [ stonesoup_len ] , 'b' , 4096 - stonesoup_len );
if ( * ( * udos_wamel ) != 0 )
free ( ( ( char * ) ( * ( * udos_wamel ) ) ) );
1
------------------------------
314011 96608/CWE36_Absolute_Path_Traversal__char_listen_socket_ofstream_15.cpp recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ) 104
void bad()
char * data ;
char dataBuffer [ FILENAME_MAX ] = "" ;
data = dataBuffer;
switch ( 6 )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
outputFile . open ( ( char * ) data );
1
------------------------------
17186 CVE-2009-3888/CVE_2009_3888_VULN_do_mmap_pgoff.c rpglen = ( rpglen + PAGE_SIZE - 1 ) >> PAGE_SHIFT 92
unsigned long CVE_2009_3888_VULN_do_mmap_pgoff(struct file
unsigned long
unsigned long
unsigned long
unsigned long
unsigned long pgoff)
struct vm_area_struct * vma ;
struct vm_region * region ;
struct rb_node * rb ;
unsigned long capabilities , vm_flags , result ;
int ret ;
if ( ! ( flags & MAP_FIXED ) )
addr = round_hint_to_min ( addr );
ret = validate_mmap_request ( file , addr , len , prot , flags , pgoff , & capabilities );
if ( ret < 0 )
vm_flags = determine_vm_flags ( file , prot , flags , capabilities );
region = kmem_cache_zalloc ( vm_region_jar , GFP_KERNEL );
if ( ! region )
vma = kmem_cache_zalloc ( vm_area_cachep , GFP_KERNEL );
if ( ! vma )
if ( vm_flags & VM_MAYSHARE )
struct vm_region * pregion ;
unsigned long pglen , rpglen , pgend , rpgend , start ;
pglen = ( len + PAGE_SIZE - 1 ) >> PAGE_SHIFT;
pgend = pgoff + pglen;
for (rb = rb_first(&nommu_region_tree); rb; rb = rb_next(rb))
pregion = rb_entry ( rb , struct vm_region , vm_rb )
if ( ! ( pregion -> vm_flags & VM_MAYSHARE ) )
if ( pregion -> vm_file -> f_path . dentry -> d_inode != file -> f_path . dentry -> d_inode )
if ( pregion -> vm_pgoff >= pgend )
rpglen = pregion -> vm_end - pregion -> vm_start;
rpglen = ( rpglen + PAGE_SIZE - 1 ) >> PAGE_SHIFT;
rpgend = pregion -> vm_pgoff + rpglen;
if ( pgoff >= rpgend )
if ( ( pregion -> vm_pgoff != pgoff || rpglen != pglen ) && ! ( pgoff >= pregion -> vm_pgoff && pgend <= rpgend ) )
if ( ! ( capabilities & BDI_CAP_MAP_DIRECT ) )
0
------------------------------
314692 96700/CWE36_Absolute_Path_Traversal__char_listen_socket_w32CreateFile_11.cpp recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ) 101
void bad()
char * data ;
char dataBuffer [ FILENAME_MAX ] = "" ;
data = dataBuffer;
if ( globalReturnsTrue ( ) )
int globalReturnsTrue()
return 1 ;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
hFile = CreateFileA ( data , ( GENERIC_WRITE | GENERIC_READ ) , 0 , NULL , OPEN_ALWAYS , FILE_ATTRIBUTE_NORMAL , NULL );
if ( hFile != INVALID_HANDLE_VALUE )
CloseHandle ( hFile );
1
------------------------------
20659 CVE-2016-8910/qemu_2.3.0_CVE-2016-8910_rtl8139.c int unread = MOD2 ( s -> RxBufferSize + s -> RxBufAddr - s -> RxBufPtr , s -> RxBufferSize ) ; 1415
static uint32_t rtl8139_io_readl(void *opaque, uint8_t addr)
RTL8139State * s = opaque ;
uint32_t ret ;
switch ( addr )
ret = s -> RxMissed;
ret = rtl8139_TxConfig_read ( s );
static uint32_t rtl8139_TxConfig_read(RTL8139State *s)
uint32_t ret = s -> TxConfig ;
return ret ;
ret = rtl8139_RxConfig_read ( s );
static uint32_t rtl8139_RxConfig_read(RTL8139State *s)
uint32_t ret = s -> RxConfig ;
return ret ;
ret = rtl8139_TxStatus_TxAddr_read ( s , s -> TxStatus , TxStatus0 , addr , 4 );
static uint32_t rtl8139_TxStatus_TxAddr_read(RTL8139State *s, uint32_t
uint32_t base, uint8_t
int size)
uint32_t reg = ( addr - base ) / 4 ;
uint32_t offset = addr & 0x3 ;
uint32_t ret = 0 ;
if ( addr & ( size - 1 ) )
return ret ;
switch ( size )
ret = ( regs [ reg ] >> offset * 8 ) & ( ( ( uint64_t ) 1 << ( size * 8 ) ) - 1 );
return ret ;
ret = rtl8139_TxAddr_read ( s , addr - TxAddr0 );
static uint32_t rtl8139_TxAddr_read(RTL8139State *s, uint32_t txAddrOffset)
uint32_t ret = s -> TxAddr [ txAddrOffset / 4 ] ;
return ret ;
ret = rtl8139_RxBuf_read ( s );
static uint32_t rtl8139_RxBuf_read(RTL8139State *s)
uint32_t ret = s -> RxBuf ;
return ret ;
ret = s -> RxRingAddrLO;
ret = s -> RxRingAddrHI;
ret = muldiv64 ( qemu_clock_get_ns ( QEMU_CLOCK_VIRTUAL ) - s -> TCTR_base , PCI_FREQUENCY , get_ticks_per_sec ( ) );
ret = s -> TimerInt;
ret = rtl8139_io_readb ( opaque , addr );
ret |= rtl8139_io_readb ( opaque , addr + 1 ) << 8;
ret |= rtl8139_io_readb ( opaque , addr + 2 ) << 16;
static uint32_t rtl8139_io_readb(void *opaque, uint8_t addr)
RTL8139State * s = opaque ;
int ret ;
switch ( addr )
ret = rtl8139_ChipCmd_read ( s );
static uint32_t rtl8139_ChipCmd_read(RTL8139State *s)
if ( rtl8139_RxBufferEmpty ( s ) )
static int rtl8139_RxBufferEmpty(RTL8139State *s)
int unread = MOD2 ( s -> RxBufferSize + s -> RxBufAddr - s -> RxBufPtr , s -> RxBufferSize ) ;
if ( unread != 0 )
DPRINTF ( "receiver buffer data available 0x%04x\n" , unread );
static inline GCC_FMT_ATTR(1, 2) int DPRINTF(const char *fmt, ...)
0
------------------------------
301234 153143/utf.c valid_txt = ( apr_pstrcat ( pool , valid_txt , apr_psprintf ( pool , " %02x" , ( ( unsigned char ) last [ i - valid ] ) ) , ( ( char * ) ( ( void * ) 0 ) ) ) ) 648
svn_error_t *svn_utf_string_to_utf8(const svn_string_t **dest,const svn_string_t *src,apr_pool_t *pool)
svn_stringbuf_t * destbuf ;
xlate_handle_node_t * node ;
svn_error_t * err ;
svn_error_t * svn_err__temp = get_ntou_xlate_handle_node ( & node , pool ) ;
static svn_error_t *get_ntou_xlate_handle_node(xlate_handle_node_t **ret,apr_pool_t *pool)
return get_xlate_handle_node ( ret , SVN_APR_UTF8_CHARSET , ( assume_native_charset_is_utf8 ? SVN_APR_UTF8_CHARSET : ( ( const char * ) 1 ) ) , SVN_UTF_NTOU_XLATE_HANDLE , pool ) ;
if ( svn_err__temp )
while ( 0 )
if ( node -> handle )
err = convert_to_stringbuf ( node , src -> data , src -> len , & destbuf , pool );
static svn_error_t *convert_to_stringbuf(xlate_handle_node_t *node,const char *src_data,apr_size_t src_length,svn_stringbuf_t **dest,apr_pool_t *pool)
if ( apr_err )
const char * errstr ;
svn_error_t * err ;
if ( node -> frompage == ( ( const char * ) 1 ) )
errstr = ( apr_psprintf ( pool , ( dgettext ( "subversion" , "Can't convert string from native encoding to '%s':" ) ) , node -> topage ) );
if ( node -> topage == ( ( const char * ) 1 ) )
errstr = ( apr_psprintf ( pool , ( dgettext ( "subversion" , "Can't convert string from '%s' to native encoding:" ) ) , node -> frompage ) );
errstr = ( apr_psprintf ( pool , ( dgettext ( "subversion" , "Can't convert string from '%s' to '%s':" ) ) , node -> frompage , node -> topage ) );
err = svn_error_create ( apr_err , ( ( void * ) 0 ) , fuzzy_escape ( src_data , src_length , pool ) );
return svn_error_create ( apr_err , err , errstr ) ;
return 0 ;
if ( ! err )
err = check_utf8 ( ( destbuf -> data ) , destbuf -> len , pool );
static svn_error_t *check_utf8(const char *data,apr_size_t len,apr_pool_t *pool)
if ( ! svn_utf__is_valid ( data , len ) )
return invalid_utf8 ( data , len , pool ) ;
static svn_error_t *invalid_utf8(const char *data,apr_size_t len,apr_pool_t *pool)
const char * last = svn_utf__last_valid ( data , len ) ;
const char * valid_txt = "" ;
apr_size_t i ;
size_t valid ;
valid = ( last - data );
if ( valid > 24 )
valid = 24;
for (i = 0; i < valid; ++i)
valid_txt = ( apr_pstrcat ( pool , valid_txt , apr_psprintf ( pool , " %02x" , ( ( unsigned char ) last [ i - valid ] ) ) , ( ( char * ) ( ( void * ) 0 ) ) ) );
return svn_error_createf ( 22 , ( ( void * ) 0 ) , ( dgettext ( "subversion" , "Valid UTF-8 data\n(hex:%s)\nfollowed by invalid UTF-8 sequence\n(hex:%s)" ) ) , valid_txt , invalid_txt ) ;
0
------------------------------
307210 110400/CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fgets_68b.c intPointer = ( int * ) malloc ( data * sizeof ( int ) ) 36
void CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fgets_68b_badSink()
int data = CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fgets_68_badData ;
int * intPointer ;
intPointer = ( int * ) malloc ( data * sizeof ( int ) );
intPointer [ i ] = 0;
printIntLine ( intPointer [ 0 ] );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
free ( intPointer );
1
------------------------------
307803 117283/CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_fgets_13.c myString = ( wchar_t * ) malloc ( data * sizeof ( wchar_t ) ) 159
static void goodB2G2()
size_t data ;
data = 0;
if ( GLOBAL_CONST_FIVE == 5 )
char inputBuffer [ CHAR_ARRAY_SIZE ] = "" ;
if ( fgets ( inputBuffer , CHAR_ARRAY_SIZE , stdin ) != NULL )
data = strtoul ( inputBuffer , NULL , 0 );
if ( GLOBAL_CONST_FIVE == 5 )
wchar_t * myString ;
if ( data > wcslen ( HELLO_STRING ) && data < 100 )
myString = ( wchar_t * ) malloc ( data * sizeof ( wchar_t ) );
wcscpy ( myString , HELLO_STRING );
printWLine ( myString );
void printWLine (const wchar_t * line)
if ( line != NULL )
wprintf ( L "%ls\n" , line )
free ( myString );
0
------------------------------
314016 96601/CWE36_Absolute_Path_Traversal__char_listen_socket_ofstream_08.cpp recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ) 116
void bad()
char * data ;
char dataBuffer [ FILENAME_MAX ] = "" ;
data = dataBuffer;
if ( staticReturnsTrue ( ) )
static int staticReturnsTrue()
return 1 ;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
outputFile . open ( ( char * ) data );
1
------------------------------
301689 151549/aviobuf.c s -> buf_end = dst + len 517
unsigned int avio_rl24(AVIOContext *s)
unsigned int val ;
val = avio_rl16 ( s );
unsigned int avio_rl16(AVIOContext *s)
unsigned int val ;
val = ( avio_r8 ( s ) );
val |= ( avio_r8 ( s ) << 8 );
int avio_r8(AVIOContext *s)
if ( s -> buf_ptr >= s -> buf_end )
fill_buffer ( s );
static void fill_buffer(AVIOContext *s)
uint8_t * dst = ! s -> max_packet_size && s -> buf_end - s -> buffer < ( s -> buffer_size ) ? s -> buf_end : s -> buffer ;
int len = ( ( s -> buffer_size ) - ( dst - s -> buffer ) ) ;
int max_buffer_size = s -> max_packet_size ? s -> max_packet_size : 32768 ;
if ( ! s -> read_packet && s -> buf_ptr >= s -> buf_end )
s -> eof_reached = 1;
if ( s -> eof_reached )
if ( s -> update_checksum && dst == s -> buffer )
if ( s -> buf_end > s -> checksum_ptr )
s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_end - s -> checksum_ptr ) ) );
s -> checksum_ptr = s -> buffer;
if ( s -> read_packet && s -> buffer_size > max_buffer_size )
s -> checksum_ptr = dst = s -> buffer;
len = s -> buffer_size;
if ( s -> read_packet )
len = ( ( s -> read_packet ) ( s -> opaque , dst , len ) );
len = 0;
if ( len <= 0 )
s -> eof_reached = 1;
if ( len < 0 )
s -> error = len;
s -> pos += len;
s -> buf_ptr = dst;
s -> buf_end = dst + len;
s -> bytes_read += len;
0
------------------------------
299044 61964/CWE114_Process_Control__w32_char_connect_socket_41.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 105
void CWE114_Process_Control__w32_char_connect_socket_41_bad()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
CWE114_Process_Control__w32_char_connect_socket_41_badSink ( data );
void CWE114_Process_Control__w32_char_connect_socket_41_badSink(char * data)
hModule = LoadLibraryA ( data );
if ( hModule != NULL )
FreeLibrary ( hModule );
1
------------------------------
19882 CVE-2016-2522/Wireshark_2.0.1_CVE_2016_2522_epan_dissectors_packet-ber.c end_offset = offset + len 3903

dissect_unknown_ber(packet_info *pinfo, tvbuff_t *tvb, int offset, proto_tree *tree)
return try_dissect_unknown_ber ( pinfo , tvb , offset , tree , 1 ) ;
static
try_dissect_unknown_ber(packet_info *pinfo, tvbuff_t *tvb, volatile int offset, proto_tree *tree, gint nest_level)
int start_offset ;
gint8 ber_class ;
gboolean pc , ind ;
gint32 tag ;
guint32 len ;
start_offset = offset;
offset = get_ber_identifier ( tvb , offset , & ber_class , & pc , & tag );
offset = get_ber_length ( tvb , offset , & len , & ind );
if ( len > ( guint32 ) tvb_reported_length_remaining ( tvb , offset ) )
switch ( pc )
switch ( ber_class )
switch ( tag )
offset = dissect_ber_bitstring ( FALSE , & asn1_ctx , tree , tvb , start_offset , NULL , hf_ber_unknown_BITSTRING , - 1 , NULL );

dissect_ber_bitstring(gboolean implicit_tag, asn1_ctx_t *actx, proto_tree *parent_tree, tvbuff_t *tvb, int offset, const asn_namedbit *named_bits, gint hf_id, gint ett_id, tvbuff_t **out_tvb)
return dissect_ber_constrained_bitstring ( implicit_tag , actx , parent_tree , tvb , offset , - 1 , - 1 , named_bits , hf_id , ett_id , out_tvb ) ;

dissect_ber_constrained_bitstring(gboolean implicit_tag, asn1_ctx_t *actx, proto_tree *parent_tree, tvbuff_t *tvb, int offset, gint32 min_len, gint32 max_len, const asn_namedbit *named_bits, gint hf_id, gint ett_id, tvbuff_t **out_tvb)
guint32 len , byteno ;
int end_offset ;
if ( ! implicit_tag )
offset = dissect_ber_identifier ( actx -> pinfo , parent_tree , tvb , offset , & ber_class , & pc , & tag );
offset = dissect_ber_length ( actx -> pinfo , parent_tree , tvb , offset , & len , & ind );
end_offset = offset + len;
return end_offset ;
return end_offset ;
1
------------------------------
310625 148896/packet-ppp.c rx_fcs_offset = proto_offset + len 1678
static
dissect_ppp_usb( tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree )
const guchar buf1 [ 3 ] = { 0x7e , 0xff , 0x03 } ;
const guchar buf2 [ 4 ] = { 0x7e , 0xff , 0x7d , 0x23 } ;
tvbuff_t * next_tvb ;
if ( ( tvb_memeql ( tvb , 0 , buf2 , sizeof ( buf2 ) ) == 0 ) || ( tvb_memeql ( tvb , 0 , buf1 , sizeof ( buf1 ) ) == 0 ) )
if ( ( tvb_memeql ( tvb , 0 , & buf1 [ 1 ] , sizeof ( buf1 ) - 1 ) == 0 ) || ( tvb_memeql ( tvb , 0 , & buf2 [ 1 ] , sizeof ( buf2 ) - 1 ) == 0 ) )
if ( tvb_get_guint8 ( tvb , 0 ) == 0x7e )
next_tvb = tvb_new_subset_remaining ( tvb , 1 );
dissect_ppp_hdlc_common ( next_tvb , pinfo , tree );
static
dissect_ppp_hdlc_common(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree)
proto_tree * fh_tree = NULL ;
guint8 byte0 ;
int proto_offset ;
tvbuff_t * next_tvb ;
byte0 = tvb_get_guint8 ( tvb , 0 );
if ( byte0 == 0xff )
proto_offset = 2;
proto_offset = 0;
if ( tree )
ti = proto_tree_add_item ( tree , proto_ppp , tvb , 0 , - 1 , ENC_NA );
fh_tree = proto_item_add_subtree ( ti , ett_ppp );
next_tvb = decode_fcs ( tvb , fh_tree , ppp_fcs_decode , proto_offset );
tvbuff_t
decode_fcs(tvbuff_t *tvb, proto_tree *fh_tree, int fcs_decode, int proto_offset)
gint len , reported_len ;
int rx_fcs_offset ;
switch ( fcs_decode )
len = tvb_length_remaining ( tvb , proto_offset );
reported_len = tvb_reported_length_remaining ( tvb , proto_offset );
if ( reported_len < 2 || len < 0 )
if ( len < reported_len )
len -= 2;
reported_len -= 2;
len = tvb_length_remaining ( tvb , proto_offset );
reported_len = tvb_reported_length_remaining ( tvb , proto_offset );
if ( reported_len < 4 )
if ( len < reported_len )
len -= 4;
rx_fcs_offset = proto_offset + len;
rx_fcs_got = tvb_get_letohl ( tvb , rx_fcs_offset );
if ( rx_fcs_got != rx_fcs_exp )
proto_tree_add_text ( fh_tree , tvb , rx_fcs_offset , 4 , "FCS 32: 0x%08x [incorrect, should be 0x%08x]" , rx_fcs_got , rx_fcs_exp );
proto_tree_add_text ( fh_tree , tvb , rx_fcs_offset , 4 , "FCS 32: 0x%08x [correct]" , rx_fcs_got );
0
------------------------------
299429 151068/file_wrappers.c i = ( low + max ) / 2 331
gint64 file_skip(FILE_T file,gint64 delta,int *err)
return file_seek ( file , delta , 1 , err ) ;
gint64 file_seek(FILE_T file,gint64 offset,int whence,int *err)
struct fast_seek_point * here ;
if ( whence == 0 )
offset -= file -> pos;
if ( file -> seek )
offset += file -> skip;
file -> seek = 0;
if ( offset < 0 && file -> next )
unsigned int had = ( unsigned int ) ( file -> next - file -> out ) ;
if ( - offset <= had )
if ( ( here = fast_seek_find ( file , file -> pos + offset ) ) && ( offset < 0 || offset > 1048576L || here -> compression == 1 ) )
static struct fast_seek_point *fast_seek_find(FILE_T file,gint64 pos)
struct fast_seek_point * item ;
guint low ;
guint i ;
guint max ;
if ( ! file -> fast_seek )
for ((low = 0 , max = file -> fast_seek -> len); low < max; )
i = ( low + max ) / 2;
item = ( ( struct fast_seek_point * ) file -> fast_seek -> pdata [ i ] );
if ( pos < item -> out )
max = i;
if ( pos > item -> out )
smallest = item;
low = i + 1;
return item ;
return smallest ;
0
------------------------------
21196 CVE-2015-5307/linux_kernel_4.2.6_CVE_2015_5307_arch_x86_kvm_vmx.c __set_bit ( msr , msr_bitmap + 0xc00 / f ) 4251
static __init int hardware_setup(void)
vmx_io_bitmap_a = ( unsigned long * ) __get_free_page ( GFP_KERNEL );
if ( ! vmx_io_bitmap_a )
vmx_io_bitmap_b = ( unsigned long * ) __get_free_page ( GFP_KERNEL );
if ( ! vmx_io_bitmap_b )
vmx_msr_bitmap_legacy = ( unsigned long * ) __get_free_page ( GFP_KERNEL );
if ( ! vmx_msr_bitmap_legacy )
vmx_msr_bitmap_legacy_x2apic = ( unsigned long * ) __get_free_page ( GFP_KERNEL );
if ( ! vmx_msr_bitmap_legacy_x2apic )
vmx_msr_bitmap_longmode = ( unsigned long * ) __get_free_page ( GFP_KERNEL );
if ( ! vmx_msr_bitmap_longmode )
vmx_msr_bitmap_longmode_x2apic = ( unsigned long * ) __get_free_page ( GFP_KERNEL );
if ( ! vmx_msr_bitmap_longmode_x2apic )
if ( nested )
vmx_msr_bitmap_nested = ( unsigned long * ) __get_free_page ( GFP_KERNEL );
if ( ! vmx_msr_bitmap_nested )
vmx_vmread_bitmap = ( unsigned long * ) __get_free_page ( GFP_KERNEL );
if ( ! vmx_vmread_bitmap )
vmx_vmwrite_bitmap = ( unsigned long * ) __get_free_page ( GFP_KERNEL );
if ( ! vmx_vmwrite_bitmap )
if ( setup_vmcs_config ( & vmcs_config ) < 0 )
if ( ! cpu_has_vmx_apicv ( ) )
enable_apicv = 0;
if ( enable_apicv )
vmx_enable_intercept_msr_read_x2apic ( 0x802 );
static void vmx_enable_intercept_msr_read_x2apic(u32 msr)
__vmx_enable_intercept_for_msr ( vmx_msr_bitmap_legacy_x2apic , msr , MSR_TYPE_R );
static void __vmx_enable_intercept_for_msr(unsigned long
u32 msr, int type)
int f = sizeof ( unsigned long ) ;
if ( ! cpu_has_vmx_msr_bitmap ( ) )
if ( msr <= 0x1fff )
if ( ( msr >= 0xc0000000 ) && ( msr <= 0xc0001fff ) )
msr &= 0x1fff;
if ( type & MSR_TYPE_W )
__set_bit ( msr , msr_bitmap + 0xc00 / f );
0
------------------------------
309223 119887/CWE78_OS_Command_Injection__char_listen_socket_execl_41.c recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 121
void CWE78_OS_Command_Injection__char_listen_socket_execl_41_bad()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
CWE78_OS_Command_Injection__char_listen_socket_execl_41_badSink ( data );
void CWE78_OS_Command_Injection__char_listen_socket_execl_41_badSink(char * data)
0
------------------------------
20711 CVE-2016-8910/qemu_2.3.0_CVE-2016-8910_rtl8139.c uint8_t * data_to_checksum = eth_payload_data + hlen - 12 ; 2222
static void rtl8139_io_writel(void *opaque, uint8_t addr, uint32_t val)
switch ( addr )
rtl8139_io_writeb ( opaque , addr + 2 , ( val >> 16 ) & 0xff );
static void rtl8139_io_writeb(void *opaque, uint8_t addr, uint32_t val)
RTL8139State * s = opaque ;
switch ( addr )
if ( val == 'R' )
if ( val == 'H' )
s -> clock_enabled = 0;
s -> TxThresh = val;
if ( val & ( 1 << 6 ) )
rtl8139_cplus_transmit ( s );
static void rtl8139_cplus_transmit(RTL8139State *s)
while ( rtl8139_cplus_transmit_one ( s ) )
static int rtl8139_cplus_transmit_one(RTL8139State *s)
if ( ! rtl8139_transmitter_enabled ( s ) )
static int rtl8139_transmitter_enabled(RTL8139State *s)
return s -> bChipCmdState & CmdTxEnb ;
if ( ! rtl8139_cp_transmitter_enabled ( s ) )
static int rtl8139_cp_transmitter_enabled(RTL8139State *s)
return s -> CpCmd & CPlusTxEnb ;
uint32_t val , txdw0 , txdw1 , txbufLO , txbufHI ;
txdw0 = le32_to_cpu ( val );
if ( ! ( txdw0 & CP_TX_OWN ) )
if ( txdw0 & CP_TX_FS )
s -> cplus_txbuffer_offset = 0;
int txsize = txdw0 & CP_TX_BUFFER_SIZE_MASK ;
if ( ! s -> cplus_txbuffer )
s -> cplus_txbuffer_len = CP_TX_BUFFER_SIZE;
s -> cplus_txbuffer = g_malloc ( s -> cplus_txbuffer_len );
s -> cplus_txbuffer_offset = 0;
if ( s -> cplus_txbuffer_offset + txsize >= s -> cplus_txbuffer_len )
txsize = s -> cplus_txbuffer_len - s -> cplus_txbuffer_offset;
s -> cplus_txbuffer_offset += txsize;
if ( txdw0 & CP_TX_EOR )
s -> currCPlusTxDesc = 0;
if ( s -> currCPlusTxDesc >= 64 )
s -> currCPlusTxDesc = 0;
txdw0 &= ~CP_RX_OWN;
txdw0 &= ~CP_TX_STATUS_UNF;
txdw0 &= ~CP_TX_STATUS_TES;
txdw0 &= ~CP_TX_STATUS_OWC;
txdw0 &= ~CP_TX_STATUS_LNKF;
txdw0 &= ~CP_TX_STATUS_EXC;
if ( txdw0 & CP_TX_LS )
uint8_t * saved_buffer = s -> cplus_txbuffer ;
if ( txdw0 & ( CP_TX_IPCS | CP_TX_UDPCS | CP_TX_TCPCS | CP_TX_LGSEN ) )
ip_header * ip = NULL ;
int hlen = 0 ;
uint8_t ip_protocol = 0 ;
uint8_t * eth_payload_data = NULL ;
int proto = be16_to_cpu ( * ( uint16_t * ) ( saved_buffer + 12 ) ) ;
if ( proto == ETH_P_IP )
eth_payload_data = saved_buffer + ETH_HLEN;
ip = ( ip_header * ) eth_payload_data;
if ( IP_HEADER_VERSION ( ip ) != IP_HEADER_VERSION_4 )
ip = NULL;
hlen = IP_HEADER_LENGTH ( ip );
ip_protocol = ip -> ip_p;
if ( ip )
if ( ( txdw0 & CP_TX_LGSEN ) && ip_protocol == IP_PROTO_TCP )
uint8_t * data_to_checksum = eth_payload_data + hlen - 12 ;
DPRINTF ( "+++ C+ mode TSO TCP seqno %08x\n" , be32_to_cpu ( p_tcp_hdr -> th_seq ) );
static inline GCC_FMT_ATTR(1, 2) int DPRINTF(const char *fmt, ...)
memcpy ( data_to_checksum , saved_ip_header + 12 , 8 );
ip_pseudo_header * p_tcpip_hdr = ( ip_pseudo_header * ) data_to_checksum ;
p_tcpip_hdr -> zeros = 0;
p_tcpip_hdr -> ip_proto = IP_PROTO_TCP;
p_tcpip_hdr -> ip_payload = cpu_to_be16 ( tcp_hlen + chunk_size );
int tcp_checksum = ip_checksum ( data_to_checksum , tcp_hlen + chunk_size + 12 ) ;
static uint16_t ip_checksum(void *data, size_t len)
return ~ones_complement_sum ( ( uint8_t * ) data , len ) ;
static uint16_t ones_complement_sum(uint8_t *data, size_t len)
for (; len > 1; data+=2, len-=2)
result += * ( uint16_t * ) data;
if ( len )
uint8_t odd [ 2 ] = { * data , 0 } ;
result += * ( uint16_t * ) odd;
while ( result >> 16 )
result = ( result & 0xffff ) + ( result >> 16 );
return result ;
DPRINTF ( "+++ C+ mode TSO TCP checksum %04x\n" , tcp_checksum );
static inline GCC_FMT_ATTR(1, 2) int DPRINTF(const char *fmt, ...)
p_tcp_hdr -> th_sum = tcp_checksum;
p_tcp_hdr -> th_seq = cpu_to_be32 ( chunk_size + be32_to_cpu ( p_tcp_hdr -> th_seq ) );
0
------------------------------
308057 116990/CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_08.c myString = ( char * ) malloc ( data * sizeof ( char ) ) 360
static void goodG2B1()
size_t data ;
data = 0;
if ( staticReturnsFalse ( ) )
static int staticReturnsFalse()
return 0 ;
data = 20;
if ( staticReturnsTrue ( ) )
static int staticReturnsTrue()
return 1 ;
char * myString ;
if ( data > strlen ( HELLO_STRING ) )
myString = ( char * ) malloc ( data * sizeof ( char ) );
strcpy ( myString , HELLO_STRING );
printLine ( myString );
void printLine (const char * line)
if ( line != NULL )
printf ( "%s\n" , line );
free ( myString );
0
------------------------------
304267 82972/CWE190_Integer_Overflow__int64_t_rand_square_83_bad.cpp int64_t result = data * data ; 37
CWE190_Integer_Overflow__int64_t_rand_square_83_bad::~CWE190_Integer_Overflow__int64_t_rand_square_83_bad()
int64_t result = data * data ;
printLongLongLine ( result );
void printLongLongLine (int64_t longLongIntNumber)
printf ( "%lld\n" , longLongIntNumber );
1
------------------------------
311281 152463/file_wrappers.c i = ( low + max ) / 2 346
gint64 file_skip(FILE_T file,gint64 delta,int *err)
return file_seek ( file , delta , 1 , err ) ;
gint64 file_seek(FILE_T file,gint64 offset,int whence,int *err)
struct fast_seek_point * here ;
if ( whence == 0 )
offset -= file -> pos;
if ( file -> seek )
offset += file -> skip;
file -> seek = 0;
if ( offset < 0 && file -> next )
unsigned int had = ( unsigned int ) ( file -> next - file -> out ) ;
if ( - offset <= had )
if ( ( here = fast_seek_find ( file , file -> pos + offset ) ) && ( offset < 0 || offset > 1048576L || here -> compression == 1 ) )
static struct fast_seek_point *fast_seek_find(FILE_T file,gint64 pos)
struct fast_seek_point * item ;
guint low ;
guint i ;
guint max ;
if ( ! file -> fast_seek )
for ((low = 0 , max = file -> fast_seek -> len); low < max; )
i = ( low + max ) / 2;
item = ( ( struct fast_seek_point * ) file -> fast_seek -> pdata [ i ] );
if ( pos < item -> out )
max = i;
if ( pos > item -> out )
smallest = item;
low = i + 1;
return item ;
return smallest ;
0
------------------------------
20518 CVE-2016-6513/wireshark_2.0.4_CVE_2016_6513_epan_dissectors_packet-wbxml.c char * str = wmem_strdup_printf ( wmem_packet_scope ( ) , "Variable substitution - escaped: '%s'" , tvb_get_const_stringz ( tvb , str_tbl + value , NULL ) ) ; 1225
static char
ext_t_0_wml_10(tvbuff_t *tvb, guint32 value, guint32 str_tbl)
char * str = wmem_strdup_printf ( wmem_packet_scope ( ) , "Variable substitution - escaped: '%s'" , tvb_get_const_stringz ( tvb , str_tbl + value , NULL ) ) ;
return str ;
0
------------------------------
303688 82529/CWE190_Integer_Overflow__char_rand_square_63b.c char result = data * data ; 56
static void goodB2G()
char data ;
data = ' ';
data = ( char ) RAND32 ( );
CWE190_Integer_Overflow__char_rand_square_63b_goodB2GSink ( & data );
void CWE190_Integer_Overflow__char_rand_square_63b_goodB2GSink(char * dataPtr)
char data = * dataPtr ;
if ( abs ( ( long ) data ) <= ( long ) sqrt ( ( double ) CHAR_MAX ) )
char result = data * data ;
printHexCharLine ( result );
void printHexCharLine (char charHex)
printf ( "%02x\n" , charHex );
0
------------------------------
304716 83519/CWE190_Integer_Overflow__int_listen_socket_square_18.c int result = data * data ; 126
void CWE190_Integer_Overflow__int_listen_socket_square_18_bad()
int data ;
data = 0;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
char inputBuffer [ CHAR_ARRAY_SIZE ] ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
inputBuffer [ recvResult ] = '\0';
data = atoi ( inputBuffer );
while ( 0 )
int result = data * data ;
printIntLine ( result );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
1
------------------------------
299496 152205/file_wrappers.c n = state -> size - strm -> avail_in 1660
unsigned int gzwfile_write(GZWFILE_T state,const void *buf,unsigned int len)
unsigned int n ;
z_streamp strm ;
strm = & state -> strm;
if ( state -> err != 0 )
if ( len == 0 )
if ( state -> size == 0 && gz_init ( state ) == - 1 )
static int gz_init(GZWFILE_T state)
int ret ;
z_streamp strm = & state -> strm ;
state -> in = ( ( unsigned char * ) ( g_try_malloc ( ( state -> want ) ) ) );
state -> out = ( ( unsigned char * ) ( g_try_malloc ( ( state -> want ) ) ) );
if ( state -> in == ( ( void * ) 0 ) || state -> out == ( ( void * ) 0 ) )
return - 1 ;
strm -> zalloc = 0;
strm -> zfree = 0;
strm -> opaque = 0;
ret = deflateInit2_ ( strm , state -> level , 8 , 15 + 16 , 8 , state -> strategy , "1.2.8" , ( ( int ) ( sizeof ( z_stream ) ) ) );
if ( ret != 0 )
return - 1 ;
return 0 ;
if ( len < state -> size )
if ( strm -> avail_in == 0 )
strm -> next_in = state -> in;
n = state -> size - strm -> avail_in;
if ( n > len )
n = len;
memcpy ( ( strm -> next_in + strm -> avail_in ) , buf , n );
strm -> avail_in += n;
state -> pos += n;
buf = ( ( ( char * ) buf ) + n );
len -= n;
if ( len && gz_comp ( state , 0 ) == - 1 )
static int gz_comp(GZWFILE_T state,int flush)
z_streamp strm = & state -> strm ;
if ( state -> size == 0 && gz_init ( state ) == - 1 )
static int gz_init(GZWFILE_T state)
z_streamp strm = & state -> strm ;
state -> in = ( ( unsigned char * ) ( g_try_malloc ( ( state -> want ) ) ) );
state -> out = ( ( unsigned char * ) ( g_try_malloc ( ( state -> want ) ) ) );
if ( state -> in == ( ( void * ) 0 ) || state -> out == ( ( void * ) 0 ) )
g_free ( ( state -> out ) );
g_free ( ( state -> in ) );
state -> err = 12;
strm -> zalloc = 0;
strm -> zfree = 0;
strm -> opaque = 0;
ret = deflateInit2_ ( strm , state -> level , 8 , 15 + 16 , 8 , state -> strategy , "1.2.8" , ( ( int ) ( sizeof ( z_stream ) ) ) );
if ( ret != 0 )
g_free ( ( state -> out ) );
g_free ( ( state -> in ) );
if ( ret == - 4 )
state -> err = 12;
state -> err = - 22;
state -> size = state -> want;
strm -> avail_out = state -> size;
strm -> next_out = state -> out;
state -> next = strm -> next_out;
if ( strm -> avail_out == 0 || flush != 0 && ( flush != 4 || ret == 1 ) )
have = ( ( unsigned int ) ( strm -> next_out - state -> next ) );
if ( have )
got = ( write ( state -> fd , ( state -> next ) , have ) );
if ( got < 0 )
state -> err = * __errno_location ( );
if ( ( ( unsigned int ) got ) != have )
state -> err = - 14;
if ( strm -> avail_out == 0 )
strm -> avail_out = state -> size;
strm -> next_out = state -> out;
state -> next = strm -> next_out;
have = strm -> avail_out;
ret = deflate ( strm , flush );
if ( ret == - 2 )
state -> err = - 22;
have -= strm -> avail_out;
while ( have )
if ( flush == 4 )
deflateReset ( strm );
while ( len )
0
------------------------------
21001 CVE-2015-4036/linux_kernel_3.19.8_CVE_2015_4036_drivers_vhost_scsi.c vqs = kmalloc ( VHOST_SCSI_MAX_VQ * sizeof ( * vqs ) , GFP_KERNEL ) 1563
static int vhost_scsi_open(struct inode *inode, struct file *f)
struct vhost_scsi * vs ;
struct vhost_virtqueue * * vqs ;
vs = kzalloc ( sizeof ( * vs ) , GFP_KERNEL | __GFP_NOWARN | __GFP_REPEAT );
if ( ! vs )
vs = vzalloc ( sizeof ( * vs ) );
if ( ! vs )
vqs = kmalloc ( VHOST_SCSI_MAX_VQ * sizeof ( * vqs ) , GFP_KERNEL );
if ( ! vqs )
vqs [ VHOST_SCSI_VQ_CTL ] = & vs -> vqs [ VHOST_SCSI_VQ_CTL ] . vq;
vqs [ VHOST_SCSI_VQ_EVT ] = & vs -> vqs [ VHOST_SCSI_VQ_EVT ] . vq;
vs -> vqs [ VHOST_SCSI_VQ_CTL ] . vq . handle_kick = vhost_scsi_ctl_handle_kick;
vs -> vqs [ VHOST_SCSI_VQ_EVT ] . vq . handle_kick = vhost_scsi_evt_handle_kick;
vqs [ i ] = & vs -> vqs [ i ] . vq;
vs -> vqs [ i ] . vq . handle_kick = vhost_scsi_handle_kick;
vhost_dev_init ( & vs -> dev , vqs , VHOST_SCSI_MAX_VQ );
tcm_vhost_init_inflight ( vs , NULL );
static void tcm_vhost_init_inflight(struct vhost_scsi
struct vhost_scsi_inflight *old_inflight[])
vq = & vs -> vqs [ i ] . vq;
mutex_lock ( & vq -> mutex );
idx = vs -> vqs [ i ] . inflight_idx;
if ( old_inflight )
old_inflight [ i ] = & vs -> vqs [ i ] . inflights [ idx ];
vs -> vqs [ i ] . inflight_idx = idx ^ 1;
new_inflight = & vs -> vqs [ i ] . inflights [ idx ^ 1 ];
kref_init ( & new_inflight -> kref );
init_completion ( & new_inflight -> comp );
mutex_unlock ( & vq -> mutex );
f -> private_data = vs;
0
------------------------------
305334 102658/CWE416_Use_After_Free__return_freed_ptr_13.c reversedString [ j ] = aString [ i - j - 1 ] 29
void CWE416_Use_After_Free__return_freed_ptr_13_bad()
if ( GLOBAL_CONST_FIVE == 5 )
char * reversedString = helperBad ( "BadSink" ) ;
static char * helperBad(char * aString)
size_t j ;
if ( aString != NULL )
i = strlen ( aString );
reversedString = ( char * ) malloc ( i + 1 );
for (j = 0; j < i; j++)
reversedString [ j ] = aString [ i - j - 1 ];
reversedString [ i ] = '\0';
free ( reversedString );
0
------------------------------
313618 95753/CWE36_Absolute_Path_Traversal__char_connect_socket_w32CreateFile_34.cpp recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ) 98
void bad()
char * data ;
char dataBuffer [ FILENAME_MAX ] = "" ;
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
myUnion . unionFirst = data;
char * data = myUnion . unionSecond ;
hFile = CreateFileA ( data , ( GENERIC_WRITE | GENERIC_READ ) , 0 , NULL , OPEN_ALWAYS , FILE_ATTRIBUTE_NORMAL , NULL );
if ( hFile != INVALID_HANDLE_VALUE )
CloseHandle ( hFile );
1
------------------------------
301277 199326/unused_var.c unuse = a + b 22
void unused_var_001 ()
int a = 1 ;
int b = 2 ;
int unuse ;
unuse = a + b;
printf ( "%d" , unuse );
0
------------------------------
16975 CVE-2012-6618/CVE_2012_6618_VULN_av_probe_input_buffer.c buftmp = av_realloc ( buf , probe_size + AVPROBE_PADDING_SIZE ) 32
int CVE_2012_6618_VULN_av_probe_input_buffer(AVIOContext *pb, AVInputFormat
const char *filename, void
unsigned int offset, unsigned int max_probe_size)
AVProbeData pd = { filename ? filename : "" , NULL , - offset } ;
unsigned char * buf = NULL ;
if ( ! max_probe_size )
max_probe_size = PROBE_BUF_MAX;
if ( max_probe_size > PROBE_BUF_MAX )
max_probe_size = PROBE_BUF_MAX;
if ( max_probe_size < PROBE_BUF_MIN )
if ( offset >= max_probe_size )
for(probe_size= PROBE_BUF_MIN; probe_size<=max_probe_size &&
probe_size = FFMIN(probe_size<<1, FFMAX(max_probe_size, probe_size+1)))
int buf_offset = ( probe_size == PROBE_BUF_MIN ) ? 0 : probe_size >> 1 ;
void * buftmp ;
if ( probe_size < offset )
buftmp = av_realloc ( buf , probe_size + AVPROBE_PADDING_SIZE );
if ( ! buftmp )
buf = buftmp;
if ( ( ret = avio_read ( pb , buf + buf_offset , probe_size - buf_offset ) ) < 0 )
if ( ret != AVERROR_EOF )
score = 0;
ret = 0;
pd . buf_size += ret;
pd . buf = & buf [ offset ];
memset ( pd . buf + pd . buf_size , 0 , AVPROBE_PADDING_SIZE );
* fmt = av_probe_input_format2 ( & pd , 1 , & score );
1
------------------------------
21227 CVE-2015-5307/linux_kernel_4.2.6_CVE_2015_5307_arch_x86_kvm_vmx.c __clear_bit ( msr , msr_bitmap_nested + 0x400 / f ) 4292
static int nested_vmx_run(struct kvm_vcpu *vcpu, bool launch)
struct vmcs12 * vmcs12 ;
int cpu ;
struct loaded_vmcs * vmcs02 ;
bool ia32e ;
if ( ! nested_vmx_check_permission ( vcpu ) || ! nested_vmx_check_vmcs12 ( vcpu ) )
vmcs12 = get_vmcs12 ( vcpu );
if ( vmcs12 -> vm_entry_controls & VM_ENTRY_LOAD_IA32_EFER )
ia32e = ( vmcs12 -> vm_entry_controls & VM_ENTRY_IA32E_MODE ) != 0;
if ( ! kvm_valid_efer ( vcpu , vmcs12 -> guest_ia32_efer ) || ia32e != ! ! ( vmcs12 -> guest_ia32_efer & EFER_LMA ) || ( ( vmcs12 -> guest_cr0 & X86_CR0_PG ) && ia32e != ! ! ( vmcs12 -> guest_ia32_efer & EFER_LME ) ) )
if ( vmcs12 -> vm_exit_controls & VM_EXIT_LOAD_IA32_EFER )
ia32e = ( vmcs12 -> vm_exit_controls & VM_EXIT_HOST_ADDR_SPACE_SIZE ) != 0;
if ( ! kvm_valid_efer ( vcpu , vmcs12 -> host_ia32_efer ) || ia32e != ! ! ( vmcs12 -> host_ia32_efer & EFER_LMA ) || ia32e != ! ! ( vmcs12 -> host_ia32_efer & EFER_LME ) )
vmcs02 = nested_get_current_vmcs02 ( vmx );
if ( ! vmcs02 )
cpu = get_cpu ( );
vcpu -> cpu = cpu;
prepare_vmcs02 ( vcpu , vmcs12 );
static void prepare_vmcs02(struct kvm_vcpu *vcpu, struct vmcs12 *vmcs12)
struct vcpu_vmx * vmx = to_vmx ( vcpu ) ;
u32 exec_control ;
exec_control = vmcs12 -> pin_based_vm_exec_control;
exec_control |= vmcs_config . pin_based_exec_ctrl;
exec_control &= ~PIN_BASED_VMX_PREEMPTION_TIMER;
if ( nested_cpu_has_posted_intr ( vmcs12 ) )
vmx -> nested . posted_intr_nv = vmcs12 -> posted_intr_nv;
vmx -> nested . pi_pending = false;
exec_control &= ~PIN_BASED_POSTED_INTR;
vmx -> nested . preemption_timer_expired = false;
if ( cpu_has_secondary_exec_ctrls ( ) )
exec_control = vmx_secondary_exec_control ( vmx );
if ( ! vmx -> rdtscp_enabled )
exec_control &= ~SECONDARY_EXEC_RDTSCP;
exec_control &= ~ ( SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES | SECONDARY_EXEC_RDTSCP | SECONDARY_EXEC_VIRTUAL_INTR_DELIVERY | SECONDARY_EXEC_APIC_REGISTER_VIRT );
if ( nested_cpu_has ( vmcs12 , CPU_BASED_ACTIVATE_SECONDARY_CONTROLS ) )
exec_control |= vmcs12 -> secondary_vm_exec_control;
if ( exec_control & SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES )
if ( ! ( nested_cpu_has_virt_x2apic_mode ( vmcs12 ) ) && ( vm_need_virtualize_apic_accesses ( vmx -> vcpu . kvm ) ) )
exec_control |= SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES;
vmx -> host_rsp = 0;
exec_control = vmx_exec_control ( vmx );
exec_control &= ~CPU_BASED_VIRTUAL_INTR_PENDING;
exec_control &= ~CPU_BASED_VIRTUAL_NMI_PENDING;
exec_control &= ~CPU_BASED_TPR_SHADOW;
exec_control |= vmcs12 -> cpu_based_vm_exec_control;
if ( cpu_has_vmx_msr_bitmap ( ) && exec_control & CPU_BASED_USE_MSR_BITMAPS )
nested_vmx_merge_msr_bitmap ( vcpu , vmcs12 );
static inline bool nested_vmx_merge_msr_bitmap(struct kvm_vcpu
struct vmcs12 *vmcs12)
int msr ;
struct page * page ;
unsigned long * msr_bitmap ;
if ( ! nested_cpu_has_virt_x2apic_mode ( vmcs12 ) )
page = nested_get_page ( vcpu , vmcs12 -> msr_bitmap );
if ( ! page )
msr_bitmap = ( unsigned long * ) kmap ( page );
if ( ! msr_bitmap )
if ( nested_cpu_has_virt_x2apic_mode ( vmcs12 ) )
if ( nested_cpu_has_apic_reg_virt ( vmcs12 ) )
static inline bool nested_cpu_has_apic_reg_virt(struct vmcs12 *vmcs12)
return nested_cpu_has2 ( vmcs12 , SECONDARY_EXEC_APIC_REGISTER_VIRT ) ;
static inline bool nested_cpu_has2(struct vmcs12 *vmcs12, u32 bit)
return ( vmcs12 -> cpu_based_vm_exec_control & CPU_BASED_ACTIVATE_SECONDARY_CONTROLS ) && ( vmcs12 -> secondary_vm_exec_control & bit ) ;
for (msr = 0x800; msr <= 0x8ff; msr++)
nested_vmx_disable_intercept_for_msr ( msr_bitmap , vmx_msr_bitmap_nested , msr , MSR_TYPE_R );
static void nested_vmx_disable_intercept_for_msr(unsigned long
unsigned long
u32 msr, int type)
int f = sizeof ( unsigned long ) ;
if ( ! cpu_has_vmx_msr_bitmap ( ) )
if ( msr <= 0x1fff )
if ( ( msr >= 0xc0000000 ) && ( msr <= 0xc0001fff ) )
msr &= 0x1fff;
if ( type & MSR_TYPE_R && ! test_bit ( msr , msr_bitmap_l1 + 0x400 / f ) )
__clear_bit ( msr , msr_bitmap_nested + 0x400 / f );
0
------------------------------
18667 CVE-2015-2716/Firefox_37.0b7_CVE_2015_2716_parser_expat_lib_xmlparse.c pool -> ptr = pool -> blocks -> s + ( pool -> ptr - pool -> start ) 6264
static ELEMENT_TYPE
getElementType(XML_Parser
const ENCODING
const char
const char *end)
DTD * const dtd = _dtd
const XML_Char * name = poolStoreString ( & dtd -> pool , enc , ptr , end ) ;
static XML_Char
poolStoreString(STRING_POOL *pool, const ENCODING
const char *ptr, const char *end)
if ( ! poolAppend ( pool , enc , ptr , end ) )
static XML_Char
poolAppend(STRING_POOL *pool, const ENCODING
const char *ptr, const char *end)
if ( ! pool -> ptr && ! poolGrow ( pool ) )
static XML_Bool
poolGrow(STRING_POOL *pool)
if ( pool -> freeBlocks )
if ( pool -> start == 0 )
if ( pool -> end - pool -> start < pool -> freeBlocks -> size )
if ( pool -> blocks && pool -> start == pool -> blocks -> s )
int blockSize = ( int ) ( pool -> end - pool -> start ) * 2 ;
pool -> blocks = ( BLOCK * ) pool -> mem -> realloc_fcn ( pool -> blocks , ( offsetof ( BLOCK , s ) + blockSize * sizeof ( XML_Char ) ) );
if ( pool -> blocks == NULL )
pool -> blocks -> size = blockSize;
pool -> ptr = pool -> blocks -> s + ( pool -> ptr - pool -> start );
pool -> start = pool -> blocks -> s;
pool -> end = pool -> start + blockSize;
0
------------------------------
312851 120041/CWE78_OS_Command_Injection__char_listen_socket_system_62b.cpp recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 99
void bad()
char * data ;
char data_buf [ 100 ] = FULL_COMMAND ;
data = data_buf;
badSource ( data );
void badSource(char * &data)
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
0
------------------------------
19065 CVE-2016-7466/qemu_2.3.0_CVE-2016-7466_hcd-xhci.c addr = intr -> er_start + TRB_SIZE * intr -> er_ep_idx 850
static int xhci_complete_packet(XHCITransfer *xfer)
if ( xfer -> packet . status == USB_RET_ASYNC )
if ( xfer -> packet . status == USB_RET_NAK )
xfer -> running_async = 0;
xfer -> running_retry = 0;
xfer -> complete = 1;
if ( xfer -> packet . status == USB_RET_SUCCESS )
xfer -> status = CC_SUCCESS;
switch ( xfer -> packet . status )
xfer -> status = CC_STALL_ERROR;
xhci_xfer_report ( xfer );
static void xhci_xfer_report(XHCITransfer *xfer)
uint32_t edtla = 0 ;
unsigned int left ;
bool reported = 0 ;
bool shortpkt = 0 ;
XHCIEvent event = { ER_TRANSFER , CC_SUCCESS } ;
XHCIState * xhci = xfer -> xhci ;
int i ;
left = xfer -> packet . actual_length;
for (i = 0; i < xfer->trb_count; i++)
XHCITRB * trb = & xfer -> trbs [ i ] ;
unsigned int chunk = 0 ;
switch ( TRB_TYPE ( * trb ) )
chunk = trb -> status & 0x1ffff;
if ( chunk > left )
chunk = left;
if ( xfer -> status == CC_SUCCESS )
shortpkt = 1;
left -= chunk;
edtla += chunk;
reported = 0;
shortpkt = 0;
if ( ( trb -> control & TRB_TR_IOC ) || ( ! reported && ( ( shortpkt && ( trb -> control & TRB_TR_ISP ) ) || ( xfer -> status != CC_SUCCESS && left == 0 ) ) ) )
event . slotid = xfer -> slotid;
event . epid = xfer -> epid;
event . length = ( trb -> status & 0x1ffff ) - chunk;
event . flags = 0;
event . ptr = trb -> addr;
if ( xfer -> status == CC_SUCCESS )
event . ccode = shortpkt ? CC_SHORT_PACKET : CC_SUCCESS;
event . ccode = xfer -> status;
if ( TRB_TYPE ( * trb ) == TR_EVDATA )
event . ptr = trb -> parameter;
event . flags |= TRB_EV_ED;
event . length = edtla & 0xffffff;
edtla = 0;
xhci_event ( xhci , & event , TRB_INTR ( * trb ) );
reported = 1;
if ( xfer -> status != CC_SUCCESS )
static void xhci_event(XHCIState *xhci, XHCIEvent *event, int v)
XHCIInterrupter * intr ;
dma_addr_t erdp ;
unsigned int dp_idx ;
if ( v >= xhci -> numintrs )
intr = & xhci -> intr [ v ];
if ( intr -> er_full )
erdp = xhci_addr64 ( intr -> erdp_low , intr -> erdp_high );
if ( erdp < intr -> er_start || erdp >= ( intr -> er_start + TRB_SIZE * intr -> er_size ) )
dp_idx = ( erdp - intr -> er_start ) / TRB_SIZE;
if ( ( intr -> er_ep_idx + 1 ) % intr -> er_size == dp_idx )
xhci_write_event ( xhci , & full );
static void xhci_write_event(XHCIState *xhci, XHCIEvent *event, int v)
XHCIInterrupter * intr = & xhci -> intr [ v ] ;
dma_addr_t addr ;
addr = intr -> er_start + TRB_SIZE * intr -> er_ep_idx;
pci_dma_write ( pci_dev , addr , & ev_trb , TRB_SIZE );
0
------------------------------
304834 83531/CWE190_Integer_Overflow__int_listen_socket_square_51b.c int result = data * data ; 50
void CWE190_Integer_Overflow__int_listen_socket_square_51_bad()
int data ;
data = 0;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
char inputBuffer [ CHAR_ARRAY_SIZE ] ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
inputBuffer [ recvResult ] = '\0';
data = atoi ( inputBuffer );
while ( 0 )
CWE190_Integer_Overflow__int_listen_socket_square_51b_badSink ( data );
void CWE190_Integer_Overflow__int_listen_socket_square_51b_badSink(int data)
int result = data * data ;
printIntLine ( result );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
1
------------------------------
310628 148896/packet-ppp.c rx_fcs_offset = proto_offset + len 1627
static
dissect_ppp_usb( tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree )
const guchar buf1 [ 3 ] = { 0x7e , 0xff , 0x03 } ;
const guchar buf2 [ 4 ] = { 0x7e , 0xff , 0x7d , 0x23 } ;
tvbuff_t * next_tvb ;
if ( ( tvb_memeql ( tvb , 0 , buf2 , sizeof ( buf2 ) ) == 0 ) || ( tvb_memeql ( tvb , 0 , buf1 , sizeof ( buf1 ) ) == 0 ) )
if ( ( tvb_memeql ( tvb , 0 , & buf1 [ 1 ] , sizeof ( buf1 ) - 1 ) == 0 ) || ( tvb_memeql ( tvb , 0 , & buf2 [ 1 ] , sizeof ( buf2 ) - 1 ) == 0 ) )
if ( tvb_get_guint8 ( tvb , 0 ) == 0x7e )
next_tvb = tvb_new_subset_remaining ( tvb , 1 );
dissect_ppp_hdlc_common ( next_tvb , pinfo , tree );
static
dissect_ppp_hdlc_common(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree)
proto_tree * fh_tree = NULL ;
guint8 byte0 ;
int proto_offset ;
tvbuff_t * next_tvb ;
byte0 = tvb_get_guint8 ( tvb , 0 );
if ( byte0 == 0xff )
proto_offset = 2;
proto_offset = 0;
if ( tree )
ti = proto_tree_add_item ( tree , proto_ppp , tvb , 0 , - 1 , ENC_NA );
fh_tree = proto_item_add_subtree ( ti , ett_ppp );
next_tvb = decode_fcs ( tvb , fh_tree , ppp_fcs_decode , proto_offset );
tvbuff_t
decode_fcs(tvbuff_t *tvb, proto_tree *fh_tree, int fcs_decode, int proto_offset)
gint len , reported_len ;
int rx_fcs_offset ;
switch ( fcs_decode )
len = tvb_length_remaining ( tvb , proto_offset );
reported_len = tvb_reported_length_remaining ( tvb , proto_offset );
if ( reported_len < 2 || len < 0 )
if ( len < reported_len )
len -= 2;
rx_fcs_offset = proto_offset + len;
rx_fcs_got = tvb_get_letohs ( tvb , rx_fcs_offset );
if ( rx_fcs_got != rx_fcs_exp )
proto_tree_add_text ( fh_tree , tvb , rx_fcs_offset , 2 , "FCS 16: 0x%04x [incorrect, should be 0x%04x]" , rx_fcs_got , rx_fcs_exp );
proto_tree_add_text ( fh_tree , tvb , rx_fcs_offset , 2 , "FCS 16: 0x%04x [correct]" , rx_fcs_got );
rx_fcs_got = tvb_get_letohl ( tvb , rx_fcs_offset );
if ( rx_fcs_got != rx_fcs_exp )
proto_tree_add_text ( fh_tree , tvb , rx_fcs_offset , 4 , "FCS 32: 0x%08x [incorrect, should be 0x%08x]" , rx_fcs_got , rx_fcs_exp );
proto_tree_add_text ( fh_tree , tvb , rx_fcs_offset , 4 , "FCS 32: 0x%08x [correct]" , rx_fcs_got );
0
------------------------------
307446 120131/CWE78_OS_Command_Injection__char_listen_socket_w32_execvp_45.c recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 125
void CWE78_OS_Command_Injection__char_listen_socket_w32_execvp_45_bad()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
CWE78_OS_Command_Injection__char_listen_socket_w32_execvp_45_badData = data;
0
------------------------------
302761 82934/CWE190_Integer_Overflow__int64_t_rand_square_09.c int64_t result = data * data ; 37
void CWE190_Integer_Overflow__int64_t_rand_square_09_bad()
int64_t data ;
data = 0L L
if ( GLOBAL_CONST_TRUE )
data = ( int64_t ) RAND64 ( );
if ( GLOBAL_CONST_TRUE )
int64_t result = data * data ;
printLongLongLine ( result );
void printLongLongLine (int64_t longLongIntNumber)
printf ( "%lld\n" , longLongIntNumber );
1
------------------------------
304236 84675/CWE190_Integer_Overflow__unsigned_int_rand_square_32.c unsigned int result = data * data ; 40
void CWE190_Integer_Overflow__unsigned_int_rand_square_32_bad()
unsigned int data ;
unsigned int * dataPtr2 = & data ;
data = 0;
data = ( unsigned int ) RAND32 ( );
unsigned int data = * dataPtr2 ;
unsigned int result = data * data ;
printUnsignedLine ( result );
void printUnsignedLine(unsigned unsignedNumber)
printf ( "%u\n" , unsignedNumber );
1
------------------------------
314285 110401/CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fgets_72b.cpp intPointer = ( int * ) malloc ( data * sizeof ( int ) ) 36
void bad()
vector < int > dataVector ;
badSink ( dataVector );
void badSink(vector<int> dataVector)
int data = dataVector [ 2 ] ;
int * intPointer ;
intPointer = ( int * ) malloc ( data * sizeof ( int ) );
intPointer [ i ] = 0;
printIntLine ( intPointer [ 0 ] );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
free ( intPointer );
1
------------------------------
18030 CVE-2014-0182/qemu_1.6.0_CVE-2014-0182_virtio.c pa = vq -> vring . avail + offsetof ( VRingAvail , idx ) 141
int virtqueue_avail_bytes(VirtQueue *vq, unsigned int
unsigned int out_bytes)
unsigned int in_total , out_total ;
virtqueue_get_avail_bytes ( vq , & in_total , & out_total , in_bytes , out_bytes );
void virtqueue_get_avail_bytes(VirtQueue *vq, unsigned int
unsigned int
unsigned max_in_bytes, unsigned max_out_bytes)
unsigned int idx ;
unsigned int total_bufs , in_total , out_total ;
idx = vq -> last_avail_idx;
total_bufs = in_total = out_total = 0;
while ( virtqueue_num_heads ( vq , idx ) )
hwaddr desc_pa ;
int i ;
max = vq -> vring . num;
i = virtqueue_get_head ( vq , idx ++ );
desc_pa = vq -> vring . desc;
if ( vring_desc_flags ( desc_pa , i ) & VRING_DESC_F_INDIRECT )
max = vring_desc_len ( desc_pa , i ) / sizeof ( VRingDesc );
num_bufs = i = 0;
desc_pa = vring_desc_addr ( desc_pa , i );
if ( vring_desc_flags ( desc_pa , i ) & VRING_DESC_F_WRITE )
in_total += vring_desc_len ( desc_pa , i );
out_total += vring_desc_len ( desc_pa , i );
if ( in_total >= max_in_bytes && out_total >= max_out_bytes )
while ( ( i = virtqueue_next_desc ( desc_pa , i , max ) ) != max )
static int virtqueue_num_heads(VirtQueue *vq, unsigned int idx)
uint16_t num_heads = vring_avail_idx ( vq ) - idx ;
if ( num_heads > vq -> vring . num )
error_report ( "Guest moved used index from %u to %u" , idx , vring_avail_idx ( vq ) );
static inline uint16_t vring_avail_idx(VirtQueue *vq)
hwaddr pa ;
pa = vq -> vring . avail + offsetof ( VRingAvail , idx );
return lduw_phys ( pa ) ;
0
------------------------------
20405 CVE-2015-2724/Firefox_38.8.0esr_CVE_2015_2724_dom_media_webaudio_MediaBufferDecoder.cpp const uint32_t maxOutSamples = resampledFrames - mDecodeJob . mWriteIndex ; 360

MediaDecodeTask::FinishDecode()
uint32_t frameCount = mAudioQueue . FrameCount ( ) ;
uint32_t channelCount = mMediaInfo . mAudio . mChannels ;
uint32_t sampleRate = mMediaInfo . mAudio . mRate ;
if ( ! frameCount || ! channelCount || ! sampleRate )
const uint32_t destSampleRate = mDecodeJob . mContext -> SampleRate ( ) ;
AutoResampler resampler ;
uint32_t resampledFrames = frameCount ;
if ( sampleRate != destSampleRate )
resampledFrames = static_cast < uint32_t > ( static_cast < uint64_t > ( destSampleRate ) * static_cast < uint64_t > ( frameCount ) / static_cast < uint64_t > ( sampleRate ) );
resampler = speex_resampler_init ( channelCount , sampleRate , destSampleRate , SPEEX_RESAMPLER_QUALITY_DEFAULT , nullptr );
resampledFrames += speex_resampler_get_output_latency ( resampler );
bool memoryAllocationSuccess = true ;
if ( ! mDecodeJob . mChannelBuffers . SetLength ( channelCount ) )
memoryAllocationSuccess = false;
for (uint32_t i = 0; i < channelCount; ++i)
mDecodeJob . mChannelBuffers [ i ] = new ( fallible ) float [ resampledFrames ]
if ( ! mDecodeJob . mChannelBuffers [ i ] )
memoryAllocationSuccess = false;
if ( ! memoryAllocationSuccess )
nsRefPtr < AudioData > audioData ;
while ( audioData = mAudioQueue . PopFront ( ) )
if ( sampleRate != destSampleRate )
const uint32_t maxOutSamples = resampledFrames - mDecodeJob . mWriteIndex ;
for (uint32_t i = 0; i < audioData->mChannels; ++i)
uint32_t outSamples = maxOutSamples ;
WebAudioUtils :: SpeexResamplerProcess ( resampler , i , & bufferData [ i * audioData -> mFrames ] , & inSamples , mDecodeJob . mChannelBuffers [ i ] + mDecodeJob . mWriteIndex , & outSamples );
if ( i == audioData -> mChannels - 1 )
mDecodeJob . mWriteIndex += outSamples;
MOZ_ASSERT ( mDecodeJob . mWriteIndex <= resampledFrames );
for (uint32_t i = 0; i < audioData->mChannels; ++i)
ConvertAudioSamples ( & bufferData [ i * audioData -> mFrames ] , mDecodeJob . mChannelBuffers [ i ] + mDecodeJob . mWriteIndex , audioData -> mFrames );
if ( i == audioData -> mChannels - 1 )
mDecodeJob . mWriteIndex += audioData -> mFrames;
const uint32_t maxOutSamples = resampledFrames - mDecodeJob . mWriteIndex ;
uint32_t outSamples = maxOutSamples ;
WebAudioUtils :: SpeexResamplerProcess ( resampler , i , ( AudioDataValue * ) nullptr , & inSamples , mDecodeJob . mChannelBuffers [ i ] + mDecodeJob . mWriteIndex , & outSamples );
mDecodeJob . mWriteIndex += outSamples;
MOZ_ASSERT ( mDecodeJob . mWriteIndex <= resampledFrames );
0
------------------------------
20268 CVE-2016-6508/wireshark_2.0.4_CVE_2016_6508_epan_dissectors_packet-rlc.c out [ i + header_size ] = tvb_get_guint8 ( tvb , header_size + i ) 1422
static
dissect_rlc_ps_dtch(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree)
proto_tree * subtree = NULL ;
fp_info * fpi ;
rlc_info * rlci ;
fpi = ( fp_info * ) p_get_proto_data ( wmem_file_scope ( ) , pinfo , proto_fp , 0 );
rlci = ( rlc_info * ) p_get_proto_data ( wmem_file_scope ( ) , pinfo , proto_rlc , 0 );
if ( ! fpi || ! rlci )
if ( tree )
ti = proto_tree_add_item ( tree , proto_rlc , tvb , 0 , - 1 , ENC_NA );
subtree = proto_item_add_subtree ( ti , ett_rlc );
switch ( rlci -> mode [ fpi -> cur_tb ] )
dissect_rlc_um ( RLC_PS_DTCH , tvb , pinfo , tree , subtree );
static
dissect_rlc_um(enum rlc_channel_type channel, tvbuff_t *tvb, packet_info
proto_tree *top_level, proto_tree *tree)
fp_info * fpinf ;
rlc_info * rlcinf ;
guint8 seq ;
guint8 next_byte , offs = 0 ;
next_byte = tvb_get_guint8 ( tvb , offs ++ );
seq = next_byte >> 1;
fpinf = ( fp_info * ) p_get_proto_data ( wmem_file_scope ( ) , pinfo , proto_fp , 0 );
rlcinf = ( rlc_info * ) p_get_proto_data ( wmem_file_scope ( ) , pinfo , proto_rlc , 0 );
if ( ! fpinf || ! rlcinf )
pos = fpinf -> cur_tb;
if ( ( rlcinf -> ciphered [ pos ] == TRUE && rlcinf -> deciphered [ pos ] == FALSE ) || global_rlc_ciphered )
if ( global_rlc_try_decipher )
rlc_decipher ( tvb , pinfo , tree , fpinf , rlcinf , seq , RLC_UM );
static
rlc_decipher(tvbuff_t *tvb, packet_info * pinfo, proto_tree * tree, fp_info *
rlc_info * rlcinf, guint16 seq, enum rlc_mode mode)
rrc_ciphering_info * c_inf ;
guint8 indx , header_size , hfn_shift ;
gint16 pos ;
indx = fpinf -> is_uplink ? 1 : 0;
pos = fpinf -> cur_tb;
if ( mode == RLC_UM )
header_size = 1;
hfn_shift = 7;
header_size = 2;
hfn_shift = 12;
c_inf = ( rrc_ciphering_info * ) g_tree_lookup ( rrc_ciph_inf , GINT_TO_POINTER ( ( gint ) fpinf -> com_context_id ) );
if ( c_inf != NULL && ( ( c_inf -> setup_frame > 0 && c_inf -> setup_frame < pinfo -> fd -> num && c_inf -> seq_no [ rlcinf -> rbid [ pos ] ] [ indx ] == - 1 ) || ( c_inf -> setup_frame < pinfo -> fd -> num && c_inf -> seq_no [ rlcinf -> rbid [ pos ] ] [ indx ] >= 0 && c_inf -> seq_no [ rlcinf -> rbid [ pos ] ] [ indx ] <= seq ) ) )
tvbuff_t * t ;
if ( ! counter_init [ rlcinf -> rbid [ pos ] ] [ indx ] )
guint32 frame_num = pinfo -> fd -> num ;
counter_init [ rlcinf -> rbid [ pos ] ] [ 0 ] = TRUE;
counter_init [ rlcinf -> rbid [ pos ] ] [ 1 ] = TRUE;
if ( max_counter + 2 > frame_num && c_inf -> seq_no [ rlcinf -> rbid [ pos ] ] [ indx ] == - 1 )
ps_counter [ rlcinf -> rbid [ pos ] ] [ 0 ] = frame_num << hfn_shift;
ps_counter [ rlcinf -> rbid [ pos ] ] [ 1 ] = frame_num << hfn_shift;
if ( rlcinf -> rbid [ pos ] == 9 )
if ( tree )
guint32 frame_num [ 3 ] ;
frame_num [ 0 ] = pinfo -> fd -> num;
t = rlc_decipher_tvb ( tvb , pinfo , ( frame_num [ indx + 1 ] | seq ) , rlcinf -> rbid [ pos ] , ! fpinf -> is_uplink , header_size );
rlc_decipher_tvb(tvbuff_t *tvb, packet_info *pinfo, guint32 counter, guint8 rbid, gboolean dir, guint8 header_size)
guint i ;
out = wmem_alloc0 ( wmem_packet_scope ( ) , strlen ( global_rlc_kasumi_key ) + 1 );
memcpy ( out , global_rlc_kasumi_key , strlen ( global_rlc_kasumi_key ) );
out = g_malloc ( tvb_captured_length ( tvb ) );
for(i = 0; i< tvb_captured_length(tvb)-header_size; i++ )
out [ i + header_size ] = tvb_get_guint8 ( tvb , header_size + i );
f8 ( key_in , counter , rbid - 1 , dir , & out [ header_size ] , ( tvb_captured_length ( tvb ) - header_size ) * 8 );
for (i = 0; i < header_size; i++)
out [ i ] = tvb_get_guint8 ( tvb , i );
t = tvb_new_real_data ( out , tvb_captured_length ( tvb ) , tvb_reported_length ( tvb ) );
add_new_data_source ( pinfo , t , "Deciphered data" );
return t ;
0
------------------------------
18949 CVE-2015-2716/Firefox_37.0b7_CVE_2015_2716_parser_expat_lib_xmlparse.c int blockSize = ( int ) ( pool -> end - pool -> start ) ; 6270
static
reportComment(XML_Parser parser, const ENCODING
const char *start, const char *end)
XML_Char * data ;
if ( ! commentHandler )
data = poolStoreString ( & tempPool , enc , start + enc -> minBytesPerChar * 4 , end - enc -> minBytesPerChar * 3 );
static XML_Char
poolStoreString(STRING_POOL *pool, const ENCODING
const char *ptr, const char *end)
if ( ! poolAppend ( pool , enc , ptr , end ) )
static XML_Char
poolAppend(STRING_POOL *pool, const ENCODING
const char *ptr, const char *end)
if ( ! pool -> ptr && ! poolGrow ( pool ) )
static XML_Bool
poolGrow(STRING_POOL *pool)
if ( pool -> freeBlocks )
if ( pool -> start == 0 )
if ( pool -> end - pool -> start < pool -> freeBlocks -> size )
if ( pool -> blocks && pool -> start == pool -> blocks -> s )
int blockSize = ( int ) ( pool -> end - pool -> start ) ;
if ( blockSize < INIT_BLOCK_SIZE )
blockSize *= 2;
tem = ( BLOCK * ) pool -> mem -> malloc_fcn ( offsetof ( BLOCK , s ) + blockSize * sizeof ( XML_Char ) );
if ( ! tem )
tem -> size = blockSize;
tem -> next = pool -> blocks;
pool -> blocks = tem;
if ( pool -> ptr != pool -> start )
memcpy ( tem -> s , pool -> start , ( pool -> ptr - pool -> start ) * sizeof ( XML_Char ) );
pool -> ptr = tem -> s + ( pool -> ptr - pool -> start );
pool -> start = tem -> s;
pool -> end = tem -> s + blockSize;
0
------------------------------
305091 94111/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_connect_socket_14.c recvResult = recv ( connectSocket , ( char * ) ( password + passwordLen ) , ( 100 - passwordLen - 1 ) * sizeof ( char ) , 0 ) 172
static void goodB2G1()
char * password ;
char passwordBuffer [ 100 ] = "" ;
password = passwordBuffer;
if ( globalFive == 5 )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t passwordLen = strlen ( password ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( password + passwordLen ) , ( 100 - passwordLen - 1 ) * sizeof ( char ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
password [ passwordLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( password , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( password , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
payloadBytes = decodeHexChars ( payload , sizeof ( payload ) , password );
size_t decodeHexChars(unsigned char * bytes, size_t numBytes, const char * hex)
while ( numWritten < numBytes && isxdigit ( hex [ 2 * numWritten ] ) && isxdigit ( hex [ 2 * numWritten + 1 ] ) )
sscanf ( & hex [ 2 * numWritten ] , "%02x" , & byte );
bytes [ numWritten ] = ( unsigned char ) byte;
return numWritten ;
SecureZeroMemory ( password , 100 * sizeof ( char ) );
memcpy ( password , payload , payloadBytes );
password [ payloadBytes / sizeof ( char ) ] = '\0';
if ( LogonUserA ( username , domain , password , LOGON32_LOGON_NETWORK , LOGON32_PROVIDER_DEFAULT , & pHandle ) != 0 )
0
------------------------------
302796 84377/CWE190_Integer_Overflow__unsigned_int_fscanf_square_12.c unsigned int result = data * data ; 42
void CWE190_Integer_Overflow__unsigned_int_fscanf_square_12_bad()
unsigned int data ;
data = 0;
if ( globalReturnsTrueOrFalse ( ) )
int globalReturnsTrueOrFalse()
return ( rand ( ) % 2 ) ;
data = 2;
if ( globalReturnsTrueOrFalse ( ) )
int globalReturnsTrueOrFalse()
return ( rand ( ) % 2 ) ;
unsigned int result = data * data ;
printUnsignedLine ( result );
void printUnsignedLine(unsigned unsignedNumber)
printf ( "%u\n" , unsignedNumber );
1
------------------------------
301331 149442/types.c farandole_chromos = * ( procreatress_wastable + rashly_seapost [ 1 ] ) 373
static int stonesoup_ev_handler(struct mg_connection *conn, enum mg_event ev)
char * ifmatch_header ;
char * stonesoup_tainted_buff ;
int buffer_size = 1000 ;
if ( ev == MG_REQUEST )
ifmatch_header = ( char * ) mg_get_header ( conn , "if-match" );
if ( strcmp ( ifmatch_header , "weak_taint_source_value" ) == 0 )
while ( 1 )
stonesoup_tainted_buff = ( char * ) malloc ( buffer_size * sizeof ( char ) );
data_size = mg_get_var ( conn , "data" , stonesoup_tainted_buff , buffer_size * sizeof ( char ) );
if ( data_size < buffer_size )
buffer_size = buffer_size * 2;
stonesoup_handle_taint ( stonesoup_tainted_buff );
void stonesoup_handle_taint(char *previse_plethodon)
long rashly_seapost [ 10 ] ;
char * procreatress_wastable [ 10 ] = { 0 } ;
if ( previse_plethodon != 0 )
procreatress_wastable [ 5 ] = previse_plethodon;
rashly_seapost [ 1 ] = 5;
farandole_chromos = * ( procreatress_wastable + rashly_seapost [ 1 ] );
if ( farandole_chromos != 0 )
gangflower_klipfish = ( ( char * ) farandole_chromos );
for (stonesoup_i = 0; ((int )stonesoup_i) <= ((int )(strlen(gangflower_klipfish) - strlen(stonesoup_finder))); ++stonesoup_i)
if ( gangflower_klipfish [ stonesoup_i + stonesoup_j ] != stonesoup_finder [ stonesoup_j ] )
stonesoup_second_buff = & gangflower_klipfish [ stonesoup_i ];
tracepoint ( stonesoup_trace , variable_address , "stonesoup_second_buff" , stonesoup_second_buff , "TRIGGER-STATE" );
stonesoup_printf ( "String length is %i\n" , strlen ( stonesoup_second_buff ) );
void stonesoup_printf(char * format, ...)
va_start ( argptr , format );
mg_vprintf_data ( ( struct mg_connection * ) stonesoup_printf_context , format , argptr );
if ( farandole_chromos != 0 )
free ( ( ( char * ) farandole_chromos ) );
1
------------------------------
313394 90655/CWE23_Relative_Path_Traversal__char_listen_socket_ofstream_22b.cpp recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ) 104
void bad()
char * data ;
char dataBuffer [ FILENAME_MAX ] = BASEPATH ;
data = dataBuffer;
data = badSource ( data );
char * badSource(char * data)
if ( badGlobal )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
return data ;
0
------------------------------
300765 150417/utils.c stonesoup_tainted_buff = ( char * ) malloc ( buffer_size * sizeof ( char ) ) 86
static int stonesoup_ev_handler(struct mg_connection *conn, enum mg_event ev)
char * ifmatch_header ;
char * stonesoup_tainted_buff ;
int buffer_size = 1000 ;
if ( ev == MG_REQUEST )
ifmatch_header = ( char * ) mg_get_header ( conn , "if-match" );
if ( strcmp ( ifmatch_header , "weak_taint_source_value" ) == 0 )
while ( 1 )
stonesoup_tainted_buff = ( char * ) malloc ( buffer_size * sizeof ( char ) );
data_size = mg_get_var ( conn , "data" , stonesoup_tainted_buff , buffer_size * sizeof ( char ) );
if ( data_size < buffer_size )
buffer_size = buffer_size * 2;
free ( stonesoup_tainted_buff );
stonesoup_handle_taint ( stonesoup_tainted_buff );
void stonesoup_handle_taint(char *gripsack_legitimacies)
if ( gripsack_legitimacies != 0 )
unprying_adays = & gripsack_legitimacies;
acarocecidium_tartemorion = unprying_adays + 5;
skirmishing_ridicule ( allelic_yacc , acarocecidium_tartemorion );
void skirmishing_ridicule(int cystenchyma_ecumenicism,char **isopycnal_brainardsville)
cystenchyma_ecumenicism --;
if ( cystenchyma_ecumenicism > 0 )
epigenesis_exotery ( cystenchyma_ecumenicism , isopycnal_brainardsville );
void epigenesis_exotery(int dealable_carbonylene,char **rotenones_vesicocele)
skirmishing_ridicule ( dealable_carbonylene , rotenones_vesicocele );
void skirmishing_ridicule(int cystenchyma_ecumenicism,char **isopycnal_brainardsville)
cystenchyma_ecumenicism --;
if ( cystenchyma_ecumenicism > 0 )
epigenesis_exotery ( cystenchyma_ecumenicism , isopycnal_brainardsville );
dripolator_akel = ( ( char * ) ( * ( isopycnal_brainardsville - 5 ) ) );
stonesoupData -> data = malloc ( sizeof ( char ) * ( strlen ( dripolator_akel ) + 1 ) );
if ( stonesoupData -> data && ( sscanf ( dripolator_akel , "%d %s" , & stonesoupData -> qsize , stonesoupData -> data ) == 2 ) && ( strlen ( stonesoupData -> data ) != 0 ) )
stonesoupData -> data_size = strlen ( stonesoupData -> data );
tracepoint ( stonesoup_trace , variable_signed_integral , "stonesoupData->qsize" , stonesoupData -> qsize , & stonesoupData -> qsize , "INITIAL-STATE" );
tracepoint ( stonesoup_trace , variable_buffer , "stonesoupData->data" , stonesoupData -> data , "INTIAL-STATE" );
tracepoint ( stonesoup_trace , variable_signed_integral , "stonesoupData->data_size" , stonesoupData -> data_size , & stonesoupData -> data_size , "INTIAL-STATE" );
if ( pthread_create ( & stonesoup_t0 , NULL , replaceSymbols , ( void * ) stonesoupData ) != 0 )
if ( pthread_create ( & stonesoup_t1 , NULL , toCaps , ( void * ) stonesoupData ) != 0 )
free ( stonesoupData -> data );
free ( stonesoupData );
if ( * ( isopycnal_brainardsville - 5 ) != 0 )
free ( ( ( char * ) ( * ( isopycnal_brainardsville - 5 ) ) ) );
dripolator_akel = ( ( char * ) ( * ( isopycnal_brainardsville - 5 ) ) );
stonesoupData -> data = malloc ( sizeof ( char ) * ( strlen ( dripolator_akel ) + 1 ) );
if ( stonesoupData -> data && ( sscanf ( dripolator_akel , "%d %s" , & stonesoupData -> qsize , stonesoupData -> data ) == 2 ) && ( strlen ( stonesoupData -> data ) != 0 ) )
stonesoupData -> data_size = strlen ( stonesoupData -> data );
tracepoint ( stonesoup_trace , variable_signed_integral , "stonesoupData->qsize" , stonesoupData -> qsize , & stonesoupData -> qsize , "INITIAL-STATE" );
tracepoint ( stonesoup_trace , variable_buffer , "stonesoupData->data" , stonesoupData -> data , "INTIAL-STATE" );
tracepoint ( stonesoup_trace , variable_signed_integral , "stonesoupData->data_size" , stonesoupData -> data_size , & stonesoupData -> data_size , "INTIAL-STATE" );
if ( pthread_create ( & stonesoup_t0 , NULL , replaceSymbols , ( void * ) stonesoupData ) != 0 )
if ( pthread_create ( & stonesoup_t1 , NULL , toCaps , ( void * ) stonesoupData ) != 0 )
free ( stonesoupData -> data );
free ( stonesoupData );
if ( * ( isopycnal_brainardsville - 5 ) != 0 )
free ( ( ( char * ) ( * ( isopycnal_brainardsville - 5 ) ) ) );
1
------------------------------
301823 151049/utf.c valid = ( last - data ) 659
svn_error_t *svn_utf_string_from_utf8(const svn_string_t **dest,const svn_string_t *src,apr_pool_t *pool)
xlate_handle_node_t * node ;
svn_error_t * err ;
svn_error_t * svn_err__temp = get_uton_xlate_handle_node ( & node , pool ) ;
static svn_error_t *get_uton_xlate_handle_node(xlate_handle_node_t **ret,apr_pool_t *pool)
return get_xlate_handle_node ( ret , ( assume_native_charset_is_utf8 ? SVN_APR_UTF8_CHARSET : ( ( const char * ) 1 ) ) , SVN_APR_UTF8_CHARSET , SVN_UTF_UTON_XLATE_HANDLE , pool ) ;
static svn_error_t *get_xlate_handle_node(xlate_handle_node_t **ret,const char *topage,const char *frompage,const char *userdata_key,apr_pool_t *pool)
xlate_handle_node_t * old_node = ( ( void * ) 0 ) ;
if ( userdata_key )
if ( xlate_handle_hash )
if ( userdata_key == SVN_UTF_NTOU_XLATE_HANDLE )
old_node = ( atomic_swap ( & xlat_ntou_static_handle , ( ( void * ) 0 ) ) );
if ( userdata_key == SVN_UTF_UTON_XLATE_HANDLE )
old_node = ( atomic_swap ( & xlat_uton_static_handle , ( ( void * ) 0 ) ) );
if ( old_node && old_node -> valid )
return 0 ;
void * p ;
old_node = p;
if ( old_node && old_node -> valid )
* ret = old_node;
return 0 ;
return xlate_alloc_handle ( ret , topage , frompage , pool ) ;
svn_mutex__t * svn_mutex__m = xlate_handle_mutex ;
svn_error_t * svn_err__temp = svn_mutex__lock ( svn_mutex__m ) ;
if ( svn_err__temp )
return svn_err__temp ;
while ( 0 )
svn_error_t * svn_err__temp = svn_mutex__unlock ( svn_mutex__m , get_xlate_handle_node_internal ( ret , topage , frompage , userdata_key , pool ) ) ;
if ( svn_err__temp )
return svn_err__temp ;
while ( 0 )
while ( 0 )
return 0 ;
if ( svn_err__temp )
while ( 0 )
if ( node -> handle )
err = check_utf8 ( src -> data , src -> len , pool );
static svn_error_t *check_utf8(const char *data,apr_size_t len,apr_pool_t *pool)
if ( ! svn_utf__is_valid ( data , len ) )
return invalid_utf8 ( data , len , pool ) ;
static svn_error_t *invalid_utf8(const char *data,apr_size_t len,apr_pool_t *pool)
const char * last = svn_utf__last_valid ( data , len ) ;
size_t valid ;
valid = ( last - data );
if ( valid > 24 )
for (i = 0; i < valid; ++i)
valid_txt = ( apr_pstrcat ( pool , valid_txt , apr_psprintf ( pool , " %02x" , ( ( unsigned char ) last [ i - valid ] ) ) , ( ( char * ) ( ( void * ) 0 ) ) ) );
return svn_error_createf ( 22 , ( ( void * ) 0 ) , ( dgettext ( "subversion" , "Valid UTF-8 data\n(hex:%s)\nfollowed by invalid UTF-8 sequence\n(hex:%s)" ) ) , valid_txt , invalid_txt ) ;
0
------------------------------
307687 119909/CWE78_OS_Command_Injection__char_listen_socket_execl_83_bad.cpp recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 98
CWE78_OS_Command_Injection__char_listen_socket_execl_83_bad::CWE78_OS_Command_Injection__char_listen_socket_execl_83_bad(char * dataCopy)
data = dataCopy;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
0
------------------------------
21271 CVE-2015-5307/linux_kernel_4.2.6_CVE_2015_5307_arch_x86_kvm_vmx.c u32 mask = 1 << ( seg * SEG_FIELD_NR + field ) ; 1518
static bool cs_ss_rpl_check(struct kvm_vcpu *vcpu)
struct kvm_segment cs , ss ;
vmx_get_segment ( vcpu , & ss , VCPU_SREG_SS );
static void vmx_get_segment(struct kvm_vcpu
struct kvm_segment *var, int seg)
struct vcpu_vmx * vmx = to_vmx ( vcpu ) ;
if ( vmx -> rmode . vm86_active && seg != VCPU_SREG_LDTR )
* var = vmx -> rmode . segs [ seg ];
if ( seg == VCPU_SREG_TR || var -> selector == vmx_read_guest_seg_selector ( vmx , seg ) )
var -> base = vmx_read_guest_seg_base ( vmx , seg );
static ulong vmx_read_guest_seg_base(struct vcpu_vmx *vmx, unsigned seg)
if ( ! vmx_segment_cache_test_set ( vmx , seg , SEG_FIELD_BASE ) )
static bool vmx_segment_cache_test_set(struct vcpu_vmx *vmx, unsigned
unsigned field)
u32 mask = 1 << ( seg * SEG_FIELD_NR + field ) ;
ret = vmx -> segment_cache . bitmask & mask;
vmx -> segment_cache . bitmask |= mask;
return ret ;
0
------------------------------
20716 CVE-2016-8910/qemu_2.3.0_CVE-2016-8910_rtl8139.c uint8_t * data_to_checksum = eth_payload_data + hlen - 12 ; 2222
static void rtl8139_io_writel(void *opaque, uint8_t addr, uint32_t val)
switch ( addr )
rtl8139_io_writeb ( opaque , addr , val & 0xff );
static void rtl8139_io_writeb(void *opaque, uint8_t addr, uint32_t val)
RTL8139State * s = opaque ;
switch ( addr )
if ( val == 'R' )
if ( val == 'H' )
s -> clock_enabled = 0;
s -> TxThresh = val;
if ( val & ( 1 << 6 ) )
rtl8139_cplus_transmit ( s );
static void rtl8139_cplus_transmit(RTL8139State *s)
while ( rtl8139_cplus_transmit_one ( s ) )
static int rtl8139_cplus_transmit_one(RTL8139State *s)
if ( ! rtl8139_transmitter_enabled ( s ) )
if ( ! rtl8139_cp_transmitter_enabled ( s ) )
uint32_t val , txdw0 , txdw1 , txbufLO , txbufHI ;
txdw0 = le32_to_cpu ( val );
if ( ! ( txdw0 & CP_TX_OWN ) )
if ( txdw0 & CP_TX_FS )
s -> cplus_txbuffer_offset = 0;
int txsize = txdw0 & CP_TX_BUFFER_SIZE_MASK ;
if ( ! s -> cplus_txbuffer )
s -> cplus_txbuffer_len = CP_TX_BUFFER_SIZE;
s -> cplus_txbuffer = g_malloc ( s -> cplus_txbuffer_len );
s -> cplus_txbuffer_offset = 0;
if ( s -> cplus_txbuffer_offset + txsize >= s -> cplus_txbuffer_len )
txsize = s -> cplus_txbuffer_len - s -> cplus_txbuffer_offset;
s -> cplus_txbuffer_offset += txsize;
if ( txdw0 & CP_TX_EOR )
s -> currCPlusTxDesc = 0;
if ( s -> currCPlusTxDesc >= 64 )
s -> currCPlusTxDesc = 0;
txdw0 &= ~CP_RX_OWN;
txdw0 &= ~CP_TX_STATUS_UNF;
txdw0 &= ~CP_TX_STATUS_TES;
txdw0 &= ~CP_TX_STATUS_OWC;
txdw0 &= ~CP_TX_STATUS_LNKF;
txdw0 &= ~CP_TX_STATUS_EXC;
if ( txdw0 & CP_TX_LS )
uint8_t * saved_buffer = s -> cplus_txbuffer ;
if ( txdw0 & ( CP_TX_IPCS | CP_TX_UDPCS | CP_TX_TCPCS | CP_TX_LGSEN ) )
ip_header * ip = NULL ;
int hlen = 0 ;
uint8_t ip_protocol = 0 ;
uint8_t * eth_payload_data = NULL ;
int proto = be16_to_cpu ( * ( uint16_t * ) ( saved_buffer + 12 ) ) ;
if ( proto == ETH_P_IP )
eth_payload_data = saved_buffer + ETH_HLEN;
ip = ( ip_header * ) eth_payload_data;
if ( IP_HEADER_VERSION ( ip ) != IP_HEADER_VERSION_4 )
ip = NULL;
hlen = IP_HEADER_LENGTH ( ip );
ip_protocol = ip -> ip_p;
if ( ip )
if ( ( txdw0 & CP_TX_LGSEN ) && ip_protocol == IP_PROTO_TCP )
uint8_t * data_to_checksum = eth_payload_data + hlen - 12 ;
DPRINTF ( "+++ C+ mode TSO TCP seqno %08x\n" , be32_to_cpu ( p_tcp_hdr -> th_seq ) );
memcpy ( data_to_checksum , saved_ip_header + 12 , 8 );
ip_pseudo_header * p_tcpip_hdr = ( ip_pseudo_header * ) data_to_checksum ;
p_tcpip_hdr -> zeros = 0;
p_tcpip_hdr -> ip_proto = IP_PROTO_TCP;
p_tcpip_hdr -> ip_payload = cpu_to_be16 ( tcp_hlen + chunk_size );
int tcp_checksum = ip_checksum ( data_to_checksum , tcp_hlen + chunk_size + 12 ) ;
DPRINTF ( "+++ C+ mode TSO TCP checksum %04x\n" , tcp_checksum );
p_tcp_hdr -> th_sum = tcp_checksum;
p_tcp_hdr -> th_seq = cpu_to_be32 ( chunk_size + be32_to_cpu ( p_tcp_hdr -> th_seq ) );
0
------------------------------
309971 150945/oids.c * left = len - i 1118
oid_info_t *oid_get_from_string(const gchar *oid_str,guint32 **subids_p,guint *matched,guint *left)
guint subids_len = oid_string2subid ( oid_str , subids_p ) ;
guint oid_string2subid(const char *str,guint32 **subids_p)
const char * r = str ;
guint32 * subids ;
guint32 * subids_overflow ;
guint n = check_num_oid ( str ) ;
static guint check_num_oid(const char *str)
const char * r = str ;
char c = '\0' ;
guint n = 0 ;
if ( ! r || ( * r ) == '.' || ( * r ) == '\0' )
return 0 ;
switch ( * r )
n ++;
if ( c == '.' )
return 0 ;
n ++;
return 0 ;
while ( c = * ( r ++ ) )
if ( c == '.' )
return 0 ;
return n ;
guint64 subid = 0 ;
if ( ! n )
return 0 ;
* subids_p = subids = ( ep_alloc0 ( sizeof ( guint32 ) * n ) );
subids_overflow = subids + n;
switch ( * r )
subid = 0;
subids ++;
subid *= 10;
subid += ( ( * r ) - 48 );
if ( subids >= subids_overflow || subid > 0xffffffff )
return 0 ;
return 0 ;
while ( * ( r ++ ) )
return n ;
return oid_get ( subids_len , * subids_p , matched , left ) ;
oid_info_t *oid_get(guint len,guint32 *subids,guint *matched,guint *left)
oid_info_t * curr_oid = & oid_root ;
guint i ;
if ( ! ( subids && * subids <= 2 ) )
for (i = 0; i < len; i++)
oid_info_t * next_oid = ( emem_tree_lookup32 ( ( curr_oid -> children ) , subids [ i ] ) ) ;
if ( next_oid )
curr_oid = next_oid;
* left = len - i;
0
------------------------------
303448 80397/CWE134_Uncontrolled_Format_String__char_listen_socket_vfprintf_04.c recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 335
static void goodB2G2()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
if ( STATIC_CONST_TRUE )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
goodB2G2VaSinkG ( data , data );
static void goodB2G2VaSinkG(char * data, ...)
va_start ( args , data );
0
------------------------------
20552 CVE-2016-4998/linux_kernel_4.5.7_CVE_2016_4998_net_ipv4_netfilter_ip_tables.c entry_offset = ( void * ) e - base 1035
static
compat_do_ipt_get_ctl(struct sock *sk, int cmd, void __user *user, int *len)
int ret ;
if ( ! ns_capable ( sock_net ( sk ) -> user_ns , CAP_NET_ADMIN ) )
switch ( cmd )
ret = get_info ( sock_net ( sk ) , user , len , 1 );
static int get_info(struct net *net, void __user
const int *len, int compat)
char name [ XT_TABLE_MAXNAMELEN ] ;
struct xt_table * t ;
int ret ;
if ( * len != sizeof ( struct ipt_getinfo ) )
if ( copy_from_user ( name , user , sizeof ( name ) ) != 0 )
name [ XT_TABLE_MAXNAMELEN - 1 ] = '\0';
t = try_then_request_module ( xt_find_table_lock ( net , AF_INET , name ) , "iptable_%s" , name );
if ( ! IS_ERR_OR_NULL ( t ) )
const struct xt_table_info * private = t -> private ;
if ( compat )
ret = compat_table_info ( private , & tmp );
static int compat_table_info(const struct xt_table_info
struct xt_table_info *newinfo)
struct ipt_entry * iter ;
const void * loc_cpu_entry ;
int ret ;
if ( ! newinfo || ! info )
memcpy ( newinfo , info , offsetof ( struct xt_table_info , entries ) )
newinfo -> initial_entries = 0;
loc_cpu_entry = info -> entries;
ret = compat_calc_entry ( iter , info , loc_cpu_entry , newinfo );
static int compat_calc_entry(const struct ipt_entry
const struct xt_table_info
const void *base, struct xt_table_info *newinfo)
unsigned int entry_offset ;
entry_offset = ( void * ) e - base;
ret = xt_compat_add_offset ( AF_INET , entry_offset , off );
if ( ret )
return ret ;
0
------------------------------
309537 153611/dfa.c size_t mid = lo + hi >> 1 ; 2242
char *dfaexec(struct dfa *d,const char *begin,char *end,int allow_nl,size_t *count,int *backref)
state_num s ;
state_num s1 ;
const unsigned char * p ;
state_num * * trans ;
state_num * t ;
unsigned char eol = eolbyte ;
s = s1 = 0;
p = ( ( const unsigned char * ) begin );
trans = d -> trans;
* end = eol;
if ( d -> mb_cur_max > 1 )
while ( ( t = trans [ s ] ) != ( ( void * ) 0 ) )
if ( p > buf_end )
s1 = s;
if ( s == 0 )
if ( ( ( char * ) p ) >= end )
if ( d -> states [ s ] . mbps . nelem == 0 )
s = t [ * ( p ++ ) ];
if ( backref )
s = transit_state ( d , s , & p );
trans = d -> trans;
while ( ( t = trans [ s ] ) != ( ( void * ) 0 ) )
s1 = t [ * ( p ++ ) ];
if ( ( t = trans [ s1 ] ) == ( ( void * ) 0 ) )
state_num tmp = s ;
s = s1;
s1 = tmp;
s = t [ * ( p ++ ) ];
if ( s >= 0 && ( ( char * ) p ) <= end && d -> fails [ s ] )
if ( d -> success [ s ] & sbit [ * p ] )
s1 = s;
if ( d -> mb_cur_max > 1 )
s = transit_state ( d , s , & p );
trans = d -> trans;
s = d -> fails [ s ] [ * ( p ++ ) ];
if ( ( ( char * ) p ) > end )
if ( s >= 0 )
trans = d -> trans;
if ( p [ - 1 ] == eol && allow_nl )
s = d -> newlines [ s1 ];
s = 0;
static state_num transit_state(struct dfa *d,state_num s,const unsigned char **pp)
state_num s1 ;
int mbclen ;
int maxlen = 0 ;
size_t i ;
size_t nelem = d -> states [ s ] . mbps . nelem ;
position_set follows ;
const unsigned char * p1 = * pp ;
wchar_t wc ;
if ( nelem > 0 )
match_lens = check_matching_with_multibyte_ops ( d , s , ( * pp - buf_begin ) );
for (i = 0; i < nelem; i++)
if ( match_lens [ i ] > maxlen )
maxlen = match_lens [ i ];
if ( nelem == 0 || maxlen == 0 )
wc = inputwcs [ * pp - mbclen - buf_begin ];
s1 = state_index ( d , ( & follows ) , wchar_context ( wc ) );
while ( * pp - p1 < maxlen )
transit_state_consume_1char ( d , s1 , pp , ( ( void * ) 0 ) , & mbclen , & follows );
wc = inputwcs [ * pp - mbclen - buf_begin ];
s1 = state_index ( d , ( & follows ) , wchar_context ( wc ) );
static status_transit_state transit_state_consume_1char(struct dfa *d,state_num s,const unsigned char **pp,int *match_lens,int *mbclen,position_set *pps)
size_t i ;
size_t j ;
int k ;
state_num s1 ;
state_num s2 ;
int * work_mbls ;
* mbclen = ( mblen_buf [ * pp - buf_begin ] == 0 ? 1 : mblen_buf [ * pp - buf_begin ] );
s1 = s;
for (k = 0; k <  *mbclen; k++)
s2 = s1;
rs = transit_state_singlebyte ( d , s2 , ( * pp ) ++ , & s1 );
if ( match_lens == ( ( void * ) 0 ) && d -> states [ s ] . mbps . nelem != 0 )
work_mbls = check_matching_with_multibyte_ops ( d , s , ( * pp - buf_begin ) );
work_mbls = match_lens;
for (i = 0; i < d -> states[s] . mbps . nelem; i++)
if ( work_mbls [ i ] == * mbclen )
for (j = 0; j < d -> follows[d -> states[s] . mbps . elems[i] . index] . nelem; j++)
insert ( d -> follows [ d -> states [ s ] . mbps . elems [ i ] . index ] . elems [ j ] , pps );
static void insert(position p,position_set *s)
size_t count = s -> nelem ;
size_t lo = 0 ;
size_t hi = count ;
while ( lo < hi )
size_t mid = lo + hi >> 1 ;
if ( s -> elems [ mid ] . index > p . index )
lo = mid + 1;
hi = mid;
if ( lo < count && p . index == s -> elems [ lo ] . index )
s -> elems [ lo ] . constraint |= p . constraint;
for (i = count; i > lo; i--)
s -> elems [ lo ] = p;
++ s -> nelem;
0
------------------------------
313884 94996/CWE369_Divide_by_Zero__int_connect_socket_divide_62a.cpp printIntLine ( 100 / data ) 35
void bad()
int data ;
data = - 1;
printIntLine ( 100 / data );
1
------------------------------
18393 CVE-2015-2710/Firefox_37.0b7_CVE_2015_2710_layout_svg_SVGTextFrame.cpp double minTextRunSize = minSize * contextScale ; 5384

SVGTextFrame::UpdateFontSizeScaleFactor()
nsPresContext * presContext = PresContext ( ) ;
bool geometricPrecision = false ;
nscoord min = nscoord_MAX , max = nscoord_MIN ;
TextFrameIterator it ( this ) ;
nsTextFrame * f = it . Current ( ) ;
while ( f )
if ( ! geometricPrecision )
geometricPrecision = f -> StyleSVG ( ) -> mTextRendering == NS_STYLE_TEXT_RENDERING_GEOMETRICPRECISION;
nscoord size = f -> StyleFont ( ) -> mFont . size ;
if ( size )
min = std :: min ( min , size );
f = it . Next ( );
if ( min == nscoord_MAX )
double minSize = presContext -> AppUnitsToFloatCSSPixels ( min ) ;
if ( geometricPrecision )
double contextScale = 1.0 ;
if ( ! ( mState & NS_FRAME_IS_NONDISPLAY ) )
gfxMatrix m ( GetCanvasTM ( ) ) ;
if ( ! m . IsSingular ( ) )
contextScale = GetContextScale ( m );
static
GetContextScale(const gfxMatrix& aMatrix)
gfxPoint p = aMatrix . Transform ( gfxPoint ( 1 , 1 ) ) - aMatrix . Transform ( gfxPoint ( 0 , 0 ) ) ;
return SVGContentUtils :: ComputeNormalizedHypotenuse ( p . x , p . y ) ;
float cssPxPerDevPx = presContext -> AppUnitsToFloatCSSPixels ( presContext -> AppUnitsPerDevPixel ( ) ) ;
contextScale *= cssPxPerDevPx;
double minTextRunSize = minSize * contextScale ;
if ( minTextRunSize >= CLAMP_MIN_SIZE && maxTextRunSize <= CLAMP_MAX_SIZE )
mFontSizeScaleFactor = CLAMP_MIN_SIZE / minTextRunSize;
if ( minTextRunSize < CLAMP_MIN_SIZE )
mFontSizeScaleFactor = CLAMP_MIN_SIZE / minTextRunSize;
return mFontSizeScaleFactor != oldFontSizeScaleFactor ;
0
------------------------------
19227 CVE-2016-3062/Ffmpeg_0.11_CVE_2016_3062_libavformat_mov.c int next = time_sample + sc -> ctts_data [ i ] . count ; 3032
static int mov_read_seek(AVFormatContext *s, int stream_index, int64_t sample_time, int flags)
AVStream * st ;
int64_t seek_timestamp , timestamp ;
int sample ;
int i ;
if ( stream_index >= s -> nb_streams )
if ( sample_time < 0 )
sample_time = 0;
st = s -> streams [ stream_index ];
sample = mov_seek_stream ( s , st , sample_time , flags );
if ( sample < 0 )
seek_timestamp = st -> index_entries [ sample ] . timestamp;
for (i = 0; i < s->nb_streams; i++)
st = s -> streams [ i ];
if ( stream_index == i )
timestamp = av_rescale_q ( seek_timestamp , s -> streams [ stream_index ] -> time_base , st -> time_base );
mov_seek_stream ( s , st , timestamp , flags );
static int mov_seek_stream(AVFormatContext *s, AVStream *st, int64_t timestamp, int flags)
MOVStreamContext * sc = st -> priv_data ;
int sample , time_sample ;
int i ;
sample = av_index_search_timestamp ( st , timestamp , flags );
if ( sample < 0 && st -> nb_index_entries && timestamp < st -> index_entries [ 0 ] . timestamp )
sample = 0;
if ( sample < 0 )
sc -> current_sample = sample;
if ( sc -> ctts_data )
time_sample = 0;
for (i = 0; i < sc->ctts_count; i++)
int next = time_sample + sc -> ctts_data [ i ] . count ;
if ( next > sc -> current_sample )
sc -> ctts_sample = sc -> current_sample - time_sample;
time_sample = next;
0
------------------------------
301040 153289/aviobuf.c s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_ptr - s -> checksum_ptr ) ) ) 202
void avio_wl64(AVIOContext *s,uint64_t val)
avio_wl32 ( s , ( ( uint32_t ) ( val & 0xffffffff ) ) );
void avio_wl32(AVIOContext *s,unsigned int val)
avio_w8 ( s , ( ( uint8_t ) ( val >> 16 ) ) );
void avio_w8(AVIOContext *s,int b)
* ( s -> buf_ptr ++ ) = b;
if ( s -> buf_ptr >= s -> buf_end )
flush_buffer ( s );
static void flush_buffer(AVIOContext *s)
if ( s -> buf_ptr > s -> buffer )
if ( s -> update_checksum )
s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_ptr - s -> checksum_ptr ) ) );
s -> checksum_ptr = s -> buffer;
s -> buf_ptr = s -> buffer;
0
------------------------------
300384 153811/dfa.c match_lens = check_matching_with_multibyte_ops ( d , s , ( * pp - buf_begin ) ) 3462
char *dfaexec(struct dfa *d,const char *begin,char *end,int allow_nl,size_t *count,int *backref)
state_num s ;
state_num s1 ;
const unsigned char * p ;
state_num * * trans ;
state_num * t ;
unsigned char eol = eolbyte ;
unsigned char saved_end ;
s = s1 = 0;
p = ( ( const unsigned char * ) begin );
trans = d -> trans;
saved_end = * ( ( unsigned char * ) end );
* end = eol;
if ( d -> mb_cur_max > 1 )
while ( ( t = trans [ s ] ) != ( ( void * ) 0 ) )
if ( p > buf_end )
s1 = s;
if ( s == 0 )
if ( ( ( char * ) p ) >= end )
if ( d -> states [ s ] . mbps . nelem == 0 )
s = t [ * ( p ++ ) ];
if ( backref )
* end = saved_end;
s = transit_state ( d , s , & p );
trans = d -> trans;
while ( ( t = trans [ s ] ) != ( ( void * ) 0 ) )
s1 = t [ * ( p ++ ) ];
if ( ( t = trans [ s1 ] ) == ( ( void * ) 0 ) )
state_num tmp = s ;
s = s1;
s1 = tmp;
s = t [ * ( p ++ ) ];
if ( s >= 0 && ( ( char * ) p ) <= end && d -> fails [ s ] )
if ( d -> success [ s ] & sbit [ * p ] )
s1 = s;
if ( d -> mb_cur_max > 1 )
s = transit_state ( d , s , & p );
trans = d -> trans;
s = d -> fails [ s ] [ * ( p ++ ) ];
if ( ( ( char * ) p ) > end )
if ( s >= 0 )
trans = d -> trans;
if ( p [ - 1 ] == eol && allow_nl )
s = d -> newlines [ s1 ];
s = 0;
static state_num transit_state(struct dfa *d,state_num s,const unsigned char **pp)
size_t nelem = d -> states [ s ] . mbps . nelem ;
if ( nelem > 0 )
match_lens = check_matching_with_multibyte_ops ( d , s , ( * pp - buf_begin ) );
if ( match_lens [ i ] > maxlen )
maxlen = match_lens [ i ];
if ( nelem == 0 || maxlen == 0 )
free ( match_lens );
transit_state_consume_1char ( d , s , pp , match_lens , & mbclen , & follows );
while ( * pp - p1 < maxlen )
if ( match_lens [ i ] == * pp - p1 )
free ( match_lens );
0
------------------------------
301175 152151/utils.c sep = start + strcspn ( start , " ," ) 4910
int ff_http_match_no_proxy(const char *no_proxy,const char *hostname)
char * buf ;
char * start ;
if ( ! no_proxy )
if ( ! hostname )
buf = av_strdup ( no_proxy );
if ( ! buf )
start = buf;
while ( start )
char * sep ;
char * next = ( ( void * ) 0 ) ;
start += strspn ( start , " ," );
sep = start + strcspn ( start , " ," );
if ( * sep )
next = sep + 1;
* sep = '\0';
if ( match_host_pattern ( start , hostname ) )
static int match_host_pattern(const char *pattern,const char *hostname)
if ( ! strcmp ( pattern , "*" ) )
if ( pattern [ 0 ] == '*' )
pattern ++;
if ( pattern [ 0 ] == '.' )
pattern ++;
len_p = ( strlen ( pattern ) );
len_h = ( strlen ( hostname ) );
if ( len_p > len_h )
if ( ! strcmp ( pattern , & hostname [ len_h - len_p ] ) )
if ( len_h == len_p )
if ( hostname [ len_h - len_p - 1 ] == '.' )
start = next;
0
------------------------------
305806 120010/CWE78_OS_Command_Injection__char_listen_socket_system_04.c recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 114
void CWE78_OS_Command_Injection__char_listen_socket_system_04_bad()
char * data ;
char data_buf [ 100 ] = FULL_COMMAND ;
data = data_buf;
if ( STATIC_CONST_TRUE )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
if ( SYSTEM ( data ) <= 0 )
1
------------------------------
301278 199326/unused_var.c s . unuse = s . a + s . b 41
void unused_var_002 ()
unused_var_002_s_001 s ;
s . a = 1;
s . b = 2;
s . unuse = s . a + s . b;
printf ( "%d" , s . unuse );
0
------------------------------
314113 112545/CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_connect_socket_43.cpp recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 87
void bad()
char * data ;
data = ( char * ) malloc ( 100 * sizeof ( char ) );
data [ 0 ] = '\0';
badSource ( data );
static void badSource(char * &data)
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
0
------------------------------
307248 118182/CWE78_OS_Command_Injection__char_connect_socket_w32_execv_84_bad.cpp recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 86
void bad()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
CWE78_OS_Command_Injection__char_connect_socket_w32_execv_84_bad * badObject = new CWE78_OS_Command_Injection__char_connect_socket_w32_execv_84_bad ( data ) ;
CWE78_OS_Command_Injection__char_connect_socket_w32_execv_84_bad::CWE78_OS_Command_Injection__char_connect_socket_w32_execv_84_bad(char * dataCopy)
data = dataCopy;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
0
------------------------------
305259 94198/CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_connect_socket_05.c recvResult = recv ( connectSocket , ( char * ) ( password + passwordLen ) , ( 100 - passwordLen - 1 ) * sizeof ( wchar_t ) , 0 ) 333
static void goodB2G2()
wchar_t * password ;
wchar_t passwordBuffer [ 100 ] = L ""
password = passwordBuffer;
if ( staticTrue )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t passwordLen = wcslen ( password ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( password + passwordLen ) , ( 100 - passwordLen - 1 ) * sizeof ( wchar_t ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
312997 90688/CWE23_Relative_Path_Traversal__char_listen_socket_open_05.cpp recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ) 117
void bad()
char * data ;
char dataBuffer [ FILENAME_MAX ] = BASEPATH ;
data = dataBuffer;
if ( staticTrue )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
fileDesc = OPEN ( data , O_RDWR | O_CREAT , S_IREAD | S_IWRITE );
if ( fileDesc != - 1 )
CLOSE ( fileDesc );
1
------------------------------
301203 152159/tile-manager.c rows = y2 - y + 1 810
void tile_manager_write_pixel_data(TileManager *tm,gint x1,gint y1,gint x2,gint y2,const guchar *buffer,guint stride)
guint x ;
guint y ;
for (y = y1; y <= y2; y += 64 - y % 64)
for (x = x1; x <= x2; x += 64 - x % 64)
Tile * tile = tile_manager_get_tile ( tm , x , y , ! 0 , ! 0 ) ;
Tile *tile_manager_get_tile(TileManager *tm,gint xpixel,gint ypixel,gboolean wantread,gboolean wantwrite)
if ( tm != ( ( void * ) 0 ) )
return ( ( void * ) 0 ) ;
while ( 0 )
return tile_manager_get ( tm , tile_manager_get_tile_num ( tm , xpixel , ypixel ) , wantread , wantwrite ) ;
inline static gint tile_manager_get_tile_num(TileManager *tm,gint xpixel,gint ypixel)
if ( xpixel < 0 || xpixel >= tm -> width || ypixel < 0 || ypixel >= tm -> height )
return - 1 ;
return ypixel / 64 * tm -> ntile_cols + xpixel / 64 ;
Tile *tile_manager_get(TileManager *tm,gint tile_num,gboolean wantread,gboolean wantwrite)
Tile * tile ;
gint ntiles ;
if ( tm != ( ( void * ) 0 ) )
return ( ( void * ) 0 ) ;
while ( 0 )
ntiles = tm -> ntile_rows * tm -> ntile_cols;
if ( tile_num < 0 || tile_num >= ntiles )
return ( ( void * ) 0 ) ;
tile = tm -> tiles [ tile_num ];
if ( wantread )
if ( wantwrite )
if ( tile -> share_count > 1 )
Tile * new = tile_new ( ( tile -> bpp )
new -> ewidth = tile ->
new -> eheight = tile ->
new -> valid = ( tile -> valid
new -> size = ( new -> ewidth ) * ( new -> eheight ) * ( new -> bpp
new -> data = ( ( guchar * ) ( g_malloc_n ( ( new -> size ) , sizeof ( guchar ) ) ) )
if ( tile -> data )
memcpy ( ( new -> data ) , ( tile -> data ) , ( new -> size ) )
memcpy ( ( new -> data ) , ( tile -> data ) , ( new -> size ) )
tile_attach ( new , tm , tile_num
tile = new
tile -> write_count ++;
tile -> dirty = ( ! 0 );
return tile ;
guint rows ;
rows = ( tile -> eheight ) - y % 64;
if ( rows > y2 - y + 1 )
rows = y2 - y + 1;
while ( rows -- )
0
------------------------------
303680 83259/CWE190_Integer_Overflow__int_fgets_square_82_goodG2B.cpp int result = data * data ; 31
static void goodG2B()
int data ;
data = 0;
data = 2;
CWE190_Integer_Overflow__int_fgets_square_82_base * baseObject = new CWE190_Integer_Overflow__int_fgets_square_82_goodG2B
baseObject -> action ( data );
void CWE190_Integer_Overflow__int_fgets_square_82_goodG2B::action(int data)
int result = data * data ;
printIntLine ( result );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
0
------------------------------
302671 79121/CWE134_Uncontrolled_Format_String__char_connect_socket_fprintf_34.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 95
void CWE134_Uncontrolled_Format_String__char_connect_socket_fprintf_34_bad()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
myUnion . unionFirst = data;
char * data = myUnion . unionSecond ;
fprintf ( stdout , data );
1
------------------------------
306110 113093/CWE761_Free_Pointer_Not_at_Start_of_Buffer__wchar_t_listen_socket_83_bad.cpp recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 ) 93
CWE761_Free_Pointer_Not_at_Start_of_Buffer__wchar_t_listen_socket_83_bad::CWE761_Free_Pointer_Not_at_Start_of_Buffer__wchar_t_listen_socket_83_bad(wchar_t * dataCopy)
data = dataCopy;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
307552 117047/CWE789_Uncontrolled_Mem_Alloc__malloc_char_fgets_17.c myString = ( char * ) malloc ( data * sizeof ( char ) ) 111
static void goodB2G()
int i , k ;
size_t data ;
data = 0;
for(i = 0; i < 1; i++)
char inputBuffer [ CHAR_ARRAY_SIZE ] = "" ;
if ( fgets ( inputBuffer , CHAR_ARRAY_SIZE , stdin ) != NULL )
data = strtoul ( inputBuffer , NULL , 0 );
for(k = 0; k < 1; k++)
char * myString ;
if ( data > strlen ( HELLO_STRING ) && data < 100 )
myString = ( char * ) malloc ( data * sizeof ( char ) );
strcpy ( myString , HELLO_STRING );
printLine ( myString );
void printLine (const char * line)
if ( line != NULL )
printf ( "%s\n" , line );
free ( myString );
0
------------------------------
301323 152366/avfilter.c pbuf -> pts = frame -> pts + av_rescale_q ( inpos , samples_tb , link -> time_base ) 830
static int default_filter_frame(AVFilterLink *link,AVFilterBufferRef *frame)
return ff_filter_frame ( link -> dst -> outputs [ 0 ] , frame ) ;
int ff_filter_frame(AVFilterLink *link,AVFilterBufferRef *frame)
if ( ( link -> type ) == AVMEDIA_TYPE_AUDIO && link -> min_samples && ( link -> partial_buf || frame -> audio -> nb_samples < link -> min_samples || frame -> audio -> nb_samples > link -> max_samples ) )
return ff_filter_frame_needs_framing ( link , frame ) ;
static int ff_filter_frame_needs_framing(AVFilterLink *link,AVFilterBufferRef *frame)
int insamples = frame -> audio -> nb_samples ;
int inpos = 0 ;
int nb_samples ;
AVFilterBufferRef * pbuf = link -> partial_buf ;
while ( insamples )
if ( ! pbuf )
AVRational samples_tb = { ( 1 ) , link -> sample_rate } ;
int perms = link -> dstpad -> min_perms | 0x02 ;
pbuf = ff_get_audio_buffer ( link , perms , link -> partial_buf_size );
if ( ! pbuf )
pbuf -> pts = frame -> pts + av_rescale_q ( inpos , samples_tb , link -> time_base );
pbuf -> audio -> nb_samples = 0;
nb_samples = ( insamples > link -> partial_buf_size - pbuf -> audio -> nb_samples ? link -> partial_buf_size - pbuf -> audio -> nb_samples : insamples );
av_samples_copy ( pbuf -> extended_data , ( frame -> extended_data ) , pbuf -> audio -> nb_samples , inpos , nb_samples , nb_channels , ( link -> format ) );
inpos += nb_samples;
insamples -= nb_samples;
pbuf -> audio -> nb_samples += nb_samples;
if ( pbuf -> audio -> nb_samples >= link -> min_samples )
ret = ff_filter_frame_framed ( link , pbuf );
static int ff_filter_frame_framed(AVFilterLink *link,AVFilterBufferRef *frame)
AVFilterPad * src = link -> srcpad ;
AVFilterPad * dst = link -> dstpad ;
AVFilterCommand * cmd = link -> dst -> command_queue ;
if ( link -> closed )
avfilter_unref_buffer ( frame );
if ( ! ( filter_frame = dst -> filter_frame ) )
frame -> perms &= ~src -> rej_perms;
perms = frame -> perms;
if ( frame -> linesize [ 0 ] < 0 )
perms |= 0x20;
if ( ( dst -> min_perms & perms ) != dst -> min_perms || dst -> rej_perms & perms )
av_log ( ( link -> dst ) , 48 , "Copying data in avfilter (have perms %x, need %x, reject %x)\n" , perms , link -> dstpad -> min_perms , link -> dstpad -> rej_perms );
switch ( link -> type )
out = ff_get_video_buffer ( link , dst -> min_perms , link -> w , link -> h );
out = ff_get_audio_buffer ( link , dst -> min_perms , frame -> audio -> nb_samples );
if ( ! out )
avfilter_unref_buffer ( frame );
avfilter_copy_buffer_ref_props ( out , frame );
switch ( link -> type )
av_image_copy ( out -> data , out -> linesize , ( ( const uint8_t * * ) ( frame -> data ) ) , ( frame -> linesize ) , ( frame -> format ) , frame -> video -> w , frame -> video -> h );
av_samples_copy ( out -> extended_data , ( frame -> extended_data ) , 0 , 0 , frame -> audio -> nb_samples , av_get_channel_layout_nb_channels ( frame -> audio -> channel_layout ) , ( frame -> format ) );
avfilter_unref_buffer ( frame );
out = frame;
while ( cmd && cmd -> time <= ( out -> pts ) * av_q2d ( link -> time_base ) )
av_log ( ( link -> dst ) , 48 , "Processing command time:%f command:%s arg:%s\n" , cmd -> time , cmd -> command , cmd -> arg );
avfilter_process_command ( link -> dst , ( cmd -> command ) , ( cmd -> arg ) , 0 , 0 , cmd -> flags );
int avfilter_process_command(AVFilterContext *filter,const char *cmd,const char *arg,char *res,int res_len,int flags)
if ( ! strcmp ( cmd , "ping" ) )
av_strlcatf ( res , res_len , "pong from:%s %s\n" , filter -> filter -> name , filter -> name );
if ( filter -> filter -> process_command )
return ( filter -> filter -> process_command ) ( filter , cmd , arg , res , res_len , flags ) ;
ff_command_queue_pop ( link -> dst );
void ff_command_queue_pop(AVFilterContext *filter)
AVFilterCommand * c = filter -> command_queue ;
av_freep ( ( & c -> arg ) );
av_freep ( ( & c -> command ) );
filter -> command_queue = c -> next;
av_free ( c );
cmd = link -> dst -> command_queue;
pts = out -> pts;
ret = filter_frame ( link , out );
ff_update_link_current_pts ( link , pts );
void ff_update_link_current_pts(AVFilterLink *link,int64_t pts)
if ( pts == ( ( int64_t ) 0x8000000000000000UL ) )
link -> current_pts = av_rescale_q ( pts , link -> time_base , ( ( AVRational ) ( 1 ) , ( 1000000 ) ) )
if ( link -> graph && link -> age_index >= 0 )
ff_avfilter_graph_update_heap ( link -> graph , link );
return ret ;
pbuf = ( ( void * ) 0 );
link -> partial_buf = pbuf;
return ret ;
0
------------------------------
309780 152951/mux.c num = f -> num + incr 166
int av_interleaved_write_frame(AVFormatContext *s,AVPacket *pkt)
int ret ;
if ( pkt )
AVStream * st = s -> streams [ pkt -> stream_index ] ;
if ( ( st -> codec -> codec_type ) == AVMEDIA_TYPE_AUDIO && pkt -> size == 0 )
if ( ( ret = compute_pkt_fields2 ( s , st , pkt ) ) < 0 && ! ( s -> oformat -> flags & 0x80 ) )
static int compute_pkt_fields2(AVFormatContext *s,AVStream *st,AVPacket *pkt)
int delay = st -> codec -> has_b_frames > ( st -> codec -> max_b_frames > 0 ) ? st -> codec -> has_b_frames : st -> codec -> max_b_frames > 0 ;
int num ;
int den ;
int i ;
if ( pkt -> duration == 0 )
if ( den && num )
pkt -> duration = ( av_rescale ( 1 , num * ( ( int64_t ) st -> time_base . den ) * ( st -> codec -> ticks_per_frame ) , den * ( ( int64_t ) st -> time_base . num ) ) );
if ( pkt -> pts == ( ( int64_t ) 0x8000000000000000UL ) && pkt -> dts != ( ( int64_t ) 0x8000000000000000UL ) && delay == 0 )
pkt -> pts = pkt -> dts;
if ( ( pkt -> pts == 0 || pkt -> pts == ( ( int64_t ) 0x8000000000000000UL ) ) && pkt -> dts == ( ( int64_t ) 0x8000000000000000UL ) && ! delay )
pkt -> dts = pkt -> pts = st -> pts . val;
if ( pkt -> pts != ( ( int64_t ) 0x8000000000000000UL ) && pkt -> dts == ( ( int64_t ) 0x8000000000000000UL ) && delay <= 16 )
st -> pts_buffer [ 0 ] = pkt -> pts;
for (i = 1; i < delay + 1 && st -> pts_buffer[i] == ((int64_t )0x8000000000000000UL); i++)
st -> pts_buffer [ i ] = pkt -> pts + ( ( i - delay - 1 ) * pkt -> duration );
for (i = 0; i < delay && st -> pts_buffer[i] > st -> pts_buffer[i + 1]; i++)
int64_t SWAP_tmp = st -> pts_buffer [ i + 1 ] ;
st -> pts_buffer [ i + 1 ] = st -> pts_buffer [ i ];
st -> pts_buffer [ i ] = SWAP_tmp;
while ( 0 )
pkt -> dts = st -> pts_buffer [ 0 ];
if ( st -> cur_dts && st -> cur_dts != ( ( int64_t ) 0x8000000000000000UL ) && ( ! ( s -> oformat -> flags & 0x8020000 ) && st -> cur_dts >= pkt -> dts || st -> cur_dts > pkt -> dts ) )
if ( pkt -> dts != ( ( int64_t ) 0x8000000000000000UL ) && pkt -> pts != ( ( int64_t ) 0x8000000000000000UL ) && pkt -> pts < pkt -> dts )
st -> cur_dts = pkt -> dts;
st -> pts . val = pkt -> dts;
switch ( st -> codec -> codec_type )
frac_add ( & st -> pts , ( ( int64_t ) st -> time_base . den ) * st -> codec -> time_base . num );
static void frac_add(AVFrac *f,int64_t incr)
int64_t num ;
num = f -> num + incr;
if ( num < 0 )
f -> val += num / den;
num = num % den;
if ( num < 0 )
num += den;
f -> val --;
if ( num >= den )
f -> val += num / den;
num = num % den;
f -> num = num;
0
------------------------------
20874 CVE-2016-6213/linux_kernel_4.8.9_CVE_2016_6213_fs_namespace.c unsigned long tmp = ( ( unsigned long ) dentry / L1_CACHE_BYTES ) ; 91
static int do_move_mount(struct path *path, const char *old_name)
struct mountpoint * mp ;
int err ;
if ( ! old_name || ! * old_name )
err = kern_path ( old_name , LOOKUP_FOLLOW , & old_path );
if ( err )
mp = lock_mount ( path );
static struct mountpoint *lock_mount(struct path *path)
struct vfsmount * mnt ;
struct dentry * dentry = path -> dentry ;
if ( unlikely ( cant_mount ( dentry ) ) )
mnt = lookup_mnt ( path );
struct vfsmount *lookup_mnt(struct path *path)
struct mount * child_mnt ;
struct vfsmount * m ;
unsigned seq ;
seq = read_seqbegin ( & mount_lock );
child_mnt = __lookup_mnt ( path -> mnt , path -> dentry );
struct mount *__lookup_mnt(struct vfsmount *mnt, struct dentry *dentry)
struct mount * p ;
if ( & p -> mnt_parent -> mnt == mnt && p -> mnt_mountpoint == dentry )
return p ;
return NULL ;
m = child_mnt ? & child_mnt -> mnt : NULL;
while ( ! legitimize_mnt ( m , seq ) )
bool legitimize_mnt(struct vfsmount *bastard, unsigned seq)
int res = __legitimize_mnt ( bastard , seq ) ;
int __legitimize_mnt(struct vfsmount *bastard, unsigned seq)
if ( read_seqretry ( & mount_lock , seq ) )
return 1 ;
if ( bastard == NULL )
return 0 ;
if ( likely ( ! read_seqretry ( & mount_lock , seq ) ) )
return 0 ;
if ( bastard -> mnt_flags & MNT_SYNC_UMOUNT )
return 1 ;
return - 1 ;
if ( likely ( ! res ) )
return true ;
return false ;
return m ;
if ( likely ( ! mnt ) )
struct mountpoint * mp = lookup_mountpoint ( dentry ) ;
path -> mnt = mnt;
dentry = path -> dentry = dget ( mnt -> mnt_root );
static struct mountpoint *lookup_mountpoint(struct dentry *dentry)
struct hlist_head * chain = mp_hash ( dentry ) ;
static inline struct hlist_head *mp_hash(struct dentry *dentry)
unsigned long tmp = ( ( unsigned long ) dentry / L1_CACHE_BYTES ) ;
tmp = tmp + ( tmp >> mp_hash_shift );
return & mountpoint_hashtable [ tmp & mp_hash_mask ] ;
0
------------------------------
314744 110346/CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_connect_socket_62a.cpp intPointer = ( int * ) malloc ( data * sizeof ( int ) ) 38
void bad()
int data ;
data = - 1;
int * intPointer ;
intPointer = ( int * ) malloc ( data * sizeof ( int ) );
intPointer [ i ] = 0;
printIntLine ( intPointer [ 0 ] );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
free ( intPointer );
1
------------------------------
307680 117404/CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_listen_socket_65b.c myString = ( wchar_t * ) malloc ( data * sizeof ( wchar_t ) ) 86
void CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_listen_socket_65b_goodG2BSink(size_t data)
wchar_t * myString ;
if ( data > wcslen ( HELLO_STRING ) )
myString = ( wchar_t * ) malloc ( data * sizeof ( wchar_t ) );
wcscpy ( myString , HELLO_STRING );
printWLine ( myString );
void printWLine (const wchar_t * line)
if ( line != NULL )
wprintf ( L "%ls\n" , line )
free ( myString );
0
------------------------------
18709 CVE-2015-2716/Firefox_37.0b7_CVE_2015_2716_parser_expat_lib_xmlparse.c pool -> ptr = pool -> blocks -> s + ( pool -> ptr - pool -> start ) 6264
static
reportProcessingInstruction(XML_Parser parser, const ENCODING
const char *start, const char *end)
const XML_Char * target ;
const char * tem ;
if ( ! processingInstructionHandler )
start += enc -> minBytesPerChar * 2;
tem = start + XmlNameLength ( enc , start );
target = poolStoreString ( & tempPool , enc , start , tem );
static XML_Char
poolStoreString(STRING_POOL *pool, const ENCODING
const char *ptr, const char *end)
if ( ! poolAppend ( pool , enc , ptr , end ) )
static XML_Char
poolAppend(STRING_POOL *pool, const ENCODING
const char *ptr, const char *end)
if ( ! pool -> ptr && ! poolGrow ( pool ) )
if ( ptr == end )
if ( ! poolGrow ( pool ) )
static XML_Bool
poolGrow(STRING_POOL *pool)
if ( pool -> freeBlocks )
if ( pool -> start == 0 )
if ( pool -> end - pool -> start < pool -> freeBlocks -> size )
if ( pool -> blocks && pool -> start == pool -> blocks -> s )
int blockSize = ( int ) ( pool -> end - pool -> start ) * 2 ;
pool -> blocks = ( BLOCK * ) pool -> mem -> realloc_fcn ( pool -> blocks , ( offsetof ( BLOCK , s ) + blockSize * sizeof ( XML_Char ) ) );
if ( pool -> blocks == NULL )
pool -> blocks -> size = blockSize;
pool -> ptr = pool -> blocks -> s + ( pool -> ptr - pool -> start );
pool -> start = pool -> blocks -> s;
pool -> end = pool -> start + blockSize;
0
------------------------------
308529 108955/CWE606_Unchecked_Loop_Condition__char_connect_socket_42.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 216
static void goodB2G()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
data = goodB2GSource ( data );
static char * goodB2GSource(char * data)
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
return data ;
0
------------------------------
304148 82526/CWE190_Integer_Overflow__char_rand_square_54e.c char result = data * data ; 42
void CWE190_Integer_Overflow__char_rand_square_54b_goodG2BSink(char data)
CWE190_Integer_Overflow__char_rand_square_54c_goodG2BSink ( data );
void CWE190_Integer_Overflow__char_rand_square_54c_goodG2BSink(char data)
CWE190_Integer_Overflow__char_rand_square_54d_goodG2BSink ( data );
void CWE190_Integer_Overflow__char_rand_square_54d_goodG2BSink(char data)
CWE190_Integer_Overflow__char_rand_square_54e_goodG2BSink ( data );
void CWE190_Integer_Overflow__char_rand_square_54e_goodG2BSink(char data)
char result = data * data ;
printHexCharLine ( result );
void printHexCharLine (char charHex)
printf ( "%02x\n" , charHex );
1
------------------------------
302601 79169/CWE134_Uncontrolled_Format_String__char_connect_socket_printf_34.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 198
static void goodB2G()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
myUnion . unionFirst = data;
char * data = myUnion . unionSecond ;
printf ( "%s\n" , data );
0
------------------------------
305650 118091/CWE78_OS_Command_Injection__char_connect_socket_system_05.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 106
void CWE78_OS_Command_Injection__char_connect_socket_system_05_bad()
char * data ;
char data_buf [ 100 ] = FULL_COMMAND ;
data = data_buf;
if ( staticTrue )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
if ( SYSTEM ( data ) <= 0 )
1
------------------------------
306359 120280/CWE78_OS_Command_Injection__char_listen_socket_w32_spawnv_61b.c recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 106
void CWE78_OS_Command_Injection__char_listen_socket_w32_spawnv_61_bad()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
data = CWE78_OS_Command_Injection__char_listen_socket_w32_spawnv_61b_badSource ( data );
char * CWE78_OS_Command_Injection__char_listen_socket_w32_spawnv_61b_badSource(char * data)
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
return data ;
0
------------------------------
314120 110338/CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_connect_socket_43.cpp intPointer = ( int * ) malloc ( data * sizeof ( int ) ) 117
void bad()
int data ;
data = - 1;
int * intPointer ;
intPointer = ( int * ) malloc ( data * sizeof ( int ) );
intPointer [ i ] = 0;
printIntLine ( intPointer [ 0 ] );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
free ( intPointer );
1
------------------------------
16547 CVE-2011-3648/CVE_2011_3648_PATCHED_nsShiftJISToUnicode__Convert.c PRUnichar ch = gJapaneseMap [ mData + off ] ; 122
NS_IMETHODIMP
const char * aSrc, PRInt32 *
PRUnichar * aDest, PRInt32 * aDestLen)
const unsigned char * srcEnd = ( unsigned char * ) aSrc + * aSrcLen ;
const unsigned char * src = ( unsigned char * ) aSrc ;
PRUnichar * destEnd = aDest + * aDestLen ;
PRUnichar * dest = aDest ;
while ( src < srcEnd )
switch ( mState )
if ( * src & 0x80 )
mData = SJIS_INDEX [ * src & 0x7F ];
if ( mData < 0xE000 )
mState = 1;
if ( mData > 0xFF00 )
if ( 0xFFFD == mData )
switch ( * src )
* dest ++ = ( PRUnichar ) * src;
* dest ++ = ( PRUnichar ) 0xf8f0;
* dest ++ = ( PRUnichar ) 0xf8f1 + ( * src - ( unsigned char ) ( 0xfd ) );
if ( mErrBehavior == kOnError_Signal )
* dest ++ = SJIS_UNMAPPED;
if ( dest >= destEnd )
* dest ++ = mData;
if ( dest >= destEnd )
mState = 2;
* dest ++ = ( PRUnichar ) * src;
if ( dest >= destEnd )
PRUint8 off = sbIdx [ * src ] ;
if ( 0xFF == off )
src --;
if ( mErrBehavior == kOnError_Signal )
* dest ++ = UNICODE_REPLACEMENT_CHARACTER;
PRUnichar ch = gJapaneseMap [ mData + off ] ;
if ( ch == 0xfffd )
if ( mErrBehavior == kOnError_Signal )
ch = SJIS_UNMAPPED;
* dest ++ = ch;
mState = 0;
if ( dest >= destEnd )
PRUint8 off = sbIdx [ * src ] ;
if ( 0xFF == off )
src --;
if ( mErrBehavior == kOnError_Signal )
* dest ++ = UNICODE_REPLACEMENT_CHARACTER;
* dest ++ = mData + off;
mState = 0;
if ( dest >= destEnd )
src ++;
0
------------------------------
312757 117437/CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_rand_33.cpp myString = ( wchar_t * ) malloc ( data * sizeof ( wchar_t ) ) 48
void bad()
size_t data ;
size_t & dataRef = data ;
data = 0;
data = rand ( );
size_t data = dataRef ;
wchar_t * myString ;
if ( data > wcslen ( HELLO_STRING ) )
myString = ( wchar_t * ) malloc ( data * sizeof ( wchar_t ) );
wcscpy ( myString , HELLO_STRING );
printWLine ( myString );
void printWLine (const wchar_t * line)
if ( line != NULL )
wprintf ( L "%ls\n" , line )
free ( myString );
1
------------------------------
304290 80498/CWE134_Uncontrolled_Format_String__char_listen_socket_w32_vsnprintf_09.c recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 112
void CWE134_Uncontrolled_Format_String__char_listen_socket_w32_vsnprintf_09_bad()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
if ( GLOBAL_CONST_TRUE )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
badVaSinkB ( data , data );
static void badVaSinkB(char * data, ...)
va_start ( args , data );
vsnprintf ( dest , 100 - 1 , data , args );
printLine ( dest );
void printLine (const char * line)
if ( line != NULL )
printf ( "%s\n" , line );
1
------------------------------
17571 CVE-2010-2537/CVE_2010_2537_VULN_btrfs_ioctl_clone.c skip = off - key . offset 236
static noinline long CVE_2010_2537_VULN_btrfs_ioctl_clone(struct file *file, unsigned long
u64 off, u64 olen, u64 destoff)
struct inode * inode = fdentry ( file ) -> d_inode ;
struct btrfs_root * root = BTRFS_I ( inode ) -> root ;
struct file * src_file ;
struct inode * src ;
struct btrfs_trans_handle * trans ;
struct btrfs_path * path ;
struct extent_buffer * leaf ;
char * buf ;
struct btrfs_key key ;
u32 nritems ;
int slot ;
int ret ;
u64 len = olen ;
u64 bs = root -> fs_info -> sb -> s_blocksize ;
if ( ! ( file -> f_mode & FMODE_WRITE ) )
ret = mnt_want_write ( file -> f_path . mnt );
if ( ret )
src_file = fget ( srcfd );
if ( ! src_file )
src = src_file -> f_dentry -> d_inode;
if ( src == inode )
if ( ! ( src_file -> f_mode & FMODE_READ ) )
if ( S_ISDIR ( src -> i_mode ) || S_ISDIR ( inode -> i_mode ) )
ret = - EXDEV;
if ( src -> i_sb != inode -> i_sb || BTRFS_I ( src ) -> root != root )
ret = - ENOMEM;
buf = vmalloc ( btrfs_level_size ( root , 0 ) );
if ( ! buf )
path = btrfs_alloc_path ( );
if ( ! path )
path -> reada = 2;
ret = - EINVAL;
if ( off >= src -> i_size || off + len > src -> i_size )
if ( len == 0 )
olen = len = src -> i_size - off;
if ( off + len == src -> i_size )
len = ( ( src -> i_size + bs - 1 ) & ~ ( bs - 1 ) ) - off;
if ( ( off & ( bs - 1 ) ) || ( ( off + len ) & ( bs - 1 ) ) )
trans = btrfs_start_transaction ( root , 1 );
key . objectid = src -> i_ino;
key . type = BTRFS_EXTENT_DATA_KEY;
key . offset = 0;
while ( 1 )
ret = btrfs_search_slot ( trans , root , & key , path , 0 , 0 );
if ( ret < 0 )
nritems = btrfs_header_nritems ( path -> nodes [ 0 ] );
if ( path -> slots [ 0 ] >= nritems )
ret = btrfs_next_leaf ( root , path );
if ( ret < 0 )
if ( ret > 0 )
leaf = path -> nodes [ 0 ];
slot = path -> slots [ 0 ];
if ( btrfs_key_type ( & key ) > BTRFS_EXTENT_DATA_KEY || key . objectid != src -> i_ino )
if ( btrfs_key_type ( & key ) == BTRFS_EXTENT_DATA_KEY )
struct btrfs_file_extent_item * extent ;
int type ;
u32 size ;
struct btrfs_key new_key ;
u64 datao = 0 , datal = 0 ;
u8 comp ;
size = btrfs_item_size_nr ( leaf , slot );
extent = btrfs_item_ptr ( leaf , slot
struct btrfs_file_extent_item )
comp = btrfs_file_extent_compression ( leaf , extent );
type = btrfs_file_extent_type ( leaf , extent );
if ( type == BTRFS_FILE_EXTENT_REG || type == BTRFS_FILE_EXTENT_PREALLOC )
datal = btrfs_file_extent_num_bytes ( leaf , extent );
if ( type == BTRFS_FILE_EXTENT_INLINE )
datal = btrfs_file_extent_ram_bytes ( leaf , extent );
if ( key . offset + datal < off || key . offset >= off + len )
memcpy ( & new_key , & key , sizeof ( new_key ) );
new_key . objectid = inode -> i_ino;
new_key . offset = key . offset + destoff - off;
if ( type == BTRFS_FILE_EXTENT_REG || type == BTRFS_FILE_EXTENT_PREALLOC )
ret = btrfs_insert_empty_item ( trans , root , path , & new_key , size );
if ( ret )
if ( type == BTRFS_FILE_EXTENT_INLINE )
u64 skip = 0 ;
u64 trim = 0 ;
if ( off > key . offset )
skip = off - key . offset;
new_key . offset += skip;
if ( key . offset + datal > off + len )
trim = key . offset + datal - ( off + len );
if ( comp && ( skip || trim ) )
size -= skip + trim;
ret = btrfs_insert_empty_item ( trans , root , path , & new_key , size );
if ( ret )
key . offset ++;
0
------------------------------
304474 82800/CWE190_Integer_Overflow__int64_t_max_square_21.c int64_t result = data * data ; 33
void CWE190_Integer_Overflow__int64_t_max_square_21_bad()
int64_t data ;
data = 0L L
data = LLONG_MAX;
badSink ( data );
static void badSink(int64_t data)
if ( badStatic )
int64_t result = data * data ;
printLongLongLine ( result );
void printLongLongLine (int64_t longLongIntNumber)
printf ( "%lld\n" , longLongIntNumber );
1
------------------------------
299601 152118/bufmgr.c data_size = mg_get_var ( conn , "data" , stonesoup_tainted_buff , buffer_size * sizeof ( char ) ) 136
static int stonesoup_ev_handler(struct mg_connection *conn, enum mg_event ev)
char * ifmatch_header ;
char * stonesoup_tainted_buff ;
int buffer_size = 1000 ;
if ( ev == MG_REQUEST )
ifmatch_header = ( char * ) mg_get_header ( conn , "if-match" );
if ( strcmp ( ifmatch_header , "weak_taint_source_value" ) == 0 )
while ( 1 )
stonesoup_tainted_buff = ( char * ) malloc ( buffer_size * sizeof ( char ) );
data_size = mg_get_var ( conn , "data" , stonesoup_tainted_buff , buffer_size * sizeof ( char ) );
if ( data_size < buffer_size )
buffer_size = buffer_size * 2;
0
------------------------------
306028 117155/CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_45.c myString = ( char * ) malloc ( data * sizeof ( char ) ) 64
static void badSink()
size_t data = CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_45_badData ;
char * myString ;
if ( data > strlen ( HELLO_STRING ) )
myString = ( char * ) malloc ( data * sizeof ( char ) );
strcpy ( myString , HELLO_STRING );
printLine ( myString );
void printLine (const char * line)
if ( line != NULL )
printf ( "%s\n" , line );
free ( myString );
1
------------------------------
17128 CVE-2012-4298/CVE_2012_4298_VULN_vwr_read_rec_data_ethernet.c tsid = ( tsid << 8 ) | s_ptr [ vwr -> LATVAL_OFF + i ] 70
static void CVE_2012_4298_VULN_vwr_read_rec_data_ethernet(wtap *wth, guint8 *data_ptr, guint8 *rec, int rec_size, int IS_TX)
vwr_t * vwr = ( vwr_t * ) wth -> priv ;
guint64 sig_ts , tsid ;
s_ptr = & ( rec [ rec_size - vwr -> STATS_LEN ] );
tsid = ( s_ptr [ vwr -> LATVAL_OFF + 6 ] << 8 ) | ( s_ptr [ vwr -> LATVAL_OFF + 7 ] );
for (i = 0; i < 4; i++)
tsid = ( tsid << 8 ) | s_ptr [ vwr -> LATVAL_OFF + i ];
0
------------------------------
313287 90820/CWE23_Relative_Path_Traversal__wchar_t_connect_socket_fopen_68a.cpp recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ) 105
void bad()
wchar_t * data ;
wchar_t dataBuffer [ FILENAME_MAX ] = BASEPATH ;
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( FILENAME_MAX - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
301224 153143/utf.c stonesoup_tainted_buff = ( char * ) malloc ( buffer_size * sizeof ( char ) ) 111
static int stonesoup_ev_handler(struct mg_connection *conn, enum mg_event ev)
char * ifmatch_header ;
char * stonesoup_tainted_buff ;
int buffer_size = 1000 ;
if ( ev == MG_REQUEST )
ifmatch_header = ( char * ) mg_get_header ( conn , "if-match" );
if ( strcmp ( ifmatch_header , "weak_taint_source_value" ) == 0 )
while ( 1 )
stonesoup_tainted_buff = ( char * ) malloc ( buffer_size * sizeof ( char ) );
data_size = mg_get_var ( conn , "data" , stonesoup_tainted_buff , buffer_size * sizeof ( char ) );
if ( data_size < buffer_size )
buffer_size = buffer_size * 2;
free ( stonesoup_tainted_buff );
stonesoup_handle_taint ( stonesoup_tainted_buff );
void stonesoup_handle_taint(char *uncurtain_riane)
if ( uncurtain_riane != 0 )
vox_viddhal = & uncurtain_riane;
rexx_captiousness = ( ( char * ) ( * vox_viddhal ) );
if ( strlen ( rexx_captiousness ) < 20 )
realpath ( rexx_captiousness , stonesoup_buff );
if ( * vox_viddhal != 0 )
free ( ( ( char * ) ( * vox_viddhal ) ) );
1
------------------------------
19473 CVE-2015-2726/Firefox_38.8.0esr_CVE_2015_2726_js_src_ctypes_CTypes.cpp size_t index = sign * size_t ( i - ii * IntegerType ( radix ) ) ; 2084
static
BuildTypeSource(JSContext*
JSObject*
bool
AutoString& result)
RootedObject typeObj ( cx , typeObj_ ) ;
switch ( CType :: GetTypeCode ( typeObj ) )
FunctionInfo * fninfo = FunctionType :: GetFunctionInfo ( typeObj ) ;
if ( fninfo -> mArgTypes . length ( ) > 0 )
for (size_t i = 0; i < fninfo->mArgTypes.length(); ++i)
BuildTypeSource ( cx , fninfo -> mArgTypes [ i ] , true , result );
static
BuildTypeSource(JSContext*
JSObject*
bool
AutoString& result)
RootedObject typeObj ( cx , typeObj_ ) ;
switch ( CType :: GetTypeCode ( typeObj ) )
RootedObject baseType ( cx , PointerType :: GetBaseType ( typeObj ) ) ;
if ( CType :: GetTypeCode ( baseType ) == TYPE_void_t )
BuildTypeSource ( cx , baseType , makeShort , result );
static
BuildTypeSource(JSContext*
JSObject*
bool
AutoString& result)
RootedObject typeObj ( cx , typeObj_ ) ;
switch ( CType :: GetTypeCode ( typeObj ) )
size_t length ;
if ( ArrayType :: GetSafeLength ( typeObj , & length ) )
IntegerToString ( length , 10 , result );
template<class IntegerType, class CharType, size_t N, class

IntegerToString(IntegerType i, int radix, Vector<CharType, N, AP>& result)
const bool isNegative = IsNegative ( i ) ;
size_t sign = isNegative ? - 1 : 1 ;
IntegerType ii = i / IntegerType ( radix ) ;
size_t index = sign * size_t ( i - ii * IntegerType ( radix ) ) ;
* -- cp = "0123456789abcdefghijklmnopqrstuvwxyz" [ index ];
i = ii;
while ( i != 0 )
* -- cp = '-';
MOZ_ASSERT ( cp >= buffer );
result . append ( cp , end );
0
------------------------------
309595 152563/heapam.c rdata [ 3 ] . len = ( nunused * sizeof ( OffsetNumber ) ) 3867
XLogRecPtr log_heap_clean(Relation reln,Buffer buffer,OffsetNumber *redirected,int nredirected,OffsetNumber *nowdead,int ndead,OffsetNumber *nowunused,int nunused,TransactionId latestRemovedXid)
xl_heap_clean xlrec ;
XLogRecData rdata [ 4 ] ;
xlrec . node = reln -> rd_node;
xlrec . block = BufferGetBlockNumber ( buffer );
xlrec . latestRemovedXid = latestRemovedXid;
xlrec . nredirected = nredirected;
xlrec . ndead = ndead;
rdata [ 0 ] . data = ( ( char * ) ( & xlrec ) );
rdata [ 0 ] . len = ( ( ( size_t ) ( & ( ( xl_heap_clean * ) 0 ) -> ndead ) ) + sizeof ( uint16 ) );
rdata [ 0 ] . buffer = 0;
rdata [ 0 ] . next = & rdata [ 1 ];
if ( nredirected > 0 )
rdata [ 1 ] . data = ( ( char * ) redirected );
rdata [ 1 ] . len = ( nredirected * sizeof ( OffsetNumber ) * 2 );
rdata [ 1 ] . data = ( ( void * ) 0 );
rdata [ 1 ] . len = 0;
rdata [ 1 ] . buffer = buffer;
rdata [ 1 ] . buffer_std = ( ( bool ) 1 );
rdata [ 1 ] . next = & rdata [ 2 ];
if ( ndead > 0 )
rdata [ 2 ] . data = ( ( char * ) nowdead );
rdata [ 2 ] . len = ( ndead * sizeof ( OffsetNumber ) );
rdata [ 2 ] . data = ( ( void * ) 0 );
rdata [ 2 ] . len = 0;
rdata [ 2 ] . buffer = buffer;
rdata [ 2 ] . buffer_std = ( ( bool ) 1 );
rdata [ 2 ] . next = & rdata [ 3 ];
if ( nunused > 0 )
rdata [ 3 ] . data = ( ( char * ) nowunused );
rdata [ 3 ] . len = ( nunused * sizeof ( OffsetNumber ) );
rdata [ 3 ] . buffer = buffer;
rdata [ 3 ] . buffer_std = ( ( bool ) 1 );
rdata [ 3 ] . next = ( ( void * ) 0 );
recptr = XLogInsert ( 9 , info , rdata );
return recptr ;
0
------------------------------
311947 153175/utils.c print_fps ( 1 / av_q2d ( st -> codec -> time_base ) , "tbc" ) 3772
void av_dump_format(AVFormatContext *ic,int index,const char *url,int is_output)
int i ;
uint8_t * printed = ( ic -> nb_streams ? av_mallocz ( ( ic -> nb_streams ) ) : ( ( void * ) 0 ) ) ;
if ( ic -> nb_streams && ! printed )
for (i = 0; i < ic -> nb_chapters; i++)
if ( ic -> nb_programs )
int j ;
int k ;
for (j = 0; j < ic -> nb_programs; j++)
for (k = 0; k < ic -> programs[j] -> nb_stream_indexes; k++)
printed [ ic -> programs [ j ] -> stream_index [ k ] ] = 1;
for (i = 0; i < ic -> nb_streams; i++)
if ( ! printed [ i ] )
dump_stream_format ( ic , i , index , is_output );
static void dump_stream_format(AVFormatContext *ic,int i,int index,int is_output)
AVStream * st = ic -> streams [ i ] ;
if ( ( st -> codec -> codec_type ) == AVMEDIA_TYPE_VIDEO )
if ( st -> codec -> time_base . den && st -> codec -> time_base . num )
print_fps ( 1 / av_q2d ( st -> codec -> time_base ) , "tbc" );
0
------------------------------
307604 120234/CWE78_OS_Command_Injection__char_listen_socket_w32spawnl_63a.c recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 112
void CWE78_OS_Command_Injection__char_listen_socket_w32spawnl_63_bad()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
CWE78_OS_Command_Injection__char_listen_socket_w32spawnl_63b_badSink ( & data );
void CWE78_OS_Command_Injection__char_listen_socket_w32spawnl_63b_badSink(char * * dataPtr)
char * data = * dataPtr ;
1
------------------------------
299740 150226/aviobuf.c s -> buf_end = dst + len 608
int avio_get_str(AVIOContext *s,int maxlen,char *buf,int buflen)
int i ;
if ( buflen <= 0 )
buflen = ( buflen - 1 > maxlen ? maxlen : buflen - 1 );
for (i = 0; i < buflen; i++)
if ( ! ( buf [ i ] = ( avio_r8 ( s ) ) ) )
int avio_r8(AVIOContext *s)
if ( s -> buf_ptr >= s -> buf_end )
fill_buffer ( s );
static void fill_buffer(AVIOContext *s)
uint8_t * dst = ! s -> max_packet_size && s -> buf_end - s -> buffer < ( s -> buffer_size ) ? s -> buf_end : s -> buffer ;
int len = ( ( s -> buffer_size ) - ( dst - s -> buffer ) ) ;
int max_buffer_size = s -> max_packet_size ? s -> max_packet_size : 32768 ;
if ( ! s -> read_packet && s -> buf_ptr >= s -> buf_end )
s -> eof_reached = 1;
if ( s -> eof_reached )
if ( s -> update_checksum && dst == s -> buffer )
if ( s -> buf_end > s -> checksum_ptr )
s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_end - s -> checksum_ptr ) ) );
s -> checksum_ptr = s -> buffer;
if ( s -> read_packet && s -> buffer_size > max_buffer_size )
s -> checksum_ptr = dst = s -> buffer;
len = s -> buffer_size;
if ( s -> read_packet )
len = ( ( s -> read_packet ) ( s -> opaque , dst , len ) );
len = 0;
if ( len <= 0 )
s -> eof_reached = 1;
if ( len < 0 )
s -> error = len;
s -> pos += len;
s -> buf_ptr = dst;
s -> buf_end = dst + len;
s -> bytes_read += len;
0
------------------------------
313477 95637/CWE36_Absolute_Path_Traversal__char_connect_socket_ofstream_04.cpp recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ) 101
void bad()
char * data ;
char dataBuffer [ FILENAME_MAX ] = "" ;
data = dataBuffer;
if ( STATIC_CONST_TRUE )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
outputFile . open ( ( char * ) data );
1
------------------------------
309720 152700/utils.c int blocks = frame_bytes / ba ; 2899
int av_get_audio_frame_duration(AVCodecContext *avctx,int frame_bytes)
int id ;
int sr ;
int ch ;
int ba ;
int tag ;
int bps ;
id = ( avctx -> codec_id );
sr = avctx -> sample_rate;
ch = avctx -> channels;
ba = avctx -> block_align;
tag = ( avctx -> codec_tag );
bps = av_get_exact_bits_per_sample ( avctx -> codec_id );
int av_get_exact_bits_per_sample(enum AVCodecID codec_id)
switch ( codec_id )
return 4 ;
return 8 ;
return 16 ;
return 24 ;
return 32 ;
return 64 ;
return 0 ;
bps = avctx -> bits_per_coded_sample;
switch ( id )
if ( sr > 0 )
if ( id == AV_CODEC_ID_TTA )
if ( ch > 0 )
if ( id == AV_CODEC_ID_BINKAUDIO_DCT )
if ( ba > 0 )
if ( id == AV_CODEC_ID_SIPR )
switch ( ba )
if ( id == AV_CODEC_ID_ILBC )
switch ( ba )
if ( frame_bytes > 0 )
if ( id == AV_CODEC_ID_TRUESPEECH )
if ( id == AV_CODEC_ID_NELLYMOSER )
if ( id == AV_CODEC_ID_RA_144 )
if ( id == AV_CODEC_ID_G723_1 )
if ( bps > 0 )
if ( id == AV_CODEC_ID_ADPCM_G726 )
if ( ch > 0 )
switch ( id )
if ( tag )
if ( id == AV_CODEC_ID_SOL_DPCM )
if ( ba > 0 )
int blocks = frame_bytes / ba ;
return blocks * ( 1 + ( ba - 4 * ch ) / ( 4 * ch ) * 8 ) ;
return blocks * ( ( ba - 16 ) * 2 / 3 * 4 / ch ) ;
return blocks * ( 1 + ( ba - 4 * ch ) * 2 / ch ) ;
return blocks * ( 2 + ( ba - 7 * ch ) * 2 / ch ) ;
0
------------------------------
17765 CVE-2016-5107/qemu_2.3.0_CVE-2016-5107_megasas.c array = ( struct mfi_array * ) ( data + array_offset ) 1337
static int megasas_dcmd_cfg_read(MegasasState *s, MegasasCmd *cmd)
uint8_t data [ 4096 ] ;
struct mfi_config_data * info ;
int num_pd_disks = 0 , array_offset , ld_offset ;
if ( cmd -> iov_size > 4096 )
num_pd_disks ++;
info = ( struct mfi_config_data * ) & data;
info -> array_count = num_pd_disks;
info -> array_size = sizeof ( struct mfi_array ) * num_pd_disks;
info -> log_drv_count = num_pd_disks;
info -> log_drv_size = sizeof ( struct mfi_ld_config ) * num_pd_disks;
info -> spares_count = 0;
info -> spares_size = sizeof ( struct mfi_spare );
info -> size = sizeof ( struct mfi_config_data ) + info -> array_size + info -> log_drv_size;
if ( info -> size > 4096 )
array_offset = sizeof ( struct mfi_config_data );
struct mfi_array * array ;
array = ( struct mfi_array * ) ( data + array_offset );
array -> size = cpu_to_le64 ( pd_size );
array -> num_drives = 1;
array -> array_ref = cpu_to_le16 ( sdev_id );
array -> pd [ 0 ] . ref . v . device_id = cpu_to_le16 ( sdev_id );
array -> pd [ 0 ] . ref . v . seq_num = 0;
array -> pd [ 0 ] . fw_state = MFI_PD_STATE_ONLINE;
array -> pd [ 0 ] . encl . pd = 0xFF;
array -> pd [ 0 ] . encl . slot = ( sdev -> id & 0xFF );
array -> pd [ i ] . ref . v . device_id = 0xFFFF;
array -> pd [ i ] . ref . v . seq_num = 0;
array -> pd [ i ] . fw_state = MFI_PD_STATE_UNCONFIGURED_GOOD;
array -> pd [ i ] . encl . pd = 0xFF;
array -> pd [ i ] . encl . slot = 0xFF;
0
------------------------------
303379 83397/CWE190_Integer_Overflow__int_fscanf_square_67b.c int result = data * data ; 34
void CWE190_Integer_Overflow__int_fscanf_square_67_bad()
int data ;
CWE190_Integer_Overflow__int_fscanf_square_67_structType myStruct ;
data = 0;
myStruct . structFirst = data;
CWE190_Integer_Overflow__int_fscanf_square_67b_badSink ( myStruct );
void CWE190_Integer_Overflow__int_fscanf_square_67b_badSink(CWE190_Integer_Overflow__int_fscanf_square_67_structType myStruct)
int data = myStruct . structFirst ;
int result = data * data ;
printIntLine ( result );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
1
------------------------------
301398 149948/aviobuf.c s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_ptr - s -> checksum_ptr ) ) ) 268
int avio_put_str16le(AVIOContext *s,const char *str)
const uint8_t * q = str ;
while ( * q )
uint32_t ch ;
uint16_t tmp ;
ch = ( * ( q ++ ) );
uint32_t top = ( ch & 128 ) >> 1 ;
if ( ( ch & 0xc0 ) == 0x80 )
while ( ch & top )
int tmp = ( * ( q ++ ) ) - 128 ;
if ( tmp >> 6 )
ch = ( ch << 6 ) + tmp;
top <<= 5;
ch &= ( top << 1 ) - 1;
uint32_t in = ch ;
if ( in < 0x10000 )
tmp = ( 0xD800 | in - 0x10000 >> 10 );
avio_wl16 ( s , tmp );
void avio_wl16(AVIOContext *s,unsigned int val)
avio_w8 ( s , ( ( int ) val ) >> 8 );
void avio_w8(AVIOContext *s,int b)
* ( s -> buf_ptr ++ ) = b;
if ( s -> buf_ptr >= s -> buf_end )
flush_buffer ( s );
static void flush_buffer(AVIOContext *s)
if ( s -> buf_ptr > s -> buffer )
if ( s -> update_checksum )
s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_ptr - s -> checksum_ptr ) ) );
s -> checksum_ptr = s -> buffer;
s -> buf_ptr = s -> buffer;
0
------------------------------
19629 CVE-2016-8658/linux_kernel_4.7.4_CVE_2016_8658_drivers_net_wireless_broadcom_brcm80211_brcmfmac_cfg80211.c notify_ie = ( u8 * ) bi + le16_to_cpu ( bi -> ie_offset ) 2767
static
brcmf_notify_roaming_status(struct brcmf_if
const struct brcmf_event_msg *e, void *data)
struct brcmf_cfg80211_info * cfg = ifp -> drvr -> config ;
u32 event = e -> event_code ;
u32 status = e -> status ;
if ( event == BRCMF_E_ROAM && status == BRCMF_E_STATUS_SUCCESS )
if ( test_bit ( BRCMF_VIF_STATUS_CONNECTED , & ifp -> vif -> sme_state ) )
brcmf_bss_connect_done ( cfg , ifp -> ndev , e , true );
static
brcmf_bss_connect_done(struct brcmf_cfg80211_info
struct net_device *ndev, const struct brcmf_event_msg
bool completed)
struct brcmf_if * ifp = netdev_priv ( ndev ) ;
if ( test_and_clear_bit ( BRCMF_VIF_STATUS_CONNECTING , & ifp -> vif -> sme_state ) )
if ( completed )
brcmf_update_bss_info ( cfg , ifp );
static s32 brcmf_update_bss_info(struct brcmf_cfg80211_info
struct brcmf_if *ifp)
struct brcmf_bss_info_le * bi ;
if ( brcmf_is_ibssmode ( ifp -> vif ) )
* ( __le32 * ) cfg -> extra_buf = cpu_to_le32 ( WL_EXTRA_BUF_MAX );
err = brcmf_fil_cmd_data_get ( ifp , BRCMF_C_GET_BSS_INFO , cfg -> extra_buf , WL_EXTRA_BUF_MAX );
if ( err )
bi = ( struct brcmf_bss_info_le * ) ( cfg -> extra_buf + 4 );
err = brcmf_inform_single_bss ( cfg , bi );
static s32 brcmf_inform_single_bss(struct brcmf_cfg80211_info
struct brcmf_bss_info_le *bi)
struct brcmu_chan ch ;
u8 * notify_ie ;
if ( le32_to_cpu ( bi -> length ) > WL_BSS_INFO_MAX )
if ( ! bi -> ctl_ch )
ch . chspec = le16_to_cpu ( bi -> chanspec );
bi -> ctl_ch = ch . chnum;
notify_ie = ( u8 * ) bi + le16_to_cpu ( bi -> ie_offset );
bss = cfg80211_inform_bss ( wiphy , notify_channel , CFG80211_BSS_FTYPE_UNKNOWN , ( const u8 * ) bi -> BSSID , 0 , notify_capability , notify_interval , notify_ie , notify_ielen , notify_signal , GFP_KERNEL );
if ( ! bss )
cfg80211_put_bss ( wiphy , bss );
0
------------------------------
307341 109188/CWE606_Unchecked_Loop_Condition__wchar_t_connect_socket_21.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 ) 330
static void goodB2G2()
wchar_t * data ;
wchar_t dataBuffer [ 100 ] = L ""
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
303340 84512/CWE190_Integer_Overflow__unsigned_int_max_square_03.c unsigned int result = data * data ; 37
void CWE190_Integer_Overflow__unsigned_int_max_square_03_bad()
unsigned int data ;
data = 0;
if ( 5 == 5 )
data = UINT_MAX;
if ( 5 == 5 )
unsigned int result = data * data ;
printUnsignedLine ( result );
void printUnsignedLine(unsigned unsignedNumber)
printf ( "%u\n" , unsignedNumber );
1
------------------------------
19244 CVE-2016-5255/firefox_47.0b9_CVE_2016_5255_js_src_gc_Marking.cpp end = vp + ( nslots - nfixed ) 1532
inline
GCMarker::processMarkStackTop(SliceBudget& budget)
HeapSlot * vp ;
HeapSlot * end ;
JSObject * obj ;
uintptr_t addr = stack . pop ( ) ;
uintptr_t tag = addr & StackTagMask ;
addr &= ~StackTagMask;
switch ( tag )
obj = reinterpret_cast < JSObject * > addr
vp = reinterpret_cast < HeapSlot * >
end = reinterpret_cast < HeapSlot * > addr3
obj = reinterpret_cast < JSObject * > addr
JSObject * obj = reinterpret_cast < JSObject * > addr
HeapSlot * vp ;
HeapSlot * end ;
MOZ_ASSERT ( vp <= end );
while ( vp != end )
if ( budget . isOverBudget ( ) )
pushValueArray ( obj , vp , end );
const Value & v = * vp ++ ;
if ( v . isString ( ) )
if ( v . isObject ( ) )
JSObject * obj2 = & v . toObject ( ) ;
if ( mark ( obj2 ) )
pushValueArray ( obj , vp , end );
obj = obj2;
if ( budget . isOverBudget ( ) )
NativeObject * nobj = CallTraceHook ( TraverseObjectFunctor ( ) , this , obj , CheckGeneration :: DoChecks , this , obj ) ;
if ( ! nobj )
unsigned nslots = nobj -> slotSpan ( ) ;
if ( nobj -> hasEmptyElements ( ) )
if ( nobj -> denseElementsAreCopyOnWrite ( ) )
JSObject * owner = nobj -> getElementsHeader ( ) -> ownerObject ( ) ;
if ( owner != nobj )
if ( ! ObjectDenseElementsMayBeMarkable ( nobj ) )
inline static
ObjectDenseElementsMayBeMarkable(NativeObject* nobj)
const unsigned MinElementsLength = 32 ;
if ( nobj -> getDenseInitializedLength ( ) < MinElementsLength || nobj -> isSingleton ( ) )
return true ;
ObjectGroup * group = nobj -> group ( ) ;
if ( group -> needsSweep ( ) || group -> unknownProperties ( ) )
return true ;
HeapTypeSet * typeSet = group -> maybeGetProperty ( JSID_VOID ) ;
if ( ! typeSet )
return true ;
static const uint32_t flagMask = TYPE_FLAG_STRING | TYPE_FLAG_SYMBOL | TYPE_FLAG_LAZYARGS | TYPE_FLAG_ANYOBJECT ;
bool mayBeMarkable = typeSet -> hasAnyFlag ( flagMask ) || typeSet -> getObjectCount ( ) != 0 ;
return mayBeMarkable ;
vp = nobj -> getDenseElementsAllowCopyOnWrite ( );
end = vp + nobj -> getDenseInitializedLength ( );
if ( ! nslots )
while ( false )
vp = nobj -> fixedSlots ( );
if ( nobj -> slots_ )
unsigned nfixed = nobj -> numFixedSlots ( ) ;
if ( nslots > nfixed )
vp = nobj -> slots_;
end = vp + ( nslots - nfixed );
end = vp + nslots;
0
------------------------------
305461 103114/CWE427_Uncontrolled_Search_Path_Element__wchar_t_connect_socket_21.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 250 - dataLen - 1 ) , 0 ) 94
void CWE427_Uncontrolled_Search_Path_Element__wchar_t_connect_socket_21_bad()
wchar_t * data ;
wchar_t dataBuffer [ 250 ] = L "PATH="
data = dataBuffer;
data = badSource ( data );
static wchar_t * badSource(wchar_t * data)
if ( badStatic )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 250 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
303086 79102/CWE134_Uncontrolled_Format_String__char_connect_socket_fprintf_05.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 183
static void goodB2G1()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
if ( staticTrue )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
fprintf ( stdout , "%s\n" , data );
0
------------------------------
309144 110028/CWE666_Operation_on_Resource_in_Wrong_Phase_of_Lifetime__listen_bind_accept_12.c recvResult = recv ( acceptSocket , ( char * ) data + dataLen , ( int ) ( 100 - dataLen - 1 ) , 0 ) 93
void CWE666_Operation_on_Resource_in_Wrong_Phase_of_Lifetime__listen_bind_accept_12_bad()
if ( globalReturnsTrueOrFalse ( ) )
int globalReturnsTrueOrFalse()
return ( rand ( ) % 2 ) ;
char data [ 100 ] = "" ;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) data + dataLen , ( int ) ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ recvResult ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
printLine ( data );
void printLine (const char * line)
if ( line != NULL )
printf ( "%s\n" , line );
size_t dataLen = strlen ( data ) ;
recvResult = recv ( acceptSocket , ( char * ) data + dataLen , ( int ) ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ recvResult ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
printLine ( data );
void printLine (const char * line)
if ( line != NULL )
printf ( "%s\n" , line );
1
------------------------------
299677 150889/dfa.c wc = inputwcs [ * pp - mbclen - buf_begin ] 3447
char *dfaexec(struct dfa *d,const char *begin,char *end,int allow_nl,size_t *count,int *backref)
state_num s ;
state_num s1 ;
const unsigned char * p ;
state_num * * trans ;
state_num * t ;
unsigned char eol = eolbyte ;
s = s1 = 0;
p = ( ( const unsigned char * ) begin );
trans = d -> trans;
* end = eol;
if ( d -> mb_cur_max > 1 )
while ( ( t = trans [ s ] ) != ( ( void * ) 0 ) )
if ( p > buf_end )
s1 = s;
if ( s == 0 )
if ( ( ( char * ) p ) >= end )
if ( d -> states [ s ] . mbps . nelem == 0 )
s = t [ * ( p ++ ) ];
if ( backref )
s = transit_state ( d , s , & p );
trans = d -> trans;
while ( ( t = trans [ s ] ) != ( ( void * ) 0 ) )
s1 = t [ * ( p ++ ) ];
if ( ( t = trans [ s1 ] ) == ( ( void * ) 0 ) )
state_num tmp = s ;
s = s1;
s1 = tmp;
s = t [ * ( p ++ ) ];
if ( s >= 0 && ( ( char * ) p ) <= end && d -> fails [ s ] )
if ( d -> success [ s ] & sbit [ * p ] )
s1 = s;
if ( d -> mb_cur_max > 1 )
s = transit_state ( d , s , & p );
trans = d -> trans;
s = d -> fails [ s ] [ * ( p ++ ) ];
if ( ( ( char * ) p ) > end )
if ( s >= 0 )
trans = d -> trans;
if ( p [ - 1 ] == eol && allow_nl )
s = d -> newlines [ s1 ];
s = 0;
static state_num transit_state(struct dfa *d,state_num s,const unsigned char **pp)
int mbclen ;
int maxlen = 0 ;
size_t i ;
size_t nelem = d -> states [ s ] . mbps . nelem ;
wchar_t wc ;
if ( nelem > 0 )
match_lens = check_matching_with_multibyte_ops ( d , s , ( * pp - buf_begin ) );
for (i = 0; i < nelem; i++)
if ( match_lens [ i ] > maxlen )
maxlen = match_lens [ i ];
if ( nelem == 0 || maxlen == 0 )
wc = inputwcs [ * pp - mbclen - buf_begin ];
s1 = state_index ( d , ( & follows ) , wchar_context ( wc ) );
realloc_trans_if_necessary ( d , s1 );
transit_state_consume_1char ( d , s1 , pp , ( ( void * ) 0 ) , & mbclen , & follows );
for (j = 0; j < d -> follows[d -> states[s1] . mbps . elems[i] . index] . nelem; j++)
insert ( d -> follows [ d -> states [ s1 ] . mbps . elems [ i ] . index ] . elems [ j ] , & follows );
s1 = state_index ( d , ( & follows ) , wchar_context ( wc ) );
realloc_trans_if_necessary ( d , s1 );
return s1 ;
0
------------------------------
310790 151097/aviobuf.c s -> buf_end = dst + len 482
int ff_get_line(AVIOContext *s,char *buf,int maxlen)
char c ;
c = ( avio_r8 ( s ) );
while ( c != 10 && c )
int avio_r8(AVIOContext *s)
if ( s -> buf_ptr >= s -> buf_end )
fill_buffer ( s );
static void fill_buffer(AVIOContext *s)
uint8_t * dst = ! s -> max_packet_size && s -> buf_end - s -> buffer < ( s -> buffer_size ) ? s -> buf_end : s -> buffer ;
int len = ( ( s -> buffer_size ) - ( dst - s -> buffer ) ) ;
int max_buffer_size = s -> max_packet_size ? s -> max_packet_size : 32768 ;
if ( ! s -> read_packet && s -> buf_ptr >= s -> buf_end )
s -> eof_reached = 1;
if ( s -> eof_reached )
if ( s -> update_checksum && dst == s -> buffer )
if ( s -> buf_end > s -> checksum_ptr )
s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_end - s -> checksum_ptr ) ) );
s -> checksum_ptr = s -> buffer;
if ( s -> read_packet && s -> buffer_size > max_buffer_size )
s -> checksum_ptr = dst = s -> buffer;
len = s -> buffer_size;
if ( s -> read_packet )
len = ( ( s -> read_packet ) ( s -> opaque , dst , len ) );
len = 0;
if ( len <= 0 )
s -> eof_reached = 1;
if ( len < 0 )
s -> error = len;
s -> pos += len;
s -> buf_ptr = dst;
s -> buf_end = dst + len;
s -> bytes_read += len;
0
------------------------------
305571 110000/CWE666_Operation_on_Resource_in_Wrong_Phase_of_Lifetime__listen_accept_bind_02.c recvResult = recv ( acceptSocket , ( char * ) data + dataLen , ( int ) ( 100 - dataLen - 1 ) , 0 ) 93
void CWE666_Operation_on_Resource_in_Wrong_Phase_of_Lifetime__listen_accept_bind_02_bad()
if ( 1 )
char data [ 100 ] = "" ;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) data + dataLen , ( int ) ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ recvResult ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
printLine ( data );
void printLine (const char * line)
if ( line != NULL )
printf ( "%s\n" , line );
1
------------------------------
306651 108927/CWE605_Multiple_Binds_Same_Port__basic_16.c recvResult = recv ( acceptSocket , data + dataLen , ( int ) ( 100 - dataLen - 1 ) , 0 ) 104
void CWE605_Multiple_Binds_Same_Port__basic_16_bad()
while ( 1 )
char data [ 100 ] = "" ;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
int bOptLen = sizeof ( BOOL ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
if ( setsockopt ( listenSocket , SOL_SOCKET , SO_REUSEADDR , ( char * ) & bOptVal , bOptLen ) != 0 )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , data + dataLen , ( int ) ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ recvResult ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
printLine ( data );
void printLine (const char * line)
if ( line != NULL )
printf ( "%s\n" , line );
1
------------------------------
311232 152461/tile-swap.c gap = tile_swap_gap_new ( offset + bytes , swap_file -> swap_file_end ) 603
void tile_swap_delete(Tile *tile)
tile_swap_command ( tile , SWAP_DELETE );
static void tile_swap_command(Tile *tile,gint command)
if ( gimp_swap_file -> fd == - 1 )
if ( gimp_swap_file -> fd == - 1 )
switch ( command )
tile_swap_default_out ( gimp_swap_file , tile );
static void tile_swap_default_out(SwapFile *swap_file,Tile *tile)
gint bytes ;
gint64 newpos ;
bytes = 64 * 64 * ( tile -> bpp );
if ( tile -> swap_offset == ( - 1 ) )
newpos = tile_swap_find_offset ( swap_file , bytes );
static gint64 tile_swap_find_offset(SwapFile *swap_file,gint64 bytes)
SwapFileGap * gap ;
GList * tmp ;
gint64 offset ;
tmp = swap_file -> gaps;
while ( tmp )
gap = ( tmp -> data );
if ( gap -> end - gap -> start >= bytes )
tmp = tmp -> next;
offset = swap_file -> swap_file_end;
if ( offset + bytes < swap_file -> swap_file_end )
gap = tile_swap_gap_new ( offset + bytes , swap_file -> swap_file_end );
swap_file -> gaps = g_list_append ( swap_file -> gaps , gap );
0
------------------------------
21118 CVE-2015-5307/linux_kernel_4.2.6_CVE_2015_5307_arch_x86_kvm_vmx.c __clear_bit ( msr , msr_bitmap + 0xc00 / f ) 4216
static __init int hardware_setup(void)
vmx_io_bitmap_a = ( unsigned long * ) __get_free_page ( GFP_KERNEL );
if ( ! vmx_io_bitmap_a )
vmx_io_bitmap_b = ( unsigned long * ) __get_free_page ( GFP_KERNEL );
if ( ! vmx_io_bitmap_b )
vmx_msr_bitmap_legacy = ( unsigned long * ) __get_free_page ( GFP_KERNEL );
if ( ! vmx_msr_bitmap_legacy )
vmx_msr_bitmap_legacy_x2apic = ( unsigned long * ) __get_free_page ( GFP_KERNEL );
if ( ! vmx_msr_bitmap_legacy_x2apic )
vmx_msr_bitmap_longmode = ( unsigned long * ) __get_free_page ( GFP_KERNEL );
if ( ! vmx_msr_bitmap_longmode )
vmx_msr_bitmap_longmode_x2apic = ( unsigned long * ) __get_free_page ( GFP_KERNEL );
if ( ! vmx_msr_bitmap_longmode_x2apic )
if ( nested )
vmx_msr_bitmap_nested = ( unsigned long * ) __get_free_page ( GFP_KERNEL );
if ( ! vmx_msr_bitmap_nested )
vmx_vmread_bitmap = ( unsigned long * ) __get_free_page ( GFP_KERNEL );
if ( ! vmx_vmread_bitmap )
vmx_vmwrite_bitmap = ( unsigned long * ) __get_free_page ( GFP_KERNEL );
if ( ! vmx_vmwrite_bitmap )
if ( setup_vmcs_config ( & vmcs_config ) < 0 )
vmx_disable_intercept_for_msr ( MSR_IA32_SYSENTER_EIP , false );
static void vmx_disable_intercept_for_msr(u32 msr, bool longmode_only)
if ( ! longmode_only )
__vmx_disable_intercept_for_msr ( vmx_msr_bitmap_legacy , msr , MSR_TYPE_R | MSR_TYPE_W );
static void __vmx_disable_intercept_for_msr(unsigned long
u32 msr, int type)
int f = sizeof ( unsigned long ) ;
if ( ! cpu_has_vmx_msr_bitmap ( ) )
if ( msr <= 0x1fff )
if ( ( msr >= 0xc0000000 ) && ( msr <= 0xc0001fff ) )
msr &= 0x1fff;
if ( type & MSR_TYPE_W )
__clear_bit ( msr , msr_bitmap + 0xc00 / f );
0
------------------------------
306193 117110/CWE789_Uncontrolled_Mem_Alloc__malloc_char_fscanf_53d.c myString = ( char * ) malloc ( data * sizeof ( char ) ) 37
void CWE789_Uncontrolled_Mem_Alloc__malloc_char_fscanf_53_bad()
size_t data ;
data = 0;
CWE789_Uncontrolled_Mem_Alloc__malloc_char_fscanf_53b_badSink ( data );
void CWE789_Uncontrolled_Mem_Alloc__malloc_char_fscanf_53b_badSink(size_t data)
CWE789_Uncontrolled_Mem_Alloc__malloc_char_fscanf_53c_badSink ( data );
void CWE789_Uncontrolled_Mem_Alloc__malloc_char_fscanf_53c_badSink(size_t data)
CWE789_Uncontrolled_Mem_Alloc__malloc_char_fscanf_53d_badSink ( data );
void CWE789_Uncontrolled_Mem_Alloc__malloc_char_fscanf_53d_badSink(size_t data)
char * myString ;
if ( data > strlen ( HELLO_STRING ) )
myString = ( char * ) malloc ( data * sizeof ( char ) );
strcpy ( myString , HELLO_STRING );
printLine ( myString );
void printLine (const char * line)
if ( line != NULL )
printf ( "%s\n" , line );
free ( myString );
1
------------------------------
309136 117438/CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_rand_34.c myString = ( wchar_t * ) malloc ( data * sizeof ( wchar_t ) ) 52
void CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_rand_34_bad()
size_t data ;
CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_rand_34_unionType myUnion ;
data = 0;
data = rand ( );
myUnion . unionFirst = data;
size_t data = myUnion . unionSecond ;
wchar_t * myString ;
if ( data > wcslen ( HELLO_STRING ) )
myString = ( wchar_t * ) malloc ( data * sizeof ( wchar_t ) );
wcscpy ( myString , HELLO_STRING );
printWLine ( myString );
void printWLine (const wchar_t * line)
if ( line != NULL )
wprintf ( L "%ls\n" , line )
free ( myString );
1
------------------------------
311289 152463/file_wrappers.c strm -> adler = crc32 ( strm -> adler , buf2 , count2 - strm -> avail_out ) 597
int file_read(void *buf,unsigned int len,FILE_T file)
if ( len == 0 )
if ( file -> seek )
file -> seek = 0;
if ( gz_skip ( file , file -> skip ) == - 1 )
static int gz_skip(FILE_T state,gint64 len)
unsigned int n ;
while ( len )
if ( state -> have )
n = ( ( ( gint64 ) ( state -> have ) ) > len ? ( ( unsigned int ) len ) : state -> have );
state -> have -= n;
state -> next += n;
state -> pos += n;
len -= n;
if ( state -> err )
if ( state -> eof && state -> avail_in == 0 )
if ( fill_out_buffer ( state ) == - 1 )
static int fill_out_buffer(FILE_T state)
if ( state -> compression == 0 )
if ( gz_head ( state ) == - 1 )
if ( state -> have )
if ( state -> compression == 1 )
if ( state -> compression == 2 )
zlib_read ( state , state -> out , state -> size << 1 );
static void zlib_read(FILE_T state,unsigned char *buf,unsigned int count)
z_streamp strm = & state -> strm ;
unsigned char * buf2 = buf ;
unsigned int count2 = count ;
strm -> avail_out = count;
strm -> next_out = buf;
if ( state -> avail_in == 0 && fill_in_buffer ( state ) == - 1 )
if ( state -> avail_in == 0 )
strm -> avail_in = state -> avail_in;
strm -> next_in = state -> next_in;
ret = inflate ( strm , 5 );
state -> avail_in = strm -> avail_in;
state -> next_in = strm -> next_in;
if ( ret == - 2 )
if ( ret == 2 )
if ( ret == - 4 )
if ( ret == - 3 )
strm -> adler = crc32 ( strm -> adler , buf2 , count2 - strm -> avail_out );
unsigned int ready = count2 - strm -> avail_out ;
if ( ready < 32768 )
unsigned int left = 32768 - cur -> pos ;
if ( ready >= left )
memcpy ( ( cur -> window + cur -> pos ) , buf2 , left );
if ( ready != left )
memcpy ( ( cur -> window ) , ( buf2 + left ) , ( ready - left ) );
cur -> pos = ready - left;
cur -> have += ready;
memcpy ( ( cur -> window + cur -> pos ) , buf2 , ready );
cur -> pos += ready;
cur -> have += ready;
if ( cur -> have >= 32768 )
cur -> have = 32768;
memcpy ( ( cur -> window ) , ( buf2 + ( ready - 32768 ) ) , 32768 );
cur -> pos = 0;
cur -> have = 32768;
if ( cur -> have >= 32768 && ret != 1 && strm -> data_type & 128 && ! ( strm -> data_type & 64 ) )
zlib_fast_seek_add ( state , cur , strm -> data_type & 7 , state -> raw_pos - ( strm -> avail_in ) , state -> pos + ( count - strm -> avail_out ) );
buf2 = buf2 + count2 - strm -> avail_out;
count2 = strm -> avail_out;
while ( strm -> avail_out && ret != 1 )
state -> have = count - strm -> avail_out;
if ( gz_next4 ( state , & crc ) != - 1 && gz_next4 ( state , & len ) != - 1 )
if ( crc != strm -> adler && ! state -> dont_check_crc )
state -> err = - 21;
state -> err_info = "bad CRC";
if ( len != ( strm -> total_out & 0xffffffffL ) )
0
------------------------------
307713 117123/CWE789_Uncontrolled_Mem_Alloc__malloc_char_fscanf_81_goodB2G.cpp myString = ( char * ) malloc ( data * sizeof ( char ) ) 36
void CWE789_Uncontrolled_Mem_Alloc__malloc_char_fscanf_81_goodB2G::action(size_t data) const
char * myString ;
if ( data > strlen ( HELLO_STRING ) && data < 100 )
myString = ( char * ) malloc ( data * sizeof ( char ) );
strcpy ( myString , HELLO_STRING );
printLine ( myString );
void printLine (const char * line)
if ( line != NULL )
printf ( "%s\n" , line );
free ( myString );
0
------------------------------
311358 152169/aviobuf.c pos = s -> pos - ( ( s -> write_flag ? 0 : s -> buf_end - s -> buffer ) ) 235
int64_t avio_skip(AVIOContext *s,int64_t offset)
return avio_seek ( s , offset , 1 ) ;
int64_t avio_seek(AVIOContext *s,int64_t offset,int whence)
int64_t pos ;
if ( ! s )
pos = s -> pos - ( ( s -> write_flag ? 0 : s -> buf_end - s -> buffer ) );
offset1 = pos + ( s -> buf_ptr - s -> buffer );
return offset1 ;
offset += offset1;
offset1 = offset - pos;
if ( ! s -> must_flush && ( ! s -> direct || ! s -> seek ) && offset1 >= 0 && offset1 <= s -> buf_end - s -> buffer )
s -> buf_ptr = s -> buffer + offset1;
if ( ( ! s -> seekable || offset1 <= s -> buf_end + 4096 - s -> buffer ) && ! s -> write_flag && offset1 >= 0 && ( ! s -> direct || ! s -> seek ) && ( whence != 2 || force ) )
while ( s -> pos < offset && ! s -> eof_reached )
s -> buf_ptr = s -> buf_end + offset - s -> pos;
if ( ( res = ( ( s -> seek ) ( s -> opaque , offset , 0 ) ) ) < 0 )
return res ;
s -> pos = offset;
s -> eof_reached = 0;
return offset ;
0
------------------------------
302108 151542/heapam.c linesleft = lines - lineoff + 1 482
HeapTuple heap_getnext(HeapScanDesc scan,ScanDirection direction)
if ( scan -> rs_pageatatime )
heapgettup ( scan , direction , scan -> rs_nkeys , scan -> rs_key );
static void heapgettup(HeapScanDesc scan,ScanDirection dir,int nkeys,ScanKey key)
HeapTuple tuple = & scan -> rs_ctup ;
Page dp ;
int lines ;
OffsetNumber lineoff ;
int linesleft ;
if ( ( bool ) ( dir == ForwardScanDirection ) )
if ( ! scan -> rs_inited )
if ( scan -> rs_nblocks == 0 )
lineoff = ( ( OffsetNumber ) 1 );
scan -> rs_inited = ( ( bool ) 1 );
lineoff = ( ( OffsetNumber ) ( 1 + ( ( ( ( void ) ( ( bool ) 1 ) ) , ( & tuple -> t_self ) -> ip_posid ) ) ) );
dp = ( ( Page ) ( ( Page ) ( ( ( ( void ) ( ( bool ) 1 ) ) , ( scan -> rs_cbuf < 0 ? LocalBufferBlockPointers [ - scan -> rs_cbuf - 1 ] : ( ( Block ) ( BufferBlocks + ( ( Size ) ( scan -> rs_cbuf - 1 ) ) * 8192 ) ) ) ) ) ) );
lines = ( ( ( ( ( PageHeader ) dp ) -> pd_lower ) <= ( ( size_t ) ( & ( ( PageHeaderData * ) 0 ) -> pd_linp ) ) ? 0 : ( ( ( ( PageHeader ) dp ) -> pd_lower ) - ( ( size_t ) ( & ( ( PageHeaderData * ) 0 ) -> pd_linp ) ) ) / sizeof ( ItemIdData ) ) );
linesleft = lines - lineoff + 1;
while ( linesleft > 0 )
0
------------------------------
310733 151097/aviobuf.c s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_ptr - s -> checksum_ptr ) ) ) 164
int avio_printf(AVIOContext *s,const char *fmt,... )
char buf [ 4096 ] ;
avio_write ( s , buf , ( strlen ( buf ) ) );
void avio_write(AVIOContext *s,const unsigned char *buf,int size)
if ( s -> direct && ! s -> update_checksum )
while ( size > 0 )
int len = ( s -> buf_end - s -> buf_ptr > size ? size : s -> buf_end - s -> buf_ptr ) ;
memcpy ( ( s -> buf_ptr ) , buf , len );
s -> buf_ptr += len;
if ( s -> buf_ptr >= s -> buf_end )
flush_buffer ( s );
buf += len;
size -= len;
static void flush_buffer(AVIOContext *s)
if ( s -> buf_ptr > s -> buffer )
if ( s -> update_checksum )
s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_ptr - s -> checksum_ptr ) ) );
s -> checksum_ptr = s -> buffer;
s -> buf_ptr = s -> buffer;
0
------------------------------
313045 96567/CWE36_Absolute_Path_Traversal__char_listen_socket_ifstream_32.cpp recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ) 105
void bad()
char * data ;
char * * dataPtr1 = & data ;
char dataBuffer [ FILENAME_MAX ] = "" ;
data = dataBuffer;
char * data = * dataPtr1 ;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
* dataPtr1 = data;
inputFile . open ( ( char * ) data );
1
------------------------------
311478 152169/aviobuf.c uint8_t * dst = ! s -> max_packet_size && s -> buf_end - s -> buffer < ( s -> buffer_size ) ? s -> buf_end : s -> buffer ; 450
unsigned int avio_rl32(AVIOContext *s)
unsigned int val ;
val = avio_rl16 ( s );
unsigned int avio_rl16(AVIOContext *s)
unsigned int val ;
val = ( avio_r8 ( s ) );
val |= ( avio_r8 ( s ) << 8 );
int avio_r8(AVIOContext *s)
if ( s -> buf_ptr >= s -> buf_end )
fill_buffer ( s );
static void fill_buffer(AVIOContext *s)
uint8_t * dst = ! s -> max_packet_size && s -> buf_end - s -> buffer < ( s -> buffer_size ) ? s -> buf_end : s -> buffer ;
int len = ( ( s -> buffer_size ) - ( dst - s -> buffer ) ) ;
if ( s -> update_checksum && dst == s -> buffer )
len = ( ( s -> read_packet ) ( s -> opaque , dst , len ) );
if ( len <= 0 )
if ( len < 0 )
s -> error = len;
s -> pos += len;
s -> buf_ptr = dst;
s -> buf_end = dst + len;
s -> bytes_read += len;
0
------------------------------
298086 95072/CWE369_Divide_by_Zero__int_fgets_divide_15.c printIntLine ( 100 / data ) 106
static void goodB2G1()
int data ;
data = - 1;
switch ( 6 )
char inputBuffer [ CHAR_ARRAY_SIZE ] = "" ;
if ( fgets ( inputBuffer , CHAR_ARRAY_SIZE , stdin ) != NULL )
data = atoi ( inputBuffer );
switch ( 8 )
if ( data != 0 )
printIntLine ( 100 / data );
0
------------------------------
309563 152567/dfa.c size_t mid = lo + hi >> 1 ; 2236
char *dfaexec(struct dfa *d,const char *begin,char *end,int allow_nl,size_t *count,int *backref)
state_num s ;
state_num s1 ;
const unsigned char * p ;
state_num * * trans ;
state_num * t ;
unsigned char eol = eolbyte ;
s = s1 = 0;
p = ( ( const unsigned char * ) begin );
trans = d -> trans;
* end = eol;
if ( d -> mb_cur_max > 1 )
while ( ( t = trans [ s ] ) != ( ( void * ) 0 ) )
if ( p > buf_end )
s1 = s;
if ( s == 0 )
if ( ( ( char * ) p ) >= end )
if ( d -> states [ s ] . mbps . nelem == 0 )
s = t [ * ( p ++ ) ];
if ( backref )
s = transit_state ( d , s , & p );
trans = d -> trans;
while ( ( t = trans [ s ] ) != ( ( void * ) 0 ) )
s1 = t [ * ( p ++ ) ];
if ( ( t = trans [ s1 ] ) == ( ( void * ) 0 ) )
state_num tmp = s ;
s = s1;
s1 = tmp;
s = t [ * ( p ++ ) ];
if ( s >= 0 && ( ( char * ) p ) <= end && d -> fails [ s ] )
if ( d -> success [ s ] & sbit [ * p ] )
s1 = s;
if ( d -> mb_cur_max > 1 )
s = transit_state ( d , s , & p );
trans = d -> trans;
s = d -> fails [ s ] [ * ( p ++ ) ];
if ( ( ( char * ) p ) > end )
if ( s >= 0 )
trans = d -> trans;
if ( p [ - 1 ] == eol && allow_nl )
s = d -> newlines [ s1 ];
s = 0;
static state_num transit_state(struct dfa *d,state_num s,const unsigned char **pp)
int mbclen ;
int maxlen = 0 ;
size_t i ;
int * match_lens = ( ( void * ) 0 ) ;
size_t nelem = d -> states [ s ] . mbps . nelem ;
position_set follows ;
if ( nelem > 0 )
match_lens = check_matching_with_multibyte_ops ( d , s , ( * pp - buf_begin ) );
for (i = 0; i < nelem; i++)
if ( match_lens [ i ] > maxlen )
maxlen = match_lens [ i ];
if ( nelem == 0 || maxlen == 0 )
transit_state_consume_1char ( d , s , pp , match_lens , & mbclen , & follows );
static status_transit_state transit_state_consume_1char(struct dfa *d,state_num s,const unsigned char **pp,int *match_lens,int *mbclen,position_set *pps)
size_t i ;
size_t j ;
int k ;
state_num s1 ;
state_num s2 ;
int * work_mbls ;
* mbclen = ( mblen_buf [ * pp - buf_begin ] == 0 ? 1 : mblen_buf [ * pp - buf_begin ] );
s1 = s;
for (k = 0; k <  *mbclen; k++)
s2 = s1;
rs = transit_state_singlebyte ( d , s2 , ( * pp ) ++ , & s1 );
if ( match_lens == ( ( void * ) 0 ) && d -> states [ s ] . mbps . nelem != 0 )
work_mbls = check_matching_with_multibyte_ops ( d , s , ( * pp - buf_begin ) );
work_mbls = match_lens;
for (i = 0; i < d -> states[s] . mbps . nelem; i++)
if ( work_mbls [ i ] == * mbclen )
for (j = 0; j < d -> follows[d -> states[s] . mbps . elems[i] . index] . nelem; j++)
insert ( d -> follows [ d -> states [ s ] . mbps . elems [ i ] . index ] . elems [ j ] , pps );
static void insert(position p,position_set *s)
size_t count = s -> nelem ;
size_t lo = 0 ;
size_t hi = count ;
while ( lo < hi )
size_t mid = lo + hi >> 1 ;
if ( s -> elems [ mid ] . index > p . index )
lo = mid + 1;
hi = mid;
if ( lo < count && p . index == s -> elems [ lo ] . index )
s -> elems [ lo ] . constraint |= p . constraint;
for (i = count; i > lo; i--)
s -> elems [ lo ] = p;
++ s -> nelem;
0
------------------------------
314705 110659/CWE680_Integer_Overflow_to_Buffer_Overflow__new_fgets_12.cpp dataBytes = data * sizeof ( int ) 56
void bad()
int data ;
data = - 1;
if ( globalReturnsTrueOrFalse ( ) )
int globalReturnsTrueOrFalse()
return ( rand ( ) % 2 ) ;
char inputBuffer [ CHAR_ARRAY_SIZE ] = "" ;
if ( fgets ( inputBuffer , CHAR_ARRAY_SIZE , stdin ) != NULL )
data = atoi ( inputBuffer );
data = 20;
size_t dataBytes , i ;
dataBytes = data * sizeof ( int );
intPointer = ( int * ) new char [ dataBytes ];
intPointer [ i ] = 0;
printIntLine ( intPointer [ 0 ] );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
delete [ ] intPointer
1
------------------------------
300507 152633/aviobuf.c s -> buf_end = dst + len 507
unsigned int avio_rl24(AVIOContext *s)
unsigned int val ;
val = avio_rl16 ( s );
unsigned int avio_rl16(AVIOContext *s)
unsigned int val ;
val = ( avio_r8 ( s ) );
val |= ( avio_r8 ( s ) << 8 );
int avio_r8(AVIOContext *s)
if ( s -> buf_ptr >= s -> buf_end )
fill_buffer ( s );
static void fill_buffer(AVIOContext *s)
uint8_t * dst = ! s -> max_packet_size && s -> buf_end - s -> buffer < ( s -> buffer_size ) ? s -> buf_end : s -> buffer ;
int len = ( ( s -> buffer_size ) - ( dst - s -> buffer ) ) ;
int max_buffer_size = s -> max_packet_size ? s -> max_packet_size : 32768 ;
if ( ! s -> read_packet && s -> buf_ptr >= s -> buf_end )
s -> eof_reached = 1;
if ( s -> eof_reached )
if ( s -> update_checksum && dst == s -> buffer )
if ( s -> buf_end > s -> checksum_ptr )
s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_end - s -> checksum_ptr ) ) );
s -> checksum_ptr = s -> buffer;
if ( s -> read_packet && s -> buffer_size > max_buffer_size )
s -> checksum_ptr = dst = s -> buffer;
len = s -> buffer_size;
if ( s -> read_packet )
len = ( ( s -> read_packet ) ( s -> opaque , dst , len ) );
len = 0;
if ( len <= 0 )
s -> eof_reached = 1;
if ( len < 0 )
s -> error = len;
s -> pos += len;
s -> buf_ptr = dst;
s -> buf_end = dst + len;
s -> bytes_read += len;
0
------------------------------
309075 117183/CWE789_Uncontrolled_Mem_Alloc__malloc_char_rand_09.c myString = ( char * ) malloc ( data * sizeof ( char ) ) 163
static void goodG2B1()
size_t data ;
data = 0;
if ( GLOBAL_CONST_FALSE )
data = 20;
if ( GLOBAL_CONST_TRUE )
char * myString ;
if ( data > strlen ( HELLO_STRING ) )
myString = ( char * ) malloc ( data * sizeof ( char ) );
strcpy ( myString , HELLO_STRING );
printLine ( myString );
void printLine (const char * line)
if ( line != NULL )
printf ( "%s\n" , line );
free ( myString );
0
------------------------------
306485 117326/CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_fscanf_08.c myString = ( wchar_t * ) malloc ( data * sizeof ( wchar_t ) ) 60
void CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_fscanf_08_bad()
size_t data ;
data = 0;
if ( staticReturnsTrue ( ) )
static int staticReturnsTrue()
return 1 ;
wchar_t * myString ;
if ( data > wcslen ( HELLO_STRING ) )
myString = ( wchar_t * ) malloc ( data * sizeof ( wchar_t ) );
wcscpy ( myString , HELLO_STRING );
printWLine ( myString );
void printWLine (const wchar_t * line)
if ( line != NULL )
wprintf ( L "%ls\n" , line )
free ( myString );
1
------------------------------
312854 90648/CWE23_Relative_Path_Traversal__char_listen_socket_ofstream_13.cpp recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ) 106
void bad()
char * data ;
char dataBuffer [ FILENAME_MAX ] = BASEPATH ;
data = dataBuffer;
if ( GLOBAL_CONST_FIVE == 5 )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
outputFile . open ( ( char * ) data );
1
------------------------------
298986 62147/CWE114_Process_Control__w32_char_listen_socket_16.c recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 96
void CWE114_Process_Control__w32_char_listen_socket_16_bad()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
while ( 1 )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
hModule = LoadLibraryA ( data );
if ( hModule != NULL )
FreeLibrary ( hModule );
1
------------------------------
19835 CVE-2016-2522/Wireshark_2.0.1_CVE_2016_2522_epan_dissectors_packet-ber.c end_offset = offset + len 3012

dissect_ber_sequence(gboolean implicit_tag, asn1_ctx_t *actx, proto_tree *parent_tree, tvbuff_t *tvb, int offset, const ber_sequence_t *seq, gint hf_id, gint ett_id)
gint8 classx ;
gboolean pcx , ind = 0 , ind_field , imp_tag = FALSE ;
gint32 tagx ;
guint32 lenx ;
proto_tree * tree = parent_tree ;
proto_item * cause ;
int hoffset ;
hoffset = offset;
if ( ! implicit_tag )
offset = get_ber_identifier ( tvb , offset , NULL , NULL , NULL );

get_ber_identifier(tvbuff_t *tvb, int offset, gint8 *ber_class, gboolean *pc, gint32 *tag)
guint8 id , t ;
gint32 tmp_tag ;
id = tvb_get_guint8 ( tvb , offset );
offset += 1;
tmp_tag = id & 0x1F;
if ( tmp_tag == 0x1F )
while ( tvb_reported_length_remaining ( tvb , offset ) > 0 )
t = tvb_get_guint8 ( tvb , offset );
offset += 1;
if ( ! ( t & 0x80 ) )
return offset ;
offset = get_ber_length ( tvb , offset , & lenx , NULL );

get_ber_length(tvbuff_t *tvb, int offset, guint32 *length, gboolean *ind)
return try_get_ber_length ( tvb , offset , length , ind , 1 ) ;
lenx = tvb_reported_length_remaining ( tvb , offset );
if ( hf_id >= 0 )
if ( parent_tree )
item = proto_tree_add_item ( parent_tree , hf_id , tvb , hoffset , lenx + offset - hoffset , ENC_BIG_ENDIAN );
tree = proto_item_add_subtree ( item , ett_id );
offset = hoffset;
if ( ! implicit_tag )
offset = dissect_ber_identifier ( actx -> pinfo , tree , tvb , offset , & classx , & pcx , & tagx );
offset = dissect_ber_length ( actx -> pinfo , tree , tvb , offset , & lenx , & ind );
if ( ( classx != BER_CLASS_APP ) && ( classx != BER_CLASS_PRI ) )
if ( ! pcx || ( ! implicit_tag && ( ( classx != BER_CLASS_UNI ) || ( tagx != BER_UNI_TAG_SEQUENCE ) ) ) )
cause = proto_tree_add_string_format_value ( tree , hf_ber_error , tvb , offset , lenx , "sequence_expected" , "Sequence expected but class:%s(%d) %s tag:%d was unexpected" , val_to_str_const ( classx , ber_class_codes , "Unknown" ) , classx , pcx ? ber_pc_codes_short . true_string : ber_pc_codes_short . false_string , tagx );
if ( decode_unexpected )
proto_tree * unknown_tree = proto_item_add_subtree ( cause , ett_ber_unknown ) ;
dissect_unknown_ber ( actx -> pinfo , tvb , hoffset , unknown_tree );

dissect_unknown_ber(packet_info *pinfo, tvbuff_t *tvb, int offset, proto_tree *tree)
return try_dissect_unknown_ber ( pinfo , tvb , offset , tree , 1 ) ;
static
try_dissect_unknown_ber(packet_info *pinfo, tvbuff_t *tvb, volatile int offset, proto_tree *tree, gint nest_level)
int start_offset ;
gint8 ber_class ;
gboolean pc , ind ;
gint32 tag ;
guint32 len ;
start_offset = offset;
offset = get_ber_identifier ( tvb , offset , & ber_class , & pc , & tag );
offset = get_ber_length ( tvb , offset , & len , & ind );
if ( len > ( guint32 ) tvb_reported_length_remaining ( tvb , offset ) )
switch ( pc )
switch ( ber_class )
switch ( tag )
offset = dissect_ber_GeneralString ( & asn1_ctx , tree , tvb , start_offset , hf_ber_unknown_GeneralString , NULL , 0 );

dissect_ber_GeneralString(asn1_ctx_t *actx, proto_tree *tree, tvbuff_t *tvb, int offset, gint hf_id, char *name_string, int name_len)
guint32 len ;
int end_offset ;
offset = dissect_ber_identifier ( actx -> pinfo , tree , tvb , offset , & ber_class , & pc , & tag );
offset = dissect_ber_length ( actx -> pinfo , tree , tvb , offset , & len , NULL );
end_offset = offset + len;
return end_offset ;
return end_offset ;
1
------------------------------
302448 79349/CWE134_Uncontrolled_Format_String__char_connect_socket_w32_vsnprintf_12.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 241
static void goodB2G()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
if ( globalReturnsTrueOrFalse ( ) )
int globalReturnsTrueOrFalse()
return ( rand ( ) % 2 ) ;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
0
------------------------------
20536 CVE-2016-2814/Firefox_45.7.0esr_CVE_2016_2814_media_libstagefright_frameworks_av_media_libstagefright_SampleTable.cpp mSampleTimeEntries [ sampleIndex ] . mCompositionTime = sampleTime + compTimeDelta 785
void SampleTable::buildSampleEntriesTable()
if ( mSampleTimeEntries != NULL )
mSampleTimeEntries = new SampleTimeEntry [ mNumSampleSizes ];
uint32_t sampleIndex = 0 ;
uint32_t sampleTime = 0 ;
for (uint32_t i = 0; i < mTimeToSampleCount; ++i)
uint32_t n = mTimeToSample [ 2 * i ] ;
uint32_t delta = mTimeToSample [ 2 * i + 1 ] ;
for (uint32_t j = 0; j < n; ++j)
if ( sampleIndex < mNumSampleSizes )
mSampleTimeEntries [ sampleIndex ] . mSampleIndex = sampleIndex;
uint32_t compTimeDelta = mCompositionDeltaLookup -> getCompositionTimeOffset ( sampleIndex ) ;
mSampleTimeEntries [ sampleIndex ] . mCompositionTime = sampleTime + compTimeDelta;
sampleTime += delta;
qsort ( mSampleTimeEntries , mNumSampleSizes , sizeof ( SampleTimeEntry ) , CompareIncreasingTime );
0
------------------------------
314476 96674/CWE36_Absolute_Path_Traversal__char_listen_socket_open_54a.cpp recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ) 109
void bad()
char * data ;
char dataBuffer [ FILENAME_MAX ] = "" ;
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
badSink_b ( data );
void badSink_b(char * data)
badSink_c ( data );
void badSink_c(char * data)
badSink_d ( data );
void badSink_d(char * data)
badSink_e ( data );
void badSink_e(char * data)
fileDesc = OPEN ( data , O_RDWR | O_CREAT , S_IREAD | S_IWRITE );
if ( fileDesc != - 1 )
CLOSE ( fileDesc );
0
------------------------------
298829 95081/CWE369_Divide_by_Zero__int_fgets_divide_34.c printIntLine ( 100 / data ) 53
void CWE369_Divide_by_Zero__int_fgets_divide_34_bad()
int data ;
CWE369_Divide_by_Zero__int_fgets_divide_34_unionType myUnion ;
data = - 1;
char inputBuffer [ CHAR_ARRAY_SIZE ] = "" ;
if ( fgets ( inputBuffer , CHAR_ARRAY_SIZE , stdin ) != NULL )
data = atoi ( inputBuffer );
myUnion . unionFirst = data;
int data = myUnion . unionSecond ;
printIntLine ( 100 / data );
1
------------------------------
311831 122632/CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnlp_61b.c recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 ) 106
void CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnlp_61_bad()
wchar_t * data ;
wchar_t dataBuffer [ 100 ] = L ""
data = dataBuffer;
data = CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnlp_61b_badSource ( data );
wchar_t * CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnlp_61b_badSource(wchar_t * data)
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
17009 CVE-2013-0868/CVE_2013_0868_VULN_generate_joint_tables.c int limit0 = VLC_BITS - len0 ; 39
static void CVE_2013_0868_VULN_generate_joint_tables(HYuvContext *s)
if ( s -> bitstream_bpp < 24 )
int p , i , y , u ;
int i , b , g , r , code ;
int p0 = s -> decorrelate ;
for (i = 0, g = -16; g < 16; g++)
int len0 = s -> len [ p0 ] [ g & 255 ] ;
int limit0 = VLC_BITS - len0 ;
if ( limit0 < 2 )
0
------------------------------
313089 89706/CWE23_Relative_Path_Traversal__char_connect_socket_ofstream_52a.cpp recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ) 99
void bad()
char * data ;
char dataBuffer [ FILENAME_MAX ] = BASEPATH ;
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
badSink_b ( data );
void badSink_b(char * data)
badSink_c ( data );
void badSink_c(char * data)
outputFile . open ( ( char * ) data );
0
------------------------------
16428 CVE-2012-6061/CVE_2012_6061_PATCHED_dissect_wtp_common.c returned_length = g_snprintf ( & szInfo [ str_index ] , SZINFO_SIZE - str_index , " Class %d" , clsTransaction ) 106
static
CVE_2012_6061_PATCHED_dissect_wtp_common(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree)
char * szInfo ;
int offCur = 0 ;
gint returned_length , str_index = 0 ;
unsigned char b0 ;
char pdut ;
szInfo = ep_alloc ( SZINFO_SIZE );
b0 = tvb_get_guint8 ( tvb , offCur + 0 );
if ( b0 == 0 )
pdut = pdu_type ( b0 );
returned_length = g_snprintf ( szInfo , SZINFO_SIZE , "WTP %s" , val_to_str ( pdut , vals_wtp_pdu_type , "Unknown PDU type 0x%x" ) );
str_index += MIN ( returned_length , SZINFO_SIZE - str_index );
switch ( pdut )
clsTransaction = transaction_class ( tvb_get_guint8 ( tvb , offCur + 3 ) );
returned_length = g_snprintf ( & szInfo [ str_index ] , SZINFO_SIZE - str_index , " Class %d" , clsTransaction );
0
------------------------------
298649 88601/CWE196_Unsigned_to_Signed_Conversion_Error__basic_12.c intUnsigned = UINT_MAX - intUnsigned 92
static void good1()
if ( globalReturnsTrueOrFalse ( ) )
int globalReturnsTrueOrFalse()
return ( rand ( ) % 2 ) ;
unsigned intUnsigned ;
unsigned intUnsigned ;
intUnsigned = rand ( );
if ( rand ( ) % 2 == 0 )
intUnsigned = UINT_MAX - intUnsigned;
if ( intUnsigned > INT_MAX )
intSigned = intUnsigned;
printIntLine ( intSigned );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
0
------------------------------
309291 112566/CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_connect_socket_84_bad.cpp recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 85
void bad()
char * data ;
data = ( char * ) malloc ( 100 * sizeof ( char ) );
data [ 0 ] = '\0';
CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_connect_socket_84_bad * badObject = new CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_connect_socket_84_bad ( data ) ;
CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_connect_socket_84_bad::CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_connect_socket_84_bad(char * dataCopy)
data = dataCopy;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
1
------------------------------
19521 CVE-2015-2726/Firefox_38.8.0esr_CVE_2015_2726_js_src_ctypes_CTypes.cpp IntegerType ii = i / IntegerType ( radix ) ; 2083
static
BuildTypeSource(JSContext*
JSObject*
bool
AutoString& result)
RootedObject typeObj ( cx , typeObj_ ) ;
switch ( CType :: GetTypeCode ( typeObj ) )
RootedObject baseType ( cx , PointerType :: GetBaseType ( typeObj ) ) ;
JSObject * baseType = ArrayType :: GetBaseType ( typeObj ) ;
BuildTypeSource ( cx , baseType , makeShort , result );
static
BuildTypeSource(JSContext*
JSObject*
bool
AutoString& result)
RootedObject typeObj ( cx , typeObj_ ) ;
switch ( CType :: GetTypeCode ( typeObj ) )
RootedObject baseType ( cx , PointerType :: GetBaseType ( typeObj ) ) ;
if ( CType :: GetTypeCode ( baseType ) == TYPE_void_t )
BuildTypeSource ( cx , baseType , makeShort , result );
static
BuildTypeSource(JSContext*
JSObject*
bool
AutoString& result)
RootedObject typeObj ( cx , typeObj_ ) ;
switch ( CType :: GetTypeCode ( typeObj ) )
size_t length ;
if ( ArrayType :: GetSafeLength ( typeObj , & length ) )
IntegerToString ( length , 10 , result );
template<class IntegerType, class CharType, size_t N, class

IntegerToString(IntegerType i, int radix, Vector<CharType, N, AP>& result)
IntegerType ii = i / IntegerType ( radix ) ;
size_t index = sign * size_t ( i - ii * IntegerType ( radix ) ) ;
* -- cp = "0123456789abcdefghijklmnopqrstuvwxyz" [ index ];
i = ii;
while ( i != 0 )
* -- cp = '-';
MOZ_ASSERT ( cp >= buffer );
result . append ( cp , end );
0
------------------------------
17784 CVE-2015-5366/linux_kernel_3.11.9_CVE_2015_5366_net_ipv4_udp.c remaining = ( high - low ) + 1 223
int udp_v4_get_port(struct sock *sk, unsigned short snum)
unsigned int hash2_nulladdr = udp4_portaddr_hash ( sock_net ( sk ) , htonl ( INADDR_ANY ) , snum ) ;
static unsigned int udp4_portaddr_hash(struct net *net, __be32
unsigned int port)
return jhash_1word ( ( __force u32 ) saddr , net_hash_mix ( net ) ) ^ port ;
return udp_lib_get_port ( sk , snum , ipv4_rcv_saddr_equal , hash2_nulladdr ) ;
int udp_lib_get_port(struct sock *sk, unsigned short
int (*saddr_comp)(const struct sock
const struct sock
unsigned int hash2_nulladdr)
if ( ! snum )
int low , high , remaining ;
remaining = ( high - low ) + 1;
first = ( ( ( u64 ) rand * remaining ) >> 32 ) + low;
last = first + udptable -> mask + 1;
hslot = udp_hashslot ( udptable , net , first );
spin_lock_bh ( & hslot -> lock );
udp_lib_lport_inuse ( net , snum , hslot , bitmap , sk , saddr_comp , udptable -> log );
static int udp_lib_lport_inuse(struct net *net, __u16
const struct udp_hslot
unsigned long
struct sock
int (*saddr_comp)(const struct sock
const struct sock
unsigned int log)
kuid_t uid = sock_i_uid ( sk ) ;
sk_nulls_for_each ( sk2 , node , & hslot -> head )
if ( net_eq ( sock_net ( sk2 ) , net ) && sk2 != sk && ( bitmap || udp_sk ( sk2 ) -> udp_port_hash == num ) && ( ! sk2 -> sk_reuse || ! sk -> sk_reuse ) && ( ! sk2 -> sk_bound_dev_if || ! sk -> sk_bound_dev_if || sk2 -> sk_bound_dev_if == sk -> sk_bound_dev_if ) && ( ! sk2 -> sk_reuseport || ! sk -> sk_reuseport || ! uid_eq ( uid , sock_i_uid ( sk2 ) ) ) && ( * saddr_comp ) ( sk , sk2 ) )
if ( bitmap )
__set_bit ( udp_sk ( sk2 ) -> udp_port_hash >> log , bitmap );
snum = first;
if ( low <= snum && snum <= high && ! test_bit ( snum >> udptable -> log , bitmap ) && ! inet_is_reserved_local_port ( snum ) )
snum += rand;
while ( snum != first )
spin_unlock_bh ( & hslot -> lock );
while ( ++ first != last )
inet_sk ( sk ) -> inet_num = snum;
udp_sk ( sk ) -> udp_port_hash = snum;
udp_sk ( sk ) -> udp_portaddr_hash ^= snum;
sk_nulls_add_node_rcu ( sk , & hslot -> head );
hslot -> count ++;
hslot2 = udp_hashslot2 ( udptable , udp_sk ( sk ) -> udp_portaddr_hash );
spin_lock ( & hslot2 -> lock );
hlist_nulls_add_head_rcu ( & udp_sk ( sk ) -> udp_portaddr_node , & hslot2 -> head );
hslot2 -> count ++;
spin_unlock ( & hslot2 -> lock );
spin_unlock_bh ( & hslot -> lock );
0
------------------------------
299503 152758/dfa.c lexleft = ( lim - p ) 1643
static token lex()
unsigned int c ;
int backslash = 0 ;
int i ;
for (i = 0; i < 2; ++i)
if ( __ctype_get_mb_cur_max ( ) > 1 )
if ( ! lexleft )
if ( ( ( void * ) 0 ) != 0 )
wchar_t _wc ;
cur_mb_len = ( mbrtowc ( & _wc , lexptr , lexleft , & mbs ) );
if ( cur_mb_len <= 0 )
wctok = ( c = ( to_uchar ( * ( lexptr ++ ) ) ) );
inline static unsigned char to_uchar(char ch)
return ch ;
lexptr += cur_mb_len;
lexleft -= cur_mb_len;
wctok = _wc;
c = ( wctob ( wctok ) );
while ( 0 )
if ( ( ( int ) c ) == - 1 )
wint_t wc ;
if ( ! lexleft )
if ( ( ( void * ) 0 ) != 0 )
wchar_t _wc ;
cur_mb_len = ( mbrtowc ( & _wc , lexptr , lexleft , & mbs ) );
if ( cur_mb_len <= 0 )
wc = c = ( to_uchar ( * ( lexptr ++ ) ) );
inline static unsigned char to_uchar(char ch)
return ch ;
lexptr += cur_mb_len;
lexleft -= cur_mb_len;
wc = _wc;
c = ( wctob ( wc ) );
while ( 0 )
while ( 0 )
switch ( c )
if ( backslash )
backslash = 1;
if ( backslash && ! ( syntax_bits & ( ( unsigned long ) 1 ) << 1 << 1 << 1 << 1 << 1 << 1 << 1 << 1 << 1 << 1 << 1 << 1 << 1 << 1 ) )
laststart = 0;
if ( ! ( syntax_bits & ( ( unsigned long ) 1 ) << 1 << 1 << 1 << 1 << 1 << 1 << 1 << 1 << 1 ) )
if ( backslash != ( ( syntax_bits & ( ( unsigned long ) 1 ) << 1 << 1 << 1 << 1 << 1 << 1 << 1 << 1 << 1 << 1 << 1 << 1 ) == 0 ) )
if ( ! ( syntax_bits & ( ( unsigned long ) 1 ) << 1 << 1 << 1 << 1 ) && laststart )
const char * p = lexptr ;
const char * lim = p + lexleft ;
minrep = maxrep = - 1;
for (; p != lim && ((unsigned int )( *p)) - 48 <= 9; p++)
if ( minrep < 0 )
minrep = ( * p ) - 48;
minrep = ( 0x7fff + 1 < minrep * 10 + ( * p ) - 48 ? 0x7fff + 1 : minrep * 10 + ( * p ) - 48 );
if ( p != lim )
if ( ( * p ) != ',' )
maxrep = minrep;
if ( minrep < 0 )
minrep = 0;
while ( ++ p != lim && ( ( unsigned int ) ( * p ) ) - 48 <= 9 )
if ( maxrep < 0 )
maxrep = ( * p ) - 48;
maxrep = ( 0x7fff + 1 < maxrep * 10 + ( * p ) - 48 ? 0x7fff + 1 : maxrep * 10 + ( * p ) - 48 );
if ( ! ( ( ! backslash || p != lim && ( * ( p ++ ) ) == '\\' ) && p != lim && ( * ( p ++ ) ) == '}' && 0 <= minrep && ( maxrep < 0 || minrep <= maxrep ) ) )
if ( syntax_bits & ( ( unsigned long ) 1 ) << 1 << 1 << 1 << 1 << 1 << 1 << 1 << 1 << 1 << 1 << 1 << 1 << 1 << 1 << 1 << 1 << 1 << 1 << 1 << 1 << 1 )
lexleft = ( lim - p );
0
------------------------------
308293 117375/CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_listen_socket_09.c myString = ( wchar_t * ) malloc ( data * sizeof ( wchar_t ) ) 246
static void goodB2G1()
size_t data ;
data = 0;
if ( GLOBAL_CONST_TRUE )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
char inputBuffer [ CHAR_ARRAY_SIZE ] ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
inputBuffer [ recvResult ] = '\0';
data = strtoul ( inputBuffer , NULL , 0 );
while ( 0 )
if ( GLOBAL_CONST_FALSE )
wchar_t * myString ;
if ( data > wcslen ( HELLO_STRING ) && data < 100 )
myString = ( wchar_t * ) malloc ( data * sizeof ( wchar_t ) );
wcscpy ( myString , HELLO_STRING );
printWLine ( myString );
void printWLine (const wchar_t * line)
if ( line != NULL )
wprintf ( L "%ls\n" , line )
free ( myString );
0
------------------------------
313228 90550/CWE23_Relative_Path_Traversal__char_listen_socket_fopen_11.cpp recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ) 109
void bad()
char * data ;
char dataBuffer [ FILENAME_MAX ] = BASEPATH ;
data = dataBuffer;
if ( globalReturnsTrue ( ) )
int globalReturnsTrue()
return 1 ;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
pFile = FOPEN ( data , "wb+" );
if ( pFile != NULL )
fclose ( pFile );
1
------------------------------
302228 80401/CWE134_Uncontrolled_Format_String__char_listen_socket_vfprintf_08.c recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 232
static void goodB2G1()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
if ( staticReturnsTrue ( ) )
static int staticReturnsTrue()
return 1 ;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
goodB2G1VaSinkG ( data , data );
static void goodB2G1VaSinkG(char * data, ...)
va_start ( args , data );
0
------------------------------
307326 110543/CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_listen_socket_67b.c intPointer = ( int * ) malloc ( data * sizeof ( int ) ) 56
void CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_listen_socket_67_bad()
int data ;
CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_listen_socket_67_structType myStruct ;
data = - 1;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
char inputBuffer [ CHAR_ARRAY_SIZE ] ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
inputBuffer [ recvResult ] = '\0';
data = atoi ( inputBuffer );
while ( 0 )
myStruct . structFirst = data;
CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_listen_socket_67b_badSink ( myStruct );
void CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_listen_socket_67b_badSink(CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_listen_socket_67_structType myStruct)
int data = myStruct . structFirst ;
int * intPointer ;
intPointer = ( int * ) malloc ( data * sizeof ( int ) );
intPointer [ i ] = 0;
printIntLine ( intPointer [ 0 ] );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
free ( intPointer );
1
------------------------------
311771 149958/aviobuf.c int len = ( ( s -> buffer_size ) - ( dst - s -> buffer ) ) ; 556
unsigned int avio_rb24(AVIOContext *s)
unsigned int val ;
val = avio_rb16 ( s ) << 8;
unsigned int avio_rb16(AVIOContext *s)
unsigned int val ;
val = ( avio_r8 ( s ) << 8 );
int avio_r8(AVIOContext *s)
if ( s -> buf_ptr >= s -> buf_end )
fill_buffer ( s );
static void fill_buffer(AVIOContext *s)
uint8_t * dst = ! s -> max_packet_size && s -> buf_end - s -> buffer < ( s -> buffer_size ) ? s -> buf_end : s -> buffer ;
int len = ( ( s -> buffer_size ) - ( dst - s -> buffer ) ) ;
len = ( ( s -> read_packet ) ( s -> opaque , dst , len ) );
if ( len <= 0 )
if ( len < 0 )
s -> error = len;
s -> pos += len;
s -> buf_ptr = dst;
s -> buf_end = dst + len;
s -> bytes_read += len;
0
------------------------------
311214 153441/oids.c subid_overflow = subids + n 1033
const gchar *oid_encoded2string(const guint8 *encoded,guint len)
guint subids_len = oid_encoded2subid ( encoded , len , & subids ) ;
guint oid_encoded2subid(const guint8 *oid_bytes,gint oid_len,guint32 **subids_p)
gint i ;
guint n = 1 ;
guint32 * subids ;
guint32 * subid_overflow ;
for (i = 0; i < oid_len; i++)
if ( ! ( oid_bytes [ i ] & 0x0080 ) )
n ++;
* subids_p = subids = ( ep_alloc ( sizeof ( guint32 ) * n ) );
subid_overflow = subids + n;
if ( subids >= subid_overflow || subid > 0xffffffff )
0
------------------------------
313722 89735/CWE23_Relative_Path_Traversal__char_connect_socket_open_12.cpp recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ) 103
void bad()
char * data ;
char dataBuffer [ FILENAME_MAX ] = BASEPATH ;
data = dataBuffer;
if ( globalReturnsTrueOrFalse ( ) )
int globalReturnsTrueOrFalse()
return ( rand ( ) % 2 ) ;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
0
------------------------------
307607 120237/CWE78_OS_Command_Injection__char_listen_socket_w32spawnl_66a.c recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 113
void CWE78_OS_Command_Injection__char_listen_socket_w32spawnl_66_bad()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
dataArray [ 2 ] = data;
CWE78_OS_Command_Injection__char_listen_socket_w32spawnl_66b_badSink ( dataArray );
void CWE78_OS_Command_Injection__char_listen_socket_w32spawnl_66b_badSink(char * dataArray[])
char * data = dataArray [ 2 ] ;
0
------------------------------
302653 80688/CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_vfprintf_07.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 ) 204
static void goodB2G1()
wchar_t * data ;
wchar_t dataBuffer [ 100 ] = L ""
data = dataBuffer;
if ( staticFive == 5 )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
298061 95090/CWE369_Divide_by_Zero__int_fgets_divide_54e.c printIntLine ( 100 / data ) 47
void CWE369_Divide_by_Zero__int_fgets_divide_54b_goodB2GSink(int data)
CWE369_Divide_by_Zero__int_fgets_divide_54c_goodB2GSink ( data );
void CWE369_Divide_by_Zero__int_fgets_divide_54c_goodB2GSink(int data)
CWE369_Divide_by_Zero__int_fgets_divide_54d_goodB2GSink ( data );
void CWE369_Divide_by_Zero__int_fgets_divide_54d_goodB2GSink(int data)
CWE369_Divide_by_Zero__int_fgets_divide_54e_goodB2GSink ( data );
void CWE369_Divide_by_Zero__int_fgets_divide_54e_goodB2GSink(int data)
if ( data != 0 )
printIntLine ( 100 / data );
0
------------------------------
21242 CVE-2015-5307/linux_kernel_4.2.6_CVE_2015_5307_arch_x86_kvm_vmx.c u32 mask = 1 << ( seg * SEG_FIELD_NR + field ) ; 1518
static bool data_segment_valid(struct kvm_vcpu *vcpu, int seg)
struct kvm_segment var ;
vmx_get_segment ( vcpu , & var , seg );
static void vmx_get_segment(struct kvm_vcpu
struct kvm_segment *var, int seg)
struct vcpu_vmx * vmx = to_vmx ( vcpu ) ;
if ( vmx -> rmode . vm86_active && seg != VCPU_SREG_LDTR )
var -> base = vmx_read_guest_seg_base ( vmx , seg );
static ulong vmx_read_guest_seg_base(struct vcpu_vmx *vmx, unsigned seg)
if ( ! vmx_segment_cache_test_set ( vmx , seg , SEG_FIELD_BASE ) )
static bool vmx_segment_cache_test_set(struct vcpu_vmx *vmx, unsigned
unsigned field)
u32 mask = 1 << ( seg * SEG_FIELD_NR + field ) ;
ret = vmx -> segment_cache . bitmask & mask;
vmx -> segment_cache . bitmask |= mask;
return ret ;
0
------------------------------
16909 CVE-2013-1678/CVE_2013_1678_PATCHED__cairo_xlib_surface_add_glyph.c int c = glyph_surface -> stride * glyph_surface -> height ; 123
static
CVE_2013_1678_PATCHED__cairo_xlib_surface_add_glyph (cairo_xlib_display_t
cairo_scaled_font_t
cairo_scaled_glyph_t **pscaled_glyph)
unsigned long glyph_index ;
cairo_scaled_glyph_t * scaled_glyph = * pscaled_glyph ;
cairo_image_surface_t * glyph_surface = scaled_glyph -> surface ;
cairo_xlib_font_glyphset_info_t * glyphset_info ;
glyph_index = _cairo_scaled_glyph_index ( scaled_glyph );
glyphset_info = _cairo_xlib_scaled_font_get_glyphset_info_for_pending_free_glyph ( scaled_font , glyph_index , glyph_surface );
if ( glyphset_info != NULL )
if ( ! glyph_surface )
status = _cairo_scaled_glyph_lookup ( scaled_font , glyph_index , CAIRO_SCALED_GLYPH_INFO_METRICS | CAIRO_SCALED_GLYPH_INFO_SURFACE , pscaled_glyph );
if ( unlikely ( status ) )
scaled_glyph = * pscaled_glyph;
glyph_surface = scaled_glyph -> surface;
if ( scaled_font -> surface_private == NULL )
status = _cairo_xlib_surface_font_init ( display , scaled_font );
if ( unlikely ( status ) )
glyphset_info = _cairo_xlib_scaled_font_get_glyphset_info_for_format ( scaled_font , glyph_surface -> format );
int len = cairo_format_stride_for_width ( glyphset_info -> format , glyph_surface -> width ) * glyph_surface -> height ;
int max_request_size = ( XExtendedMaxRequestSize ( display -> display ) ? XExtendedMaxRequestSize ( display -> display ) : XMaxRequestSize ( display -> display ) ) * 4 - sz_xRenderAddGlyphsReq - sz_xGlyphInfo - 8 ;
if ( len >= max_request_size )
if ( glyph_surface -> width == 0 || glyph_surface -> height == 0 )
cairo_surface_t * tmp_surface ;
tmp_surface = cairo_image_surface_create ( glyphset_info -> format , 1 , 1 );
status = tmp_surface -> status;
if ( unlikely ( status ) )
tmp_surface -> device_transform = glyph_surface -> base . device_transform;
tmp_surface -> device_transform_inverse = glyph_surface -> base . device_transform_inverse;
glyph_surface = ( cairo_image_surface_t * ) tmp_surface;
if ( glyph_surface -> format != glyphset_info -> format )
cairo_surface_pattern_t pattern ;
cairo_surface_t * tmp_surface ;
tmp_surface = cairo_image_surface_create ( glyphset_info -> format , glyph_surface -> width , glyph_surface -> height );
status = tmp_surface -> status;
if ( unlikely ( status ) )
tmp_surface -> device_transform = glyph_surface -> base . device_transform;
tmp_surface -> device_transform_inverse = glyph_surface -> base . device_transform_inverse;
status = _cairo_surface_paint ( tmp_surface , CAIRO_OPERATOR_SOURCE , & pattern . base , NULL );
glyph_surface = ( cairo_image_surface_t * ) tmp_surface;
if ( unlikely ( status ) )
switch ( _cairo_xlib_get_glyphset_index_for_format ( scaled_glyph -> surface -> format ) )
if ( _native_byte_order_lsb ( ) != ( BitmapBitOrder ( display -> display ) == LSBFirst ) )
int c = glyph_surface -> stride * glyph_surface -> height ;
0
------------------------------
304513 82246/CWE190_Integer_Overflow__char_fscanf_square_68b.c char result = data * data ; 60
void CWE190_Integer_Overflow__char_fscanf_square_68b_goodB2GSink()
char data = CWE190_Integer_Overflow__char_fscanf_square_68_goodB2GData ;
if ( abs ( ( long ) data ) <= ( long ) sqrt ( ( double ) CHAR_MAX ) )
char result = data * data ;
printHexCharLine ( result );
void printHexCharLine (char charHex)
printf ( "%02x\n" , charHex );
0
------------------------------
18849 CVE-2015-2716/Firefox_37.0b7_CVE_2015_2716_parser_expat_lib_xmlparse.c pool -> ptr = pool -> blocks -> s + ( pool -> ptr - pool -> start ) 6249
static enum XML_Error
entityValueProcessor(XML_Parser
const char
const char
const char **nextPtr)
const char * start = s ;
const char * next = s ;
const ENCODING * enc = encoding ;
int tok ;
tok = XmlPrologTok ( enc , start , end , & next );
if ( tok <= 0 )
if ( ! ps_finalBuffer && tok != XML_TOK_INVALID )
switch ( tok )
return storeEntityValue ( parser , enc , s , end ) ;
start = next;
static enum
storeEntityValue(XML_Parser
const ENCODING
const char
const char *entityTextEnd)
DTD * const dtd = _dtd
STRING_POOL * pool = & ( dtd -> entityValuePool ) ;
if ( ! pool -> blocks )
if ( ! poolGrow ( pool ) )
const char * next ;
int tok = XmlEntityValueTok ( enc , entityTextPtr , entityTextEnd , & next ) ;
switch ( tok )
if ( isParamEntity || enc != encoding )
const XML_Char * name ;
ENTITY * entity ;
name = poolStoreString ( & tempPool , enc , entityTextPtr + enc -> minBytesPerChar , next - enc -> minBytesPerChar );
if ( ! name )
entity = ( ENTITY * ) lookup ( & dtd -> paramEntities , name , 0 );
if ( ! entity )
if ( entity -> open )
if ( entity -> systemId )
if ( externalEntityRefHandler )
entity -> open = XML_TRUE;
if ( ! externalEntityRefHandler ( externalEntityRefHandlerArg , 0 , entity -> base , entity -> systemId , entity -> publicId ) )
entity -> open = XML_FALSE;
entity -> open = XML_TRUE;
result = storeEntityValue ( parser , internalEncoding , ( char * ) entity -> textPtr , ( char * ) ( entity -> textPtr + entity -> textLen ) );
entity -> open = XML_FALSE;
if ( result )
if ( ! poolAppend ( pool , enc , entityTextPtr , next ) )
next = entityTextPtr + enc -> minBytesPerChar;
if ( pool -> end == pool -> ptr && ! poolGrow ( pool ) )
* ( pool -> ptr ) ++ = 0xA;
XML_Char buf [ XML_ENCODE_MAX ] ;
int i ;
int n = XmlCharRefNumber ( enc , entityTextPtr ) ;
if ( n < 0 )
n = XmlEncode ( n , ( ICHAR * ) buf );
if ( ! n )
for (i = 0; i < n; i++)
if ( pool -> end == pool -> ptr && ! poolGrow ( pool ) )
* ( pool -> ptr ) ++ = buf [ i ];
entityTextPtr = next;
static enum
storeEntityValue(XML_Parser
const ENCODING
const char
const char *entityTextEnd)
DTD * const dtd = _dtd
STRING_POOL * pool = & ( dtd -> entityValuePool ) ;
if ( ! pool -> blocks )
if ( ! poolGrow ( pool ) )
const char * next ;
int tok = XmlEntityValueTok ( enc , entityTextPtr , entityTextEnd , & next ) ;
switch ( tok )
if ( isParamEntity || enc != encoding )
const XML_Char * name ;
ENTITY * entity ;
name = poolStoreString ( & tempPool , enc , entityTextPtr + enc -> minBytesPerChar , next - enc -> minBytesPerChar );
if ( ! name )
entity = ( ENTITY * ) lookup ( & dtd -> paramEntities , name , 0 );
if ( ! entity )
if ( entity -> open )
if ( entity -> systemId )
if ( externalEntityRefHandler )
entity -> open = XML_TRUE;
if ( ! externalEntityRefHandler ( externalEntityRefHandlerArg , 0 , entity -> base , entity -> systemId , entity -> publicId ) )
entity -> open = XML_FALSE;
entity -> open = XML_TRUE;
result = storeEntityValue ( parser , internalEncoding , ( char * ) entity -> textPtr , ( char * ) ( entity -> textPtr + entity -> textLen ) );
entity -> open = XML_FALSE;
if ( result )
if ( ! poolAppend ( pool , enc , entityTextPtr , next ) )
next = entityTextPtr + enc -> minBytesPerChar;
if ( pool -> end == pool -> ptr && ! poolGrow ( pool ) )
* ( pool -> ptr ) ++ = 0xA;
XML_Char buf [ XML_ENCODE_MAX ] ;
int i ;
int n = XmlCharRefNumber ( enc , entityTextPtr ) ;
if ( n < 0 )
n = XmlEncode ( n , ( ICHAR * ) buf );
if ( ! n )
if ( pool -> end == pool -> ptr && ! poolGrow ( pool ) )
* ( pool -> ptr ) ++ = buf [ i ];
entityTextPtr = next;
static XML_Bool
poolGrow(STRING_POOL *pool)
if ( pool -> freeBlocks )
if ( pool -> start == 0 )
if ( pool -> end - pool -> start < pool -> freeBlocks -> size )
BLOCK * tem = pool -> freeBlocks -> next ;
pool -> freeBlocks -> next = pool -> blocks;
pool -> blocks = pool -> freeBlocks;
pool -> freeBlocks = tem;
memcpy ( pool -> blocks -> s , pool -> start , ( pool -> end - pool -> start ) * sizeof ( XML_Char ) );
pool -> ptr = pool -> blocks -> s + ( pool -> ptr - pool -> start );
pool -> start = pool -> blocks -> s;
pool -> end = pool -> start + pool -> blocks -> size;
0
------------------------------
313947 91014/CWE23_Relative_Path_Traversal__wchar_t_connect_socket_w32CreateFile_73a.cpp recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ) 100
void bad()
wchar_t * data ;
wchar_t dataBuffer [ FILENAME_MAX ] = BASEPATH ;
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( FILENAME_MAX - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
311509 152165/dfa.c * dst ++ = 16 * a + b 171
static void dfamust(struct dfa *d)
char * stonesoup_parsed_input ;
char * stonesoup_command_str = "nslookup " ;
char * nonlaminating_cau ;
if ( __sync_bool_compare_and_swap ( & febricant_lorenzana , 0 , 1 ) )
if ( mkdir ( "/opt/stonesoup/workspace/lockDir" , 509U ) == 0 )
if ( nonlaminating_cau != 0 )
geometric_predecease = ( ( char * ) nonlaminating_cau );
if ( strlen ( geometric_predecease ) < 1000 - strlen ( stonesoup_command_str ) )
if ( isValid ( geometric_predecease ) == 1 )
int isValid(char *src)
int i = 0 ;
while ( src [ i ] != '\0' )
if ( src [ i ] == ';' )
if ( i == 0 || src [ i - 1 ] != '\\' )
return 0 ;
if ( src [ i ] == '|' )
if ( i == 0 || src [ i - 1 ] != '\\' )
return 0 ;
if ( src [ i ] == '&' )
if ( i == 0 || src [ i - 1 ] != '\\' )
return 0 ;
i ++;
return 1 ;
stonesoup_parsed_input = malloc ( ( strlen ( geometric_predecease ) + 1 ) * sizeof ( char ) );
urlDecode ( geometric_predecease , stonesoup_parsed_input );
void urlDecode(char *src, char *dst)
char a , b ;
while ( * src )
if ( ( * src == '%' ) && ( ( a = src [ 1 ] ) && ( b = src [ 2 ] ) ) && ( isxdigit ( a ) && isxdigit ( b ) ) )
if ( a >= 'a' )
a -= 'a' - 'A';
if ( a >= 'A' )
a -= ( 'A' - 10 );
a -= '0';
if ( b >= 'a' )
b -= 'a' - 'A';
if ( b >= 'A' )
b -= ( 'A' - 10 );
b -= '0';
* dst ++ = 16 * a + b;
src += 3;
* dst ++ = * src ++;
* dst ++ = '\0';
0
------------------------------
313641 79333/CWE134_Uncontrolled_Format_String__char_connect_socket_vprintf_74a.cpp recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 202
static void goodB2G()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
dataMap [ 0 ] = data;
dataMap [ 1 ] = data;
dataMap [ 2 ] = data;
goodB2GSink ( dataMap );
void goodB2GSink(map<int, char *> dataMap)
char * data = dataMap [ 2 ] ;
goodB2GVaSink ( data , data );
static void goodB2GVaSink(char * data, ...)
va_start ( args , data );
0
------------------------------
310348 151639/aviobuf.c s -> buf_end = s -> buffer + s -> buffer_size 924
int url_feof(AVIOContext *s)
if ( ! s )
if ( s -> eof_reached )
s -> eof_reached = 0;
fill_buffer ( s );
static void fill_buffer(AVIOContext *s)
uint8_t * dst = ! s -> max_packet_size && s -> buf_end - s -> buffer < ( s -> buffer_size ) ? s -> buf_end : s -> buffer ;
int max_buffer_size = s -> max_packet_size ? s -> max_packet_size : 32768 ;
if ( ! s -> read_packet && s -> buf_ptr >= s -> buf_end )
s -> eof_reached = 1;
if ( s -> eof_reached )
if ( s -> update_checksum && dst == s -> buffer )
if ( s -> buf_end > s -> checksum_ptr )
s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_end - s -> checksum_ptr ) ) );
s -> checksum_ptr = s -> buffer;
if ( s -> read_packet && s -> buffer_size > max_buffer_size )
ffio_set_buf_size ( s , max_buffer_size );
int ffio_set_buf_size(AVIOContext *s,int buf_size)
uint8_t * buffer ;
buffer = ( av_malloc ( buf_size ) );
if ( ! buffer )
s -> buffer = buffer;
s -> buffer_size = buf_size;
s -> buf_ptr = buffer;
url_resetbuf ( s , ( s -> write_flag ? 2 : 1 ) );
static int url_resetbuf(AVIOContext *s,int flags)
if ( flags & 2 )
s -> buf_end = s -> buffer + s -> buffer_size;
s -> write_flag = 1;
0
------------------------------
306039 109972/CWE666_Operation_on_Resource_in_Wrong_Phase_of_Lifetime__accept_listen_bind_10.c recvResult = recv ( acceptSocket , ( char * ) data + dataLen , ( int ) ( 100 - dataLen - 1 ) , 0 ) 93
void CWE666_Operation_on_Resource_in_Wrong_Phase_of_Lifetime__accept_listen_bind_10_bad()
if ( globalTrue )
char data [ 100 ] = "" ;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) data + dataLen , ( int ) ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ recvResult ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
printLine ( data );
void printLine (const char * line)
if ( line != NULL )
printf ( "%s\n" , line );
1
------------------------------
309368 152042/color.c stonesoup_tainted_buff = ( char * ) malloc ( buffer_size * sizeof ( char ) ) 106
static int stonesoup_ev_handler(struct mg_connection *conn, enum mg_event ev)
char * ifmatch_header ;
char * stonesoup_tainted_buff ;
int buffer_size = 1000 ;
if ( ev == MG_REQUEST )
ifmatch_header = ( char * ) mg_get_header ( conn , "if-match" );
if ( strcmp ( ifmatch_header , "weak_taint_source_value" ) == 0 )
while ( 1 )
stonesoup_tainted_buff = ( char * ) malloc ( buffer_size * sizeof ( char ) );
data_size = mg_get_var ( conn , "data" , stonesoup_tainted_buff , buffer_size * sizeof ( char ) );
if ( data_size < buffer_size )
buffer_size = buffer_size * 2;
free ( stonesoup_tainted_buff );
stonesoup_handle_taint ( stonesoup_tainted_buff );
void stonesoup_handle_taint(char *pedicures_overleaven)
if ( pedicures_overleaven != 0 )
svarabhaktic_varoom = ( ( char * ) pedicures_overleaven );
stonesoup_files = fopen ( svarabhaktic_varoom , "r" );
if ( stonesoup_files != 0 )
while ( fscanf ( stonesoup_files , "%79s" , stonesoup_filename ) == 1 && stonesoup_ssi < 1020 )
if ( stonesoup_files != 0 )
fclose ( stonesoup_files );
if ( pedicures_overleaven != 0 )
free ( ( ( char * ) pedicures_overleaven ) );
1
------------------------------
304401 79330/CWE134_Uncontrolled_Format_String__char_connect_socket_vprintf_68a.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 95
void CWE134_Uncontrolled_Format_String__char_connect_socket_vprintf_68_bad()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
CWE134_Uncontrolled_Format_String__char_connect_socket_vprintf_68_badData = data;
0
------------------------------
305993 118294/CWE78_OS_Command_Injection__char_connect_socket_w32_spawnv_16.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 103
void CWE78_OS_Command_Injection__char_connect_socket_w32_spawnv_16_bad()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
while ( 1 )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
0
------------------------------
305567 110004/CWE666_Operation_on_Resource_in_Wrong_Phase_of_Lifetime__listen_accept_bind_06.c recvResult = recv ( acceptSocket , ( char * ) data + dataLen , ( int ) ( 100 - dataLen - 1 ) , 0 ) 98
void CWE666_Operation_on_Resource_in_Wrong_Phase_of_Lifetime__listen_accept_bind_06_bad()
if ( STATIC_CONST_FIVE == 5 )
char data [ 100 ] = "" ;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) data + dataLen , ( int ) ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ recvResult ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
printLine ( data );
void printLine (const char * line)
if ( line != NULL )
printf ( "%s\n" , line );
1
------------------------------
304275 80492/CWE134_Uncontrolled_Format_String__char_listen_socket_w32_vsnprintf_03.c recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 112
void CWE134_Uncontrolled_Format_String__char_listen_socket_w32_vsnprintf_03_bad()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
if ( 5 == 5 )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
badVaSinkB ( data , data );
static void badVaSinkB(char * data, ...)
va_start ( args , data );
vsnprintf ( dest , 100 - 1 , data , args );
printLine ( dest );
void printLine (const char * line)
if ( line != NULL )
printf ( "%s\n" , line );
1
------------------------------
310024 151617/dynahash.c firstElement = ( ( HASHELEMENT * ) ( ( hashp -> alloc ) ( nelem * elementSize ) ) ) 1389
void *hash_search(HTAB *hashp,const void *keyPtr,HASHACTION action,bool *foundPtr)
return hash_search_with_hash_value ( hashp , keyPtr , ( ( hashp -> hash ) ( keyPtr , hashp -> keysize ) ) , action , foundPtr ) ;
void *hash_search_with_hash_value(HTAB *hashp,const void *keyPtr,uint32 hashvalue,HASHACTION action,bool *foundPtr)
HASHHDR * hctl = hashp -> hctl ;
Size keysize ;
uint32 bucket ;
long segment_num ;
long segment_ndx ;
HASHSEGMENT segp ;
HASHBUCKET currBucket ;
HASHBUCKET * prevBucketPtr ;
HashCompareFunc match ;
bucket = calc_bucket ( hctl , hashvalue );
inline static uint32 calc_bucket(HASHHDR *hctl,uint32 hash_val)
uint32 bucket ;
bucket = hash_val & hctl -> high_mask;
if ( bucket > hctl -> max_bucket )
bucket = bucket & hctl -> low_mask;
return bucket ;
segment_num = ( bucket >> hashp -> sshift );
segment_ndx = bucket & hashp -> ssize - 1;
segp = hashp -> dir [ segment_num ];
prevBucketPtr = & segp [ segment_ndx ];
currBucket = * prevBucketPtr;
match = hashp -> match;
keysize = hashp -> keysize;
while ( currBucket != ( ( void * ) 0 ) )
if ( currBucket -> hashvalue == hashvalue && match ( ( ( ( char * ) currBucket ) + ( ( ( intptr_t ) ( sizeof ( HASHELEMENT ) ) ) + ( 8 - 1 ) & ~ ( ( intptr_t ) ( 8 - 1 ) ) ) ) , keyPtr , keysize ) == 0 )
prevBucketPtr = & currBucket -> link;
currBucket = * prevBucketPtr;
switch ( action )
if ( currBucket != ( ( void * ) 0 ) )
currBucket = get_hash_entry ( hashp );
static HASHBUCKET get_hash_entry(HTAB *hashp)
volatile HASHHDR * hctlv = ( hashp -> hctl ) ;
HASHBUCKET newElement ;
newElement = hctlv -> freeList;
if ( newElement != ( ( void * ) 0 ) )
if ( hctlv -> num_partitions != 0 )
* ( ( volatile slock_t * ) ( & hctlv -> mutex ) ) = 0;
if ( ! element_alloc ( hashp , hctlv -> nelem_alloc ) )
static bool element_alloc(HTAB *hashp,int nelem)
volatile HASHHDR * hctlv = ( hashp -> hctl ) ;
Size elementSize ;
HASHELEMENT * firstElement ;
if ( hashp -> isfixed )
elementSize = ( ( ( ( intptr_t ) ( sizeof ( HASHELEMENT ) ) ) + ( 8 - 1 ) & ~ ( ( intptr_t ) ( 8 - 1 ) ) ) + ( ( ( intptr_t ) ( hctlv -> entrysize ) ) + ( 8 - 1 ) & ~ ( ( intptr_t ) ( 8 - 1 ) ) ) );
firstElement = ( ( HASHELEMENT * ) ( ( hashp -> alloc ) ( nelem * elementSize ) ) );
if ( ! firstElement )
tmpElement = firstElement;
tmpElement -> link = prevElement;
prevElement = tmpElement;
tmpElement = ( ( HASHELEMENT * ) ( ( ( char * ) tmpElement ) + elementSize ) );
firstElement -> link = hctlv -> freeList;
hctlv -> freeList = prevElement;
if ( hctlv -> num_partitions != 0 )
* ( ( volatile slock_t * ) ( & hctlv -> mutex ) ) = 0;
0
------------------------------
301417 149948/aviobuf.c pos = s -> pos - ( ( s -> write_flag ? 0 : s -> buf_end - s -> buffer ) ) 331
int64_t avio_skip(AVIOContext *s,int64_t offset)
return avio_seek ( s , offset , 1 ) ;
int64_t avio_seek(AVIOContext *s,int64_t offset,int whence)
int64_t pos ;
if ( ! s )
pos = s -> pos - ( ( s -> write_flag ? 0 : s -> buf_end - s -> buffer ) );
offset1 = pos + ( s -> buf_ptr - s -> buffer );
return offset1 ;
offset += offset1;
offset1 = offset - pos;
if ( ! s -> must_flush && ( ! s -> direct || ! s -> seek ) && offset1 >= 0 && offset1 <= s -> buf_end - s -> buffer )
s -> buf_ptr = s -> buffer + offset1;
if ( ( ! s -> seekable || offset1 <= s -> buf_end + 4096 - s -> buffer ) && ! s -> write_flag && offset1 >= 0 && ( ! s -> direct || ! s -> seek ) && ( whence != 2 || force ) )
while ( s -> pos < offset && ! s -> eof_reached )
s -> buf_ptr = s -> buf_end + offset - s -> pos;
if ( ( res = ( ( s -> seek ) ( s -> opaque , offset , 0 ) ) ) < 0 )
return res ;
s -> pos = offset;
s -> eof_reached = 0;
return offset ;
0
------------------------------
313604 80532/CWE134_Uncontrolled_Format_String__char_listen_socket_w32_vsnprintf_73a.cpp recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 222
static void goodB2G()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
dataList . push_back ( data );
dataList . push_back ( data );
dataList . push_back ( data );
0
------------------------------
21411 CVE-2015-4002/linux_kernel_4.0.5_CVE_2015_4002_drivers_staging_ozwpan_ozusbsvc1.c ei -> length = elt -> length + sizeof ( struct oz_elt ) 38
int oz_usb_control_req(void *hpd, u8 req_id, struct usb_ctrlrequest
const u8 *data, int data_len)
unsigned wvalue = le16_to_cpu ( setup -> wValue ) ;
if ( ( setup -> bRequestType & USB_TYPE_MASK ) == USB_TYPE_STANDARD )
switch ( setup -> bRequest )
rc = oz_usb_set_config_req ( hpd , req_id , ( u8 ) wvalue );
static int oz_usb_set_config_req(void *hpd, u8 req_id, u8 index)
struct oz_usb_ctx * usb_ctx = hpd ;
struct oz_pd * pd = usb_ctx -> pd ;
struct oz_elt_buf * eb = & pd -> elt_buff ;
struct oz_elt_info * ei = oz_elt_info_alloc ( & pd -> elt_buff ) ;
if ( ei == NULL )
return oz_usb_submit_elt ( eb , ei , usb_ctx , 0 , 0 ) ;
static int oz_usb_submit_elt(struct oz_elt_buf *eb, struct oz_elt_info
struct oz_usb_ctx *usb_ctx, u8 strid, u8 isoc)
struct oz_elt * elt = ( struct oz_elt * ) ei -> data ;
elt -> type = OZ_ELT_APP_DATA;
ei -> app_id = OZ_APPID_USB;
ei -> length = elt -> length + sizeof ( struct oz_elt );
ret = oz_queue_elt_info ( eb , isoc , strid , ei );
if ( ret )
oz_elt_info_free ( eb , ei );
return ret ;
0
------------------------------
302395 79247/CWE134_Uncontrolled_Format_String__char_connect_socket_vfprintf_06.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 107
void CWE134_Uncontrolled_Format_String__char_connect_socket_vfprintf_06_bad()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
if ( STATIC_CONST_FIVE == 5 )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
badVaSinkB ( data , data );
static void badVaSinkB(char * data, ...)
va_start ( args , data );
vfprintf ( stdout , data , args );
1
------------------------------
21281 CVE-2015-5307/linux_kernel_4.2.6_CVE_2015_5307_arch_x86_kvm_vmx.c u32 mask = 1 << ( seg * SEG_FIELD_NR + field ) ; 1518
static bool rmode_segment_valid(struct kvm_vcpu *vcpu, int seg)
struct kvm_segment var ;
vmx_get_segment ( vcpu , & var , seg );
static void vmx_get_segment(struct kvm_vcpu
struct kvm_segment *var, int seg)
struct vcpu_vmx * vmx = to_vmx ( vcpu ) ;
if ( vmx -> rmode . vm86_active && seg != VCPU_SREG_LDTR )
* var = vmx -> rmode . segs [ seg ];
if ( seg == VCPU_SREG_TR || var -> selector == vmx_read_guest_seg_selector ( vmx , seg ) )
var -> base = vmx_read_guest_seg_base ( vmx , seg );
static ulong vmx_read_guest_seg_base(struct vcpu_vmx *vmx, unsigned seg)
if ( ! vmx_segment_cache_test_set ( vmx , seg , SEG_FIELD_BASE ) )
static bool vmx_segment_cache_test_set(struct vcpu_vmx *vmx, unsigned
unsigned field)
u32 mask = 1 << ( seg * SEG_FIELD_NR + field ) ;
ret = vmx -> segment_cache . bitmask & mask;
vmx -> segment_cache . bitmask |= mask;
return ret ;
0
------------------------------
300446 152633/aviobuf.c s -> buf_end = s -> buffer + buffer_size 156
int avio_open2(AVIOContext **s,const char *filename,int flags,const AVIOInterruptCB *int_cb,AVDictionary **options)
URLContext * h ;
int err ;
err = ffurl_open ( & h , filename , flags , int_cb , options );
if ( err < 0 )
err = ffio_fdopen ( s , h );
int ffio_fdopen(AVIOContext **s,URLContext *h)
uint8_t * buffer ;
int buffer_size ;
int max_packet_size ;
max_packet_size = h -> max_packet_size;
if ( max_packet_size )
buffer_size = max_packet_size;
buffer_size = 32768;
buffer = ( av_malloc ( buffer_size ) );
if ( ! buffer )
* s = avio_alloc_context ( buffer , buffer_size , h -> flags & 2 , h , ( ( void * ) ffurl_read ) , ( ( void * ) ffurl_write ) , ( ( void * ) ffurl_seek ) );
AVIOContext *avio_alloc_context(unsigned char *buffer,int buffer_size,int write_flag,void *opaque,int (*read_packet)(void *, uint8_t *, int ),int (*write_packet)(void *, uint8_t *, int ),int64_t (*seek)(void *, int64_t , int ))
AVIOContext * s = ( av_mallocz ( sizeof ( AVIOContext ) ) ) ;
if ( ! s )
ffio_init_context ( s , buffer , buffer_size , write_flag , opaque , read_packet , write_packet , seek );
int ffio_init_context(AVIOContext *s,unsigned char *buffer,int buffer_size,int write_flag,void *opaque,int (*read_packet)(void *, uint8_t *, int ),int (*write_packet)(void *, uint8_t *, int ),int64_t (*seek)(void *, int64_t , int ))
s -> buffer = buffer;
s -> buffer_size = buffer_size;
s -> buf_ptr = buffer;
s -> opaque = opaque;
s -> direct = 0;
s -> write_packet = write_packet;
s -> read_packet = read_packet;
s -> seek = seek;
s -> pos = 0;
s -> must_flush = 0;
s -> eof_reached = 0;
s -> error = 0;
s -> seekable = 0x1;
s -> max_packet_size = 0;
s -> update_checksum = ( ( void * ) 0 );
if ( ! read_packet && ! write_flag )
s -> pos = buffer_size;
s -> buf_end = s -> buffer + buffer_size;
s -> read_pause = ( ( void * ) 0 );
s -> read_seek = ( ( void * ) 0 );
0
------------------------------
299985 151494/oids.c stonesoup_file_list = malloc ( stonesoup_num_files * sizeof ( FILE * ) ) 1447
void gombay_rockhearted(union mediaevalism_counterpleading *septuplet_tricephalus)
sephirah_reaccenting ( septuplet_tricephalus );
void sephirah_reaccenting(union mediaevalism_counterpleading *grovelingly_decentered)
sulliage_shenshai ( grovelingly_decentered );
void sulliage_shenshai(union mediaevalism_counterpleading *hostetter_marrilee)
dyfed_glibnesses ( hostetter_marrilee );
void dyfed_glibnesses(union mediaevalism_counterpleading *poodler_unspecific)
FILE * * stonesoup_file_list ;
FILE * stonesoup_files ;
char * * stonesoup_str_list ;
int stonesoup_num_files = 10 ;
sapremias_bergomask = ( ( char * ) ( * ( poodler_unspecific - 5 ) ) . unspiritualised_phagocytism );
stonesoup_str_list = malloc ( sizeof ( char * ) * stonesoup_num_files );
if ( stonesoup_str_list != 0 )
stonesoup_files = fopen ( sapremias_bergomask , "rb" );
if ( stonesoup_files != 0 )
stonesoup_file_list = malloc ( stonesoup_num_files * sizeof ( FILE * ) );
if ( stonesoup_file_list == 0 )
stonesoup_file_list [ stonesoup_ssi ] = fopen ( stonesoup_filename , "rb" );
while ( stonesoup_ssi < stonesoup_num_files )
stonesoup_file = stonesoup_file_list [ stonesoup_ssi ];
if ( stonesoup_file == 0 )
fseek ( stonesoup_file , 0 , 2 );
stonesoup_size = ftell ( stonesoup_file );
rewind ( stonesoup_file );
stonesoup_contents = malloc ( ( stonesoup_size + 1 ) * sizeof ( char ) );
if ( stonesoup_contents == 0 && errno == 12 )
if ( stonesoup_contents == 0 )
fclose ( stonesoup_file );
memset ( stonesoup_contents , 0 , ( stonesoup_size + 1 ) * sizeof ( char ) );
fread ( stonesoup_contents , 1 , stonesoup_size , stonesoup_file );
stonesoup_contents = stonesoup_isAlphaNum ( stonesoup_contents , stonesoup_size );
char *stonesoup_isAlphaNum(char *str,int size_param)
for (index = 0; index < size_param; index++)
if ( ! stonesoup_isalnum ( str [ index ] ) )
int stonesoup_isalnum(int c)
if ( ( c >= 97 && c <= 122 ) || ( c >= 65 && c <= 90 ) || ( c >= 48 && c <= 57 ) )
return str ;
stonesoup_str_list [ stonesoup_ssi ] = stonesoup_contents;
fclose ( stonesoup_file );
stonesoup_ssi ++;
if ( stonesoup_file_list != 0 )
free ( stonesoup_file_list );
stonesoup_cleanup ( stonesoup_str_list , stonesoup_num_files );
void stonesoup_cleanup(char **ptrs,int size)
for (; i < size; ++i)
if ( ptrs [ i ] != 0 )
free ( ptrs [ i ] );
free ( stonesoup_str_list );
1
------------------------------
312529 152495/oids.c * left = len - i 1161
const gchar *oid_resolved_from_string(const gchar *oid_str)
guint32 * subid_oid ;
guint subid_oid_length = oid_string2subid ( oid_str , & subid_oid ) ;
guint oid_string2subid(const char *str,guint32 **subids_p)
const char * r = str ;
guint32 * subids ;
guint32 * subids_overflow ;
guint n = check_num_oid ( str ) ;
guint64 subid = 0 ;
if ( ! n )
return 0 ;
* subids_p = subids = ( ep_alloc0 ( sizeof ( guint32 ) * n ) );
subids_overflow = subids + n;
switch ( * r )
subid = 0;
subids ++;
subid *= 10;
subid += ( ( * r ) - 48 );
if ( subids >= subids_overflow || subid > 0xffffffff )
return 0 ;
return 0 ;
while ( * ( r ++ ) )
return n ;
return oid_resolved ( subid_oid_length , subid_oid ) ;
const gchar *oid_resolved(guint32 num_subids,guint32 *subids)
oid_info_t * oid ;
if ( ! ( subids && * subids <= 2 ) )
oid = oid_get ( num_subids , subids , & matched , & left );
oid_info_t *oid_get(guint len,guint32 *subids,guint *matched,guint *left)
oid_info_t * curr_oid = & oid_root ;
guint i ;
if ( ! ( subids && * subids <= 2 ) )
for (i = 0; i < len; i++)
oid_info_t * next_oid = ( emem_tree_lookup32 ( ( curr_oid -> children ) , subids [ i ] ) ) ;
if ( next_oid )
curr_oid = next_oid;
* left = len - i;
0
------------------------------
302012 149942/aviobuf.c s -> buf_end = dst + len 562
int ff_get_line(AVIOContext *s,char *buf,int maxlen)
char c ;
c = ( avio_r8 ( s ) );
while ( c != 10 && c )
int avio_r8(AVIOContext *s)
if ( s -> buf_ptr >= s -> buf_end )
fill_buffer ( s );
static void fill_buffer(AVIOContext *s)
uint8_t * dst = ! s -> max_packet_size && s -> buf_end - s -> buffer < ( s -> buffer_size ) ? s -> buf_end : s -> buffer ;
int len = ( ( s -> buffer_size ) - ( dst - s -> buffer ) ) ;
int max_buffer_size = s -> max_packet_size ? s -> max_packet_size : 32768 ;
if ( ! s -> read_packet && s -> buf_ptr >= s -> buf_end )
s -> eof_reached = 1;
if ( s -> eof_reached )
if ( s -> update_checksum && dst == s -> buffer )
if ( s -> buf_end > s -> checksum_ptr )
s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_end - s -> checksum_ptr ) ) );
s -> checksum_ptr = s -> buffer;
if ( s -> read_packet && s -> buffer_size > max_buffer_size )
s -> checksum_ptr = dst = s -> buffer;
len = s -> buffer_size;
if ( s -> read_packet )
len = ( ( s -> read_packet ) ( s -> opaque , dst , len ) );
len = 0;
if ( len <= 0 )
s -> eof_reached = 1;
if ( len < 0 )
s -> error = len;
s -> pos += len;
s -> buf_ptr = dst;
s -> buf_end = dst + len;
s -> bytes_read += len;
0
------------------------------
299570 151287/file_wrappers.c data_size = mg_get_var ( conn , "data" , stonesoup_tainted_buff , buffer_size * sizeof ( char ) ) 114
static int stonesoup_ev_handler(struct mg_connection *conn, enum mg_event ev)
char * ifmatch_header ;
char * stonesoup_tainted_buff ;
int buffer_size = 1000 ;
if ( ev == MG_REQUEST )
ifmatch_header = ( char * ) mg_get_header ( conn , "if-match" );
if ( strcmp ( ifmatch_header , "weak_taint_source_value" ) == 0 )
while ( 1 )
stonesoup_tainted_buff = ( char * ) malloc ( buffer_size * sizeof ( char ) );
data_size = mg_get_var ( conn , "data" , stonesoup_tainted_buff , buffer_size * sizeof ( char ) );
if ( data_size < buffer_size )
buffer_size = buffer_size * 2;
0
------------------------------
304643 84368/CWE190_Integer_Overflow__unsigned_int_fscanf_square_03.c unsigned int result = data * data ; 67
static void goodB2G1()
unsigned int data ;
data = 0;
if ( 5 != 5 )
if ( abs ( ( long ) data ) <= ( long ) sqrt ( ( double ) UINT_MAX ) )
unsigned int result = data * data ;
printUnsignedLine ( result );
void printUnsignedLine(unsigned unsignedNumber)
printf ( "%u\n" , unsignedNumber );
0
------------------------------
305311 94247/CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_06.c recvResult = recv ( acceptSocket , ( char * ) ( password + passwordLen ) , ( 100 - passwordLen - 1 ) * sizeof ( wchar_t ) , 0 ) 199
static void goodB2G1()
wchar_t * password ;
wchar_t passwordBuffer [ 100 ] = L ""
password = passwordBuffer;
if ( STATIC_CONST_FIVE == 5 )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t passwordLen = wcslen ( password ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( password + passwordLen ) , ( 100 - passwordLen - 1 ) * sizeof ( wchar_t ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
311368 152169/aviobuf.c s -> buf_end = dst + len 490
int ff_get_line(AVIOContext *s,char *buf,int maxlen)
char c ;
c = ( avio_r8 ( s ) );
while ( c != 10 && c )
int avio_r8(AVIOContext *s)
if ( s -> buf_ptr >= s -> buf_end )
fill_buffer ( s );
static void fill_buffer(AVIOContext *s)
uint8_t * dst = ! s -> max_packet_size && s -> buf_end - s -> buffer < ( s -> buffer_size ) ? s -> buf_end : s -> buffer ;
int len = ( ( s -> buffer_size ) - ( dst - s -> buffer ) ) ;
int max_buffer_size = s -> max_packet_size ? s -> max_packet_size : 32768 ;
if ( ! s -> read_packet && s -> buf_ptr >= s -> buf_end )
s -> eof_reached = 1;
if ( s -> eof_reached )
if ( s -> update_checksum && dst == s -> buffer )
if ( s -> buf_end > s -> checksum_ptr )
s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_end - s -> checksum_ptr ) ) );
s -> checksum_ptr = s -> buffer;
if ( s -> read_packet && s -> buffer_size > max_buffer_size )
s -> checksum_ptr = dst = s -> buffer;
len = s -> buffer_size;
if ( s -> read_packet )
len = ( ( s -> read_packet ) ( s -> opaque , dst , len ) );
len = 0;
if ( len <= 0 )
s -> eof_reached = 1;
if ( len < 0 )
s -> error = len;
s -> pos += len;
s -> buf_ptr = dst;
s -> buf_end = dst + len;
s -> bytes_read += len;
0
------------------------------
17817 CVE-2015-7220/Firefox_42.0b9_CVE_2015_7220_js_src_vm_Xdr.cpp size_t nbytes = nchars * sizeof ( char16_t ) ; 74
XDRState<mode>::codeChars(char16_t* chars, size_t nchars)
size_t nbytes = nchars * sizeof ( char16_t ) ;
uint8_t * ptr = buf . write ( nbytes ) ;
if ( ! ptr )
mozilla :: NativeEndian :: copyAndSwapToLittleEndian ( ptr , chars , nchars );
const uint8_t * ptr = buf . read ( nbytes ) ;
mozilla :: NativeEndian :: copyAndSwapFromLittleEndian ( chars , ptr , nchars );
0
------------------------------
300491 152633/aviobuf.c s -> buf_ptr = s -> buffer + offset1 266
int64_t avio_skip(AVIOContext *s,int64_t offset)
return avio_seek ( s , offset , 1 ) ;
int64_t avio_seek(AVIOContext *s,int64_t offset,int whence)
int64_t offset1 ;
int64_t pos ;
whence &= ~0x20000;
if ( ! s )
pos = s -> pos - ( ( s -> write_flag ? 0 : s -> buf_end - s -> buffer ) );
if ( whence != 1 && whence != 0 )
if ( whence == 1 )
offset1 = pos + ( s -> buf_ptr - s -> buffer );
if ( offset == 0 )
offset += offset1;
offset1 = offset - pos;
if ( ! s -> must_flush && ( ! s -> direct || ! s -> seek ) && offset1 >= 0 && offset1 <= s -> buf_end - s -> buffer )
s -> buf_ptr = s -> buffer + offset1;
0
------------------------------
302977 79308/CWE134_Uncontrolled_Format_String__char_connect_socket_vprintf_21.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 211
static void goodB2G1()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
goodB2G1_vasink ( data , data );
static void goodB2G1_vasink(char * data, ...)
va_start ( args , data );
0
------------------------------
310107 152043/utils.c ret = avio_read ( s , pkt -> data + old_size , size ) 407
int av_append_packet(AVIOContext *s,AVPacket *pkt,int size)
int ret ;
int old_size ;
if ( ! pkt -> size )
old_size = pkt -> size;
ret = av_grow_packet ( pkt , size );
if ( ret < 0 )
ret = avio_read ( s , pkt -> data + old_size , size );
av_shrink_packet ( pkt , old_size + ( ( ret > 0 ? ret : 0 ) ) );
return ret ;
0
------------------------------
312670 150896/mem_dbg.c dirpath = ( char * ) malloc ( size_dirpath * sizeof ( char ) ) 227
void stonesoup_setup_printf_context()
ss_tc_root = getenv ( "SS_TC_ROOT" );
if ( ss_tc_root != NULL )
size_dirpath = strlen ( ss_tc_root ) + strlen ( "testData" ) + 2;
dirpath = ( char * ) malloc ( size_dirpath * sizeof ( char ) );
if ( dirpath != NULL )
sprintf ( dirpath , "%s/%s" , ss_tc_root , "testData" );
if ( stat ( dirpath , & st ) == - 1 )
retval = mkdir ( dirpath , 0700 );
if ( retval == 0 )
size_filepath = strlen ( dirpath ) + strlen ( "logfile.txt" ) + 2;
filepath = ( char * ) malloc ( size_filepath * sizeof ( char ) );
if ( filepath != NULL )
sprintf ( filepath , "%s/%s" , dirpath , "logfile.txt" );
stonesoup_printf_context = fopen ( filepath , "w" );
free ( filepath );
free ( dirpath );
if ( stonesoup_printf_context == NULL )
0
------------------------------
300600 150204/mutex.c filepath = ( char * ) malloc ( size_filepath * sizeof ( char ) ) 53
void stonesoup_setup_printf_context()
ss_tc_root = getenv ( "SS_TC_ROOT" );
if ( ss_tc_root != NULL )
size_dirpath = strlen ( ss_tc_root ) + strlen ( "testData" ) + 2;
dirpath = ( char * ) malloc ( size_dirpath * sizeof ( char ) );
if ( dirpath != NULL )
sprintf ( dirpath , "%s/%s" , ss_tc_root , "testData" );
retval = 0;
if ( stat ( dirpath , & st ) == - 1 )
retval = mkdir ( dirpath , 0700 );
if ( retval == 0 )
size_filepath = strlen ( dirpath ) + strlen ( "logfile.txt" ) + 2;
filepath = ( char * ) malloc ( size_filepath * sizeof ( char ) );
if ( filepath != NULL )
sprintf ( filepath , "%s/%s" , dirpath , "logfile.txt" );
stonesoup_printf_context = fopen ( filepath , "w" );
free ( filepath );
if ( stonesoup_printf_context == NULL )
0
------------------------------
20104 CVE-2016-5829/linux_kernel_4.6.2_CVE_2016_5829_drivers_hid_usbhid_hiddev.c report_enum = hid -> report_enum + ( uref -> report_type - HID_REPORT_TYPE_MIN ) 141
static long hiddev_compat_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
return hiddev_ioctl ( file , cmd , ( unsigned long ) compat_ptr ( arg ) ) ;
static long hiddev_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
struct hiddev_list * list = file -> private_data ;
struct hiddev * hiddev = list -> hiddev ;
void __user * user_arg = ( void __user * ) arg ;
if ( ! hiddev -> exist )
switch ( cmd )
r = hiddev_ioctl_usage ( hiddev , cmd , user_arg );
static noinline int hiddev_ioctl_usage(struct hiddev *hiddev, unsigned int cmd, void __user *user_arg)
struct hid_device * hid = hiddev -> hid ;
struct hiddev_report_info rinfo ;
struct hiddev_usage_ref * uref ;
struct hid_report * report ;
struct hid_field * field ;
uref_multi = kmalloc ( sizeof ( struct hiddev_usage_ref_multi ) , GFP_KERNEL );
if ( ! uref_multi )
uref = & uref_multi -> uref;
if ( cmd == HIDIOCGUSAGES || cmd == HIDIOCSUSAGES )
if ( copy_from_user ( uref_multi , user_arg , sizeof ( * uref_multi ) ) )
if ( copy_from_user ( uref , user_arg , sizeof ( * uref ) ) )
switch ( cmd )
rinfo . report_type = uref -> report_type;
rinfo . report_id = uref -> report_id;
if ( ( report = hiddev_lookup_report ( hid , & rinfo ) ) == NULL )
static struct hid_report
hiddev_lookup_report(struct hid_device *hid, struct hiddev_report_info *rinfo)
unsigned int flags = rinfo -> report_id & ~HID_REPORT_ID_MASK ;
unsigned int rid = rinfo -> report_id & HID_REPORT_ID_MASK ;
struct hid_report_enum * report_enum ;
struct hid_report * report ;
struct list_head * list ;
if ( rinfo -> report_type < HID_REPORT_TYPE_MIN || rinfo -> report_type > HID_REPORT_TYPE_MAX )
return NULL ;
report_enum = hid -> report_enum + ( rinfo -> report_type - HID_REPORT_TYPE_MIN );
switch ( flags )
if ( list_empty ( & report_enum -> report_list ) )
return NULL ;
list = report_enum -> report_list . next;
report = list_entry ( list , struct hid_report , list )
rinfo -> report_id = report -> id;
report = report_enum -> report_id_hash [ rid ];
if ( ! report )
return NULL ;
list = report -> list . next;
if ( list == & report_enum -> report_list )
return NULL ;
report = list_entry ( list , struct hid_report , list )
rinfo -> report_id = report -> id;
return NULL ;
return report_enum -> report_id_hash [ rinfo -> report_id ] ;
if ( uref -> field_index >= report -> maxfield )
field = report -> field [ uref -> field_index ];
if ( uref -> usage_index >= field -> maxusage )
uref -> usage_code = field -> usage [ uref -> usage_index ] . hid;
if ( cmd != HIDIOCGUSAGE && cmd != HIDIOCGUSAGES && uref -> report_type == HID_REPORT_TYPE_INPUT )
if ( uref -> report_id == HID_REPORT_ID_UNKNOWN )
field = hiddev_lookup_usage ( hid , uref );
static struct hid_field
hiddev_lookup_usage(struct hid_device *hid, struct hiddev_usage_ref *uref)
struct hid_report_enum * report_enum ;
if ( uref -> report_type < HID_REPORT_TYPE_MIN || uref -> report_type > HID_REPORT_TYPE_MAX )
report_enum = hid -> report_enum + ( uref -> report_type - HID_REPORT_TYPE_MIN );
list_for_each_entry ( report , & report_enum -> report_list , list )
0
------------------------------
304046 83942/CWE190_Integer_Overflow__short_fscanf_square_09.c short result = data * data ; 141
static void goodG2B2()
short data ;
data = 0;
if ( GLOBAL_CONST_TRUE )
data = 2;
if ( GLOBAL_CONST_TRUE )
short result = data * data ;
printIntLine ( result );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
0
------------------------------
311158 153292/config.c stonesoup_other_buff [ stonesoup_other_size - stonesoup_i - 1 ] = infixation_faussebraie [ stonesoup_buff_size - stonesoup_i - 1 ] 1065
svn_error_t *svn_config_read3(svn_config_t **cfgp,const char *file,svn_boolean_t must_exist,svn_boolean_t section_names_case_sensitive,svn_boolean_t option_names_case_sensitive,apr_pool_t *result_pool)
int pitocin_pillage = 7 ;
union torpedoplane_aedility nematology_nondehiscent ;
char * middorsal_hateable ;
if ( __sync_bool_compare_and_swap ( & theoreticalism_protract , 0 , 1 ) )
if ( mkdir ( "/opt/stonesoup/workspace/lockDir" , 509U ) == 0 )
if ( middorsal_hateable != 0 )
nematology_nondehiscent . rejourn_bacilliform = middorsal_hateable;
upbring_order = & nematology_nondehiscent;
postmuscular_symbolisms ( pitocin_pillage , upbring_order );
void postmuscular_symbolisms(int polysulphide_cassena,union torpedoplane_aedility *plainnesses_chelmsford)
int stonesoup_size ;
polysulphide_cassena --;
if ( polysulphide_cassena > 0 )
infixation_faussebraie = ( ( char * ) ( * plainnesses_chelmsford ) . rejourn_bacilliform );
stonesoup_buff_size = strlen ( infixation_faussebraie ) + 1;
stonesoup_other_size = 64;
stonesoup_other_buff = ( char * ) malloc ( stonesoup_other_size * sizeof ( char ) );
if ( stonesoup_other_buff != NULL )
stonesoup_size = stonesoup_other_size < stonesoup_buff_size ? stonesoup_other_size : stonesoup_buff_size;
for (stonesoup_i = 0; stonesoup_i < stonesoup_size; stonesoup_i++)
stonesoup_other_buff [ stonesoup_other_size - stonesoup_i - 1 ] = infixation_faussebraie [ stonesoup_buff_size - stonesoup_i - 1 ];
for (stonesoup_i = 0; stonesoup_i < stonesoup_buff_size; stonesoup_i++)
stonesoup_printf ( "%02x" , stonesoup_other_buff [ stonesoup_other_size - stonesoup_i - 1 ] );
void stonesoup_printf(char * format, ...)
va_start ( argptr , format );
vfprintf ( stonesoup_printf_context , format , argptr );
free ( stonesoup_other_buff );
tracepoint ( stonesoup_trace , variable_signed_integral , "stonesoup_other_size" , stonesoup_other_size , & stonesoup_other_size , "TRIGGER-STATE" );
1
------------------------------
307036 119912/CWE78_OS_Command_Injection__char_listen_socket_execlp_02.c recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 116
void CWE78_OS_Command_Injection__char_listen_socket_execlp_02_bad()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
if ( 1 )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
0
------------------------------
306555 120719/CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_spawnv_68a.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 ) 107
void CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_spawnv_68_bad()
wchar_t * data ;
wchar_t dataBuffer [ 100 ] = L ""
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
303432 79098/CWE134_Uncontrolled_Format_String__char_connect_socket_fprintf_01.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 88
void CWE134_Uncontrolled_Format_String__char_connect_socket_fprintf_01_bad()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
fprintf ( stdout , data );
1
------------------------------
304235 84674/CWE190_Integer_Overflow__unsigned_int_rand_square_31.c unsigned int result = data * data ; 76
static void goodB2G()
unsigned int data ;
data = 0;
data = ( unsigned int ) RAND32 ( );
unsigned int dataCopy = data ;
unsigned int data = dataCopy ;
if ( abs ( ( long ) data ) <= ( long ) sqrt ( ( double ) UINT_MAX ) )
unsigned int result = data * data ;
printUnsignedLine ( result );
void printUnsignedLine(unsigned unsignedNumber)
printf ( "%u\n" , unsignedNumber );
0
------------------------------
304975 82971/CWE190_Integer_Overflow__int64_t_rand_square_82_goodB2G.cpp int64_t result = data * data ; 32
static void goodB2G()
int64_t data ;
data = 0L L
data = ( int64_t ) RAND64 ( );
CWE190_Integer_Overflow__int64_t_rand_square_82_base * baseObject = new CWE190_Integer_Overflow__int64_t_rand_square_82_goodB2G
baseObject -> action ( data );
void CWE190_Integer_Overflow__int64_t_rand_square_82_goodB2G::action(int64_t data)
if ( abs ( ( long ) data ) <= ( long ) sqrt ( ( double ) LLONG_MAX ) )
int64_t result = data * data ;
printLongLongLine ( result );
void printLongLongLine (int64_t longLongIntNumber)
printf ( "%lld\n" , longLongIntNumber );
0
------------------------------
306758 110359/CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_connect_socket_84_bad.cpp intPointer = ( int * ) malloc ( data * sizeof ( int ) ) 113
void bad()
int data ;
data = - 1;
CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_connect_socket_84_bad * badObject = new CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_connect_socket_84_bad ( data ) ;
CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_connect_socket_84_bad::CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_connect_socket_84_bad(int dataCopy)
data = dataCopy;
WSADATA wsaData ;
int wsaDataInit = 0 ;
int recvResult ;
struct sockaddr_in service ;
SOCKET connectSocket = INVALID_SOCKET ;
char inputBuffer [ CHAR_ARRAY_SIZE ] ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
break ;
wsaDataInit = 1;
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
break ;
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
break ;
recvResult = recv ( connectSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
break ;
inputBuffer [ recvResult ] = '\0';
data = atoi ( inputBuffer );
while ( 0 )
if ( connectSocket != INVALID_SOCKET )
CLOSE_SOCKET ( connectSocket );
if ( wsaDataInit )
WSACleanup ( );
delete badObject
CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_connect_socket_84_bad::~CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_connect_socket_84_bad()
int * intPointer ;
intPointer = ( int * ) malloc ( data * sizeof ( int ) );
intPointer [ i ] = 0;
printIntLine ( intPointer [ 0 ] );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
free ( intPointer );
1
------------------------------
21389 CVE-2015-5307/linux_kernel_4.2.6_CVE_2015_5307_arch_x86_kvm_vmx.c u32 mask = 1 << ( seg * SEG_FIELD_NR + field ) ; 1518
static int nested_vmx_check_permission(struct kvm_vcpu *vcpu)
struct kvm_segment cs ;
struct vcpu_vmx * vmx = to_vmx ( vcpu ) ;
if ( ! vmx -> nested . vmxon )
vmx_get_segment ( vcpu , & cs , VCPU_SREG_CS );
static void vmx_get_segment(struct kvm_vcpu
struct kvm_segment *var, int seg)
struct vcpu_vmx * vmx = to_vmx ( vcpu ) ;
u32 ar ;
if ( vmx -> rmode . vm86_active && seg != VCPU_SREG_LDTR )
ar = vmx_read_guest_seg_ar ( vmx , seg );
static u32 vmx_read_guest_seg_ar(struct vcpu_vmx *vmx, unsigned seg)
if ( ! vmx_segment_cache_test_set ( vmx , seg , SEG_FIELD_AR ) )
static bool vmx_segment_cache_test_set(struct vcpu_vmx *vmx, unsigned
unsigned field)
u32 mask = 1 << ( seg * SEG_FIELD_NR + field ) ;
ret = vmx -> segment_cache . bitmask & mask;
vmx -> segment_cache . bitmask |= mask;
return ret ;
0
------------------------------
302711 80356/CWE134_Uncontrolled_Format_String__char_listen_socket_snprintf_11.c recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 207
static void goodB2G1()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
if ( globalReturnsTrue ( ) )
int globalReturnsTrue()
return 1 ;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
SNPRINTF ( dest , 100 - 1 , "%s" , data );
0
------------------------------
306040 109973/CWE666_Operation_on_Resource_in_Wrong_Phase_of_Lifetime__accept_listen_bind_11.c recvResult = recv ( acceptSocket , ( char * ) data + dataLen , ( int ) ( 100 - dataLen - 1 ) , 0 ) 93
void CWE666_Operation_on_Resource_in_Wrong_Phase_of_Lifetime__accept_listen_bind_11_bad()
if ( globalReturnsTrue ( ) )
int globalReturnsTrue()
return 1 ;
char data [ 100 ] = "" ;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) data + dataLen , ( int ) ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ recvResult ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
printLine ( data );
void printLine (const char * line)
if ( line != NULL )
printf ( "%s\n" , line );
1
------------------------------
19380 CVE-2015-2726/Firefox_38.8.0esr_CVE_2015_2726_js_src_ctypes_CTypes.cpp * dstlenp = ( origDstlen - dstlen ) 162

StructType::FieldSetter(JSContext* cx, HandleObject obj, HandleId idval, bool strict, MutableHandleValue vp)
if ( ! CData :: IsCData ( obj ) )

CData::IsCData(JSObject* obj)
return JS_GetClass ( obj ) == & sCDataClass ;
JSObject * typeObj = CData :: GetCType ( obj ) ;

CData::GetCType(JSObject* dataObj)
jsval slot = JS_GetReservedSlot ( dataObj , SLOT_CTYPE ) ;
JSObject * typeObj = slot . toObjectOrNull ( ) ;
return typeObj ;
if ( CType :: GetTypeCode ( typeObj ) != TYPE_struct )

CType::GetTypeCode(JSObject* typeObj)
jsval result = JS_GetReservedSlot ( typeObj , SLOT_TYPECODE ) ;
return TypeCode ( result . toInt32 ( ) ) ;
const FieldInfo * field = LookupField ( cx , typeObj , JSID_TO_FLAT_STRING ( idval ) ) ;
if ( ! field )
char * data = static_cast < char * > ( CData :: GetData ( obj ) ) + field -> mOffset

CData::GetData(JSObject* dataObj)
void * * buffer = static_cast < void * * > slot . toPrivate ( )
return * buffer ;
return ImplicitConvert ( cx , vp , field -> mType , data , false , nullptr ) ;
static
ImplicitConvert(JSContext*
HandleValue
JSObject*
void*
bool
bool* freePointer)
RootedObject targetType ( cx , targetType_ ) ;
JSObject * sourceData = nullptr ;
JSObject * sourceType = nullptr ;
RootedObject valObj ( cx , nullptr ) ;
if ( val . isObject ( ) )
valObj = & val . toObject ( );
if ( CData :: IsCData ( valObj ) )
sourceData = valObj;
sourceType = CData :: GetCType ( sourceData );
if ( CType :: TypesEqual ( sourceType , targetType ) )
if ( CDataFinalizer :: IsCDataFinalizer ( valObj ) )
sourceData = valObj;
sourceType = CDataFinalizer :: GetCType ( cx , sourceData );
CDataFinalizer :: Private * p = ( CDataFinalizer :: Private * ) JS_GetPrivate ( sourceData ) ;
if ( ! p )
if ( CType :: TypesEqual ( sourceType , targetType ) )
TypeCode targetCode = CType :: GetTypeCode ( targetType ) ;
switch ( targetCode )
bool result ;
if ( ! jsvalToBool ( cx , val , & result ) )
* static_cast < bool * > ( buffer ) = result
type result ;
type result ;
type result ;
if ( ! jsvalToFloat ( cx , val , & result ) )
* static_cast < type * > ( buffer ) = result
if ( val . isNull ( ) )
* static_cast < void * * > ( buffer ) = nullptr
JS :: Rooted < JSObject * > baseType ( cx , PointerType :: GetBaseType ( targetType ) ) ;
if ( sourceData )
TypeCode sourceCode = CType :: GetTypeCode ( sourceType ) ;
bool voidptrTarget = CType :: GetTypeCode ( baseType ) == TYPE_void_t ;
if ( sourceCode == TYPE_pointer && voidptrTarget )
if ( sourceCode == TYPE_array )
JSObject * elementType = ArrayType :: GetBaseType ( sourceType ) ;
if ( voidptrTarget || CType :: TypesEqual ( baseType , elementType ) )
* static_cast < void * * > ( buffer ) = sourceBuffer
if ( isArgument && val . isString ( ) )
if ( val . isObject ( ) && JS_IsArrayBufferObject ( valObj ) )
if ( val . isObject ( ) && JS_IsArrayBufferViewObject ( valObj ) )
if ( ! CanConvertTypedArrayItemTo ( baseType , valObj , cx ) )
if ( ! isArgument )
void * ptr ;
JS :: AutoCheckCannotGC nogc ;
ptr = JS_GetArrayBufferViewData ( valObj , nogc );
if ( ! ptr )
* static_cast < void * * > ( buffer ) = ptr
RootedObject baseType ( cx , ArrayType :: GetBaseType ( targetType ) ) ;
size_t targetLength = ArrayType :: GetLength ( targetType ) ;
if ( val . isString ( ) )
JSString * sourceString = val . toString ( ) ;
JSLinearString * sourceLinear = sourceString -> ensureLinear ( cx ) ;
if ( ! sourceLinear )
switch ( CType :: GetTypeCode ( baseType ) )
size_t nbytes = GetDeflatedUTF8StringLength ( cx , sourceLinear ) ;
if ( nbytes == ( size_t ) - 1 )
if ( targetLength < nbytes )
char * charBuffer = static_cast < char * > buffer
ASSERT_OK ( DeflateStringToUTF8Buffer ( cx , sourceLinear , charBuffer , & nbytes ) );
template <typename

DeflateStringToUTF8Buffer(JSContext* maybecx, const CharT* src, size_t
char* dst, size_t* dstlenp)
size_t i , utf8Len ;
char16_t c , c2 ;
uint32_t v ;
uint8_t utf8buf [ 6 ] ;
size_t dstlen = * dstlenp ;
size_t origDstlen = dstlen ;
while ( srclen )
c = * src ++;
srclen --;
if ( c >= 0xDC00 && c <= 0xDFFF )
if ( c < 0xD800 || c > 0xDBFF )
v = c;
if ( srclen < 1 )
c2 = * src;
if ( ( c2 < 0xDC00 ) || ( c2 > 0xDFFF ) )
src ++;
srclen --;
v = ( ( c - 0xD800 ) << 10 ) + ( c2 - 0xDC00 ) + 0x10000;
if ( v < 0x0080 )
if ( dstlen == 0 )
utf8Len = 1;
utf8Len = js_OneUcs4ToUtf8Char ( utf8buf , v );
if ( utf8Len > dstlen )
dstlen -= utf8Len;
* dstlenp = ( origDstlen - dstlen );
0
------------------------------
19508 CVE-2015-2726/Firefox_38.8.0esr_CVE_2015_2726_js_src_ctypes_CTypes.cpp IntegerType ii = i / IntegerType ( radix ) ; 2083
static
BuildTypeSource(JSContext*
JSObject*
bool
AutoString& result)
RootedObject typeObj ( cx , typeObj_ ) ;
switch ( CType :: GetTypeCode ( typeObj ) )
FunctionInfo * fninfo = FunctionType :: GetFunctionInfo ( typeObj ) ;
BuildTypeSource ( cx , fninfo -> mReturnType , true , result );
static
BuildTypeSource(JSContext*
JSObject*
bool
AutoString& result)
RootedObject typeObj ( cx , typeObj_ ) ;
switch ( CType :: GetTypeCode ( typeObj ) )
FunctionInfo * fninfo = FunctionType :: GetFunctionInfo ( typeObj ) ;
if ( fninfo -> mArgTypes . length ( ) > 0 )
for (size_t i = 0; i < fninfo->mArgTypes.length(); ++i)
BuildTypeSource ( cx , fninfo -> mArgTypes [ i ] , true , result );
static
BuildTypeSource(JSContext*
JSObject*
bool
AutoString& result)
RootedObject typeObj ( cx , typeObj_ ) ;
switch ( CType :: GetTypeCode ( typeObj ) )
size_t length ;
if ( ArrayType :: GetSafeLength ( typeObj , & length ) )
IntegerToString ( length , 10 , result );
template<class IntegerType, class CharType, size_t N, class

IntegerToString(IntegerType i, int radix, Vector<CharType, N, AP>& result)
IntegerType ii = i / IntegerType ( radix ) ;
size_t index = sign * size_t ( i - ii * IntegerType ( radix ) ) ;
* -- cp = "0123456789abcdefghijklmnopqrstuvwxyz" [ index ];
i = ii;
while ( i != 0 )
* -- cp = '-';
MOZ_ASSERT ( cp >= buffer );
result . append ( cp , end );
0
------------------------------
313133 95707/CWE36_Absolute_Path_Traversal__char_connect_socket_open_42.cpp recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ) 95
void bad()
char * data ;
char dataBuffer [ FILENAME_MAX ] = "" ;
data = dataBuffer;
data = badSource ( data );
static char * badSource(char * data)
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
return data ;
0
------------------------------
314719 110653/CWE680_Integer_Overflow_to_Buffer_Overflow__new_fgets_06.cpp dataBytes = data * sizeof ( int ) 56
void bad()
int data ;
data = - 1;
if ( STATIC_CONST_FIVE == 5 )
char inputBuffer [ CHAR_ARRAY_SIZE ] = "" ;
if ( fgets ( inputBuffer , CHAR_ARRAY_SIZE , stdin ) != NULL )
data = atoi ( inputBuffer );
size_t dataBytes , i ;
dataBytes = data * sizeof ( int );
intPointer = ( int * ) new char [ dataBytes ];
intPointer [ i ] = 0;
printIntLine ( intPointer [ 0 ] );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
delete [ ] intPointer
1
------------------------------
304885 80696/CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_vfprintf_15.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 ) 103
void CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_vfprintf_15_bad()
wchar_t * data ;
wchar_t dataBuffer [ 100 ] = L ""
data = dataBuffer;
switch ( 6 )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
314134 110688/CWE680_Integer_Overflow_to_Buffer_Overflow__new_fgets_68b.cpp dataBytes = data * sizeof ( int ) 61
void goodG2BSink()
int data = CWE680_Integer_Overflow_to_Buffer_Overflow__new_fgets_68_goodG2BData ;
size_t dataBytes , i ;
dataBytes = data * sizeof ( int );
intPointer = ( int * ) new char [ dataBytes ];
intPointer [ i ] = 0;
printIntLine ( intPointer [ 0 ] );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
delete [ ] intPointer
0
------------------------------
20959 CVE-2015-4522/Firefox_40.0b9_CVE_2015_4522_intl_uconv_ucvlatin_nsUTF16ToUnicode.cpp srcEvenEnd = src + ( ( srcEnd - src ) & ~1 ) 87

nsUTF16ToUnicodeBase::UTF16ConvertToUnicode(const char *
int32_t *
char16_t *
int32_t *
bool aSwapBytes)
const char * src = aSrc ;
const char * srcEnd = aSrc + * aSrcLength ;
switch ( mState )
src += 2;
mState = STATE_NORMAL;
src ++;
mState = STATE_NORMAL;
if ( * aDestLength < 2 )
mState = STATE_NORMAL;
if ( src == srcEnd )
const char * srcEvenEnd ;
if ( mState == STATE_HALF_CODE_POINT )
srcEvenEnd = src + ( ( srcEnd - src ) & ~1 );
while ( src != srcEvenEnd )
0
------------------------------
20117 CVE-2016-2847/linux_kernel_4.3_CVE_2016_2847_fs_pipe.c struct pipe_buffer * buf = pipe -> bufs + i ; 612
static int fifo_open(struct inode *inode, struct file *filp)
struct pipe_inode_info * pipe ;
if ( inode -> i_pipe )
pipe = alloc_pipe_info ( );
struct pipe_inode_info *alloc_pipe_info(void)
struct pipe_inode_info * pipe ;
pipe = kzalloc ( sizeof ( struct pipe_inode_info ) , GFP_KERNEL );
if ( pipe )
pipe -> bufs = kzalloc ( sizeof ( struct pipe_buffer ) * PIPE_DEF_BUFFERS , GFP_KERNEL );
if ( pipe -> bufs )
return pipe ;
return NULL ;
if ( ! pipe )
pipe -> files = 1;
if ( unlikely ( inode -> i_pipe ) )
free_pipe_info ( pipe );
void free_pipe_info(struct pipe_inode_info *pipe)
int i ;
for (i = 0; i < pipe->buffers; i++)
struct pipe_buffer * buf = pipe -> bufs + i ;
if ( buf -> ops )
buf -> ops -> release ( pipe , buf );
0
------------------------------
17740 CVE-2016-5106/qemu_2.3.0_CVE-2016-5106_megasas.c cmd -> iov_size = dcmd_size - resid 1084
static void megasas_command_complete(SCSIRequest *req, uint32_t
size_t resid)
MegasasCmd * cmd = req -> hba_private ;
if ( cmd -> req != req )
cmd_status = megasas_finish_internal_command ( cmd , req , resid );
static int megasas_finish_internal_command(MegasasCmd
SCSIRequest *req, size_t resid)
if ( cmd -> frame -> header . frame_cmd == MFI_CMD_DCMD )
cmd -> iov_size -= resid;
retval = megasas_finish_internal_dcmd ( cmd , req );
static int megasas_finish_internal_dcmd(MegasasCmd
SCSIRequest *req)
int opcode ;
int lun = req -> lun ;
opcode = le32_to_cpu ( cmd -> frame -> dcmd . opcode );
switch ( opcode )
retval = megasas_pd_get_info_submit ( req -> dev , lun , cmd );
static int megasas_pd_get_info_submit(SCSIDevice *sdev, int
MegasasCmd *cmd)
struct mfi_pd_info * info = cmd -> iov_buf ;
size_t dcmd_size = sizeof ( struct mfi_pd_info ) ;
uint8_t cmdbuf [ 6 ] ;
SCSIRequest * req ;
size_t len , resid ;
if ( ! cmd -> iov_buf )
if ( info -> inquiry_data [ 0 ] != 0x7f && info -> vpd_page83 [ 0 ] == 0x7f )
req = scsi_req_new ( sdev , cmd -> index , lun , cmdbuf , cmd );
if ( ! req )
len = scsi_req_enqueue ( req );
if ( len > 0 )
cmd -> iov_size = len;
resid = dma_buf_read ( cmd -> iov_buf , dcmd_size , & cmd -> qsg );
cmd -> iov_size = dcmd_size - resid;
cmd -> iov_buf = NULL;
0
------------------------------
300385 153811/dfa.c buf_end = ( ( unsigned char * ) ( begin + i ) ) 3543
char *dfaexec(struct dfa *d,const char *begin,char *end,int allow_nl,size_t *count,int *backref)
const unsigned char * p ;
unsigned char eol = eolbyte ;
p = ( ( const unsigned char * ) begin );
* end = eol;
if ( d -> mb_cur_max > 1 )
prepare_wc_buf ( ( ( const char * ) p ) , end );
static void prepare_wc_buf(const char *begin,const char *end)
unsigned char eol = eolbyte ;
size_t remain_bytes ;
size_t i ;
remain_bytes = 0;
for (i = 0; i < (end - begin + 1); i++)
if ( remain_bytes == 0 )
remain_bytes = mbrtowc ( inputwcs + i , begin + i , ( end - begin ) - i + 1 , & mbs );
if ( remain_bytes < 1 || remain_bytes == ( ( size_t ) ( - 1 ) ) || remain_bytes == ( ( size_t ) ( - 2 ) ) || remain_bytes == 1 && inputwcs [ i ] == ( ( wchar_t ) begin [ i ] ) )
remain_bytes = 0;
inputwcs [ i ] = ( ( wchar_t ) begin [ i ] );
mblen_buf [ i ] = 0;
if ( begin [ i ] == eol )
mblen_buf [ i ] = remain_bytes;
remain_bytes --;
mblen_buf [ i ] = remain_bytes;
inputwcs [ i ] = 0;
remain_bytes --;
buf_end = ( ( unsigned char * ) ( begin + i ) );
0
------------------------------
299440 151068/file_wrappers.c off = here -> in + ( off2 - here -> out ) 1080
gint64 file_skip(FILE_T file,gint64 delta,int *err)
return file_seek ( file , delta , 1 , err ) ;
gint64 file_seek(FILE_T file,gint64 offset,int whence,int *err)
struct fast_seek_point * here ;
if ( whence == 0 )
offset -= file -> pos;
if ( file -> seek )
offset += file -> skip;
file -> seek = 0;
if ( offset < 0 && file -> next )
unsigned int had = ( unsigned int ) ( file -> next - file -> out ) ;
if ( - offset <= had )
if ( ( here = fast_seek_find ( file , file -> pos + offset ) ) && ( offset < 0 || offset > 1048576L || here -> compression == 1 ) )
static struct fast_seek_point *fast_seek_find(FILE_T file,gint64 pos)
struct fast_seek_point * smallest = ( ( void * ) 0 ) ;
struct fast_seek_point * item ;
guint low ;
guint i ;
guint max ;
if ( ! file -> fast_seek )
return ( ( void * ) 0 ) ;
for ((low = 0 , max = file -> fast_seek -> len); low < max; )
i = ( low + max ) / 2;
item = ( ( struct fast_seek_point * ) file -> fast_seek -> pdata [ i ] );
if ( pos < item -> out )
max = i;
if ( pos > item -> out )
smallest = item;
low = i + 1;
return item ;
return smallest ;
gint64 off ;
gint64 off2 ;
if ( here -> compression == 2 )
if ( here -> compression == 3 )
off2 = file -> pos + offset;
off = here -> in + ( off2 - here -> out );
if ( lseek ( file -> fd , off , 0 ) == ( - 1 ) )
file -> raw_pos = off;
file -> have = 0;
file -> eof = 0;
file -> seek = 0;
file -> err = 0;
file -> err_info = ( ( void * ) 0 );
file -> avail_in = 0;
z_stream * strm = & file -> strm ;
inflateReset ( strm );
strm -> adler = here -> data . zlib . adler;
strm -> total_out = here -> data . zlib . total_out;
FILE_T state = file ;
int ret = state -> avail_in == 0 && fill_in_buffer ( state ) == - 1 ? - 1 : ( ( state -> avail_in == 0 ? - 1 : ( ( state -> avail_in -- , * ( state -> next_in ++ ) ) ) ) ) ;
static int fill_in_buffer(FILE_T state)
if ( state -> err )
if ( state -> eof == 0 )
if ( raw_read ( state , state -> in , state -> size , ( ( unsigned int * ) ( & state -> avail_in ) ) ) == - 1 )
static int raw_read(FILE_T state,unsigned char *buf,unsigned int count,unsigned int *have)
* have = 0;
ret = ( read ( state -> fd , ( buf + * have ) , ( count - * have ) ) );
if ( ret <= 0 )
* have += ret;
state -> raw_pos += ret;
while ( * have < count )
if ( ret < 0 )
state -> err = * __errno_location ( );
state -> err_info = ( ( void * ) 0 );
if ( ret == 0 )
state -> eof = 1;
state -> next_in = state -> in;
if ( ret == - 1 )
if ( state -> err == 0 )
* err = state -> err;
( void ) ( inflatePrime ( strm , here -> data . zlib . bits , ret >> 8 - here -> data . zlib . bits ) );
( void ) ( inflateSetDictionary ( strm , here -> data . zlib . window , 32768 ) );
file -> compression = 2;
offset = file -> pos + offset - off2;
if ( offset )
file -> skip = offset;
return file -> pos + offset ;
0
------------------------------
302462 80542/CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_fprintf_05.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 ) 271
static void goodB2G2()
wchar_t * data ;
wchar_t dataBuffer [ 100 ] = L ""
data = dataBuffer;
if ( staticTrue )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
314062 110710/CWE680_Integer_Overflow_to_Buffer_Overflow__new_fixed_15.cpp dataBytes = data * sizeof ( int ) 82
static void goodG2B1()
int data ;
data = - 1;
switch ( 5 )
data = 20;
size_t dataBytes , i ;
dataBytes = data * sizeof ( int );
intPointer = ( int * ) new char [ dataBytes ];
intPointer [ i ] = 0;
printIntLine ( intPointer [ 0 ] );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
delete [ ] intPointer
0
------------------------------
301409 149948/aviobuf.c s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_ptr - s -> checksum_ptr ) ) ) 268
int avio_closep(AVIOContext **s)
int ret = avio_close ( * s ) ;
int avio_close(AVIOContext *s)
if ( ! s )
avio_flush ( s );
void avio_flush(AVIOContext *s)
flush_buffer ( s );
static void flush_buffer(AVIOContext *s)
if ( s -> buf_ptr > s -> buffer )
if ( s -> update_checksum )
s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_ptr - s -> checksum_ptr ) ) );
s -> checksum_ptr = s -> buffer;
s -> buf_ptr = s -> buffer;
0
------------------------------
301138 152156/tile-swap.c gap = tile_swap_gap_new ( offset + bytes , swap_file -> swap_file_end ) 668
void tile_swap_in(Tile *tile)
if ( tile -> swap_offset == ( - 1 ) )
tile_swap_command ( tile , SWAP_IN );
static void tile_swap_command(Tile *tile,gint command)
if ( gimp_swap_file -> fd == - 1 )
if ( gimp_swap_file -> fd == - 1 )
switch ( command )
tile_swap_default_out ( gimp_swap_file , tile );
static void tile_swap_default_out(SwapFile *swap_file,Tile *tile)
gint bytes ;
gint64 newpos ;
bytes = 64 * 64 * ( tile -> bpp );
if ( tile -> swap_offset == ( - 1 ) )
newpos = tile_swap_find_offset ( swap_file , bytes );
static gint64 tile_swap_find_offset(SwapFile *swap_file,gint64 bytes)
SwapFileGap * gap ;
GList * tmp ;
gint64 offset ;
tmp = swap_file -> gaps;
while ( tmp )
gap = ( tmp -> data );
if ( gap -> end - gap -> start >= bytes )
tmp = tmp -> next;
offset = swap_file -> swap_file_end;
if ( offset + bytes < swap_file -> swap_file_end )
gap = tile_swap_gap_new ( offset + bytes , swap_file -> swap_file_end );
swap_file -> gaps = g_list_append ( swap_file -> gaps , gap );
0
------------------------------
20920 CVE-2015-8962/linux_kernel_4.3_CVE_2015_8962_drivers_scsi_sg.c req_sz = vma -> vm_end - vma -> vm_start 1239
static
sg_mmap(struct file *filp, struct vm_area_struct *vma)
Sg_fd * sfp ;
unsigned long req_sz , len , sa ;
if ( ( ! filp ) || ( ! vma ) || ( ! ( sfp = ( Sg_fd * ) filp -> private_data ) ) )
req_sz = vma -> vm_end - vma -> vm_start;
SCSI_LOG_TIMEOUT ( 3 , sg_printk ( KERN_INFO , sfp -> parentdp , "sg_mmap starting, vm_start=%p, len=%d\n" , ( void * ) vma -> vm_start , ( int ) req_sz ) );
if ( req_sz > rsv_schp -> bufflen )
0
------------------------------
298489 94250/CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_09.c recvResult = recv ( acceptSocket , ( char * ) ( password + passwordLen ) , ( 100 - passwordLen - 1 ) * sizeof ( wchar_t ) , 0 ) 81
void CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_09_bad()
wchar_t * password ;
wchar_t passwordBuffer [ 100 ] = L ""
password = passwordBuffer;
if ( GLOBAL_CONST_TRUE )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t passwordLen = wcslen ( password ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( password + passwordLen ) , ( 100 - passwordLen - 1 ) * sizeof ( wchar_t ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
1
------------------------------
306851 119959/CWE78_OS_Command_Injection__char_listen_socket_popen_01.c recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 108
void CWE78_OS_Command_Injection__char_listen_socket_popen_01_bad()
char * data ;
char data_buf [ 100 ] = FULL_COMMAND ;
data = data_buf;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
pipe = POPEN ( data , "wb" );
if ( pipe != NULL )
PCLOSE ( pipe );
1
------------------------------
20745 CVE-2016-7913/linux_kernel_4.2.5_CVE_2016_7913_drivers_media_tuners_tuner-xc2028.c endp = p + priv -> firm [ pos ] . size 562
static int xc2028_set_analog_freq(struct dvb_frontend
struct analog_parameters *p)
struct xc2028_data * priv = fe -> tuner_priv ;
unsigned int type = 0 ;
if ( p -> mode == V4L2_TUNER_RADIO )
type |= FM;
if ( priv -> ctrl . input1 )
type |= INPUT1;
return generic_set_freq ( fe , ( 625l * p -> frequency ) / 10 , V4L2_TUNER_RADIO , type , 0 , 0 ) ;
static int generic_set_freq(struct dvb_frontend *fe, u32 freq
enum v4l2_tuner_type
unsigned int
v4l2_std_id
u16 int_freq)
if ( check_firmware ( fe , type , std , int_freq ) < 0 )
static int check_firmware(struct dvb_frontend *fe, unsigned int
v4l2_std_id std, __u16 int_freq)
struct xc2028_data * priv = fe -> tuner_priv ;
struct firmware_properties new_fw ;
int rc , retry_count = 0 ;
u16 version , hwmodel ;
v4l2_std_id std0 ;
rc = check_device_status ( priv );
if ( rc < 0 )
if ( priv -> ctrl . mts && ! ( type & FM ) )
type |= MTS;
new_fw . type = type;
new_fw . id = std;
new_fw . std_req = std;
new_fw . scode_table = SCODE | priv -> ctrl . scode_table;
new_fw . scode_nr = 0;
new_fw . int_freq = int_freq;
if ( ( priv -> state == XC2028_ACTIVE ) && ( ( ( BASE | new_fw . type ) & BASE_TYPES ) == ( priv -> cur_fw . type & BASE_TYPES ) ) )
memset ( & priv -> cur_fw , 0 , sizeof ( priv -> cur_fw ) );
rc = do_tuner_callback ( fe , XC2028_TUNER_RESET , 0 );
if ( rc < 0 )
std0 = 0;
rc = load_firmware ( fe , BASE | new_fw . type , & std0 );
if ( rc < 0 )
rc = load_firmware ( fe , BASE | INIT1 | new_fw . type , & std0 );
if ( rc == - ENOENT )
rc = load_firmware ( fe , ( BASE | INIT1 | new_fw . type ) & ~F8MHZ , & std0 );
if ( rc < 0 && rc != - ENOENT )
if ( priv -> cur_fw . type == ( BASE | new_fw . type ) && priv -> cur_fw . std_req == std )
priv -> cur_fw . scode_table = 0;
rc = load_firmware ( fe , new_fw . type , & new_fw . id );
if ( rc == - ENOENT )
rc = load_firmware ( fe , new_fw . type & ~F8MHZ , & new_fw . id );
if ( rc < 0 )
if ( xc2028_get_reg ( priv , 0x0004 , & version ) < 0 || xc2028_get_reg ( priv , 0x0008 , & hwmodel ) < 0 )
if ( priv -> ctrl . read_not_reliable )
if ( priv -> firm_version != ( ( version & 0xf0 ) << 4 | ( version & 0x0f ) ) )
if ( ! priv -> ctrl . read_not_reliable )
hwmodel = 3028;
if ( priv -> hwmodel == 0 && ( hwmodel == 2028 || hwmodel == 3028 ) )
priv -> hwmodel = hwmodel;
priv -> hwvers = version & 0xff00;
if ( priv -> hwmodel == 0 || priv -> hwmodel != hwmodel || priv -> hwvers != ( version & 0xff00 ) )
priv -> cur_fw = new_fw;
priv -> cur_fw . type |= BASE;
priv -> state = XC2028_ACTIVE;
priv -> state = XC2028_NO_FIRMWARE;
if ( retry_count < 8 )
retry_count ++;
static int load_firmware(struct dvb_frontend *fe, unsigned int
v4l2_std_id *id)
struct xc2028_data * priv = fe -> tuner_priv ;
int pos , rc ;
unsigned char * p , * endp , buf [ MAX_XFER_SIZE ] ;
if ( priv -> ctrl . max_len > sizeof ( buf ) )
priv -> ctrl . max_len = sizeof ( buf );
pos = seek_firmware ( fe , type , id );
if ( pos < 0 )
p = priv -> firm [ pos ] . ptr;
endp = p + priv -> firm [ pos ] . size;
while ( p < endp )
if ( p + sizeof ( size ) > endp )
if ( size + p > endp )
tuner_err ( "missing bytes: need %d, have %d\n" , size , ( int ) ( endp - p ) );
0
------------------------------
16411 CVE-2014-0160/CVE_2014_0160_PATCHED_tls1_process_heartbeat.c r = ssl3_write_bytes ( s , TLS1_RT_HEARTBEAT , buffer , 3 + payload + padding ) 43

CVE_2014_0160_PATCHED_tls1_process_heartbeat(SSL *s)
unsigned char * p = & s -> s3 -> rrec . data [ 0 ] , * pl ;
unsigned short hbtype ;
unsigned int payload ;
unsigned int padding = 16 ;
if ( 1 + 2 + 16 > s -> s3 -> rrec . length )
hbtype = * p ++;
if ( 1 + 2 + payload + 16 > s -> s3 -> rrec . length )
if ( hbtype == TLS1_HB_REQUEST )
unsigned char * buffer , * bp ;
int r ;
buffer = OPENSSL_malloc ( 1 + 2 + payload + padding );
r = ssl3_write_bytes ( s , TLS1_RT_HEARTBEAT , buffer , 3 + payload + padding );
1
------------------------------
305341 95458/CWE369_Divide_by_Zero__int_zero_divide_17.c printIntLine ( 100 / data ) 61
static void goodB2G()
int i , k ;
int data ;
data = - 1;
for(i = 0; i < 1; i++)
data = 0;
for(k = 0; k < 1; k++)
if ( data != 0 )
printIntLine ( 100 / data );
0
------------------------------
17476 CVE-2015-3331/CVE_2015_3331_VULN___driver_rfc4106_decrypt.c src = kmalloc ( req -> cryptlen + req -> assoclen , GFP_ATOMIC ) 49
static int CVE_2015_3331_VULN___driver_rfc4106_decrypt(struct aead_request *req)
u8 * src , * dst , * assoc ;
struct crypto_aead * tfm = crypto_aead_reqtfm ( req ) ;
unsigned long auth_tag_len = crypto_aead_authsize ( tfm ) ;
if ( unlikely ( ( req -> cryptlen < auth_tag_len ) || ( req -> assoclen != 8 && req -> assoclen != 12 ) ) )
if ( ( sg_is_last ( req -> src ) ) && ( sg_is_last ( req -> assoc ) ) )
src = kmalloc ( req -> cryptlen + req -> assoclen , GFP_ATOMIC );
0
------------------------------
314380 110629/CWE680_Integer_Overflow_to_Buffer_Overflow__new_connect_socket_51b.cpp dataBytes = data * sizeof ( int ) 54
void bad()
int data ;
data = - 1;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
char inputBuffer [ CHAR_ARRAY_SIZE ] ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
inputBuffer [ recvResult ] = '\0';
data = atoi ( inputBuffer );
while ( 0 )
badSink ( data );
void badSink(int data)
size_t dataBytes , i ;
dataBytes = data * sizeof ( int );
intPointer = ( int * ) new char [ dataBytes ];
intPointer [ i ] = 0;
printIntLine ( intPointer [ 0 ] );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
delete [ ] intPointer
1
------------------------------
298228 95159/CWE369_Divide_by_Zero__int_fscanf_divide_06.c printIntLine ( 100 / data ) 40
void CWE369_Divide_by_Zero__int_fscanf_divide_06_bad()
int data ;
data = - 1;
if ( STATIC_CONST_FIVE == 5 )
printIntLine ( 100 / data );
1
------------------------------
313829 110792/CWE680_Integer_Overflow_to_Buffer_Overflow__new_listen_socket_01.cpp dataBytes = data * sizeof ( int ) 124
void bad()
int data ;
data = - 1;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
char inputBuffer [ CHAR_ARRAY_SIZE ] ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
inputBuffer [ recvResult ] = '\0';
data = atoi ( inputBuffer );
while ( 0 )
size_t dataBytes , i ;
dataBytes = data * sizeof ( int );
intPointer = ( int * ) new char [ dataBytes ];
intPointer [ i ] = 0;
printIntLine ( intPointer [ 0 ] );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
delete [ ] intPointer
1
------------------------------
17593 CVE-2010-2538/CVE_2010_2538_VULN_btrfs_ioctl_clone.c skip = off - key . offset 236
static noinline long CVE_2010_2538_VULN_btrfs_ioctl_clone(struct file *file, unsigned long
u64 off, u64 olen, u64 destoff)
struct inode * inode = fdentry ( file ) -> d_inode ;
struct btrfs_root * root = BTRFS_I ( inode ) -> root ;
struct file * src_file ;
struct inode * src ;
struct btrfs_trans_handle * trans ;
struct btrfs_path * path ;
struct extent_buffer * leaf ;
char * buf ;
struct btrfs_key key ;
u32 nritems ;
int slot ;
int ret ;
u64 len = olen ;
u64 bs = root -> fs_info -> sb -> s_blocksize ;
if ( ! ( file -> f_mode & FMODE_WRITE ) )
ret = mnt_want_write ( file -> f_path . mnt );
if ( ret )
src_file = fget ( srcfd );
if ( ! src_file )
src = src_file -> f_dentry -> d_inode;
if ( src == inode )
if ( ! ( src_file -> f_mode & FMODE_READ ) )
if ( S_ISDIR ( src -> i_mode ) || S_ISDIR ( inode -> i_mode ) )
if ( src -> i_sb != inode -> i_sb || BTRFS_I ( src ) -> root != root )
ret = - ENOMEM;
buf = vmalloc ( btrfs_level_size ( root , 0 ) );
if ( ! buf )
path = btrfs_alloc_path ( );
if ( ! path )
path -> reada = 2;
if ( off >= src -> i_size || off + len > src -> i_size )
if ( len == 0 )
olen = len = src -> i_size - off;
if ( off + len == src -> i_size )
len = ( ( src -> i_size + bs - 1 ) & ~ ( bs - 1 ) ) - off;
if ( ( off & ( bs - 1 ) ) || ( ( off + len ) & ( bs - 1 ) ) )
trans = btrfs_start_transaction ( root , 1 );
key . objectid = src -> i_ino;
key . type = BTRFS_EXTENT_DATA_KEY;
key . offset = 0;
while ( 1 )
ret = btrfs_search_slot ( trans , root , & key , path , 0 , 0 );
if ( ret < 0 )
nritems = btrfs_header_nritems ( path -> nodes [ 0 ] );
if ( path -> slots [ 0 ] >= nritems )
ret = btrfs_next_leaf ( root , path );
if ( ret < 0 )
if ( ret > 0 )
leaf = path -> nodes [ 0 ];
slot = path -> slots [ 0 ];
if ( btrfs_key_type ( & key ) > BTRFS_EXTENT_DATA_KEY || key . objectid != src -> i_ino )
if ( btrfs_key_type ( & key ) == BTRFS_EXTENT_DATA_KEY )
struct btrfs_file_extent_item * extent ;
int type ;
u32 size ;
struct btrfs_key new_key ;
u64 datao = 0 , datal = 0 ;
u8 comp ;
size = btrfs_item_size_nr ( leaf , slot );
extent = btrfs_item_ptr ( leaf , slot
struct btrfs_file_extent_item )
comp = btrfs_file_extent_compression ( leaf , extent );
type = btrfs_file_extent_type ( leaf , extent );
if ( type == BTRFS_FILE_EXTENT_REG || type == BTRFS_FILE_EXTENT_PREALLOC )
datal = btrfs_file_extent_num_bytes ( leaf , extent );
if ( type == BTRFS_FILE_EXTENT_INLINE )
datal = btrfs_file_extent_ram_bytes ( leaf , extent );
if ( key . offset + datal < off || key . offset >= off + len )
memcpy ( & new_key , & key , sizeof ( new_key ) );
new_key . objectid = inode -> i_ino;
new_key . offset = key . offset + destoff - off;
if ( type == BTRFS_FILE_EXTENT_REG || type == BTRFS_FILE_EXTENT_PREALLOC )
ret = btrfs_insert_empty_item ( trans , root , path , & new_key , size );
if ( ret )
if ( type == BTRFS_FILE_EXTENT_INLINE )
u64 skip = 0 ;
u64 trim = 0 ;
if ( off > key . offset )
skip = off - key . offset;
new_key . offset += skip;
if ( key . offset + datal > off + len )
trim = key . offset + datal - ( off + len );
if ( comp && ( skip || trim ) )
size -= skip + trim;
ret = btrfs_insert_empty_item ( trans , root , path , & new_key , size );
if ( ret )
key . offset ++;
0
------------------------------
310297 151639/aviobuf.c s -> buf_end = dst + len 494
int64_t avio_skip(AVIOContext *s,int64_t offset)
return avio_seek ( s , offset , 1 ) ;
int64_t avio_seek(AVIOContext *s,int64_t offset,int whence)
int64_t offset1 ;
int64_t pos ;
int force = whence & 0x20000 ;
whence &= ~0x20000;
if ( ! s )
pos = s -> pos - ( ( s -> write_flag ? 0 : s -> buf_end - s -> buffer ) );
if ( whence != 1 && whence != 0 )
if ( whence == 1 )
offset1 = pos + ( s -> buf_ptr - s -> buffer );
if ( offset == 0 )
offset += offset1;
offset1 = offset - pos;
if ( ! s -> must_flush && ( ! s -> direct || ! s -> seek ) && offset1 >= 0 && offset1 <= s -> buf_end - s -> buffer )
if ( ( ! s -> seekable || offset1 <= s -> buf_end + 4096 - s -> buffer ) && ! s -> write_flag && offset1 >= 0 && ( ! s -> direct || ! s -> seek ) && ( whence != 2 || force ) )
while ( s -> pos < offset && ! s -> eof_reached )
fill_buffer ( s );
static void fill_buffer(AVIOContext *s)
uint8_t * dst = ! s -> max_packet_size && s -> buf_end - s -> buffer < ( s -> buffer_size ) ? s -> buf_end : s -> buffer ;
int len = ( ( s -> buffer_size ) - ( dst - s -> buffer ) ) ;
int max_buffer_size = s -> max_packet_size ? s -> max_packet_size : 32768 ;
if ( ! s -> read_packet && s -> buf_ptr >= s -> buf_end )
s -> eof_reached = 1;
if ( s -> eof_reached )
if ( s -> update_checksum && dst == s -> buffer )
if ( s -> buf_end > s -> checksum_ptr )
s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_end - s -> checksum_ptr ) ) );
s -> checksum_ptr = s -> buffer;
if ( s -> read_packet && s -> buffer_size > max_buffer_size )
s -> checksum_ptr = dst = s -> buffer;
len = s -> buffer_size;
if ( s -> read_packet )
len = ( ( s -> read_packet ) ( s -> opaque , dst , len ) );
len = 0;
if ( len <= 0 )
s -> eof_reached = 1;
if ( len < 0 )
s -> error = len;
s -> pos += len;
s -> buf_ptr = dst;
s -> buf_end = dst + len;
s -> bytes_read += len;
0
------------------------------
302556 79147/CWE134_Uncontrolled_Format_String__char_connect_socket_printf_02.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 265
static void goodB2G2()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
if ( 1 )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
printf ( "%s\n" , data );
0
------------------------------
17248 CVE-2008-0420/CVE_2008_0420_VULN_nsBMPDecoder__ProcessData.c PRUint32 rowSize = ( mBIH . bpp * mBIH . width + 7 ) / 8 ; 142
NS_METHOD CVE_2008_0420_VULN_nsBMPDecoder::ProcessData(const char* aBuffer, PRUint32 aCount)
if ( ! aCount || ! mCurLine )
if ( mPos < BFH_LENGTH )
PRUint32 toCopy = BFH_LENGTH - mPos ;
if ( toCopy > aCount )
toCopy = aCount;
mPos += toCopy;
aCount -= toCopy;
if ( mPos == BFH_LENGTH )
if ( mBFH . signature [ 0 ] != 'B' || mBFH . signature [ 1 ] != 'M' )
if ( mBFH . bihsize == OS2_BIH_LENGTH )
mLOH = OS2_HEADER_LENGTH;
if ( mPos >= BFH_LENGTH && mPos < mLOH )
PRUint32 toCopy = mLOH - mPos ;
if ( toCopy > aCount )
toCopy = aCount;
mPos += toCopy;
aCount -= toCopy;
if ( mPos == mLOH )
if ( mBIH . bpp != 1 && mBIH . bpp != 4 && mBIH . bpp != 8 && mBIH . bpp != 16 && mBIH . bpp != 24 && mBIH . bpp != 32 )
if ( mBIH . bpp <= 8 )
mNumColors = 1 << mBIH . bpp;
if ( mBIH . colors && mBIH . colors < mNumColors )
mNumColors = mBIH . colors;
mColors = new colorTable [ mNumColors ];
if ( ! mColors )
if ( mBIH . width < 0 )
mRow = new PRUint8 [ ( mBIH . width * mBIH . bpp ) / 8 + 4 ];
if ( ! mRow )
PRUint8 bpc ;
bpc = ( mBFH . bihsize == OS2_BIH_LENGTH ) ? 3 : 4;
if ( mColors && ( mPos >= mLOH && ( mPos < ( mLOH + mNumColors * bpc ) ) ) )
while ( aCount && ( mPos < ( mLOH + mNumColors * bpc ) ) )
mPos ++;
aCount --;
if ( aCount && mBIH . compression == BI_BITFIELDS && mPos < ( WIN_HEADER_LENGTH + BITFIELD_LENGTH ) )
PRUint32 toCopy = ( WIN_HEADER_LENGTH + BITFIELD_LENGTH ) - mPos ;
if ( toCopy > aCount )
toCopy = aCount;
mPos += toCopy;
aCount -= toCopy;
while ( aCount && ( mPos < mBFH . dataoffset ) )
mPos ++;
aCount --;
if ( aCount && ++ mPos >= mBFH . dataoffset )
if ( ! mBIH . compression || mBIH . compression == BI_BITFIELDS )
PRUint32 rowSize = ( mBIH . bpp * mBIH . width + 7 ) / 8 ;
1
------------------------------
305030 79110/CWE134_Uncontrolled_Format_String__char_connect_socket_fprintf_13.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 177
static void goodB2G1()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
if ( GLOBAL_CONST_FIVE == 5 )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
fprintf ( stdout , "%s\n" , data );
0
------------------------------
16587 CVE-2006-6333/CVE_2006_6333_PATCHED_tr_rx.c skb_size = length - lan_hdr_len + sizeof ( struct trh_hdr ) + sizeof ( struct trllc ) 87
static void CVE_2006_6333_PATCHED_tr_rx(struct net_device *dev)
unsigned int rbuffer_len , lan_hdr_len , hdr_len , ip_len , length ;
struct arb_rec_req rarb ;
lan_hdr_len = rarb . lan_hdr_len;
length = ntohs ( rarb . frame_len );
skb_size = length - lan_hdr_len + sizeof ( struct trh_hdr ) + sizeof ( struct trllc );
0
------------------------------
301924 151540/utils.c buf_size = ( buf_size > len ? buf_size - len : 0 ) 2379
void avcodec_string(char *buf,int buf_size,AVCodecContext *enc,int encode)
if ( ! buf || buf_size <= 0 )
if ( enc -> codec_tag )
char tag_buf [ 32 ] ;
av_get_codec_tag_string ( tag_buf , sizeof ( tag_buf ) , enc -> codec_tag );
size_t av_get_codec_tag_string(char *buf,size_t buf_size,unsigned int codec_tag)
int i ;
int len ;
for (i = 0; i < 4; i++)
len = snprintf ( buf , buf_size , ( ( ( codec_tag & 0xff ) >= 48 && ( codec_tag & 0xff ) <= '9' || ( codec_tag & 0xff ) >= 'a' && ( codec_tag & 0xff ) <= 'z' || ( codec_tag & 0xff ) >= 'A' && ( codec_tag & 0xff ) <= 'Z' || ( ( codec_tag & 0xff ) == '.' || ( codec_tag & 0xff ) == 32 || ( codec_tag & 0xff ) == '-' || ( codec_tag & 0xff ) == '_' ) ? "%c" : "[%d]" ) ) , codec_tag & 0xff );
buf += len;
buf_size = ( buf_size > len ? buf_size - len : 0 );
ret += len;
codec_tag >>= 8;
return ret ;
0
------------------------------
305290 103052/CWE427_Uncontrolled_Search_Path_Element__char_listen_socket_05.c recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 250 - dataLen - 1 ) , 0 ) 109
void CWE427_Uncontrolled_Search_Path_Element__char_listen_socket_05_bad()
char * data ;
char dataBuffer [ 250 ] = "PATH=" ;
data = dataBuffer;
if ( staticTrue )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 250 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
PUTENV ( data );
1
------------------------------
305145 94973/CWE369_Divide_by_Zero__int_connect_socket_divide_12.c printIntLine ( 100 / data ) 116
void CWE369_Divide_by_Zero__int_connect_socket_divide_12_bad()
int data ;
data = - 1;
if ( globalReturnsTrueOrFalse ( ) )
int globalReturnsTrueOrFalse()
return ( rand ( ) % 2 ) ;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
char inputBuffer [ CHAR_ARRAY_SIZE ] ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
inputBuffer [ recvResult ] = '\0';
data = atoi ( inputBuffer );
while ( 0 )
data = 7;
if ( globalReturnsTrueOrFalse ( ) )
int globalReturnsTrueOrFalse()
return ( rand ( ) % 2 ) ;
printIntLine ( 100 / data );
1
------------------------------
310714 151133/utils.c print_fps ( 1 / av_q2d ( st -> codec -> time_base ) , "tbc" ) 3807
void av_dump_format(AVFormatContext *ic,int index,const char *url,int is_output)
int i ;
uint8_t * printed = ( ic -> nb_streams ? av_mallocz ( ( ic -> nb_streams ) ) : ( ( void * ) 0 ) ) ;
if ( ic -> nb_streams && ! printed )
for (i = 0; i < ic -> nb_chapters; i++)
if ( ic -> nb_programs )
int j ;
int k ;
for (j = 0; j < ic -> nb_programs; j++)
for (k = 0; k < ic -> programs[j] -> nb_stream_indexes; k++)
printed [ ic -> programs [ j ] -> stream_index [ k ] ] = 1;
for (i = 0; i < ic -> nb_streams; i++)
if ( ! printed [ i ] )
dump_stream_format ( ic , i , index , is_output );
static void dump_stream_format(AVFormatContext *ic,int i,int index,int is_output)
AVStream * st = ic -> streams [ i ] ;
if ( ( st -> codec -> codec_type ) == AVMEDIA_TYPE_VIDEO )
if ( st -> codec -> time_base . den && st -> codec -> time_base . num )
print_fps ( 1 / av_q2d ( st -> codec -> time_base ) , "tbc" );
0
------------------------------
20262 CVE-2016-6508/wireshark_2.0.4_CVE_2016_6508_epan_dissectors_packet-rlc.c out [ i + header_size ] = tvb_get_guint8 ( tvb , header_size + i ) 1422
static
dissect_rlc_dcch(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree)
proto_tree * subtree = NULL ;
fp_info * fpi ;
rlc_info * rlci ;
enum rlc_channel_type channel ;
fpi = ( fp_info * ) p_get_proto_data ( wmem_file_scope ( ) , pinfo , proto_fp , 0 );
rlci = ( rlc_info * ) p_get_proto_data ( wmem_file_scope ( ) , pinfo , proto_rlc , 0 );
if ( ! fpi || ! rlci )
if ( tree )
ti = proto_tree_add_item ( tree , proto_rlc , tvb , 0 , - 1 , ENC_NA );
subtree = proto_item_add_subtree ( ti , ett_rlc );
channel = fpi -> is_uplink ? RLC_UL_DCCH : RLC_DL_DCCH;
switch ( rlci -> mode [ fpi -> cur_tb ] )
dissect_rlc_um ( channel , tvb , pinfo , tree , subtree );
static
dissect_rlc_um(enum rlc_channel_type channel, tvbuff_t *tvb, packet_info
proto_tree *top_level, proto_tree *tree)
fp_info * fpinf ;
rlc_info * rlcinf ;
guint8 seq ;
guint8 next_byte , offs = 0 ;
next_byte = tvb_get_guint8 ( tvb , offs ++ );
seq = next_byte >> 1;
fpinf = ( fp_info * ) p_get_proto_data ( wmem_file_scope ( ) , pinfo , proto_fp , 0 );
rlcinf = ( rlc_info * ) p_get_proto_data ( wmem_file_scope ( ) , pinfo , proto_rlc , 0 );
if ( ! fpinf || ! rlcinf )
pos = fpinf -> cur_tb;
if ( ( rlcinf -> ciphered [ pos ] == TRUE && rlcinf -> deciphered [ pos ] == FALSE ) || global_rlc_ciphered )
if ( global_rlc_try_decipher )
rlc_decipher ( tvb , pinfo , tree , fpinf , rlcinf , seq , RLC_UM );
static
rlc_decipher(tvbuff_t *tvb, packet_info * pinfo, proto_tree * tree, fp_info *
rlc_info * rlcinf, guint16 seq, enum rlc_mode mode)
rrc_ciphering_info * c_inf ;
guint8 indx , header_size , hfn_shift ;
gint16 pos ;
indx = fpinf -> is_uplink ? 1 : 0;
pos = fpinf -> cur_tb;
if ( mode == RLC_UM )
header_size = 1;
hfn_shift = 7;
header_size = 2;
hfn_shift = 12;
c_inf = ( rrc_ciphering_info * ) g_tree_lookup ( rrc_ciph_inf , GINT_TO_POINTER ( ( gint ) fpinf -> com_context_id ) );
if ( c_inf != NULL && ( ( c_inf -> setup_frame > 0 && c_inf -> setup_frame < pinfo -> fd -> num && c_inf -> seq_no [ rlcinf -> rbid [ pos ] ] [ indx ] == - 1 ) || ( c_inf -> setup_frame < pinfo -> fd -> num && c_inf -> seq_no [ rlcinf -> rbid [ pos ] ] [ indx ] >= 0 && c_inf -> seq_no [ rlcinf -> rbid [ pos ] ] [ indx ] <= seq ) ) )
tvbuff_t * t ;
if ( ! counter_init [ rlcinf -> rbid [ pos ] ] [ indx ] )
guint32 frame_num = pinfo -> fd -> num ;
counter_init [ rlcinf -> rbid [ pos ] ] [ 0 ] = TRUE;
counter_init [ rlcinf -> rbid [ pos ] ] [ 1 ] = TRUE;
if ( max_counter + 2 > frame_num && c_inf -> seq_no [ rlcinf -> rbid [ pos ] ] [ indx ] == - 1 )
ps_counter [ rlcinf -> rbid [ pos ] ] [ 0 ] = ( max_counter + 2 ) << hfn_shift;
ps_counter [ rlcinf -> rbid [ pos ] ] [ 1 ] = ( max_counter + 2 ) << hfn_shift;
ps_counter [ rlcinf -> rbid [ pos ] ] [ 0 ] = frame_num << hfn_shift;
ps_counter [ rlcinf -> rbid [ pos ] ] [ 1 ] = frame_num << hfn_shift;
if ( rlcinf -> rbid [ pos ] == 9 )
if ( tree )
t = rlc_decipher_tvb ( tvb , pinfo , ( ( ps_counter [ rlcinf -> rbid [ pos ] ] [ indx ] ) | seq ) , rlcinf -> rbid [ pos ] , ! fpinf -> is_uplink , header_size );
rlc_decipher_tvb(tvbuff_t *tvb, packet_info *pinfo, guint32 counter, guint8 rbid, gboolean dir, guint8 header_size)
guint i ;
out = wmem_alloc0 ( wmem_packet_scope ( ) , strlen ( global_rlc_kasumi_key ) + 1 );
memcpy ( out , global_rlc_kasumi_key , strlen ( global_rlc_kasumi_key ) );
out = g_malloc ( tvb_captured_length ( tvb ) );
for(i = 0; i< tvb_captured_length(tvb)-header_size; i++ )
out [ i + header_size ] = tvb_get_guint8 ( tvb , header_size + i );
f8 ( key_in , counter , rbid - 1 , dir , & out [ header_size ] , ( tvb_captured_length ( tvb ) - header_size ) * 8 );
for (i = 0; i < header_size; i++)
out [ i ] = tvb_get_guint8 ( tvb , i );
t = tvb_new_real_data ( out , tvb_captured_length ( tvb ) , tvb_reported_length ( tvb ) );
add_new_data_source ( pinfo , t , "Deciphered data" );
return t ;
0
------------------------------
307038 119914/CWE78_OS_Command_Injection__char_listen_socket_execlp_04.c recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 123
void CWE78_OS_Command_Injection__char_listen_socket_execlp_04_bad()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
if ( STATIC_CONST_TRUE )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
0
------------------------------
310882 151097/aviobuf.c int len = ( ( s -> buffer_size ) - ( dst - s -> buffer ) ) ; 443
unsigned int avio_rl32(AVIOContext *s)
unsigned int val ;
val = avio_rl16 ( s );
unsigned int avio_rl16(AVIOContext *s)
unsigned int val ;
val = ( avio_r8 ( s ) );
int avio_r8(AVIOContext *s)
if ( s -> buf_ptr >= s -> buf_end )
fill_buffer ( s );
static void fill_buffer(AVIOContext *s)
uint8_t * dst = ! s -> max_packet_size && s -> buf_end - s -> buffer < ( s -> buffer_size ) ? s -> buf_end : s -> buffer ;
int len = ( ( s -> buffer_size ) - ( dst - s -> buffer ) ) ;
len = ( ( s -> read_packet ) ( s -> opaque , dst , len ) );
if ( len <= 0 )
if ( len < 0 )
s -> error = len;
s -> pos += len;
s -> buf_ptr = dst;
s -> buf_end = dst + len;
s -> bytes_read += len;
0
------------------------------
310144 152040/dirent_uri.c apr_size_t seglen = ( ptr - seg ) ; 1376
char *svn_fspath__get_longest_ancestor(const char *fspath1,const char *fspath2,apr_pool_t *result_pool)
svn_fspath__is_canonical ( fspath2 ) ? ( ( void ) 0 ) : __assert_fail ( "svn_fspath__is_canonical(fspath2)" , "dirent_uri.c" , 2564 , __PRETTY_FUNCTION__ );
svn_boolean_t svn_fspath__is_canonical(const char *fspath)
return fspath [ 0 ] == 47 && relpath_is_canonical ( fspath + 1 ) ;
static svn_boolean_t relpath_is_canonical(const char *relpath)
const char * ptr = relpath ;
const char * seg = relpath ;
if ( ( * relpath ) == '\0' )
if ( ( * ptr ) == 47 )
while ( 1 )
apr_size_t seglen = ( ptr - seg ) ;
if ( seglen == 1 && ( * seg ) == 46 )
if ( ( * ptr ) == 47 && ( * ( ptr + 1 ) ) == 47 )
if ( ! ( * ptr ) && ( * ( ptr - 1 ) ) == 47 )
if ( ! ( * ptr ) )
if ( ( * ptr ) == 47 )
ptr ++;
seg = ptr;
while ( * ptr && ( * ptr ) != 47 )
ptr ++;
0
------------------------------
302511 79281/CWE134_Uncontrolled_Format_String__char_connect_socket_vfprintf_67a.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 97
void CWE134_Uncontrolled_Format_String__char_connect_socket_vfprintf_67_bad()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
myStruct . structFirst = data;
CWE134_Uncontrolled_Format_String__char_connect_socket_vfprintf_67b_badSink ( myStruct );
void CWE134_Uncontrolled_Format_String__char_connect_socket_vfprintf_67b_badSink(CWE134_Uncontrolled_Format_String__char_connect_socket_vfprintf_67_structType myStruct)
char * data = myStruct . structFirst ;
badVaSink ( data , data );
static void badVaSink(char * data, ...)
va_start ( args , data );
vfprintf ( stdout , data , args );
0
------------------------------
18706 CVE-2015-2716/Firefox_37.0b7_CVE_2015_2716_parser_expat_lib_xmlparse.c pool -> ptr = pool -> blocks -> s + ( pool -> ptr - pool -> start ) 6264
static enum
processXmlDecl(XML_Parser parser, int
const char *s, const char *next)
const char * encodingName = NULL ;
const char * version = NULL ;
const char * versionend ;
if ( ! ( ns ? XmlParseXmlDeclNS : XmlParseXmlDecl ) ( isGeneralTextEntity , encoding , s , next , & eventPtr , & version , & versionend , & encodingName , & newEncoding , & standalone ) )
if ( xmlDeclHandler )
if ( encodingName != NULL )
storedEncName = poolStoreString ( & temp2Pool , encoding , encodingName , encodingName + XmlNameLength ( encoding , encodingName ) );
if ( ! storedEncName )
if ( version )
storedversion = poolStoreString ( & temp2Pool , encoding , version , versionend - encoding -> minBytesPerChar );
static XML_Char
poolStoreString(STRING_POOL *pool, const ENCODING
const char *ptr, const char *end)
if ( ! poolAppend ( pool , enc , ptr , end ) )
static XML_Char
poolAppend(STRING_POOL *pool, const ENCODING
const char *ptr, const char *end)
if ( ! pool -> ptr && ! poolGrow ( pool ) )
if ( ptr == end )
if ( ! poolGrow ( pool ) )
static XML_Bool
poolGrow(STRING_POOL *pool)
if ( pool -> freeBlocks )
if ( pool -> start == 0 )
if ( pool -> end - pool -> start < pool -> freeBlocks -> size )
if ( pool -> blocks && pool -> start == pool -> blocks -> s )
int blockSize = ( int ) ( pool -> end - pool -> start ) * 2 ;
pool -> blocks = ( BLOCK * ) pool -> mem -> realloc_fcn ( pool -> blocks , ( offsetof ( BLOCK , s ) + blockSize * sizeof ( XML_Char ) ) );
if ( pool -> blocks == NULL )
pool -> blocks -> size = blockSize;
pool -> ptr = pool -> blocks -> s + ( pool -> ptr - pool -> start );
pool -> start = pool -> blocks -> s;
pool -> end = pool -> start + blockSize;
0
------------------------------
304854 83797/CWE190_Integer_Overflow__int_rand_square_08.c int result = data * data ; 138
static void goodG2B1()
int data ;
data = 0;
if ( staticReturnsFalse ( ) )
static int staticReturnsFalse()
return 0 ;
data = 2;
if ( staticReturnsTrue ( ) )
static int staticReturnsTrue()
return 1 ;
int result = data * data ;
printIntLine ( result );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
0
------------------------------
307578 109194/CWE606_Unchecked_Loop_Condition__wchar_t_connect_socket_41.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 ) 108
void CWE606_Unchecked_Loop_Condition__wchar_t_connect_socket_41_bad()
wchar_t * data ;
wchar_t dataBuffer [ 100 ] = L ""
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
313293 90790/CWE23_Relative_Path_Traversal__wchar_t_connect_socket_fopen_11.cpp recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ) 101
void bad()
wchar_t * data ;
wchar_t dataBuffer [ FILENAME_MAX ] = BASEPATH ;
data = dataBuffer;
if ( globalReturnsTrue ( ) )
int globalReturnsTrue()
return 1 ;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( FILENAME_MAX - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
307644 113054/CWE761_Free_Pointer_Not_at_Start_of_Buffer__wchar_t_listen_socket_08.c recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 ) 108
void CWE761_Free_Pointer_Not_at_Start_of_Buffer__wchar_t_listen_socket_08_bad()
wchar_t * data ;
data = ( wchar_t * ) malloc ( 100 * sizeof ( wchar_t ) );
data [ 0 ] = L '\0'
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
309754 152959/dfa.c match_lens = check_matching_with_multibyte_ops ( d , s , ( * pp - buf_begin ) ) 3453
char *dfaexec(struct dfa *d,const char *begin,char *end,int allow_nl,size_t *count,int *backref)
state_num s ;
state_num s1 ;
const unsigned char * p ;
state_num * * trans ;
state_num * t ;
unsigned char eol = eolbyte ;
unsigned char saved_end ;
s = s1 = 0;
p = ( ( const unsigned char * ) begin );
trans = d -> trans;
saved_end = * ( ( unsigned char * ) end );
* end = eol;
if ( d -> mb_cur_max > 1 )
while ( ( t = trans [ s ] ) != ( ( void * ) 0 ) )
if ( p > buf_end )
s1 = s;
if ( s == 0 )
if ( ( ( char * ) p ) >= end )
if ( d -> states [ s ] . mbps . nelem == 0 )
s = t [ * ( p ++ ) ];
if ( backref )
* end = saved_end;
s = transit_state ( d , s , & p );
trans = d -> trans;
while ( ( t = trans [ s ] ) != ( ( void * ) 0 ) )
s1 = t [ * ( p ++ ) ];
if ( ( t = trans [ s1 ] ) == ( ( void * ) 0 ) )
state_num tmp = s ;
s = s1;
s1 = tmp;
s = t [ * ( p ++ ) ];
if ( s >= 0 && ( ( char * ) p ) <= end && d -> fails [ s ] )
if ( d -> success [ s ] & sbit [ * p ] )
s1 = s;
if ( d -> mb_cur_max > 1 )
s = transit_state ( d , s , & p );
trans = d -> trans;
s = d -> fails [ s ] [ * ( p ++ ) ];
if ( ( ( char * ) p ) > end )
if ( s >= 0 )
trans = d -> trans;
if ( p [ - 1 ] == eol && allow_nl )
s = d -> newlines [ s1 ];
s = 0;
static state_num transit_state(struct dfa *d,state_num s,const unsigned char **pp)
size_t nelem = d -> states [ s ] . mbps . nelem ;
if ( nelem > 0 )
match_lens = check_matching_with_multibyte_ops ( d , s , ( * pp - buf_begin ) );
if ( match_lens [ i ] > maxlen )
maxlen = match_lens [ i ];
if ( nelem == 0 || maxlen == 0 )
free ( match_lens );
transit_state_consume_1char ( d , s , pp , match_lens , & mbclen , & follows );
while ( * pp - p1 < maxlen )
if ( match_lens [ i ] == * pp - p1 )
free ( match_lens );
0
------------------------------
299425 151060/tile-swap.c gap = tile_swap_gap_new ( offset + bytes , swap_file -> swap_file_end ) 577
void tile_swap_out(Tile *tile)
tile_swap_command ( tile , SWAP_OUT );
static void tile_swap_command(Tile *tile,gint command)
if ( gimp_swap_file -> fd == - 1 )
if ( gimp_swap_file -> fd == - 1 )
switch ( command )
tile_swap_default_out ( gimp_swap_file , tile );
static void tile_swap_default_out(SwapFile *swap_file,Tile *tile)
gint bytes ;
gint64 newpos ;
bytes = 64 * 64 * ( tile -> bpp );
if ( tile -> swap_offset == ( - 1 ) )
newpos = tile_swap_find_offset ( swap_file , bytes );
static gint64 tile_swap_find_offset(SwapFile *swap_file,gint64 bytes)
SwapFileGap * gap ;
GList * tmp ;
gint64 offset ;
tmp = swap_file -> gaps;
while ( tmp )
gap = ( tmp -> data );
if ( gap -> end - gap -> start >= bytes )
tmp = tmp -> next;
offset = swap_file -> swap_file_end;
if ( offset + bytes < swap_file -> swap_file_end )
gap = tile_swap_gap_new ( offset + bytes , swap_file -> swap_file_end );
swap_file -> gaps = g_list_append ( swap_file -> gaps , gap );
0
------------------------------
300010 151490/stream.c stonesoup_buffer_array = ( ( unsigned int * * ) ( malloc ( stonesoup_num * sizeof ( unsigned int * ) ) ) ) 1806
void flexuosities_twain(char **puccinia_continuousness)
int stonesoup_num ;
diplopy_wadmal = ( ( char * ) puccinia_continuousness [ 60 ] );
stonesoup_num = atoi ( diplopy_wadmal );
if ( stonesoup_num > 0 && stonesoup_num < 4294967295U / sizeof ( unsigned int * * ) )
stonesoup_buffer_array = ( ( unsigned int * * ) ( malloc ( stonesoup_num * sizeof ( unsigned int * ) ) ) );
tracepoint ( stonesoup_trace , variable_address , "stonesoup_buffer_array" , stonesoup_buffer_array , "INITIAL-STATE" );
stonesoup_buffer_array [ stonesoup_i ] = 0;
while ( stonesoup_buffer_array [ stonesoup_i ] == 0 )
stonesoup_buffer_array [ stonesoup_i ] = ( ( unsigned int * ) ( malloc ( stonesoup_size * sizeof ( unsigned int ) ) ) );
if ( stonesoup_buffer_array [ stonesoup_i ] != 0 )
tracepoint ( stonesoup_trace , variable_unsigned_integral , "stonesoup_i" , stonesoup_i , & stonesoup_i , "CROSSOVER-STATE" );
tracepoint ( stonesoup_trace , variable_address , "stonesoup_buffer_array[stonesoup_i]" , stonesoup_buffer_array [ stonesoup_i ] , "CROSSOVER-STATE" );
tracepoint ( stonesoup_trace , variable_unsigned_integral , "stonesoup_i" , stonesoup_i , & stonesoup_i , "TRIGGER-STATE" );
tracepoint ( stonesoup_trace , variable_address , "stonesoup_buffer_array[stonesoup_i]" , stonesoup_buffer_array [ stonesoup_i ] , "TRIGGER-STATE" );
if ( stonesoup_buffer_array [ stonesoup_i ] != 0 )
memset ( stonesoup_buffer_array [ stonesoup_i ] , 0 , stonesoup_size * sizeof ( unsigned int ) );
tracepoint ( stonesoup_trace , variable_unsigned_integral , "stonesoup_i" , stonesoup_i , & stonesoup_i , "FINAL-STATE" );
for (stonesoup_i = 0; stonesoup_i < stonesoup_num; ++stonesoup_i)
if ( stonesoup_buffer_array [ stonesoup_i ] != 0 )
free ( stonesoup_buffer_array [ stonesoup_i ] );
if ( stonesoup_buffer_array != 0 )
free ( stonesoup_buffer_array );
1
------------------------------
314539 110728/CWE680_Integer_Overflow_to_Buffer_Overflow__new_fixed_54e.cpp dataBytes = data * sizeof ( int ) 32
void badSink_b(int data)
badSink_c ( data );
void badSink_c(int data)
badSink_d ( data );
void badSink_d(int data)
badSink_e ( data );
void badSink_e(int data)
size_t dataBytes , i ;
dataBytes = data * sizeof ( int );
intPointer = ( int * ) new char [ dataBytes ];
intPointer [ i ] = 0;
printIntLine ( intPointer [ 0 ] );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
delete [ ] intPointer
1
------------------------------
312186 153760/aviobuf.c uint8_t * dst = ! s -> max_packet_size && s -> buf_end - s -> buffer < ( s -> buffer_size ) ? s -> buf_end : s -> buffer ; 476
int avio_read(AVIOContext *s,unsigned char *buf,int size)
int len ;
while ( size > 0 )
len = ( s -> buf_end - s -> buf_ptr );
if ( len > size )
len = size;
if ( len == 0 || s -> write_flag )
if ( ( s -> direct || size > s -> buffer_size ) && ! s -> update_checksum )
if ( s -> read_packet )
len = ( ( s -> read_packet ) ( s -> opaque , buf , size ) );
if ( len <= 0 )
s -> pos += len;
s -> bytes_read += len;
size -= len;
buf += len;
s -> buf_ptr = s -> buffer;
s -> buf_end = s -> buffer;
fill_buffer ( s );
len = ( s -> buf_end - s -> buf_ptr );
if ( len == 0 )
memcpy ( buf , ( s -> buf_ptr ) , len );
buf += len;
s -> buf_ptr += len;
size -= len;
static void fill_buffer(AVIOContext *s)
uint8_t * dst = ! s -> max_packet_size && s -> buf_end - s -> buffer < ( s -> buffer_size ) ? s -> buf_end : s -> buffer ;
int len = ( ( s -> buffer_size ) - ( dst - s -> buffer ) ) ;
if ( s -> update_checksum && dst == s -> buffer )
len = ( ( s -> read_packet ) ( s -> opaque , dst , len ) );
if ( len <= 0 )
if ( len < 0 )
s -> error = len;
s -> pos += len;
s -> buf_ptr = dst;
s -> buf_end = dst + len;
s -> bytes_read += len;
0
------------------------------
307888 120170/CWE78_OS_Command_Injection__char_listen_socket_w32_spawnlp_22b.c recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 109
void CWE78_OS_Command_Injection__char_listen_socket_w32_spawnlp_22_bad()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
data = CWE78_OS_Command_Injection__char_listen_socket_w32_spawnlp_22_badSource ( data );
char * CWE78_OS_Command_Injection__char_listen_socket_w32_spawnlp_22_badSource(char * data)
if ( CWE78_OS_Command_Injection__char_listen_socket_w32_spawnlp_22_badGlobal )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
return data ;
0
------------------------------
314509 110855/CWE680_Integer_Overflow_to_Buffer_Overflow__new_rand_16.cpp dataBytes = data * sizeof ( int ) 39
void bad()
int data ;
data = - 1;
while ( 1 )
data = RAND32 ( );
size_t dataBytes , i ;
dataBytes = data * sizeof ( int );
intPointer = ( int * ) new char [ dataBytes ];
intPointer [ i ] = 0;
printIntLine ( intPointer [ 0 ] );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
delete [ ] intPointer
1
------------------------------
311314 152169/aviobuf.c s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_ptr - s -> checksum_ptr ) ) ) 172
int avio_close_dyn_buf(AVIOContext *s,uint8_t **pbuffer)
static const char padbuf [ 16 ] = { ( 0 ) } ;
if ( ! s -> max_packet_size )
avio_write ( s , padbuf , ( sizeof ( padbuf ) ) );
void avio_write(AVIOContext *s,const unsigned char *buf,int size)
if ( s -> direct && ! s -> update_checksum )
while ( size > 0 )
int len = ( s -> buf_end - s -> buf_ptr > size ? size : s -> buf_end - s -> buf_ptr ) ;
memcpy ( ( s -> buf_ptr ) , buf , len );
s -> buf_ptr += len;
if ( s -> buf_ptr >= s -> buf_end )
flush_buffer ( s );
buf += len;
size -= len;
static void flush_buffer(AVIOContext *s)
if ( s -> buf_ptr > s -> buffer )
if ( s -> update_checksum )
s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_ptr - s -> checksum_ptr ) ) );
s -> checksum_ptr = s -> buffer;
s -> buf_ptr = s -> buffer;
0
------------------------------
308361 117081/CWE789_Uncontrolled_Mem_Alloc__malloc_char_fscanf_03.c myString = ( char * ) malloc ( data * sizeof ( char ) ) 47
void CWE789_Uncontrolled_Mem_Alloc__malloc_char_fscanf_03_bad()
size_t data ;
data = 0;
if ( 5 == 5 )
char * myString ;
if ( data > strlen ( HELLO_STRING ) )
myString = ( char * ) malloc ( data * sizeof ( char ) );
strcpy ( myString , HELLO_STRING );
printLine ( myString );
void printLine (const char * line)
if ( line != NULL )
printf ( "%s\n" , line );
free ( myString );
1
------------------------------
306948 119970/CWE78_OS_Command_Injection__char_listen_socket_popen_12.c recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 110
void CWE78_OS_Command_Injection__char_listen_socket_popen_12_bad()
char * data ;
char data_buf [ 100 ] = FULL_COMMAND ;
data = data_buf;
if ( globalReturnsTrueOrFalse ( ) )
int globalReturnsTrueOrFalse()
return ( rand ( ) % 2 ) ;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
0
------------------------------
311890 153176/stream.c apr_size_t left_to_read = btn -> str -> len - btn -> amt_read ; 1397
static svn_error_t *read_handler_stringbuf(void *baton,char *buffer,apr_size_t *len)
struct stringbuf_stream_baton * btn = baton ;
apr_size_t left_to_read = btn -> str -> len - btn -> amt_read ;
* len = ( * len > left_to_read ? left_to_read : * len );
memcpy ( buffer , ( btn -> str -> data + btn -> amt_read ) , * len );
btn -> amt_read += * len;
0
------------------------------
308127 109386/CWE606_Unchecked_Loop_Condition__wchar_t_listen_socket_41.c recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 ) 116
void CWE606_Unchecked_Loop_Condition__wchar_t_listen_socket_41_bad()
wchar_t * data ;
wchar_t dataBuffer [ 100 ] = L ""
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
303512 80432/CWE134_Uncontrolled_Format_String__char_listen_socket_vfprintf_66a.c recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 101
void CWE134_Uncontrolled_Format_String__char_listen_socket_vfprintf_66_bad()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
dataArray [ 2 ] = data;
CWE134_Uncontrolled_Format_String__char_listen_socket_vfprintf_66b_badSink ( dataArray );
void CWE134_Uncontrolled_Format_String__char_listen_socket_vfprintf_66b_badSink(char * dataArray[])
char * data = dataArray [ 2 ] ;
badVaSink ( data , data );
static void badVaSink(char * data, ...)
va_start ( args , data );
vfprintf ( stdout , data , args );
0
------------------------------
313910 83672/CWE190_Integer_Overflow__int_max_square_43.cpp int result = data * data ; 65
static void goodG2B()
int data ;
data = 0;
int result = data * data ;
printIntLine ( result );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
0
------------------------------
310341 151639/aviobuf.c s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_ptr - s -> checksum_ptr ) ) ) 506
unsigned long ffio_get_checksum(AVIOContext *s)
s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_ptr - s -> checksum_ptr ) ) );
s -> update_checksum = ( ( void * ) 0 );
return s -> checksum ;
0
------------------------------
314257 110665/CWE680_Integer_Overflow_to_Buffer_Overflow__new_fgets_18.cpp dataBytes = data * sizeof ( int ) 79
static void goodG2B()
int data ;
data = - 1;
data = 20;
size_t dataBytes , i ;
dataBytes = data * sizeof ( int );
intPointer = ( int * ) new char [ dataBytes ];
intPointer [ i ] = 0;
printIntLine ( intPointer [ 0 ] );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
delete [ ] intPointer
0
------------------------------
17352 CVE-2015-3808/CVE_2015_3808_VULN_dissect_lbmr_pser.c flags = tvb_get_ntohs ( tvb , curr_offset + O_LBMR_PSER_T_FLAGS ) 12
static int CVE_2015_3808_VULN_dissect_lbmr_pser(tvbuff_t * tvb, int offset, packet_info * pinfo, proto_tree * tree)
int curr_offset = offset ;
flags = tvb_get_ntohs ( tvb , curr_offset + O_LBMR_PSER_T_FLAGS );
0
------------------------------
19398 CVE-2015-2726/Firefox_38.8.0esr_CVE_2015_2726_js_src_ctypes_CTypes.cpp * dstlenp = ( origDstlen - dstlen ) 162

StructType::FieldSetter(JSContext* cx, HandleObject obj, HandleId idval, bool strict, MutableHandleValue vp)
if ( ! CData :: IsCData ( obj ) )
JSObject * typeObj = CData :: GetCType ( obj ) ;
if ( CType :: GetTypeCode ( typeObj ) != TYPE_struct )
const FieldInfo * field = LookupField ( cx , typeObj , JSID_TO_FLAT_STRING ( idval ) ) ;
if ( ! field )
char * data = static_cast < char * > ( CData :: GetData ( obj ) ) + field -> mOffset
return ImplicitConvert ( cx , vp , field -> mType , data , false , nullptr ) ;
static
ImplicitConvert(JSContext*
HandleValue
JSObject*
void*
bool
bool* freePointer)
RootedObject targetType ( cx , targetType_ ) ;
JSObject * sourceData = nullptr ;
JSObject * sourceType = nullptr ;
RootedObject valObj ( cx , nullptr ) ;
if ( val . isObject ( ) )
valObj = & val . toObject ( );
if ( CData :: IsCData ( valObj ) )
sourceData = valObj;
sourceType = CData :: GetCType ( sourceData );
if ( CType :: TypesEqual ( sourceType , targetType ) )
if ( CDataFinalizer :: IsCDataFinalizer ( valObj ) )
sourceData = valObj;
sourceType = CDataFinalizer :: GetCType ( cx , sourceData );
CDataFinalizer :: Private * p = ( CDataFinalizer :: Private * ) JS_GetPrivate ( sourceData ) ;
if ( ! p )
if ( CType :: TypesEqual ( sourceType , targetType ) )
TypeCode targetCode = CType :: GetTypeCode ( targetType ) ;
switch ( targetCode )
bool result ;
if ( ! jsvalToBool ( cx , val , & result ) )
* static_cast < bool * > ( buffer ) = result
type result ;
type result ;
type result ;
if ( ! jsvalToFloat ( cx , val , & result ) )
* static_cast < type * > ( buffer ) = result
if ( val . isNull ( ) )
* static_cast < void * * > ( buffer ) = nullptr
JS :: Rooted < JSObject * > baseType ( cx , PointerType :: GetBaseType ( targetType ) ) ;
if ( sourceData )
TypeCode sourceCode = CType :: GetTypeCode ( sourceType ) ;
bool voidptrTarget = CType :: GetTypeCode ( baseType ) == TYPE_void_t ;
if ( sourceCode == TYPE_pointer && voidptrTarget )
if ( sourceCode == TYPE_array )
JSObject * elementType = ArrayType :: GetBaseType ( sourceType ) ;
if ( voidptrTarget || CType :: TypesEqual ( baseType , elementType ) )
* static_cast < void * * > ( buffer ) = sourceBuffer
if ( isArgument && val . isString ( ) )
if ( val . isObject ( ) && JS_IsArrayBufferObject ( valObj ) )
if ( val . isObject ( ) && JS_IsArrayBufferViewObject ( valObj ) )
if ( ! CanConvertTypedArrayItemTo ( baseType , valObj , cx ) )
if ( ! isArgument )
void * ptr ;
JS :: AutoCheckCannotGC nogc ;
ptr = JS_GetArrayBufferViewData ( valObj , nogc );
if ( ! ptr )
* static_cast < void * * > ( buffer ) = ptr
RootedObject baseType ( cx , ArrayType :: GetBaseType ( targetType ) ) ;
size_t targetLength = ArrayType :: GetLength ( targetType ) ;
if ( val . isString ( ) )
JSString * sourceString = val . toString ( ) ;
JSLinearString * sourceLinear = sourceString -> ensureLinear ( cx ) ;
if ( ! sourceLinear )
switch ( CType :: GetTypeCode ( baseType ) )
size_t nbytes = GetDeflatedUTF8StringLength ( cx , sourceLinear ) ;
if ( nbytes == ( size_t ) - 1 )
if ( targetLength < nbytes )
char * charBuffer = static_cast < char * > buffer
ASSERT_OK ( DeflateStringToUTF8Buffer ( cx , sourceLinear , charBuffer , & nbytes ) );
static
DeflateStringToUTF8Buffer(JSContext* maybecx, JSLinearString* str, char*
size_t* dstlenp)
size_t length = str -> length ( ) ;
JS :: AutoCheckCannotGC nogc ;
return str -> hasLatin1Chars ( ) ? DeflateStringToUTF8Buffer ( maybecx , str -> latin1Chars ( nogc ) , length , dst , dstlenp ) : DeflateStringToUTF8Buffer ( maybecx , str -> twoByteChars ( nogc ) , length , dst , dstlenp ) ;
template <typename

DeflateStringToUTF8Buffer(JSContext* maybecx, const CharT* src, size_t
char* dst, size_t* dstlenp)
size_t i , utf8Len ;
char16_t c , c2 ;
uint32_t v ;
uint8_t utf8buf [ 6 ] ;
size_t dstlen = * dstlenp ;
size_t origDstlen = dstlen ;
while ( srclen )
c = * src ++;
srclen --;
if ( c >= 0xDC00 && c <= 0xDFFF )
if ( c < 0xD800 || c > 0xDBFF )
v = c;
if ( srclen < 1 )
c2 = * src;
if ( ( c2 < 0xDC00 ) || ( c2 > 0xDFFF ) )
src ++;
srclen --;
v = ( ( c - 0xD800 ) << 10 ) + ( c2 - 0xDC00 ) + 0x10000;
if ( v < 0x0080 )
if ( dstlen == 0 )
utf8Len = 1;
utf8Len = js_OneUcs4ToUtf8Char ( utf8buf , v );
if ( utf8Len > dstlen )
dstlen -= utf8Len;
* dstlenp = ( origDstlen - dstlen );
0
------------------------------
19621 CVE-2016-8658/linux_kernel_4.7.4_CVE_2016_8658_drivers_net_wireless_broadcom_brcm80211_brcmfmac_cfg80211.c ie_len = rsn_ie -> len + TLV_HDR_LEN 1900
static
brcmf_cfg80211_connect(struct wiphy *wiphy, struct net_device
struct cfg80211_connect_params *sme)
struct brcmf_cfg80211_info * cfg = wiphy_to_cfg ( wiphy ) ;
struct brcmf_if * ifp = netdev_priv ( ndev ) ;
const struct brcmf_tlv * rsn_ie ;
const struct brcmf_vs_tlv * wpa_ie ;
u32 ie_len ;
if ( ! check_vif_up ( ifp -> vif ) )
static bool check_vif_up(struct brcmf_cfg80211_vif *vif)
if ( ! test_bit ( BRCMF_VIF_STATUS_READY , & vif -> sme_state ) )
return false ;
return true ;
if ( ! sme -> ssid )
if ( ifp -> vif == cfg -> p2p . bss_idx [ P2PAPI_BSSCFG_PRIMARY ] . vif )
wpa_ie = brcmf_find_wpaie ( ( u8 * ) sme -> ie , sme -> ie_len );
static struct brcmf_vs_tlv
brcmf_find_wpaie(const u8 *parse, u32 len)
const struct brcmf_tlv * ie ;
while ( ie = brcmf_parse_tlvs ( parse , len , WLAN_EID_VENDOR_SPECIFIC ) )
const struct brcmf_tlv
brcmf_parse_tlvs(const void *buf, int buflen, uint key)
const struct brcmf_tlv * elt = buf ;
int totlen = buflen ;
while ( totlen >= TLV_HDR_LEN )
int len = elt -> len ;
if ( ( elt -> id == key ) && ( totlen >= ( len + TLV_HDR_LEN ) ) )
return elt ;
elt = ( struct brcmf_tlv * ) ( ( u8 * ) elt + ( len + TLV_HDR_LEN ) );
totlen -= ( len + TLV_HDR_LEN );
return NULL ;
if ( brcmf_tlv_has_ie ( ( const u8 * ) ie , & parse , & len , WPA_OUI , TLV_OUI_LEN , WPA_OUI_TYPE ) )
static
brcmf_tlv_has_ie(const u8 *ie, const u8 **tlvs, u32
const u8 *oui, u32 oui_len, u8 type)
if ( ie [ TLV_LEN_OFF ] >= oui_len + 1 && ! memcmp ( & ie [ TLV_BODY_OFF ] , oui , oui_len ) && type == ie [ TLV_BODY_OFF + oui_len ] )
return true ;
if ( tlvs == NULL )
return false ;
return false ;
return ( struct brcmf_vs_tlv * ) ie ;
return NULL ;
if ( wpa_ie )
rsn_ie = brcmf_parse_tlvs ( ( const u8 * ) sme -> ie , sme -> ie_len , WLAN_EID_RSN );
const struct brcmf_tlv
brcmf_parse_tlvs(const void *buf, int buflen, uint key)
const struct brcmf_tlv * elt = buf ;
int totlen = buflen ;
while ( totlen >= TLV_HDR_LEN )
int len = elt -> len ;
if ( ( elt -> id == key ) && ( totlen >= ( len + TLV_HDR_LEN ) ) )
return elt ;
elt = ( struct brcmf_tlv * ) ( ( u8 * ) elt + ( len + TLV_HDR_LEN ) );
totlen -= ( len + TLV_HDR_LEN );
return NULL ;
if ( rsn_ie )
ie_len = rsn_ie -> len + TLV_HDR_LEN;
brcmf_fil_iovar_data_set ( ifp , "wpaie" , ie , ie_len );
0
------------------------------
314020 110530/CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_listen_socket_43.cpp intPointer = ( int * ) malloc ( data * sizeof ( int ) ) 130
void bad()
int data ;
data = - 1;
int * intPointer ;
intPointer = ( int * ) malloc ( data * sizeof ( int ) );
intPointer [ i ] = 0;
printIntLine ( intPointer [ 0 ] );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
free ( intPointer );
1
------------------------------
307635 117147/CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_31.c myString = ( char * ) malloc ( data * sizeof ( char ) ) 134
void CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_31_bad()
size_t data ;
data = 0;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
char inputBuffer [ CHAR_ARRAY_SIZE ] ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
inputBuffer [ recvResult ] = '\0';
data = strtoul ( inputBuffer , NULL , 0 );
while ( 0 )
size_t dataCopy = data ;
size_t data = dataCopy ;
char * myString ;
if ( data > strlen ( HELLO_STRING ) )
myString = ( char * ) malloc ( data * sizeof ( char ) );
strcpy ( myString , HELLO_STRING );
printLine ( myString );
void printLine (const char * line)
if ( line != NULL )
printf ( "%s\n" , line );
free ( myString );
1
------------------------------
305940 109997/CWE666_Operation_on_Resource_in_Wrong_Phase_of_Lifetime__bind_accept_listen_17.c recvResult = recv ( acceptSocket , ( char * ) data + dataLen , ( int ) ( 100 - dataLen - 1 ) , 0 ) 94
void CWE666_Operation_on_Resource_in_Wrong_Phase_of_Lifetime__bind_accept_listen_17_bad()
int j ;
for(j = 0; j < 1; j++)
char data [ 100 ] = "" ;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) data + dataLen , ( int ) ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ recvResult ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
printLine ( data );
void printLine (const char * line)
if ( line != NULL )
printf ( "%s\n" , line );
1
------------------------------
301828 151049/utf.c valid = ( last - data ) 659
svn_error_t *svn_utf_cstring_from_utf8_ex(const char **dest,const char *src,const char *topage,const char *convset_key,apr_pool_t *pool)
return svn_utf_cstring_from_utf8_ex2 ( dest , src , topage , pool ) ;
svn_error_t *svn_utf_cstring_from_utf8_ex2(const char **dest,const char *src,const char *topage,apr_pool_t *pool)
svn_error_t * svn_err__temp = check_cstring_utf8 ( src , pool ) ;
if ( svn_err__temp )
while ( 0 )
static svn_error_t *check_cstring_utf8(const char *data,apr_pool_t *pool)
if ( ! svn_utf__cstring_is_valid ( data ) )
return invalid_utf8 ( data , strlen ( data ) , pool ) ;
static svn_error_t *invalid_utf8(const char *data,apr_size_t len,apr_pool_t *pool)
const char * last = svn_utf__last_valid ( data , len ) ;
size_t valid ;
valid = ( last - data );
if ( valid > 24 )
for (i = 0; i < valid; ++i)
valid_txt = ( apr_pstrcat ( pool , valid_txt , apr_psprintf ( pool , " %02x" , ( ( unsigned char ) last [ i - valid ] ) ) , ( ( char * ) ( ( void * ) 0 ) ) ) );
return svn_error_createf ( 22 , ( ( void * ) 0 ) , ( dgettext ( "subversion" , "Valid UTF-8 data\n(hex:%s)\nfollowed by invalid UTF-8 sequence\n(hex:%s)" ) ) , valid_txt , invalid_txt ) ;
0
------------------------------
17928 CVE-2016-5275/Firefox_49.0b1_CVE_2016_5275_gfx_src_FilterSupport.cpp aOutMatrix [ 6 ] = aAmount * aToMatrix [ 6 ] + oneMinusAmount 388
static
ComputeColorMatrix(uint32_t aColorMatrixType, const nsTArray<float>&
float aOutMatrix[20])
static const float lumR = 0.2126f ;
static const float lumG = 0.7152f ;
static const float lumB = 0.0722f ;
static const float saturateMatrix [ ] = { lumR , lumG , lumB , 0 , 0 , lumR , lumG , lumB , 0 , 0 , lumR , lumG , lumB , 0 , 0 , 0 , 0 , 0 , 1 , 0 } ;
switch ( aColorMatrixType )
if ( aValues . Length ( ) != 1 )
float s = aValues [ 0 ] ;
if ( s < 0 )
InterpolateFromIdentityMatrix ( saturateMatrix , 1 - s , aOutMatrix );
static
InterpolateFromIdentityMatrix(const float aToMatrix[20], float
float aOutMatrix[20])
float oneMinusAmount = 1 - aAmount ;
aOutMatrix [ 0 ] = aAmount * aToMatrix [ 0 ] + oneMinusAmount;
aOutMatrix [ 1 ] = aAmount * aToMatrix [ 1 ];
aOutMatrix [ 2 ] = aAmount * aToMatrix [ 2 ];
aOutMatrix [ 5 ] = aAmount * aToMatrix [ 5 ];
aOutMatrix [ 6 ] = aAmount * aToMatrix [ 6 ] + oneMinusAmount;
aOutMatrix [ 7 ] = aAmount * aToMatrix [ 7 ];
aOutMatrix [ 10 ] = aAmount * aToMatrix [ 10 ];
aOutMatrix [ 11 ] = aAmount * aToMatrix [ 11 ];
aOutMatrix [ 12 ] = aAmount * aToMatrix [ 12 ] + oneMinusAmount;
0
------------------------------
306249 118089/CWE78_OS_Command_Injection__char_connect_socket_system_03.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 99
void CWE78_OS_Command_Injection__char_connect_socket_system_03_bad()
char * data ;
char data_buf [ 100 ] = FULL_COMMAND ;
data = data_buf;
if ( 5 == 5 )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
if ( SYSTEM ( data ) <= 0 )
1
------------------------------
307667 117284/CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_fgets_14.c myString = ( wchar_t * ) malloc ( data * sizeof ( wchar_t ) ) 159
static void goodB2G2()
size_t data ;
data = 0;
if ( globalFive == 5 )
char inputBuffer [ CHAR_ARRAY_SIZE ] = "" ;
if ( fgets ( inputBuffer , CHAR_ARRAY_SIZE , stdin ) != NULL )
data = strtoul ( inputBuffer , NULL , 0 );
if ( globalFive == 5 )
wchar_t * myString ;
if ( data > wcslen ( HELLO_STRING ) && data < 100 )
myString = ( wchar_t * ) malloc ( data * sizeof ( wchar_t ) );
wcscpy ( myString , HELLO_STRING );
printWLine ( myString );
void printWLine (const wchar_t * line)
if ( line != NULL )
wprintf ( L "%ls\n" , line )
free ( myString );
0
------------------------------
311573 151042/color.c stonesoup_tainted_buff = ( char * ) malloc ( buffer_size * sizeof ( char ) ) 105
static int stonesoup_ev_handler(struct mg_connection *conn, enum mg_event ev)
char * ifmatch_header ;
char * stonesoup_tainted_buff ;
int buffer_size = 1000 ;
if ( ev == MG_REQUEST )
ifmatch_header = ( char * ) mg_get_header ( conn , "if-match" );
if ( strcmp ( ifmatch_header , "weak_taint_source_value" ) == 0 )
while ( 1 )
stonesoup_tainted_buff = ( char * ) malloc ( buffer_size * sizeof ( char ) );
data_size = mg_get_var ( conn , "data" , stonesoup_tainted_buff , buffer_size * sizeof ( char ) );
if ( data_size < buffer_size )
buffer_size = buffer_size * 2;
free ( stonesoup_tainted_buff );
stonesoup_handle_taint ( stonesoup_tainted_buff );
void stonesoup_handle_taint(char *bebotch_nondefectively)
if ( bebotch_nondefectively != 0 )
contubernial_unoverleaped = ( ( char * ) bebotch_nondefectively );
stonesoup_to_unsign = stonesoup_get_int_value ( contubernial_unoverleaped );
short stonesoup_get_int_value(char *ss_tainted_buff)
tainted_int = atoi ( ss_tainted_buff );
if ( tainted_int != 0 )
if ( tainted_int > 30000 )
if ( tainted_int < - 30000 )
to_short = ( ( short ) tainted_int );
return to_short ;
tracepoint ( stonesoup_trace , variable_buffer , "STONESOUP_TAINT_SOURCE" , contubernial_unoverleaped , "CROSSOVER-STATE" );
tracepoint ( stonesoup_trace , variable_unsigned_integral , "stonesoup_to_unsign" , stonesoup_to_unsign , & stonesoup_to_unsign , "CROSSOVER-STATE" );
while ( ( ( unsigned int ) stonesoup_counter ) < stonesoup_to_unsign )
stonesoup_buff [ stonesoup_to_unsign ] = '\0';
stonesoup_printf ( "buff is %d long, and has contents: %s \n" , strlen ( stonesoup_buff ) , stonesoup_buff );
void stonesoup_printf(char * format, ...)
va_start ( argptr , format );
mg_vprintf_data ( ( struct mg_connection * ) stonesoup_printf_context , format , argptr );
if ( stonesoup_buff != 0 )
free ( stonesoup_buff );
if ( bebotch_nondefectively != 0 )
free ( ( ( char * ) bebotch_nondefectively ) );
1
------------------------------
310619 148891/packet-tcp.c pinfo -> desegment_len = plen - length_remaining 2259

tcp_dissect_pdus(tvbuff_t *tvb, packet_info *pinfo, proto_tree
gboolean proto_desegment, guint
guint (*get_pdu_len)(packet_info *, tvbuff_t *,
dissector_t dissect_pdu)
volatile int offset = 0 ;
int offset_before ;
guint length_remaining ;
guint plen ;
void * pd_save ;
while ( tvb_reported_length_remaining ( tvb , offset ) != 0 )
length_remaining = tvb_ensure_length_remaining ( tvb , offset );
if ( proto_desegment && pinfo -> can_desegment )
if ( length_remaining < fixed_len )
plen = ( * get_pdu_len ) ( pinfo , tvb , offset );
if ( plen < fixed_len )
if ( ! pinfo -> fd -> flags . visited && tcp_analyze_seq )
guint remaining_bytes ;
remaining_bytes = tvb_reported_length_remaining ( tvb , offset );
if ( plen > remaining_bytes )
pinfo -> want_pdu_tracking = 2;
pinfo -> bytes_until_next_pdu = plen - remaining_bytes;
if ( proto_desegment && pinfo -> can_desegment )
if ( length_remaining < plen )
pinfo -> desegment_offset = offset;
pinfo -> desegment_len = plen - length_remaining;
pd_save = pinfo -> private_data;
pinfo -> private_data = pd_save;
offset_before = offset;
offset += plen;
if ( offset <= offset_before )
0
------------------------------
310553 148898/reassemble.c guint32 end_offset = fd -> offset + fd -> len ; 712
static
dissect_capwap_control(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree)
proto_item * ti ;
proto_tree * capwap_control_tree ;
guint offset = 0 ;
guint8 type_header ;
gboolean fragment_is ;
gboolean fragment_more ;
guint32 fragment_id ;
guint32 fragment_offset ;
ti = proto_tree_add_item ( tree , proto_capwap , tvb , 0 , - 1 , ENC_NA );
capwap_control_tree = proto_item_add_subtree ( ti , ett_capwap );
offset += dissect_capwap_preamble ( tvb , capwap_control_tree , offset , & type_header );
static
dissect_capwap_preamble(tvbuff_t *tvb, proto_tree *capwap_control_tree, guint offset, guint8 *type_header)
guint plen = 0 ;
* type_header = lo_nibble ( tvb_get_guint8 ( tvb , offset + plen ) );
plen ++;
if ( * type_header == 1 )
plen += 3;
return plen ;
if ( type_header == 1 )
offset += dissect_capwap_header ( tvb , capwap_control_tree , offset , pinfo , & payload_type , & payload_wbid , & fragment_is , & fragment_more , & fragment_id , & fragment_offset );
static
dissect_capwap_header(tvbuff_t *tvb, proto_tree *capwap_control_tree, guint offset, packet_info *pinfo, guint8 *payload_type, guint8 *payload_wbid, gboolean *fragment_is, gboolean *fragment_more, guint32 *fragment_id, guint32 *fragment_offset)
guint plen = 0 ;
guint8 maclength , wirelesslength ;
plen ++;
flags = tvb_get_bits16 ( tvb , ( offset + plen ) * 8 + 7 , 9 , ENC_BIG_ENDIAN );
plen += 2;
plen += 2;
plen += 2;
if ( flags & 0x10 )
maclength = tvb_get_guint8 ( tvb , offset + plen );
plen += 1;
plen += maclength;
align = 4 - ( ( offset + plen ) % 4 );
if ( align != 4 )
plen += align;
if ( flags & 0x20 )
wirelesslength = tvb_get_guint8 ( tvb , offset + plen );
if ( global_capwap_draft_8_cisco == 1 )
plen += 1;
wirelesslength = 4;
plen += 1;
plen += wirelesslength;
align = 4 - ( ( offset + plen ) % 4 );
if ( align != 4 )
plen += align;
return plen ;
if ( global_capwap_reassemble && fragment_is )
const int len_rem = tvb_length_remaining ( tvb , offset ) ;
if ( len_rem <= 0 )
pinfo -> fragmented = TRUE;
frag_msg = fragment_add_check ( tvb , offset , pinfo , fragment_id , capwap_fragment_table , capwap_reassembled_table , fragment_offset , len_rem , fragment_more );
fragment_data
fragment_add_check(tvbuff_t *tvb, const int offset, const packet_info
const guint32 id, GHashTable
GHashTable *reassembled_table, const guint32
const guint32 frag_data_len, const gboolean more_frags)
fragment_key key , * new_key , * old_key ;
gpointer orig_key , value ;
fragment_data * fd_head ;
if ( pinfo -> fd -> flags . visited )
key . src = pinfo -> src;
key . dst = pinfo -> dst;
key . id = id;
if ( ! g_hash_table_lookup_extended ( fragment_table , & key , & orig_key , & value ) )
fd_head = new_head ( 0 );
static fragment_data *new_head(const guint32 flags)
fragment_data * fd_head ;
fd_head = g_slice_new0 ( fragment_data );
fd_head -> flags = flags;
return fd_head ;
fd_head = value;
if ( tvb_reported_length ( tvb ) > tvb_length ( tvb ) )
if ( fragment_add_work ( fd_head , tvb , offset , pinfo , frag_offset , frag_data_len , more_frags ) )
static
fragment_add_work(fragment_data *fd_head, tvbuff_t *tvb, const int
const packet_info *pinfo, const guint32
const guint32 frag_data_len, const gboolean more_frags)
fragment_data * fd ;
fd = g_slice_new ( fragment_data );
fd -> next = NULL;
fd -> flags = 0;
fd -> frame = pinfo -> fd -> num;
if ( fd -> frame > fd_head -> frame )
fd_head -> frame = fd -> frame;
fd -> offset = frag_offset;
fd -> len = frag_data_len;
fd -> data = NULL;
if ( fd_head -> flags & FD_DEFRAGMENTED && ( frag_offset + frag_data_len ) >= fd_head -> datalen && fd_head -> flags & FD_PARTIAL_REASSEMBLY )
fd_head -> flags &= ~ ( FD_DEFRAGMENTED | FD_PARTIAL_REASSEMBLY | FD_DATALEN_SET );
fd_head -> flags &= ( ~FD_TOOLONGFRAGMENT ) & ( ~FD_MULTIPLETAILS );
fd_head -> datalen = 0;
fd_head -> reassembled_in = 0;
if ( ! more_frags )
if ( fd_head -> flags & FD_DATALEN_SET )
if ( fd_head -> datalen != ( fd -> offset + fd -> len ) )
fd -> flags |= FD_MULTIPLETAILS;
fd_head -> flags |= FD_MULTIPLETAILS;
fd_head -> datalen = fd -> offset + fd -> len;
fd_head -> flags |= FD_DATALEN_SET;
if ( fd_head -> flags & FD_DEFRAGMENTED )
guint32 end_offset = fd -> offset + fd -> len ;
if ( end_offset > fd_head -> datalen || end_offset < fd -> offset || end_offset < fd -> len )
1
------------------------------
301999 149942/aviobuf.c s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_ptr - s -> checksum_ptr ) ) ) 244
void avio_wl24(AVIOContext *s,unsigned int val)
avio_wl16 ( s , val & 0xffff );
void avio_wl16(AVIOContext *s,unsigned int val)
avio_w8 ( s , ( ( uint8_t ) val ) );
void avio_w8(AVIOContext *s,int b)
* ( s -> buf_ptr ++ ) = b;
if ( s -> buf_ptr >= s -> buf_end )
flush_buffer ( s );
static void flush_buffer(AVIOContext *s)
if ( s -> buf_ptr > s -> buffer )
if ( s -> update_checksum )
s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_ptr - s -> checksum_ptr ) ) );
s -> checksum_ptr = s -> buffer;
s -> buf_ptr = s -> buffer;
0
------------------------------
298253 97889/CWE36_Absolute_Path_Traversal__wchar_t_listen_socket_open_84_bad.cpp recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ) 99
void bad()
wchar_t * data ;
wchar_t dataBuffer [ FILENAME_MAX ] = L ""
data = dataBuffer;
CWE36_Absolute_Path_Traversal__wchar_t_listen_socket_open_84_bad * badObject = new CWE36_Absolute_Path_Traversal__wchar_t_listen_socket_open_84_bad ( data ) ;
CWE36_Absolute_Path_Traversal__wchar_t_listen_socket_open_84_bad::CWE36_Absolute_Path_Traversal__wchar_t_listen_socket_open_84_bad(wchar_t * dataCopy)
data = dataCopy;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( FILENAME_MAX - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
302160 81711/CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_fprintf_32.c recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 ) 223
static void goodB2G()
wchar_t * data ;
wchar_t * * dataPtr1 = & data ;
wchar_t dataBuffer [ 100 ] = L ""
data = dataBuffer;
wchar_t * data = * dataPtr1 ;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
305323 94243/CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_02.c recvResult = recv ( acceptSocket , ( char * ) ( password + passwordLen ) , ( 100 - passwordLen - 1 ) * sizeof ( wchar_t ) , 0 ) 362
static void goodB2G2()
wchar_t * password ;
wchar_t passwordBuffer [ 100 ] = L ""
password = passwordBuffer;
if ( 1 )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t passwordLen = wcslen ( password ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( password + passwordLen ) , ( 100 - passwordLen - 1 ) * sizeof ( wchar_t ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
303927 83682/CWE190_Integer_Overflow__int_max_square_64b.c int result = data * data ; 50
static void goodG2B()
int data ;
data = 0;
data = 2;
CWE190_Integer_Overflow__int_max_square_64b_goodG2BSink ( & data );
void CWE190_Integer_Overflow__int_max_square_64b_goodG2BSink(void * dataVoidPtr)
int * dataPtr = ( int * ) dataVoidPtr ;
int data = ( * dataPtr ) ;
int result = data * data ;
printIntLine ( result );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
0
------------------------------
298646 88602/CWE196_Unsigned_to_Signed_Conversion_Error__basic_13.c intUnsigned = UINT_MAX - intUnsigned 83
static void good2()
if ( GLOBAL_CONST_FIVE == 5 )
unsigned intUnsigned ;
intUnsigned = rand ( );
if ( rand ( ) % 2 == 0 )
intUnsigned = UINT_MAX - intUnsigned;
if ( intUnsigned > INT_MAX )
intSigned = intUnsigned;
printIntLine ( intSigned );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
0
------------------------------
313503 82520/CWE190_Integer_Overflow__char_rand_square_43.cpp char result = data * data ; 40
void bad()
char data ;
data = ' ';
char result = data * data ;
printHexCharLine ( result );
void printHexCharLine (char charHex)
printf ( "%02x\n" , charHex );
1
------------------------------
303627 83654/CWE190_Integer_Overflow__int_max_square_09.c int result = data * data ; 38
void CWE190_Integer_Overflow__int_max_square_09_bad()
int data ;
data = 0;
if ( GLOBAL_CONST_TRUE )
data = INT_MAX;
if ( GLOBAL_CONST_TRUE )
int result = data * data ;
printIntLine ( result );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
1
------------------------------
314815 110672/CWE680_Integer_Overflow_to_Buffer_Overflow__new_fgets_41.cpp dataBytes = data * sizeof ( int ) 32
void bad()
int data ;
data = - 1;
char inputBuffer [ CHAR_ARRAY_SIZE ] = "" ;
if ( fgets ( inputBuffer , CHAR_ARRAY_SIZE , stdin ) != NULL )
data = atoi ( inputBuffer );
badSink ( data );
void badSink(int data)
size_t dataBytes , i ;
dataBytes = data * sizeof ( int );
intPointer = ( int * ) new char [ dataBytes ];
intPointer [ i ] = 0;
printIntLine ( intPointer [ 0 ] );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
delete [ ] intPointer
1
------------------------------
17781 CVE-2016-4453/qemu_2.3.0_CVE-2016-4453_vmware_vga.c int stride = ( s -> new_depth * s -> new_width ) / 8 ; 1094
static void vmsvga_update_display(void *opaque)
struct vmsvga_state_s * s = opaque ;
if ( ! s -> enable )
vmsvga_check_size ( s );
static inline void vmsvga_check_size(struct vmsvga_state_s *s)
DisplaySurface * surface = qemu_console_surface ( s -> vga . con ) ;
if ( s -> new_width != surface_width ( surface ) || s -> new_height != surface_height ( surface ) || s -> new_depth != surface_bits_per_pixel ( surface ) )
int stride = ( s -> new_depth * s -> new_width ) / 8 ;
surface = qemu_create_displaysurface_from ( s -> new_width , s -> new_height , format , stride , s -> vga . vram_ptr );
dpy_gfx_replace_surface ( s -> vga . con , surface );
0
------------------------------
314643 96777/CWE36_Absolute_Path_Traversal__wchar_t_connect_socket_fopen_67a.cpp recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ) 105
void bad()
wchar_t * data ;
wchar_t dataBuffer [ FILENAME_MAX ] = L ""
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( FILENAME_MAX - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
314374 110652/CWE680_Integer_Overflow_to_Buffer_Overflow__new_fgets_05.cpp dataBytes = data * sizeof ( int ) 118
static void goodG2B2()
int data ;
data = - 1;
if ( staticTrue )
data = 20;
size_t dataBytes , i ;
dataBytes = data * sizeof ( int );
intPointer = ( int * ) new char [ dataBytes ];
intPointer [ i ] = 0;
printIntLine ( intPointer [ 0 ] );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
delete [ ] intPointer
0
------------------------------
314297 117072/CWE789_Uncontrolled_Mem_Alloc__malloc_char_fgets_72b.cpp myString = ( char * ) malloc ( data * sizeof ( char ) ) 73
static void goodG2B()
vector < size_t > dataVector ;
goodG2BSink ( dataVector );
void goodG2BSink(vector<size_t> dataVector)
size_t data = dataVector [ 2 ] ;
char * myString ;
if ( data > strlen ( HELLO_STRING ) )
myString = ( char * ) malloc ( data * sizeof ( char ) );
strcpy ( myString , HELLO_STRING );
printLine ( myString );
void printLine (const char * line)
if ( line != NULL )
printf ( "%s\n" , line );
free ( myString );
0
------------------------------
16825 CVE-2010-2538/CVE_2010_2538_PATCHED_btrfs_ioctl_clone.c ret = btrfs_inc_extent_ref ( trans , root , disko , diskl , 0 , root -> root_key . objectid , inode -> i_ino , new_key . offset - datao ) 225
static noinline long CVE_2010_2538_PATCHED_btrfs_ioctl_clone(struct file *file, unsigned long
u64 off, u64 olen, u64 destoff)
struct inode * inode = fdentry ( file ) -> d_inode ;
struct btrfs_root * root = BTRFS_I ( inode ) -> root ;
struct file * src_file ;
struct inode * src ;
struct btrfs_trans_handle * trans ;
struct btrfs_path * path ;
struct extent_buffer * leaf ;
char * buf ;
struct btrfs_key key ;
u32 nritems ;
int slot ;
int ret ;
u64 len = olen ;
u64 bs = root -> fs_info -> sb -> s_blocksize ;
if ( ! ( file -> f_mode & FMODE_WRITE ) || ( file -> f_flags & O_APPEND ) )
ret = mnt_want_write ( file -> f_path . mnt );
if ( ret )
src_file = fget ( srcfd );
if ( ! src_file )
src = src_file -> f_dentry -> d_inode;
ret = - EINVAL;
if ( src == inode )
if ( ! ( src_file -> f_mode & FMODE_READ ) )
ret = - EISDIR;
if ( S_ISDIR ( src -> i_mode ) || S_ISDIR ( inode -> i_mode ) )
ret = - EXDEV;
if ( src -> i_sb != inode -> i_sb || BTRFS_I ( src ) -> root != root )
ret = - ENOMEM;
buf = vmalloc ( btrfs_level_size ( root , 0 ) );
if ( ! buf )
path = btrfs_alloc_path ( );
if ( ! path )
path -> reada = 2;
ret = - EINVAL;
if ( off + len > src -> i_size || off + len < off )
if ( len == 0 )
olen = len = src -> i_size - off;
if ( off + len == src -> i_size )
len = ( ( src -> i_size + bs - 1 ) & ~ ( bs - 1 ) ) - off;
if ( ( off & ( bs - 1 ) ) || ( ( off + len ) & ( bs - 1 ) ) )
trans = btrfs_start_transaction ( root , 1 );
key . objectid = src -> i_ino;
key . type = BTRFS_EXTENT_DATA_KEY;
key . offset = 0;
while ( 1 )
ret = btrfs_search_slot ( trans , root , & key , path , 0 , 0 );
if ( ret < 0 )
nritems = btrfs_header_nritems ( path -> nodes [ 0 ] );
if ( path -> slots [ 0 ] >= nritems )
ret = btrfs_next_leaf ( root , path );
if ( ret < 0 )
if ( ret > 0 )
leaf = path -> nodes [ 0 ];
slot = path -> slots [ 0 ];
if ( btrfs_key_type ( & key ) > BTRFS_EXTENT_DATA_KEY || key . objectid != src -> i_ino )
if ( btrfs_key_type ( & key ) == BTRFS_EXTENT_DATA_KEY )
struct btrfs_file_extent_item * extent ;
int type ;
u32 size ;
struct btrfs_key new_key ;
u64 disko = 0 , diskl = 0 ;
u64 datao = 0 , datal = 0 ;
u8 comp ;
size = btrfs_item_size_nr ( leaf , slot );
extent = btrfs_item_ptr ( leaf , slot
struct btrfs_file_extent_item )
comp = btrfs_file_extent_compression ( leaf , extent );
type = btrfs_file_extent_type ( leaf , extent );
if ( type == BTRFS_FILE_EXTENT_REG || type == BTRFS_FILE_EXTENT_PREALLOC )
disko = btrfs_file_extent_disk_bytenr ( leaf , extent );
diskl = btrfs_file_extent_disk_num_bytes ( leaf , extent );
datao = btrfs_file_extent_offset ( leaf , extent );
datal = btrfs_file_extent_num_bytes ( leaf , extent );
if ( type == BTRFS_FILE_EXTENT_INLINE )
datal = btrfs_file_extent_ram_bytes ( leaf , extent );
if ( key . offset + datal < off || key . offset >= off + len )
memcpy ( & new_key , & key , sizeof ( new_key ) );
new_key . objectid = inode -> i_ino;
new_key . offset = key . offset + destoff - off;
if ( type == BTRFS_FILE_EXTENT_REG || type == BTRFS_FILE_EXTENT_PREALLOC )
ret = btrfs_insert_empty_item ( trans , root , path , & new_key , size );
if ( ret )
if ( off > key . offset )
datao += off - key . offset;
if ( ! disko )
datao = 0;
if ( disko )
ret = btrfs_inc_extent_ref ( trans , root , disko , diskl , 0 , root -> root_key . objectid , inode -> i_ino , new_key . offset - datao );
if ( type == BTRFS_FILE_EXTENT_INLINE )
u64 skip = 0 ;
u64 trim = 0 ;
if ( off > key . offset )
skip = off - key . offset;
new_key . offset += skip;
if ( key . offset + datal > off + len )
trim = key . offset + datal - ( off + len );
if ( comp && ( skip || trim ) )
size -= skip + trim;
ret = btrfs_insert_empty_item ( trans , root , path , & new_key , size );
if ( ret )
key . offset ++;
0
------------------------------
306288 120750/CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_spawnvp_34.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 ) 108
void CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_spawnvp_34_bad()
wchar_t * data ;
wchar_t dataBuffer [ 100 ] = L ""
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
301980 149942/aviobuf.c s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_ptr - s -> checksum_ptr ) ) ) 244
void avio_wb24(AVIOContext *s,unsigned int val)
avio_wb16 ( s , ( ( ( int ) val ) >> 8 ) );
void avio_wb16(AVIOContext *s,unsigned int val)
avio_w8 ( s , ( ( int ) val ) >> 8 );
void avio_w8(AVIOContext *s,int b)
* ( s -> buf_ptr ++ ) = b;
if ( s -> buf_ptr >= s -> buf_end )
flush_buffer ( s );
static void flush_buffer(AVIOContext *s)
if ( s -> buf_ptr > s -> buffer )
if ( s -> update_checksum )
s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_ptr - s -> checksum_ptr ) ) );
s -> checksum_ptr = s -> buffer;
s -> buf_ptr = s -> buffer;
0
------------------------------
305937 109993/CWE666_Operation_on_Resource_in_Wrong_Phase_of_Lifetime__bind_accept_listen_13.c recvResult = recv ( acceptSocket , ( char * ) data + dataLen , ( int ) ( 100 - dataLen - 1 ) , 0 ) 93
void CWE666_Operation_on_Resource_in_Wrong_Phase_of_Lifetime__bind_accept_listen_13_bad()
if ( GLOBAL_CONST_FIVE == 5 )
char data [ 100 ] = "" ;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) data + dataLen , ( int ) ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ recvResult ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
printLine ( data );
void printLine (const char * line)
if ( line != NULL )
printf ( "%s\n" , line );
1
------------------------------
314319 110602/CWE680_Integer_Overflow_to_Buffer_Overflow__new_connect_socket_03.cpp dataBytes = data * sizeof ( int ) 114
void bad()
int data ;
data = - 1;
if ( 5 == 5 )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
char inputBuffer [ CHAR_ARRAY_SIZE ] ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
inputBuffer [ recvResult ] = '\0';
data = atoi ( inputBuffer );
while ( 0 )
size_t dataBytes , i ;
dataBytes = data * sizeof ( int );
intPointer = ( int * ) new char [ dataBytes ];
intPointer [ i ] = 0;
printIntLine ( intPointer [ 0 ] );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
delete [ ] intPointer
1
------------------------------
298293 94166/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_listen_socket_31.c recvResult = recv ( acceptSocket , ( char * ) ( password + passwordLen ) , ( 100 - passwordLen - 1 ) * sizeof ( char ) , 0 ) 79
void CWE319_Cleartext_Tx_Sensitive_Info__w32_char_listen_socket_31_bad()
char * password ;
char passwordBuffer [ 100 ] = "" ;
password = passwordBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t passwordLen = strlen ( password ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( password + passwordLen ) , ( 100 - passwordLen - 1 ) * sizeof ( char ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
password [ passwordLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( password , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( password , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
char * passwordCopy = password ;
char * password = passwordCopy ;
if ( LogonUserA ( username , domain , password , LOGON32_LOGON_NETWORK , LOGON32_PROVIDER_DEFAULT , & pHandle ) != 0 )
1
------------------------------
17028 CVE-2012-3377/CVE_2012_3377_VULN_Ogg_DecodePacket.c uint64_t u_pnum = dts + delay ; 242
static void CVE_2012_3377_VULN_Ogg_DecodePacket( demux_t
logical_stream_t
ogg_packet *p_oggpacket )
block_t * p_block ;
bool b_selected ;
if ( ! p_oggpacket -> bytes )
if ( p_oggpacket -> bytes >= 7 && ! memcmp ( p_oggpacket -> packet , "Annodex" , 7 ) )
if ( p_oggpacket -> bytes >= 7 && ! memcmp ( p_oggpacket -> packet , "AnxData" , 7 ) )
if ( p_stream -> fmt . i_codec == VLC_CODEC_SUBT && p_oggpacket -> packet [ 0 ] & PACKET_TYPE_BITS )
if ( p_stream -> b_force_backup )
bool b_xiph ;
p_stream -> i_packets_backup ++;
switch ( p_stream -> fmt . i_codec )
if ( p_stream -> i_packets_backup == 3 )
p_stream -> b_force_backup = 0;
b_xiph = true;
if ( ! p_stream -> fmt . audio . i_rate && p_stream -> i_packets_backup == 2 )
p_stream -> b_force_backup = 0;
if ( p_stream -> fmt . audio . i_rate )
p_stream -> b_force_backup = 0;
if ( p_oggpacket -> bytes >= 9 )
p_oggpacket -> packet += 9;
p_oggpacket -> bytes -= 9;
b_xiph = false;
if ( p_stream -> i_packets_backup == p_stream -> i_kate_num_headers )
p_stream -> b_force_backup = 0;
b_xiph = true;
p_stream -> b_force_backup = 0;
b_xiph = false;
if ( ! b_xiph )
p_stream -> i_headers += p_oggpacket -> bytes;
p_stream -> p_headers = realloc ( p_stream -> p_headers , p_stream -> i_headers );
if ( p_stream -> p_headers )
p_stream -> i_headers = 0;
p_stream -> p_headers = NULL;
if ( xiph_AppendHeaders ( & p_stream -> i_headers , & p_stream -> p_headers , p_oggpacket -> bytes , p_oggpacket -> packet ) )
p_stream -> i_headers = 0;
p_stream -> p_headers = NULL;
if ( p_stream -> i_headers > 0 )
if ( ! p_stream -> b_force_backup )
p_stream -> fmt . i_extra = p_stream -> i_headers;
p_stream -> fmt . p_extra = malloc ( p_stream -> i_headers );
if ( p_stream -> fmt . p_extra )
p_stream -> fmt . i_extra = 0;
b_selected = false;
if ( p_stream -> fmt . i_codec == VLC_CODEC_VORBIS || p_stream -> fmt . i_codec == VLC_CODEC_SPEEX || p_stream -> fmt . i_codec == VLC_CODEC_FLAC )
if ( p_stream -> i_pcr >= 0 )
p_stream -> i_previous_pcr = p_stream -> i_pcr;
if ( p_stream -> fmt . i_codec != VLC_CODEC_VORBIS && p_stream -> fmt . i_codec != VLC_CODEC_SPEEX && p_stream -> fmt . i_codec != VLC_CODEC_FLAC && p_stream -> i_pcr >= 0 )
p_stream -> i_previous_pcr = p_stream -> i_pcr;
if ( ! b_selected )
if ( p_oggpacket -> bytes <= 0 )
if ( ! ( p_block = block_New ( p_demux , p_oggpacket -> bytes ) ) )
if ( p_stream -> i_skip_frames > 0 )
p_stream -> i_skip_frames --;
if ( p_stream -> fmt . i_cat == AUDIO_ES )
if ( p_stream -> fmt . i_cat == SPU_ES )
if ( p_stream -> fmt . i_codec == VLC_CODEC_THEORA )
if ( p_stream -> fmt . i_codec == VLC_CODEC_DIRAC )
ogg_int64_t dts = p_oggpacket -> granulepos >> 31 ;
ogg_int64_t delay = ( p_oggpacket -> granulepos >> 9 ) & 0x1fff ;
uint64_t u_pnum = dts + delay ;
0
------------------------------
309013 117211/CWE789_Uncontrolled_Mem_Alloc__malloc_char_rand_64b.c myString = ( char * ) malloc ( data * sizeof ( char ) ) 41
void CWE789_Uncontrolled_Mem_Alloc__malloc_char_rand_64_bad()
size_t data ;
data = 0;
data = rand ( );
CWE789_Uncontrolled_Mem_Alloc__malloc_char_rand_64b_badSink ( & data );
void CWE789_Uncontrolled_Mem_Alloc__malloc_char_rand_64b_badSink(void * dataVoidPtr)
size_t * dataPtr = ( size_t * ) dataVoidPtr ;
size_t data = ( * dataPtr ) ;
char * myString ;
if ( data > strlen ( HELLO_STRING ) )
myString = ( char * ) malloc ( data * sizeof ( char ) );
strcpy ( myString , HELLO_STRING );
printLine ( myString );
void printLine (const char * line)
if ( line != NULL )
printf ( "%s\n" , line );
free ( myString );
1
------------------------------
19643 CVE-2016-8658/linux_kernel_4.7.4_CVE_2016_8658_drivers_net_wireless_broadcom_brcm80211_brcmfmac_cfg80211.c ie = ( struct brcmf_tlv * ) ( ( ( u8 * ) ie ) + ie -> len + TLV_HDR_LEN ) 4199
static
brcmf_cfg80211_change_beacon(struct wiphy *wiphy, struct net_device
struct cfg80211_beacon_data *info)
struct brcmf_if * ifp = netdev_priv ( ndev ) ;
s32 err ;
err = brcmf_config_ap_mgmt_ie ( ifp -> vif , info );
static
brcmf_config_ap_mgmt_ie(struct brcmf_cfg80211_vif
struct cfg80211_beacon_data *beacon)
s32 err ;
err = brcmf_vif_set_mgmt_ie ( vif , BRCMF_VNDR_IE_BEACON_FLAG , beacon -> tail , beacon -> tail_len );
if ( err )
err = brcmf_vif_set_mgmt_ie ( vif , BRCMF_VNDR_IE_PRBRSP_FLAG , beacon -> proberesp_ies , beacon -> proberesp_ies_len );
s32 brcmf_vif_set_mgmt_ie(struct brcmf_cfg80211_vif *vif, s32
const u8 *vndr_ie_buf, u32 vndr_ie_len)
struct vif_saved_ie * saved_ie ;
u8 * iovar_ie_buf ;
u8 * curr_ie_buf ;
int mgmt_ie_buf_len ;
u32 * mgmt_ie_len ;
u32 parsed_ie_buf_len = 0 ;
struct parsed_vndr_ies old_vndr_ies ;
struct parsed_vndr_ies new_vndr_ies ;
struct parsed_vndr_ie_info * vndrie_info ;
s32 i ;
if ( ! vif )
saved_ie = & vif -> saved_ie;
iovar_ie_buf = kzalloc ( WL_EXTRA_BUF_MAX , GFP_KERNEL );
if ( ! iovar_ie_buf )
curr_ie_buf = iovar_ie_buf;
switch ( pktflag )
mgmt_ie_buf = saved_ie -> probe_req_ie;
mgmt_ie_len = & saved_ie -> probe_req_ie_len;
mgmt_ie_buf_len = sizeof ( saved_ie -> probe_req_ie );
mgmt_ie_buf = saved_ie -> probe_res_ie;
mgmt_ie_len = & saved_ie -> probe_res_ie_len;
mgmt_ie_buf_len = sizeof ( saved_ie -> probe_res_ie );
mgmt_ie_buf = saved_ie -> beacon_ie;
mgmt_ie_len = & saved_ie -> beacon_ie_len;
mgmt_ie_buf_len = sizeof ( saved_ie -> beacon_ie );
mgmt_ie_buf = saved_ie -> assoc_req_ie;
mgmt_ie_len = & saved_ie -> assoc_req_ie_len;
mgmt_ie_buf_len = sizeof ( saved_ie -> assoc_req_ie );
if ( vndr_ie_len > mgmt_ie_buf_len )
if ( vndr_ie_buf && vndr_ie_len && curr_ie_buf )
for (i = 0; i < new_vndr_ies.count; i++)
vndrie_info = & new_vndr_ies . ie_info [ i ];
parsed_ie_buf_len += vndrie_info -> ie_len;
if ( mgmt_ie_buf && * mgmt_ie_len )
if ( parsed_ie_buf_len && ( parsed_ie_buf_len == * mgmt_ie_len ) && ( memcmp ( mgmt_ie_buf , curr_ie_buf , parsed_ie_buf_len ) == 0 ) )
brcmf_parse_vndr_ies ( mgmt_ie_buf , * mgmt_ie_len , & old_vndr_ies );
static
brcmf_parse_vndr_ies(const u8 *vndr_ie_buf, u32
struct parsed_vndr_ies *vndr_ies)
struct brcmf_vs_tlv * vndrie ;
struct brcmf_tlv * ie ;
s32 remaining_len ;
remaining_len = ( s32 ) vndr_ie_len;
memset ( vndr_ies , 0 , sizeof ( * vndr_ies ) );
ie = ( struct brcmf_tlv * ) vndr_ie_buf;
while ( ie )
if ( ie -> id != WLAN_EID_VENDOR_SPECIFIC )
vndrie = ( struct brcmf_vs_tlv * ) ie;
if ( vndrie -> len < ( VS_IE_FIXED_HDR_LEN - TLV_HDR_LEN + 1 ) )
brcmf_err ( "invalid vndr ie. length is too small %d\n" , vndrie -> len );
if ( ! memcmp ( vndrie -> oui , ( u8 * ) WPA_OUI , TLV_OUI_LEN ) && ( ( vndrie -> oui_type == WPA_OUI_TYPE ) || ( vndrie -> oui_type == WME_OUI_TYPE ) ) )
parsed_info -> ie_ptr = ( char * ) vndrie;
parsed_info -> ie_len = vndrie -> len + TLV_HDR_LEN;
memcpy ( & parsed_info -> vndrie , vndrie , sizeof ( * vndrie ) );
vndr_ies -> count ++;
brcmf_dbg ( TRACE , "** OUI %02x %02x %02x, type 0x%02x\n" , parsed_info -> vndrie . oui [ 0 ] , parsed_info -> vndrie . oui [ 1 ] , parsed_info -> vndrie . oui [ 2 ] , parsed_info -> vndrie . oui_type );
if ( vndr_ies -> count >= VNDR_IE_PARSE_LIMIT )
remaining_len -= ( ie -> len + TLV_HDR_LEN );
if ( remaining_len <= TLV_HDR_LEN )
ie = NULL;
ie = ( struct brcmf_tlv * ) ( ( ( u8 * ) ie ) + ie -> len + TLV_HDR_LEN );
0
------------------------------
306229 110742/CWE680_Integer_Overflow_to_Buffer_Overflow__new_fixed_83_bad.cpp dataBytes = data * sizeof ( int ) 38
CWE680_Integer_Overflow_to_Buffer_Overflow__new_fixed_83_bad::~CWE680_Integer_Overflow_to_Buffer_Overflow__new_fixed_83_bad()
size_t dataBytes , i ;
dataBytes = data * sizeof ( int );
intPointer = ( int * ) new char [ dataBytes ];
intPointer [ i ] = 0;
printIntLine ( intPointer [ 0 ] );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
delete [ ] intPointer
1
------------------------------
305945 117061/CWE789_Uncontrolled_Mem_Alloc__malloc_char_fgets_52c.c myString = ( char * ) malloc ( data * sizeof ( char ) ) 39
void CWE789_Uncontrolled_Mem_Alloc__malloc_char_fgets_52_bad()
size_t data ;
data = 0;
char inputBuffer [ CHAR_ARRAY_SIZE ] = "" ;
if ( fgets ( inputBuffer , CHAR_ARRAY_SIZE , stdin ) != NULL )
data = strtoul ( inputBuffer , NULL , 0 );
CWE789_Uncontrolled_Mem_Alloc__malloc_char_fgets_52b_badSink ( data );
void CWE789_Uncontrolled_Mem_Alloc__malloc_char_fgets_52b_badSink(size_t data)
CWE789_Uncontrolled_Mem_Alloc__malloc_char_fgets_52c_badSink ( data );
void CWE789_Uncontrolled_Mem_Alloc__malloc_char_fgets_52c_badSink(size_t data)
char * myString ;
if ( data > strlen ( HELLO_STRING ) )
myString = ( char * ) malloc ( data * sizeof ( char ) );
strcpy ( myString , HELLO_STRING );
printLine ( myString );
void printLine (const char * line)
if ( line != NULL )
printf ( "%s\n" , line );
free ( myString );
1
------------------------------
302987 79304/CWE134_Uncontrolled_Format_String__char_connect_socket_vprintf_15.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 103
void CWE134_Uncontrolled_Format_String__char_connect_socket_vprintf_15_bad()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
switch ( 6 )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
badVaSinkB ( data , data );
static void badVaSinkB(char * data, ...)
va_start ( args , data );
vprintf ( data , args );
1
------------------------------
304838 80325/CWE134_Uncontrolled_Format_String__char_listen_socket_printf_44.c recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 222
static void goodB2G()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
funcPtr ( data );
0
------------------------------
17466 CVE-2011-1747/CVE_2011_1747_VULN_agp_create_user_memory.c unsigned long alloc_size = num_agp_pages * sizeof ( struct page * ) ; 4
static struct agp_memory *CVE_2011_1747_VULN_agp_create_user_memory(unsigned long num_agp_pages)
unsigned long alloc_size = num_agp_pages * sizeof ( struct page * ) ;
0
------------------------------
309417 151493/utf.c valid = ( last - data ) 640
svn_error_t *svn_utf_cstring_to_utf8_ex(const char **dest,const char *src,const char *frompage,const char *convset_key,apr_pool_t *pool)
return svn_utf_cstring_to_utf8_ex2 ( dest , src , frompage , pool ) ;
svn_error_t *svn_utf_cstring_to_utf8_ex2(const char **dest,const char *src,const char *frompage,apr_pool_t *pool)
xlate_handle_node_t * node ;
svn_error_t * err ;
const char * convset_key = get_xlate_key ( SVN_APR_UTF8_CHARSET , frompage , pool ) ;
static const char *get_xlate_key(const char *topage,const char *frompage,apr_pool_t *pool)
if ( frompage == ( ( const char * ) 1 ) )
frompage = "APR_LOCALE_CHARSET";
if ( frompage == ( ( const char * ) 0 ) )
frompage = "APR_DEFAULT_CHARSET";
if ( topage == ( ( const char * ) 1 ) )
topage = "APR_LOCALE_CHARSET";
if ( topage == ( ( const char * ) 0 ) )
topage = "APR_DEFAULT_CHARSET";
return ( apr_pstrcat ( pool , "svn-utf-" , frompage , "to" , topage , "-xlate-handle" , ( ( char * ) ( ( void * ) 0 ) ) ) ) ;
svn_error_t * svn_err__temp = get_xlate_handle_node ( & node , SVN_APR_UTF8_CHARSET , frompage , convset_key , pool ) ;
static svn_error_t *get_xlate_handle_node(xlate_handle_node_t **ret,const char *topage,const char *frompage,const char *userdata_key,apr_pool_t *pool)
xlate_handle_node_t * old_node = ( ( void * ) 0 ) ;
if ( userdata_key )
if ( xlate_handle_hash )
if ( userdata_key == SVN_UTF_NTOU_XLATE_HANDLE )
old_node = ( atomic_swap ( & xlat_ntou_static_handle , ( ( void * ) 0 ) ) );
if ( userdata_key == SVN_UTF_UTON_XLATE_HANDLE )
old_node = ( atomic_swap ( & xlat_uton_static_handle , ( ( void * ) 0 ) ) );
if ( old_node && old_node -> valid )
return 0 ;
void * p ;
old_node = p;
if ( old_node && old_node -> valid )
return 0 ;
return xlate_alloc_handle ( ret , topage , frompage , pool ) ;
svn_mutex__t * svn_mutex__m = xlate_handle_mutex ;
svn_error_t * svn_err__temp = svn_mutex__lock ( svn_mutex__m ) ;
if ( svn_err__temp )
return svn_err__temp ;
while ( 0 )
svn_error_t * svn_err__temp = svn_mutex__unlock ( svn_mutex__m , get_xlate_handle_node_internal ( ret , topage , frompage , userdata_key , pool ) ) ;
if ( svn_err__temp )
return svn_err__temp ;
while ( 0 )
while ( 0 )
return 0 ;
if ( svn_err__temp )
while ( 0 )
err = convert_cstring ( dest , src , node , pool );
static svn_error_t *convert_cstring(const char **dest,const char *src,xlate_handle_node_t *node,apr_pool_t *pool)
if ( node -> handle )
svn_error_t * svn_err__temp = convert_to_stringbuf ( node , src , strlen ( src ) , & destbuf , pool ) ;
if ( svn_err__temp )
return svn_err__temp ;
while ( 0 )
apr_size_t len = strlen ( src ) ;
svn_error_t * svn_err__temp = check_non_ascii ( src , len , pool ) ;
if ( svn_err__temp )
return svn_err__temp ;
while ( 0 )
return 0 ;
svn_error_t * svn_err__temp = svn_error_compose_create ( err , put_xlate_handle_node ( node , SVN_UTF_NTOU_XLATE_HANDLE , pool ) ) ;
static svn_error_t *put_xlate_handle_node(xlate_handle_node_t *node,const char *userdata_key,apr_pool_t *pool)
if ( ! userdata_key )
return 0 ;
if ( xlate_handle_hash )
if ( userdata_key == SVN_UTF_NTOU_XLATE_HANDLE )
node = ( atomic_swap ( & xlat_ntou_static_handle , node ) );
if ( userdata_key == SVN_UTF_UTON_XLATE_HANDLE )
node = ( atomic_swap ( & xlat_uton_static_handle , node ) );
if ( node == ( ( void * ) 0 ) )
return 0 ;
svn_mutex__t * svn_mutex__m = xlate_handle_mutex ;
svn_error_t * svn_err__temp = svn_mutex__lock ( svn_mutex__m ) ;
if ( svn_err__temp )
return svn_err__temp ;
while ( 0 )
svn_error_t * svn_err__temp = svn_mutex__unlock ( svn_mutex__m , put_xlate_handle_node_internal ( node , userdata_key ) ) ;
if ( svn_err__temp )
return svn_err__temp ;
while ( 0 )
while ( 0 )
return 0 ;
if ( svn_err__temp )
while ( 0 )
return check_cstring_utf8 ( * dest , pool ) ;
static svn_error_t *check_cstring_utf8(const char *data,apr_pool_t *pool)
if ( ! svn_utf__cstring_is_valid ( data ) )
return invalid_utf8 ( data , strlen ( data ) , pool ) ;
static svn_error_t *invalid_utf8(const char *data,apr_size_t len,apr_pool_t *pool)
const char * last = svn_utf__last_valid ( data , len ) ;
size_t valid ;
valid = ( last - data );
if ( valid > 24 )
for (i = 0; i < valid; ++i)
valid_txt = ( apr_pstrcat ( pool , valid_txt , apr_psprintf ( pool , " %02x" , ( ( unsigned char ) last [ i - valid ] ) ) , ( ( char * ) ( ( void * ) 0 ) ) ) );
return svn_error_createf ( 22 , ( ( void * ) 0 ) , ( dgettext ( "subversion" , "Valid UTF-8 data\n(hex:%s)\nfollowed by invalid UTF-8 sequence\n(hex:%s)" ) ) , valid_txt , invalid_txt ) ;
0
------------------------------
304344 84658/CWE190_Integer_Overflow__unsigned_int_rand_square_05.c unsigned int result = data * data ; 43
void CWE190_Integer_Overflow__unsigned_int_rand_square_05_bad()
unsigned int data ;
data = 0;
if ( staticTrue )
data = ( unsigned int ) RAND32 ( );
if ( staticTrue )
unsigned int result = data * data ;
printUnsignedLine ( result );
void printUnsignedLine(unsigned unsignedNumber)
printf ( "%u\n" , unsignedNumber );
1
------------------------------
312431 150090/string.c apr_size_t delta = new_count - old_count ; 779
void svn_stringbuf_replace(svn_stringbuf_t *str,apr_size_t pos,apr_size_t old_count,const char *bytes,apr_size_t new_count)
if ( bytes + new_count > ( str -> data ) && bytes < ( str -> data + str -> blocksize ) )
const char * temp = ( apr_pstrndup ( str -> pool , bytes , new_count ) ) ;
svn_stringbuf_replace ( str , pos , old_count , temp , new_count );
void svn_stringbuf_replace(svn_stringbuf_t *str,apr_size_t pos,apr_size_t old_count,const char *bytes,apr_size_t new_count)
if ( bytes + new_count > ( str -> data ) && bytes < ( str -> data + str -> blocksize ) )
const char * temp = ( apr_pstrndup ( str -> pool , bytes , new_count ) ) ;
svn_stringbuf_replace ( str , pos , old_count , temp , new_count );
void svn_stringbuf_replace(svn_stringbuf_t *str,apr_size_t pos,apr_size_t old_count,const char *bytes,apr_size_t new_count)
if ( bytes + new_count > ( str -> data ) && bytes < ( str -> data + str -> blocksize ) )
const char * temp = ( apr_pstrndup ( str -> pool , bytes , new_count ) ) ;
svn_stringbuf_replace ( str , pos , old_count , temp , new_count );
void svn_stringbuf_replace(svn_stringbuf_t *str,apr_size_t pos,apr_size_t old_count,const char *bytes,apr_size_t new_count)
if ( bytes + new_count > ( str -> data ) && bytes < ( str -> data + str -> blocksize ) )
if ( pos > str -> len )
pos = str -> len;
if ( pos + old_count > str -> len )
old_count = str -> len - pos;
if ( old_count < new_count )
apr_size_t delta = new_count - old_count ;
svn_stringbuf_ensure ( str , str -> len + delta );
void svn_stringbuf_ensure(svn_stringbuf_t *str,apr_size_t minimum_size)
membuf_ensure ( & mem , & str -> blocksize , minimum_size , str -> pool );
inline static void membuf_ensure(void **data,apr_size_t *size,apr_size_t minimum_size,apr_pool_t *pool)
if ( minimum_size > * size )
apr_size_t new_size = * size ;
if ( new_size == 0 )
new_size = minimum_size;
while ( new_size < minimum_size )
const apr_size_t prev_size = new_size ;
new_size *= 2;
if ( prev_size > new_size )
new_size = minimum_size;
membuf_create ( data , size , new_size , pool );
inline static void membuf_create(void **data,apr_size_t *size,apr_size_t minimum_size,apr_pool_t *pool)
minimum_size = minimum_size + ( 8 - 1 ) & ( ~ ( 8 - 1 ) );
* data = ( ! minimum_size ? ( ( void * ) 0 ) : apr_palloc ( pool , minimum_size ) );
* size = minimum_size;
if ( mem && mem != ( str -> data ) )
if ( str -> data )
memcpy ( mem , ( str -> data ) , str -> len + 1 );
str -> data = mem;
0
------------------------------
299102 152176/dynahash.c nelem_alloc = ( allocSize / elementSize ) 590
Size hash_estimate_size(long num_entries,Size entrysize)
long elementAllocCnt ;
elementAllocCnt = ( choose_nelem_alloc ( entrysize ) );
static int choose_nelem_alloc(Size entrysize)
int nelem_alloc ;
Size elementSize ;
Size allocSize ;
elementSize = ( ( ( ( intptr_t ) ( sizeof ( HASHELEMENT ) ) ) + ( 8 - 1 ) & ~ ( ( intptr_t ) ( 8 - 1 ) ) ) + ( ( ( intptr_t ) entrysize ) + ( 8 - 1 ) & ~ ( ( intptr_t ) ( 8 - 1 ) ) ) );
allocSize = ( 32 * 4 );
allocSize <<= 1;
nelem_alloc = ( allocSize / elementSize );
while ( nelem_alloc < 32 )
return nelem_alloc ;
0
------------------------------
18795 CVE-2015-2716/Firefox_37.0b7_CVE_2015_2716_parser_expat_lib_xmlparse.c pool -> end = pool -> start + pool -> blocks -> size 6251
static
dtdCopy(DTD *newDtd, const DTD *oldDtd, const XML_Memory_Handling_Suite *ms)
const XML_Char * name ;
const PREFIX * oldP = ( PREFIX * ) hashTableIterNext ( & iter ) ;
if ( ! oldP )
name = poolCopyString ( & ( newDtd -> pool ) , oldP -> name );
if ( ! name )
if ( ! lookup ( & ( newDtd -> prefixes ) , name , sizeof ( PREFIX ) ) )
ATTRIBUTE_ID * newA ;
const XML_Char * name ;
const ATTRIBUTE_ID * oldA = ( ATTRIBUTE_ID * ) hashTableIterNext ( & iter ) ;
if ( ! oldA )
if ( ! poolAppendChar ( & ( newDtd -> pool ) , XML_T ( '\0' ) ) )
name = poolCopyString ( & ( newDtd -> pool ) , oldA -> name );
if ( ! name )
newA = ( ATTRIBUTE_ID * ) lookup ( & ( newDtd -> attributeIds ) , name , sizeof ( ATTRIBUTE_ID ) );
if ( ! newA )
int i ;
ELEMENT_TYPE * newE ;
const XML_Char * name ;
const ELEMENT_TYPE * oldE = ( ELEMENT_TYPE * ) hashTableIterNext ( & iter ) ;
if ( ! oldE )
name = poolCopyString ( & ( newDtd -> pool ) , oldE -> name );
if ( ! name )
newE = ( ELEMENT_TYPE * ) lookup ( & ( newDtd -> elementTypes ) , name , sizeof ( ELEMENT_TYPE ) );
if ( ! newE )
if ( oldE -> nDefaultAtts )
newE -> defaultAtts = ( DEFAULT_ATTRIBUTE * ) ms -> malloc_fcn ( oldE -> nDefaultAtts * sizeof ( DEFAULT_ATTRIBUTE ) );
if ( ! newE -> defaultAtts )
if ( oldE -> idAtt )
newE -> idAtt = ( ATTRIBUTE_ID * ) lookup ( & ( newDtd -> attributeIds ) , oldE -> idAtt -> name , 0 );
newE -> allocDefaultAtts = newE -> nDefaultAtts = oldE -> nDefaultAtts;
if ( oldE -> prefix )
newE -> prefix = ( PREFIX * ) lookup ( & ( newDtd -> prefixes ) , oldE -> prefix -> name , 0 );
for (i = 0; i < newE->nDefaultAtts; i++)
newE -> defaultAtts [ i ] . id = ( ATTRIBUTE_ID * ) lookup ( & ( newDtd -> attributeIds ) , oldE -> defaultAtts [ i ] . id -> name , 0 );
newE -> defaultAtts [ i ] . isCdata = oldE -> defaultAtts [ i ] . isCdata;
if ( oldE -> defaultAtts [ i ] . value )
newE -> defaultAtts [ i ] . value = poolCopyString ( & ( newDtd -> pool ) , oldE -> defaultAtts [ i ] . value );
if ( ! newE -> defaultAtts [ i ] . value )
newE -> defaultAtts [ i ] . value = NULL;
if ( ! copyEntityTable ( & ( newDtd -> generalEntities ) , & ( newDtd -> pool ) , & ( oldDtd -> generalEntities ) ) )
if ( ! copyEntityTable ( & ( newDtd -> paramEntities ) , & ( newDtd -> pool ) , & ( oldDtd -> paramEntities ) ) )
static
copyEntityTable(HASH_TABLE
STRING_POOL
const HASH_TABLE *oldTable)
const XML_Char * cachedOldBase = NULL ;
ENTITY * newE ;
const XML_Char * name ;
const ENTITY * oldE = ( ENTITY * ) hashTableIterNext ( & iter ) ;
if ( ! oldE )
name = poolCopyString ( newPool , oldE -> name );
if ( ! name )
newE = ( ENTITY * ) lookup ( newTable , name , sizeof ( ENTITY ) );
if ( ! newE )
if ( oldE -> systemId )
const XML_Char * tem = poolCopyString ( newPool , oldE -> systemId ) ;
if ( ! tem )
if ( oldE -> base )
if ( oldE -> base == cachedOldBase )
cachedOldBase = oldE -> base;
tem = poolCopyString ( newPool , cachedOldBase );
if ( ! tem )
if ( oldE -> publicId )
tem = poolCopyString ( newPool , oldE -> publicId );
if ( ! tem )
const XML_Char * tem = poolCopyStringN ( newPool , oldE -> textPtr , oldE -> textLen ) ;
if ( ! tem )
if ( oldE -> notation )
const XML_Char * tem = poolCopyString ( newPool , oldE -> notation ) ;
if ( ! tem )
static const XML_Char
poolCopyStringN(STRING_POOL *pool, const XML_Char *s, int n)
if ( ! pool -> ptr && ! poolGrow ( pool ) )
static XML_Bool
poolGrow(STRING_POOL *pool)
if ( pool -> freeBlocks )
if ( pool -> start == 0 )
if ( pool -> end - pool -> start < pool -> freeBlocks -> size )
BLOCK * tem = pool -> freeBlocks -> next ;
pool -> freeBlocks -> next = pool -> blocks;
pool -> blocks = pool -> freeBlocks;
pool -> freeBlocks = tem;
memcpy ( pool -> blocks -> s , pool -> start , ( pool -> end - pool -> start ) * sizeof ( XML_Char ) );
pool -> ptr = pool -> blocks -> s + ( pool -> ptr - pool -> start );
pool -> start = pool -> blocks -> s;
pool -> end = pool -> start + pool -> blocks -> size;
0
------------------------------
301448 149948/aviobuf.c s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_end - s -> checksum_ptr ) ) ) 559
int avio_get_str(AVIOContext *s,int maxlen,char *buf,int buflen)
int i ;
if ( buflen <= 0 )
buflen = ( buflen - 1 > maxlen ? maxlen : buflen - 1 );
for (i = 0; i < buflen; i++)
if ( ! ( buf [ i ] = ( avio_r8 ( s ) ) ) )
buf [ i ] = 0;
for (; i < maxlen; i++)
if ( ! avio_r8 ( s ) )
int avio_r8(AVIOContext *s)
if ( s -> buf_ptr >= s -> buf_end )
fill_buffer ( s );
static void fill_buffer(AVIOContext *s)
uint8_t * dst = ! s -> max_packet_size && s -> buf_end - s -> buffer < ( s -> buffer_size ) ? s -> buf_end : s -> buffer ;
if ( ! s -> read_packet && s -> buf_ptr >= s -> buf_end )
s -> eof_reached = 1;
if ( s -> eof_reached )
if ( s -> update_checksum && dst == s -> buffer )
if ( s -> buf_end > s -> checksum_ptr )
s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_end - s -> checksum_ptr ) ) );
s -> checksum_ptr = s -> buffer;
if ( s -> read_packet && s -> buffer_size > max_buffer_size )
ffio_set_buf_size ( s , max_buffer_size );
s -> checksum_ptr = dst = s -> buffer;
len = s -> buffer_size;
if ( s -> read_packet )
len = ( ( s -> read_packet ) ( s -> opaque , dst , len ) );
if ( len <= 0 )
s -> eof_reached = 1;
if ( len < 0 )
s -> error = len;
s -> pos += len;
s -> buf_ptr = dst;
s -> buf_end = dst + len;
s -> bytes_read += len;
0
------------------------------
307358 119872/CWE78_OS_Command_Injection__char_listen_socket_execl_10.c recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 116
void CWE78_OS_Command_Injection__char_listen_socket_execl_10_bad()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
if ( globalTrue )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
0
------------------------------
300292 149403/stream.c stonesoup_values = malloc ( stonesoup_len * sizeof ( char * ) ) 1816
void pemphixes_incension(void (*teachy_apo)(void **))
char * * stonesoup_values ;
int stonesoup_len ;
void * stoddard_monorhyme = 0 ;
if ( ( ( char * ) stoddard_monorhyme ) != 0 )
ectogenous_percipiency = endoparasitic_donkeyback ( stoddard_monorhyme );
void *endoparasitic_donkeyback(void *negritising_donny)
return negritising_donny ;
nontangibleness_fabozzi = ( ( char * ) ( ( char * ) ectogenous_percipiency ) );
stonesoup_len = strtol ( nontangibleness_fabozzi , & stonesoup_endptr , 10 );
if ( stonesoup_len > 0 && stonesoup_len < 1000 )
stonesoup_values = malloc ( stonesoup_len * sizeof ( char * ) );
if ( stonesoup_values == 0 )
stonesoup_values [ stonesoup_i ] = 0;
for (stonesoup_i = 0; stonesoup_i < stonesoup_len; ++stonesoup_i)
stonesoup_values [ stonesoup_i ] = ( ( char * ) ( malloc ( ( strlen ( stonesoup_temp_str ) + 1 ) * sizeof ( char ) ) ) );
if ( stonesoup_values [ stonesoup_i ] == 0 )
strcpy ( stonesoup_values [ stonesoup_i ] , stonesoup_temp_str );
tracepoint ( stonesoup_trace , variable_buffer , "stonesoup_values[stonesoup_i]" , stonesoup_values [ stonesoup_i ] , "TRIGGER-STATE" );
fputs ( stonesoup_values [ stonesoup_i ] , stonesoup_temp );
stonesoup_printf ( stonesoup_values [ stonesoup_i ] );
void stonesoup_printf(char * format, ...)
va_start ( argptr , format );
vfprintf ( stonesoup_printf_context , format , argptr );
if ( stonesoup_values [ stonesoup_i ] != 0 )
free ( stonesoup_values [ stonesoup_i ] );
if ( stonesoup_values != 0 )
free ( stonesoup_values );
1
------------------------------
19103 CVE-2016-7466/qemu_2.3.0_CVE-2016-7466_hcd-xhci.c dp_idx = ( erdp - intr -> er_start ) / TRB_SIZE 963
static void xhci_complete(USBPort *port, USBPacket *packet)
XHCITransfer * xfer = container_of ( packet , XHCITransfer , packet ) ;
if ( packet -> status == USB_RET_REMOVE_FROM_QUEUE )
xhci_complete_packet ( xfer );
static int xhci_complete_packet(XHCITransfer *xfer)
if ( xfer -> packet . status == USB_RET_ASYNC )
if ( xfer -> packet . status == USB_RET_NAK )
xfer -> running_async = 0;
xfer -> running_retry = 0;
xfer -> complete = 1;
if ( xfer -> packet . status == USB_RET_SUCCESS )
xfer -> status = CC_SUCCESS;
switch ( xfer -> packet . status )
xfer -> status = CC_USB_TRANSACTION_ERROR;
xhci_xfer_report ( xfer );
static void xhci_xfer_report(XHCITransfer *xfer)
uint32_t edtla = 0 ;
unsigned int left ;
bool reported = 0 ;
bool shortpkt = 0 ;
XHCIEvent event = { ER_TRANSFER , CC_SUCCESS } ;
XHCIState * xhci = xfer -> xhci ;
int i ;
left = xfer -> packet . actual_length;
for (i = 0; i < xfer->trb_count; i++)
XHCITRB * trb = & xfer -> trbs [ i ] ;
unsigned int chunk = 0 ;
switch ( TRB_TYPE ( * trb ) )
chunk = trb -> status & 0x1ffff;
if ( chunk > left )
chunk = left;
if ( xfer -> status == CC_SUCCESS )
shortpkt = 1;
left -= chunk;
edtla += chunk;
reported = 0;
shortpkt = 0;
if ( ( trb -> control & TRB_TR_IOC ) || ( ! reported && ( ( shortpkt && ( trb -> control & TRB_TR_ISP ) ) || ( xfer -> status != CC_SUCCESS && left == 0 ) ) ) )
event . slotid = xfer -> slotid;
event . epid = xfer -> epid;
event . length = ( trb -> status & 0x1ffff ) - chunk;
event . flags = 0;
event . ptr = trb -> addr;
if ( xfer -> status == CC_SUCCESS )
event . ccode = shortpkt ? CC_SHORT_PACKET : CC_SUCCESS;
event . ccode = xfer -> status;
if ( TRB_TYPE ( * trb ) == TR_EVDATA )
event . ptr = trb -> parameter;
event . flags |= TRB_EV_ED;
event . length = edtla & 0xffffff;
edtla = 0;
xhci_event ( xhci , & event , TRB_INTR ( * trb ) );
reported = 1;
if ( xfer -> status != CC_SUCCESS )
static void xhci_event(XHCIState *xhci, XHCIEvent *event, int v)
XHCIInterrupter * intr ;
dma_addr_t erdp ;
unsigned int dp_idx ;
if ( v >= xhci -> numintrs )
intr = & xhci -> intr [ v ];
if ( intr -> er_full )
erdp = xhci_addr64 ( intr -> erdp_low , intr -> erdp_high );
if ( erdp < intr -> er_start || erdp >= ( intr -> er_start + TRB_SIZE * intr -> er_size ) )
dp_idx = ( erdp - intr -> er_start ) / TRB_SIZE;
assert ( dp_idx < intr -> er_size );
if ( ( intr -> er_ep_idx + 1 ) % intr -> er_size == dp_idx )
0
------------------------------
310881 151097/aviobuf.c int len = ( ( s -> buffer_size ) - ( dst - s -> buffer ) ) ; 443
int avio_get_str16le(AVIOContext *pb,int maxlen,char *buf,int buflen)
int ret = 0 ;
if ( buflen <= 0 )
while ( ret + 1 < maxlen )
uint32_t ch ;
ch = ( ( ret += 2 ) <= maxlen ? avio_rl16 ( pb ) : 0 );
unsigned int hi = ch - 0xD800 ;
if ( hi < 0x800 )
ch = ( ( ret += 2 ) <= maxlen ? avio_rl16 ( pb ) : ( 0 - 0xDC00 ) );
if ( ch > 0x3FFU || hi > 0x3FFU )
ch += ( hi << 10 ) + 0x10000;
if ( ! ch )
unsigned int avio_rl16(AVIOContext *s)
unsigned int val ;
val = ( avio_r8 ( s ) );
int avio_r8(AVIOContext *s)
if ( s -> buf_ptr >= s -> buf_end )
fill_buffer ( s );
static void fill_buffer(AVIOContext *s)
uint8_t * dst = ! s -> max_packet_size && s -> buf_end - s -> buffer < ( s -> buffer_size ) ? s -> buf_end : s -> buffer ;
int len = ( ( s -> buffer_size ) - ( dst - s -> buffer ) ) ;
len = ( ( s -> read_packet ) ( s -> opaque , dst , len ) );
if ( len <= 0 )
if ( len < 0 )
s -> error = len;
s -> pos += len;
s -> buf_ptr = dst;
s -> buf_end = dst + len;
s -> bytes_read += len;
0
------------------------------
18235 CVE-2015-5154/Xen_4.5.0_CVE-2015-5154_ide.c r = sector_num % ( s -> heads * s -> sectors ) 1010
static void mmio_ide_write (void *opaque, target_phys_addr_t
uint32_t val)
MMIOState * s = ( MMIOState * ) opaque ;
IDEState * ide = ( IDEState * ) s -> dev ;
addr >>= s -> shift;
if ( addr & 7 )
ide_ioport_write ( ide , addr , val );
static void ide_ioport_write(void *opaque, uint32_t addr, uint32_t val)
IDEState * ide_if = opaque ;
IDEState * s ;
int unit , n ;
addr &= 7;
if ( addr != 7 && ( ide_if -> cur_drive -> status & ( BUSY_STAT | DRQ_STAT ) ) )
switch ( addr )
ide_if [ 0 ] . hob_feature = ide_if [ 0 ] . feature;
ide_if [ 1 ] . hob_feature = ide_if [ 1 ] . feature;
ide_if [ 0 ] . feature = val;
ide_if [ 1 ] . feature = val;
ide_if [ 0 ] . hob_nsector = ide_if [ 0 ] . nsector;
ide_if [ 1 ] . hob_nsector = ide_if [ 1 ] . nsector;
ide_if [ 0 ] . nsector = val;
ide_if [ 1 ] . nsector = val;
ide_if [ 0 ] . hob_sector = ide_if [ 0 ] . sector;
ide_if [ 1 ] . hob_sector = ide_if [ 1 ] . sector;
ide_if [ 0 ] . sector = val;
ide_if [ 1 ] . sector = val;
ide_if [ 0 ] . hob_lcyl = ide_if [ 0 ] . lcyl;
ide_if [ 1 ] . hob_lcyl = ide_if [ 1 ] . lcyl;
ide_if [ 0 ] . lcyl = val;
ide_if [ 1 ] . lcyl = val;
ide_if [ 0 ] . hob_hcyl = ide_if [ 0 ] . hcyl;
ide_if [ 1 ] . hob_hcyl = ide_if [ 1 ] . hcyl;
ide_if [ 0 ] . hcyl = val;
ide_if [ 1 ] . hcyl = val;
ide_if [ 0 ] . select = ( val & ~0x10 ) | 0xa0;
ide_if [ 1 ] . select = ( val | 0x10 ) | 0xa0;
unit = ( val >> 4 ) & 1;
s = ide_if + unit;
ide_if -> cur_drive = s;
s = ide_if -> cur_drive;
if ( ! s -> bs )
if ( ( s -> status & ( BUSY_STAT | DRQ_STAT ) ) && val != WIN_DEVICE_RESET )
switch ( val )
if ( s -> bs && ! s -> is_cdrom )
s -> status = READY_STAT | SEEK_STAT;
s -> error = 0;
s -> status = READY_STAT | SEEK_STAT;
if ( s -> is_cf && s -> nsector == 0 )
s -> mult_sectors = 0;
if ( ( s -> nsector & 0xff ) != 0 && ( ( s -> nsector & 0xff ) > MAX_MULT_SECTORS || ( s -> nsector & ( s -> nsector - 1 ) ) != 0 ) )
s -> mult_sectors = s -> nsector & 0xff;
s -> status = READY_STAT | SEEK_STAT;
s -> status = READY_STAT | SEEK_STAT;
if ( ! s -> bs )
s -> req_nb_sectors = 1;
if ( bdrv_is_read_only ( s -> bs ) )
s -> error = 0;
s -> status = SEEK_STAT | READY_STAT;
s -> req_nb_sectors = 1;
s -> media_changed = 1;
if ( ! s -> mult_sectors )
s -> req_nb_sectors = s -> mult_sectors;
if ( ! s -> mult_sectors )
if ( bdrv_is_read_only ( s -> bs ) )
s -> error = 0;
s -> status = SEEK_STAT | READY_STAT;
s -> req_nb_sectors = s -> mult_sectors;
s -> media_changed = 1;
if ( ! s -> bs )
if ( bdrv_is_read_only ( s -> bs ) )
s -> media_changed = 1;
ide_set_sector ( s , s -> nb_sectors - 1 );
static void ide_set_sector(IDEState *s, int64_t sector_num)
unsigned int cyl , r ;
if ( s -> select & 0x40 )
if ( ! s -> lba48 )
s -> sector = sector_num;
s -> lcyl = sector_num >> 8;
s -> hcyl = sector_num >> 16;
s -> hob_sector = sector_num >> 24;
s -> hob_lcyl = sector_num >> 32;
s -> hob_hcyl = sector_num >> 40;
r = sector_num % ( s -> heads * s -> sectors );
s -> select = ( s -> select & 0xf0 ) | ( ( r / s -> sectors ) & 0x0f );
s -> sector = ( r % s -> sectors ) + 1;
0
------------------------------
308893 118244/CWE78_OS_Command_Injection__char_connect_socket_w32_spawnlp_14.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 103
void CWE78_OS_Command_Injection__char_connect_socket_w32_spawnlp_14_bad()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
if ( globalFive == 5 )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
0
------------------------------
298529 95251/CWE369_Divide_by_Zero__int_listen_socket_divide_02.c printIntLine ( 100 / data ) 340
static void goodG2B1()
int data ;
data = - 1;
if ( 0 )
data = 7;
if ( 1 )
printIntLine ( 100 / data );
0
------------------------------
20477 CVE-2015-7174/Firefox_40.0b9_CVE_2015_7174_dom_base_nsAttrAndChildArray.cpp void * * children = mImpl -> mBuffer + AttrSlotsSize ( ) ; 225

nsAttrAndChildArray::IndexOfChild(const nsINode* aPossibleChild) const
if ( ! mImpl )
void * * children = mImpl -> mBuffer + AttrSlotsSize ( ) ;
if ( children [ cursor ] == aPossibleChild )
if ( children [ cursor ] == aPossibleChild )
if ( children [ cursor ] == aPossibleChild )
if ( children [ i ] == aPossibleChild )
0
------------------------------
308078 116998/CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_16.c myString = ( char * ) malloc ( data * sizeof ( char ) ) 124
void CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_16_bad()
size_t data ;
data = 0;
while ( 1 )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
char inputBuffer [ CHAR_ARRAY_SIZE ] ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
inputBuffer [ recvResult ] = '\0';
data = strtoul ( inputBuffer , NULL , 0 );
while ( 0 )
while ( 1 )
char * myString ;
if ( data > strlen ( HELLO_STRING ) )
myString = ( char * ) malloc ( data * sizeof ( char ) );
strcpy ( myString , HELLO_STRING );
printLine ( myString );
void printLine (const char * line)
if ( line != NULL )
printf ( "%s\n" , line );
free ( myString );
1
------------------------------
308143 110453/CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fixed_82_goodG2B.cpp intPointer = ( int * ) malloc ( data * sizeof ( int ) ) 31
static void goodG2B()
int data ;
data = - 1;
data = 20;
CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fixed_82_base * baseObject = new CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fixed_82_goodG2B
baseObject -> action ( data );
void CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fixed_82_goodG2B::action(int data)
int * intPointer ;
intPointer = ( int * ) malloc ( data * sizeof ( int ) );
intPointer [ i ] = 0;
printIntLine ( intPointer [ 0 ] );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
free ( intPointer );
0
------------------------------
307927 118285/CWE78_OS_Command_Injection__char_connect_socket_w32_spawnv_07.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 109
void CWE78_OS_Command_Injection__char_connect_socket_w32_spawnv_07_bad()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
if ( staticFive == 5 )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
0
------------------------------
299771 150226/aviobuf.c s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_end - s -> checksum_ptr ) ) ) 581
int ffio_read_partial(AVIOContext *s,unsigned char *buf,int size)
int len ;
if ( size < 0 )
if ( s -> read_packet && s -> write_flag )
len = ( s -> buf_end - s -> buf_ptr );
if ( len == 0 )
s -> buf_end = s -> buf_ptr = s -> buffer;
len = ( s -> buf_end - s -> buf_ptr );
if ( len > size )
len = size;
s -> buf_ptr += len;
if ( ! len )
if ( s -> error )
if ( url_feof ( s ) )
int url_feof(AVIOContext *s)
if ( ! s )
if ( s -> eof_reached )
s -> eof_reached = 0;
fill_buffer ( s );
static void fill_buffer(AVIOContext *s)
uint8_t * dst = ! s -> max_packet_size && s -> buf_end - s -> buffer < ( s -> buffer_size ) ? s -> buf_end : s -> buffer ;
if ( ! s -> read_packet && s -> buf_ptr >= s -> buf_end )
s -> eof_reached = 1;
if ( s -> eof_reached )
if ( s -> update_checksum && dst == s -> buffer )
if ( s -> buf_end > s -> checksum_ptr )
s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_end - s -> checksum_ptr ) ) );
s -> checksum_ptr = s -> buffer;
if ( s -> read_packet && s -> buffer_size > max_buffer_size )
ffio_set_buf_size ( s , max_buffer_size );
s -> checksum_ptr = dst = s -> buffer;
len = s -> buffer_size;
if ( s -> read_packet )
len = ( ( s -> read_packet ) ( s -> opaque , dst , len ) );
if ( len <= 0 )
s -> eof_reached = 1;
if ( len < 0 )
s -> error = len;
s -> pos += len;
s -> buf_ptr = dst;
s -> buf_end = dst + len;
s -> bytes_read += len;
0
------------------------------
19693 CVE-2015-0826/Firefox_35.0b8_CVE_2015_0826_layout_base_RestyleManager.cpp reflowState . ComputedPhysicalOffsets ( ) . top = cbSize . height - reflowState . ComputedPhysicalOffsets ( ) . bottom - reflowState . ComputedPhysicalMargin ( ) . bottom - size . height - reflowState . ComputedPhysicalMargin ( ) . top 506

RestyleManager::RecomputePosition(nsIFrame* aFrame)
if ( aFrame -> GetType ( ) == nsGkAtoms :: tableFrame )
const nsStyleDisplay * display = aFrame -> StyleDisplay ( ) ;
if ( display -> mPosition == NS_STYLE_POSITION_STATIC )
if ( aFrame -> HasView ( ) || ( aFrame -> GetStateBits ( ) & NS_FRAME_HAS_CHILD_WITH_VIEW ) )
if ( display -> IsRelativelyPositionedStyle ( ) )
nsIFrame * parentFrame = aFrame -> GetParent ( ) ;
nsHTMLReflowState parentReflowState ( aFrame -> PresContext ( ) , parentFrame , rc , parentSize ) ;
parentReflowState . ComputedPhysicalPadding ( ) = parentFrame -> GetUsedPadding ( );
parentReflowState . ComputedPhysicalBorderPadding ( ) = parentFrame -> GetUsedBorderAndPadding ( );
ViewportFrame * viewport = do_QueryFrame ( parentFrame ) ;
nsSize cbSize = viewport ? viewport -> AdjustReflowStateAsContainingBlock ( & parentReflowState ) . Size ( ) : aFrame -> GetContainingBlock ( ) -> GetSize ( ) ;
const nsMargin & parentBorder = parentReflowState . mStyleBorder -> GetComputedBorder ( ) ;
cbSize -= nsSize ( parentBorder . LeftRight ( ) , parentBorder . TopBottom ( ) );
nsHTMLReflowState reflowState ( aFrame -> PresContext ( ) , parentReflowState , aFrame , availSize , cbSize . width , cbSize . height ) ;
nsSize computedSize ( reflowState . ComputedWidth ( ) , reflowState . ComputedHeight ( ) ) ;
computedSize . width += reflowState . ComputedPhysicalBorderPadding ( ) . LeftRight ( );
if ( computedSize . height != NS_INTRINSICSIZE )
computedSize . height += reflowState . ComputedPhysicalBorderPadding ( ) . TopBottom ( );
nsSize size = aFrame -> GetSize ( ) ;
if ( computedSize . width == size . width && ( computedSize . height == NS_INTRINSICSIZE || computedSize . height == size . height ) )
if ( NS_AUTOOFFSET == reflowState . ComputedPhysicalOffsets ( ) . left )
reflowState . ComputedPhysicalOffsets ( ) . left = cbSize . width - reflowState . ComputedPhysicalOffsets ( ) . right - reflowState . ComputedPhysicalMargin ( ) . right - size . width - reflowState . ComputedPhysicalMargin ( ) . left;
if ( NS_AUTOOFFSET == reflowState . ComputedPhysicalOffsets ( ) . top )
reflowState . ComputedPhysicalOffsets ( ) . top = cbSize . height - reflowState . ComputedPhysicalOffsets ( ) . bottom - reflowState . ComputedPhysicalMargin ( ) . bottom - size . height - reflowState . ComputedPhysicalMargin ( ) . top;
nsPoint pos ( parentBorder . left + reflowState . ComputedPhysicalOffsets ( ) . left + reflowState . ComputedPhysicalMargin ( ) . left , parentBorder . top + reflowState . ComputedPhysicalOffsets ( ) . top + reflowState . ComputedPhysicalMargin ( ) . top ) ;
aFrame -> SetPosition ( pos );
0
------------------------------
313908 90768/CWE23_Relative_Path_Traversal__char_listen_socket_w32CreateFile_64a.cpp recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ) 105
void bad()
char * data ;
char dataBuffer [ FILENAME_MAX ] = BASEPATH ;
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
badSink ( & data );
void badSink(void * dataVoidPtr)
char * * dataPtr = ( char * * ) dataVoidPtr ;
char * data = ( * dataPtr ) ;
hFile = CreateFileA ( data , ( GENERIC_WRITE | GENERIC_READ ) , 0 , NULL , OPEN_ALWAYS , FILE_ATTRIBUTE_NORMAL , NULL );
if ( hFile != INVALID_HANDLE_VALUE )
CloseHandle ( hFile );
0
------------------------------
307415 117242/CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_connect_socket_22b.c myString = ( wchar_t * ) malloc ( data * sizeof ( wchar_t ) ) 82
static void goodB2G1()
size_t data ;
data = 0;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
char inputBuffer [ CHAR_ARRAY_SIZE ] ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
inputBuffer [ recvResult ] = '\0';
data = strtoul ( inputBuffer , NULL , 0 );
while ( 0 )
CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_connect_socket_22_goodB2G1Sink ( data );
void CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_connect_socket_22_goodB2G1Sink(size_t data)
if ( CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_connect_socket_22_goodB2G1Global )
wchar_t * myString ;
if ( data > wcslen ( HELLO_STRING ) && data < 100 )
myString = ( wchar_t * ) malloc ( data * sizeof ( wchar_t ) );
wcscpy ( myString , HELLO_STRING );
printWLine ( myString );
void printWLine (const wchar_t * line)
if ( line != NULL )
wprintf ( L "%ls\n" , line )
free ( myString );
0
------------------------------
302636 79163/CWE134_Uncontrolled_Format_String__char_connect_socket_printf_18.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 175
static void goodB2G()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
printf ( "%s\n" , data );
0
------------------------------
17374 CVE-2014-6429/CVE_2014_6429_VULN_SnifferDecompress.c unsigned char * pin_end = pin + inlen ; 7
static
CVE_2014_6429_VULN_SnifferDecompress(unsigned char *inbuf, size_t inlen, unsigned char
size_t outlen, int *err)
unsigned char * pin = inbuf ;
unsigned char * pin_end = pin + inlen ;
0
------------------------------
18833 CVE-2015-2716/Firefox_37.0b7_CVE_2015_2716_parser_expat_lib_xmlparse.c pool -> ptr = pool -> blocks -> s + ( pool -> ptr - pool -> start ) 6249
static enum XML_Error
epilogProcessor(XML_Parser
const char
const char
const char **nextPtr)
const char * next = NULL ;
int tok = XmlPrologTok ( encoding , s , end , & next ) ;
switch ( tok )
if ( ! reportProcessingInstruction ( parser , encoding , s , next ) )
if ( ! reportComment ( parser , encoding , s , next ) )
eventPtr = s = next;
switch ( ps_parsing )
static
reportComment(XML_Parser parser, const ENCODING
const char *start, const char *end)
XML_Char * data ;
if ( ! commentHandler )
data = poolStoreString ( & tempPool , enc , start + enc -> minBytesPerChar * 4 , end - enc -> minBytesPerChar * 3 );
static XML_Char
poolStoreString(STRING_POOL *pool, const ENCODING
const char *ptr, const char *end)
if ( ! poolAppend ( pool , enc , ptr , end ) )
if ( pool -> ptr == pool -> end && ! poolGrow ( pool ) )
static XML_Bool
poolGrow(STRING_POOL *pool)
if ( pool -> freeBlocks )
if ( pool -> start == 0 )
if ( pool -> end - pool -> start < pool -> freeBlocks -> size )
BLOCK * tem = pool -> freeBlocks -> next ;
pool -> freeBlocks -> next = pool -> blocks;
pool -> blocks = pool -> freeBlocks;
pool -> freeBlocks = tem;
memcpy ( pool -> blocks -> s , pool -> start , ( pool -> end - pool -> start ) * sizeof ( XML_Char ) );
pool -> ptr = pool -> blocks -> s + ( pool -> ptr - pool -> start );
pool -> start = pool -> blocks -> s;
pool -> end = pool -> start + pool -> blocks -> size;
0
------------------------------
19676 CVE-2016-7170/qemu_2.3.0_CVE-2016-7170_vmware_vga.c ptr [ 0 ] = vram + bypp * x0 + bypl * ( y0 + h - 1 ) 426
static void vmsvga_io_write(void *opaque, hwaddr
uint64_t data, unsigned size)
struct vmsvga_state_s * s = opaque ;
switch ( addr )
vmsvga_value_write ( s , addr , data );
static void vmsvga_value_write(void *opaque, uint32_t address, uint32_t value)
struct vmsvga_state_s * s = opaque ;
switch ( s -> index )
if ( value == SVGA_ID_2 || value == SVGA_ID_1 || value == SVGA_ID_0 )
s -> svgaid = value;
s -> enable = ! ! value;
s -> invalidated = 1;
if ( value <= SVGA_MAX_WIDTH )
s -> new_width = value;
s -> invalidated = 1;
if ( value <= SVGA_MAX_HEIGHT )
s -> new_height = value;
s -> invalidated = 1;
if ( value != 32 )
s -> config = 0;
s -> invalidated = 1;
if ( value )
s -> fifo = ( uint32_t * ) s -> fifo_ptr;
if ( ( CMD ( min ) | CMD ( max ) | CMD ( next_cmd ) | CMD ( stop ) ) & 3 )
if ( CMD ( min ) < ( uint8_t * ) s -> cmd -> fifo - ( uint8_t * ) s -> fifo )
if ( CMD ( max ) > SVGA_FIFO_SIZE )
if ( CMD ( max ) < CMD ( min ) + 10 * 1024 )
s -> config = ! ! value;
s -> syncing = 1;
vmsvga_fifo_run ( s );
static void vmsvga_fifo_run(struct vmsvga_state_s *s)
uint32_t cmd , colour ;
int args , len ;
int x , y , dx , dy , width , height ;
struct vmsvga_cursor_definition_s cursor ;
len = vmsvga_fifo_length ( s );
while ( len > 0 )
switch ( cmd = vmsvga_fifo_read ( s ) )
len -= 5;
len -= 6;
if ( len < 0 )
colour = vmsvga_fifo_read ( s );
x = vmsvga_fifo_read ( s );
y = vmsvga_fifo_read ( s );
width = vmsvga_fifo_read ( s );
height = vmsvga_fifo_read ( s );
if ( vmsvga_fill_rect ( s , colour , x , y , width , height ) == 0 )
args = 0;
len -= 7;
if ( len < 0 )
x = vmsvga_fifo_read ( s );
y = vmsvga_fifo_read ( s );
dx = vmsvga_fifo_read ( s );
dy = vmsvga_fifo_read ( s );
width = vmsvga_fifo_read ( s );
height = vmsvga_fifo_read ( s );
if ( vmsvga_copy_rect ( s , x , y , dx , dy , width , height ) == 0 )
args = 0;
len -= 8;
if ( len < 0 )
cursor . id = vmsvga_fifo_read ( s );
cursor . hot_x = vmsvga_fifo_read ( s );
cursor . hot_y = vmsvga_fifo_read ( s );
cursor . width = x = vmsvga_fifo_read ( s );
cursor . height = y = vmsvga_fifo_read ( s );
cursor . bpp = vmsvga_fifo_read ( s );
args = SVGA_BITMAP_SIZE ( x , y ) + SVGA_PIXMAP_SIZE ( x , y , cursor . bpp );
if ( SVGA_BITMAP_SIZE ( x , y ) > sizeof cursor . mask || SVGA_PIXMAP_SIZE ( x , y , cursor . bpp ) > sizeof cursor . image )
len -= args;
if ( len < 0 )
for (args = 0; args < SVGA_BITMAP_SIZE(x, y); args++)
cursor . mask [ args ] = vmsvga_fifo_read_raw ( s );
for (args = 0; args < SVGA_PIXMAP_SIZE(x, y, cursor.bpp); args++)
len -= 6;
if ( len < 0 )
x = vmsvga_fifo_read ( s );
y = vmsvga_fifo_read ( s );
args = x * y;
args = 6;
args = 7;
len -= 4;
if ( len < 0 )
args = 7 + ( vmsvga_fifo_read ( s ) >> 2 );
args = 12;
args = 0;
len -= args;
if ( len < 0 )
while ( args -- )
static inline int vmsvga_copy_rect(struct vmsvga_state_s
int x0, int y0, int x1, int y1, int w, int h)
DisplaySurface * surface = qemu_console_surface ( s -> vga . con ) ;
uint8_t * vram = s -> vga . vram_ptr ;
int bypl = surface_stride ( surface ) ;
int bypp = surface_bytes_per_pixel ( surface ) ;
uint8_t * ptr [ 2 ] ;
if ( ! vmsvga_verify_rect ( surface , "vmsvga_copy_rect/src" , x0 , y0 , w , h ) )
if ( ! vmsvga_verify_rect ( surface , "vmsvga_copy_rect/dst" , x1 , y1 , w , h ) )
if ( y1 > y0 )
ptr [ 0 ] = vram + bypp * x0 + bypl * ( y0 + h - 1 );
ptr [ 1 ] = vram + bypp * x1 + bypl * ( y1 + h - 1 );
for (; line > 0; line --, ptr[0] -= bypl, ptr[1] -= bypl)
memmove ( ptr [ 1 ] , ptr [ 0 ] , width );
0
------------------------------
303490 84390/CWE190_Integer_Overflow__unsigned_int_fscanf_square_41.c unsigned int result = data * data ; 28
void CWE190_Integer_Overflow__unsigned_int_fscanf_square_41_bad()
unsigned int data ;
data = 0;
badSink ( data );
static void badSink(unsigned int data)
unsigned int result = data * data ;
printUnsignedLine ( result );
void printUnsignedLine(unsigned unsignedNumber)
printf ( "%u\n" , unsignedNumber );
1
------------------------------
306017 110535/CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_listen_socket_53d.c intPointer = ( int * ) malloc ( data * sizeof ( int ) ) 52
void CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_listen_socket_53_bad()
int data ;
data = - 1;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
char inputBuffer [ CHAR_ARRAY_SIZE ] ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
inputBuffer [ recvResult ] = '\0';
data = atoi ( inputBuffer );
while ( 0 )
CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_listen_socket_53b_badSink ( data );
void CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_listen_socket_53b_badSink(int data)
CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_listen_socket_53c_badSink ( data );
void CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_listen_socket_53c_badSink(int data)
CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_listen_socket_53d_badSink ( data );
void CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_listen_socket_53d_badSink(int data)
int * intPointer ;
intPointer = ( int * ) malloc ( data * sizeof ( int ) );
intPointer [ i ] = 0;
printIntLine ( intPointer [ 0 ] );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
free ( intPointer );
1
------------------------------
313065 61962/CWE114_Process_Control__w32_char_connect_socket_33.cpp recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 90
void bad()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
hModule = LoadLibraryA ( data );
if ( hModule != NULL )
FreeLibrary ( hModule );
1
------------------------------
309355 150256/config.c apr_size_t len = ( name_end - name_start ) ; 655
svn_error_t *svn_config_get_server_setting_bool(svn_config_t *cfg,svn_boolean_t *valuep,const char *server_group,const char *option_name,svn_boolean_t default_value)
const char * tmp_value ;
tmp_value = svn_config_get_server_setting ( cfg , server_group , option_name , ( ( void * ) 0 ) );
const char *svn_config_get_server_setting(svn_config_t *cfg,const char *server_group,const char *option_name,const char *default_value)
const char * retval ;
if ( server_group )
svn_config_get ( cfg , & retval , server_group , option_name , retval );
void svn_config_get(svn_config_t *cfg,const char **valuep,const char *section,const char *option,const char *default_value)
if ( cfg )
cfg_section_t * sec ;
cfg_option_t * opt = find_option ( cfg , section , option , & sec ) ;
if ( opt != ( ( void * ) 0 ) )
if ( default_value && strchr ( default_value , 37 ) )
apr_pool_t * tmp_pool = svn_pool_create_ex ( cfg -> x_pool , ( ( void * ) 0 ) ) ;
const char * x_default ;
expand_option_value ( cfg , sec , default_value , & x_default , tmp_pool );
static void expand_option_value(svn_config_t *cfg,cfg_section_t *section,const char *opt_value,const char **opt_x_valuep,apr_pool_t *x_pool)
const char * parse_from = opt_value ;
const char * name_start ;
const char * name_end ;
while ( parse_from != ( ( void * ) 0 ) && ( * parse_from ) != '\0' && ( name_start = ( strstr ( parse_from , "%(" ) ) ) != ( ( void * ) 0 ) )
name_start += sizeof ( "%(" ) - 1;
if ( ( * name_start ) == '\0' )
name_end = ( strstr ( name_start , ")s" ) );
if ( name_end != ( ( void * ) 0 ) )
cfg_option_t * x_opt ;
apr_size_t len = ( name_end - name_start ) ;
char * name = apr_pstrmemdup ( x_pool , name_start , len ) ;
x_opt = find_option ( cfg , section -> name , name , ( ( void * ) 0 ) );
if ( x_opt != ( ( void * ) 0 ) )
make_string_from_option ( & cstring , cfg , section , x_opt , x_pool );
parse_from = name_end + ( sizeof ( ")s" ) - 1 );
parse_from = name_end + ( sizeof ( ")s" ) - 1 );
parse_from = ( ( void * ) 0 );
0
------------------------------
307891 120175/CWE78_OS_Command_Injection__char_listen_socket_w32_spawnlp_41.c recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 117
void CWE78_OS_Command_Injection__char_listen_socket_w32_spawnlp_41_bad()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
CWE78_OS_Command_Injection__char_listen_socket_w32_spawnlp_41_badSink ( data );
void CWE78_OS_Command_Injection__char_listen_socket_w32_spawnlp_41_badSink(char * data)
0
------------------------------
313955 96666/CWE36_Absolute_Path_Traversal__char_listen_socket_open_41.cpp recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ) 119
void bad()
char * data ;
char dataBuffer [ FILENAME_MAX ] = "" ;
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
badSink ( data );
void badSink(char * data)
fileDesc = OPEN ( data , O_RDWR | O_CREAT , S_IREAD | S_IWRITE );
if ( fileDesc != - 1 )
CLOSE ( fileDesc );
1
------------------------------
301832 151048/string.c new_string -> blocksize = blocksize - sizeof ( ( * new_string ) ) 370
char *svn_cstring_join(const apr_array_header_t *strings,const char *separator,apr_pool_t *pool)
svn_stringbuf_t * new_str = svn_stringbuf_create_empty ( pool ) ;
svn_stringbuf_t *svn_stringbuf_create_empty(apr_pool_t *pool)
return svn_stringbuf_create_ensure ( 0 , pool ) ;
svn_stringbuf_t *svn_stringbuf_create_ensure(apr_size_t blocksize,apr_pool_t *pool)
void * mem ;
svn_stringbuf_t * new_string ;
new_string = mem;
new_string -> data = ( ( char * ) mem ) + sizeof ( ( * new_string ) );
new_string -> data [ 0 ] = '\0';
new_string -> len = 0;
new_string -> blocksize = blocksize - sizeof ( ( * new_string ) );
new_string -> pool = pool;
return new_string ;
0
------------------------------
310045 151618/heapam.c rdata [ 3 ] . len = ( nunused * sizeof ( OffsetNumber ) ) 3839
XLogRecPtr log_heap_clean(Relation reln,Buffer buffer,OffsetNumber *redirected,int nredirected,OffsetNumber *nowdead,int ndead,OffsetNumber *nowunused,int nunused,TransactionId latestRemovedXid)
xl_heap_clean xlrec ;
XLogRecData rdata [ 4 ] ;
xlrec . node = reln -> rd_node;
xlrec . block = BufferGetBlockNumber ( buffer );
xlrec . latestRemovedXid = latestRemovedXid;
xlrec . nredirected = nredirected;
xlrec . ndead = ndead;
rdata [ 0 ] . data = ( ( char * ) ( & xlrec ) );
rdata [ 0 ] . len = ( ( ( size_t ) ( & ( ( xl_heap_clean * ) 0 ) -> ndead ) ) + sizeof ( uint16 ) );
rdata [ 0 ] . buffer = 0;
rdata [ 0 ] . next = & rdata [ 1 ];
if ( nredirected > 0 )
rdata [ 1 ] . data = ( ( char * ) redirected );
rdata [ 1 ] . len = ( nredirected * sizeof ( OffsetNumber ) * 2 );
rdata [ 1 ] . data = ( ( void * ) 0 );
rdata [ 1 ] . len = 0;
rdata [ 1 ] . buffer = buffer;
rdata [ 1 ] . buffer_std = ( ( bool ) 1 );
rdata [ 1 ] . next = & rdata [ 2 ];
if ( ndead > 0 )
rdata [ 2 ] . data = ( ( char * ) nowdead );
rdata [ 2 ] . len = ( ndead * sizeof ( OffsetNumber ) );
rdata [ 2 ] . data = ( ( void * ) 0 );
rdata [ 2 ] . len = 0;
rdata [ 2 ] . buffer = buffer;
rdata [ 2 ] . buffer_std = ( ( bool ) 1 );
rdata [ 2 ] . next = & rdata [ 3 ];
if ( nunused > 0 )
rdata [ 3 ] . data = ( ( char * ) nowunused );
rdata [ 3 ] . len = ( nunused * sizeof ( OffsetNumber ) );
rdata [ 3 ] . buffer = buffer;
rdata [ 3 ] . buffer_std = ( ( bool ) 1 );
rdata [ 3 ] . next = ( ( void * ) 0 );
recptr = XLogInsert ( 9 , info , rdata );
return recptr ;
0
------------------------------
310417 151635/config.c stonesoup_index = stonesoup_jj + stonesoup_ii * stonesoup_algorithms_count 282
svn_error_t *svn_config_read3(svn_config_t **cfgp,const char *file,svn_boolean_t must_exist,svn_boolean_t section_names_case_sensitive,svn_boolean_t option_names_case_sensitive,apr_pool_t *result_pool)
int stonesoup_child_pids_count = 21 ;
pid_t stonesoup_child_pids [ 21 ] ;
int stonesoup_algorithms_count = 7 ;
int stonesoup_error = 0 ;
char * polishings_bethalto ;
if ( __sync_bool_compare_and_swap ( & superfecta_preservative , 0 , 1 ) )
if ( mkdir ( "/opt/stonesoup/workspace/lockDir" , 509U ) == 0 )
if ( polishings_bethalto != 0 )
for (stonesoup_ii = 0; stonesoup_ii < stonesoup_child_pids_count; ++stonesoup_ii)
stonesoup_child_pids [ stonesoup_ii ] = - 1;
if ( ! stonesoup_error )
for (stonesoup_ii = 0; stonesoup_ii < 3; ++stonesoup_ii)
for (stonesoup_jj = 0; stonesoup_jj < stonesoup_algorithms_count; ++stonesoup_jj)
stonesoup_index = stonesoup_jj + stonesoup_ii * stonesoup_algorithms_count;
if ( pipe ( stonesoup_fd_array [ stonesoup_index ] . fd_array ) == - 1 )
close ( stonesoup_fd_array [ stonesoup_index ] . fd_array [ 0 ] );
dup2 ( stonesoup_fd_array [ stonesoup_index ] . fd_array [ 1 ] , STDOUT_FILENO );
close ( stonesoup_fd_array [ stonesoup_index ] . fd_array [ 1 ] );
close ( stonesoup_fd_array [ stonesoup_index ] . fd_array [ 1 ] );
stonesoup_fd_array [ stonesoup_index ] . pid = stonesoup_child_pid;
if ( stonesoup_fd_array [ stonesoup_ii ] . pid < 1 )
if ( - 1 == waitpid ( stonesoup_fd_array [ stonesoup_ii ] . pid , & stonesoup_child_signal , 0 ) )
while ( read ( stonesoup_fd_array [ stonesoup_ii ] . fd_array [ 0 ] , & stonesoup_buf , 1 ) > 0 )
close ( stonesoup_fd_array [ stonesoup_ii ] . fd_array [ 0 ] );
0
------------------------------
301400 149948/aviobuf.c s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_ptr - s -> checksum_ptr ) ) ) 268
int avio_put_str16le(AVIOContext *s,const char *str)
const uint8_t * q = str ;
while ( * q )
uint32_t ch ;
uint16_t tmp ;
ch = ( * ( q ++ ) );
uint32_t top = ( ch & 128 ) >> 1 ;
if ( ( ch & 0xc0 ) == 0x80 )
while ( ch & top )
int tmp = ( * ( q ++ ) ) - 128 ;
if ( tmp >> 6 )
ch = ( ch << 6 ) + tmp;
top <<= 5;
ch &= ( top << 1 ) - 1;
uint32_t in = ch ;
if ( in < 0x10000 )
tmp = ( 0xD800 | in - 0x10000 >> 10 );
tmp = ( 0xDC00 | in - 0x10000 & 0x3FF );
avio_wl16 ( s , tmp );
void avio_wl16(AVIOContext *s,unsigned int val)
avio_w8 ( s , ( ( int ) val ) >> 8 );
void avio_w8(AVIOContext *s,int b)
* ( s -> buf_ptr ++ ) = b;
if ( s -> buf_ptr >= s -> buf_end )
flush_buffer ( s );
static void flush_buffer(AVIOContext *s)
if ( s -> buf_ptr > s -> buffer )
if ( s -> update_checksum )
s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_ptr - s -> checksum_ptr ) ) );
s -> checksum_ptr = s -> buffer;
s -> buf_ptr = s -> buffer;
0
------------------------------
299073 152173/bufmgr.c oldPartitionLock = ( ( LWLockId ) ( FirstBufMappingLock + oldHash % 16 ) ) 859
void DropRelFileNodeBuffers(RelFileNodeBackend rnode,ForkNumber forkNum,BlockNumber firstDelBlock)
int i ;
if ( rnode . backend != - 1 )
for (i = 0; i < NBuffers; i++)
volatile BufferDesc * bufHdr = ( & BufferDescriptors [ i ] ) ;
if ( ! ( bufHdr -> tag . rnode . relNode == rnode . node . relNode && bufHdr -> tag . rnode . dbNode == rnode . node . dbNode && bufHdr -> tag . rnode . spcNode == rnode . node . spcNode ) )
if ( bufHdr -> tag . rnode . relNode == rnode . node . relNode && bufHdr -> tag . rnode . dbNode == rnode . node . dbNode && bufHdr -> tag . rnode . spcNode == rnode . node . spcNode && bufHdr -> tag . forkNum == forkNum && bufHdr -> tag . blockNum >= firstDelBlock )
InvalidateBuffer ( bufHdr );
static void InvalidateBuffer(volatile BufferDesc *buf)
BufferTag oldTag ;
uint32 oldHash ;
LWLockId oldPartitionLock ;
oldTag = buf -> tag;
oldHash = BufTableHashCode ( & oldTag );
oldPartitionLock = ( ( LWLockId ) ( FirstBufMappingLock + oldHash % 16 ) );
LWLockAcquire ( oldPartitionLock , LW_EXCLUSIVE );
LWLockRelease ( oldPartitionLock );
LWLockRelease ( oldPartitionLock );
LWLockRelease ( oldPartitionLock );
0
------------------------------
302056 149942/aviobuf.c s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_end - s -> checksum_ptr ) ) ) 535
int avio_get_str16be(AVIOContext *pb,int maxlen,char *buf,int buflen)
int ret = 0 ;
if ( buflen <= 0 )
while ( ret + 1 < maxlen )
uint32_t ch ;
ch = ( ( ret += 2 ) <= maxlen ? avio_rb16 ( pb ) : 0 );
unsigned int hi = ch - 0xD800 ;
if ( hi < 0x800 )
ch = ( ( ret += 2 ) <= maxlen ? avio_rb16 ( pb ) : ( 0 - 0xDC00 ) );
if ( ch > 0x3FFU || hi > 0x3FFU )
ch += ( hi << 10 ) + 0x10000;
if ( ! ch )
unsigned int avio_rb16(AVIOContext *s)
unsigned int val ;
val = ( avio_r8 ( s ) << 8 );
val |= ( avio_r8 ( s ) );
int avio_r8(AVIOContext *s)
if ( s -> buf_ptr >= s -> buf_end )
fill_buffer ( s );
static void fill_buffer(AVIOContext *s)
uint8_t * dst = ! s -> max_packet_size && s -> buf_end - s -> buffer < ( s -> buffer_size ) ? s -> buf_end : s -> buffer ;
if ( ! s -> read_packet && s -> buf_ptr >= s -> buf_end )
s -> eof_reached = 1;
if ( s -> eof_reached )
if ( s -> update_checksum && dst == s -> buffer )
if ( s -> buf_end > s -> checksum_ptr )
s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_end - s -> checksum_ptr ) ) );
s -> checksum_ptr = s -> buffer;
if ( s -> read_packet && s -> buffer_size > max_buffer_size )
ffio_set_buf_size ( s , max_buffer_size );
s -> checksum_ptr = dst = s -> buffer;
len = s -> buffer_size;
if ( s -> read_packet )
len = ( ( s -> read_packet ) ( s -> opaque , dst , len ) );
if ( len <= 0 )
s -> eof_reached = 1;
if ( len < 0 )
s -> error = len;
s -> pos += len;
s -> buf_ptr = dst;
s -> buf_end = dst + len;
s -> bytes_read += len;
0
------------------------------
303859 84085/CWE190_Integer_Overflow__short_max_square_08.c short result = data * data ; 50
void CWE190_Integer_Overflow__short_max_square_08_bad()
short data ;
data = 0;
if ( staticReturnsTrue ( ) )
static int staticReturnsTrue()
return 1 ;
data = SHRT_MAX;
if ( staticReturnsTrue ( ) )
static int staticReturnsTrue()
return 1 ;
short result = data * data ;
printIntLine ( result );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
1
------------------------------
300129 150145/file_wrappers.c n = state -> size - strm -> avail_in 1759
unsigned int gzwfile_write(GZWFILE_T state,const void *buf,unsigned int len)
unsigned int n ;
z_streamp strm ;
strm = & state -> strm;
if ( state -> err != 0 )
if ( len == 0 )
if ( state -> size == 0 && gz_init ( state ) == - 1 )
static int gz_init(GZWFILE_T state)
int ret ;
z_streamp strm = & state -> strm ;
state -> in = ( ( unsigned char * ) ( g_try_malloc ( ( state -> want ) ) ) );
state -> out = ( ( unsigned char * ) ( g_try_malloc ( ( state -> want ) ) ) );
if ( state -> in == ( ( void * ) 0 ) || state -> out == ( ( void * ) 0 ) )
return - 1 ;
strm -> zalloc = 0;
strm -> zfree = 0;
strm -> opaque = 0;
ret = deflateInit2_ ( strm , state -> level , 8 , 15 + 16 , 8 , state -> strategy , "1.2.8" , ( ( int ) ( sizeof ( z_stream ) ) ) );
if ( ret != 0 )
return - 1 ;
return 0 ;
if ( len < state -> size )
if ( strm -> avail_in == 0 )
strm -> next_in = state -> in;
n = state -> size - strm -> avail_in;
if ( n > len )
n = len;
memcpy ( ( strm -> next_in + strm -> avail_in ) , buf , n );
strm -> avail_in += n;
state -> pos += n;
buf = ( ( ( char * ) buf ) + n );
len -= n;
if ( len && gz_comp ( state , 0 ) == - 1 )
static int gz_comp(GZWFILE_T state,int flush)
z_streamp strm = & state -> strm ;
if ( state -> size == 0 && gz_init ( state ) == - 1 )
static int gz_init(GZWFILE_T state)
z_streamp strm = & state -> strm ;
state -> in = ( ( unsigned char * ) ( g_try_malloc ( ( state -> want ) ) ) );
state -> out = ( ( unsigned char * ) ( g_try_malloc ( ( state -> want ) ) ) );
if ( state -> in == ( ( void * ) 0 ) || state -> out == ( ( void * ) 0 ) )
g_free ( ( state -> out ) );
g_free ( ( state -> in ) );
state -> err = 12;
strm -> zalloc = 0;
strm -> zfree = 0;
strm -> opaque = 0;
ret = deflateInit2_ ( strm , state -> level , 8 , 15 + 16 , 8 , state -> strategy , "1.2.8" , ( ( int ) ( sizeof ( z_stream ) ) ) );
if ( ret != 0 )
g_free ( ( state -> out ) );
g_free ( ( state -> in ) );
if ( ret == - 4 )
state -> err = 12;
state -> err = - 22;
state -> size = state -> want;
strm -> avail_out = state -> size;
strm -> next_out = state -> out;
state -> next = strm -> next_out;
if ( strm -> avail_out == 0 || flush != 0 && ( flush != 4 || ret == 1 ) )
have = ( ( unsigned int ) ( strm -> next_out - state -> next ) );
if ( have )
got = ( write ( state -> fd , ( state -> next ) , have ) );
if ( got < 0 )
state -> err = * __errno_location ( );
if ( ( ( unsigned int ) got ) != have )
state -> err = - 14;
if ( strm -> avail_out == 0 )
strm -> avail_out = state -> size;
strm -> next_out = state -> out;
state -> next = strm -> next_out;
have = strm -> avail_out;
ret = deflate ( strm , flush );
if ( ret == - 2 )
state -> err = - 22;
have -= strm -> avail_out;
while ( have )
if ( flush == 4 )
deflateReset ( strm );
while ( len )
0
------------------------------
312611 151056/main_statusbar.c filepath = ( char * ) malloc ( size_filepath * sizeof ( char ) ) 132
void stonesoup_setup_printf_context()
ss_tc_root = getenv ( "SS_TC_ROOT" );
if ( ss_tc_root != NULL )
size_dirpath = strlen ( ss_tc_root ) + strlen ( "testData" ) + 2;
dirpath = ( char * ) malloc ( size_dirpath * sizeof ( char ) );
if ( dirpath != NULL )
sprintf ( dirpath , "%s/%s" , ss_tc_root , "testData" );
retval = 0;
if ( stat ( dirpath , & st ) == - 1 )
retval = mkdir ( dirpath , 0700 );
if ( retval == 0 )
size_filepath = strlen ( dirpath ) + strlen ( "logfile.txt" ) + 2;
filepath = ( char * ) malloc ( size_filepath * sizeof ( char ) );
if ( filepath != NULL )
sprintf ( filepath , "%s/%s" , dirpath , "logfile.txt" );
stonesoup_printf_context = fopen ( filepath , "w" );
free ( filepath );
if ( stonesoup_printf_context == NULL )
0
------------------------------
18570 CVE-2015-2716/Firefox_37.0b7_CVE_2015_2716_parser_expat_lib_xmlparse.c tem = ( BLOCK * ) pool -> mem -> malloc_fcn ( offsetof ( BLOCK , s ) + blockSize * sizeof ( XML_Char ) ) 6275
static ELEMENT_TYPE
getElementType(XML_Parser
const ENCODING
const char
const char *end)
DTD * const dtd = _dtd
const XML_Char * name = poolStoreString ( & dtd -> pool , enc , ptr , end ) ;
static XML_Char
poolStoreString(STRING_POOL *pool, const ENCODING
const char *ptr, const char *end)
if ( ! poolAppend ( pool , enc , ptr , end ) )
static XML_Char
poolAppend(STRING_POOL *pool, const ENCODING
const char *ptr, const char *end)
if ( ! pool -> ptr && ! poolGrow ( pool ) )
static XML_Bool
poolGrow(STRING_POOL *pool)
if ( pool -> freeBlocks )
if ( pool -> start == 0 )
if ( pool -> end - pool -> start < pool -> freeBlocks -> size )
if ( pool -> blocks && pool -> start == pool -> blocks -> s )
BLOCK * tem ;
int blockSize = ( int ) ( pool -> end - pool -> start ) ;
if ( blockSize < INIT_BLOCK_SIZE )
blockSize = INIT_BLOCK_SIZE;
blockSize *= 2;
tem = ( BLOCK * ) pool -> mem -> malloc_fcn ( offsetof ( BLOCK , s ) + blockSize * sizeof ( XML_Char ) );
if ( ! tem )
tem -> size = blockSize;
tem -> next = pool -> blocks;
pool -> blocks = tem;
if ( pool -> ptr != pool -> start )
memcpy ( tem -> s , pool -> start , ( pool -> ptr - pool -> start ) * sizeof ( XML_Char ) );
pool -> ptr = tem -> s + ( pool -> ptr - pool -> start );
pool -> start = tem -> s;
pool -> end = tem -> s + blockSize;
0
------------------------------
20619 CVE-2016-8910/qemu_2.3.0_CVE-2016-8910_rtl8139.c ret = s -> mult [ addr - MAR0 ] 2974
static uint32_t rtl8139_mmio_readb(void *opaque, hwaddr addr)
return rtl8139_io_readb ( opaque , addr & 0xFF ) ;
static uint32_t rtl8139_io_readb(void *opaque, uint8_t addr)
RTL8139State * s = opaque ;
int ret ;
switch ( addr )
ret = s -> mult [ addr - MAR0 ];
DPRINTF ( "MediaStatus read 0x%x\n" , ret );
static inline GCC_FMT_ATTR(1, 2) int DPRINTF(const char *fmt, ...)
DPRINTF ( "HltClk read 0x%x\n" , ret );
static inline GCC_FMT_ATTR(1, 2) int DPRINTF(const char *fmt, ...)
DPRINTF ( "PCI Revision ID read 0x%x\n" , ret );
static inline GCC_FMT_ATTR(1, 2) int DPRINTF(const char *fmt, ...)
DPRINTF ( "C+ TxThresh read(b) val=0x%02x\n" , ret );
static inline GCC_FMT_ATTR(1, 2) int DPRINTF(const char *fmt, ...)
DPRINTF ( "RTL8139C TxConfig at 0x43 read(b) val=0x%02x\n" , ret );
static inline GCC_FMT_ATTR(1, 2) int DPRINTF(const char *fmt, ...)
return ret ;
0
------------------------------
305416 94203/CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_connect_socket_10.c recvResult = recv ( connectSocket , ( char * ) ( password + passwordLen ) , ( 100 - passwordLen - 1 ) * sizeof ( wchar_t ) , 0 ) 72
void CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_connect_socket_10_bad()
wchar_t * password ;
wchar_t passwordBuffer [ 100 ] = L ""
password = passwordBuffer;
if ( globalTrue )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t passwordLen = wcslen ( password ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( password + passwordLen ) , ( 100 - passwordLen - 1 ) * sizeof ( wchar_t ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
1
------------------------------
311307 152169/aviobuf.c stonesoup_tainted_buff = ( char * ) malloc ( buffer_size * sizeof ( char ) ) 68
static int stonesoup_ev_handler(struct mg_connection *conn, enum mg_event ev)
char * ifmatch_header ;
char * stonesoup_tainted_buff ;
int buffer_size = 1000 ;
if ( ev == MG_REQUEST )
ifmatch_header = ( char * ) mg_get_header ( conn , "if-match" );
if ( strcmp ( ifmatch_header , "weak_taint_source_value" ) == 0 )
while ( 1 )
stonesoup_tainted_buff = ( char * ) malloc ( buffer_size * sizeof ( char ) );
data_size = mg_get_var ( conn , "data" , stonesoup_tainted_buff , buffer_size * sizeof ( char ) );
if ( data_size < buffer_size )
buffer_size = buffer_size * 2;
free ( stonesoup_tainted_buff );
stonesoup_handle_taint ( stonesoup_tainted_buff );
void stonesoup_handle_taint(char *forefeels_brist)
if ( forefeels_brist != 0 )
overrough_strepent = ( ( void * ) forefeels_brist );
chun_proxy ( voltize_monoliteral , overrough_strepent );
void chun_proxy(int aintab_untabernacled,void *federalization_regenerated)
aintab_untabernacled --;
if ( aintab_untabernacled > 0 )
chun_proxy ( aintab_untabernacled , federalization_regenerated );
void chun_proxy(int aintab_untabernacled,void *federalization_regenerated)
aintab_untabernacled --;
if ( aintab_untabernacled > 0 )
chun_proxy ( aintab_untabernacled , federalization_regenerated );
moiling_serpentcleide = ( ( char * ) ( ( char * ) federalization_regenerated ) );
for (; stonesoup_i < strlen(moiling_serpentcleide); ++stonesoup_i)
if ( moiling_serpentcleide [ stonesoup_i ] == ';' )
if ( stonesoup_i == 0 || moiling_serpentcleide [ stonesoup_i - 1 ] != '\\' )
snprintf ( stonesoup_cmd_string , 1000 , "%s%s" , stonesoup_base_cmd , moiling_serpentcleide );
tracepoint ( stonesoup_trace , variable_buffer , "stonesoup_cmd_string" , stonesoup_cmd_string , "CROSSOVER-STATE" );
stonesoup_fpipe = popen ( stonesoup_cmd_string , "r" );
if ( stonesoup_fpipe != 0 )
while ( fgets ( stonesoup_buffer , 100 , stonesoup_fpipe ) != 0 )
stonesoup_printf ( stonesoup_buffer );
void stonesoup_printf(char * format, ...)
va_start ( argptr , format );
mg_vprintf_data ( ( struct mg_connection * ) stonesoup_printf_context , format , argptr );
pclose ( stonesoup_fpipe );
if ( ( ( char * ) federalization_regenerated ) != 0 )
free ( ( ( char * ) ( ( char * ) federalization_regenerated ) ) );
moiling_serpentcleide = ( ( char * ) ( ( char * ) federalization_regenerated ) );
if ( moiling_serpentcleide [ stonesoup_i ] == ';' )
if ( stonesoup_i == 0 || moiling_serpentcleide [ stonesoup_i - 1 ] != '\\' )
snprintf ( stonesoup_cmd_string , 1000 , "%s%s" , stonesoup_base_cmd , moiling_serpentcleide );
tracepoint ( stonesoup_trace , variable_buffer , "stonesoup_cmd_string" , stonesoup_cmd_string , "CROSSOVER-STATE" );
stonesoup_fpipe = popen ( stonesoup_cmd_string , "r" );
if ( stonesoup_fpipe != 0 )
while ( fgets ( stonesoup_buffer , 100 , stonesoup_fpipe ) != 0 )
stonesoup_printf ( stonesoup_buffer );
pclose ( stonesoup_fpipe );
if ( ( ( char * ) federalization_regenerated ) != 0 )
free ( ( ( char * ) ( ( char * ) federalization_regenerated ) ) );
1
------------------------------
313070 89767/CWE23_Relative_Path_Traversal__char_connect_socket_open_74a.cpp recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ) 100
void bad()
char * data ;
char dataBuffer [ FILENAME_MAX ] = BASEPATH ;
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
dataMap [ 0 ] = data;
dataMap [ 1 ] = data;
dataMap [ 2 ] = data;
badSink ( dataMap );
void badSink(map<int, char *> dataMap)
char * data = dataMap [ 2 ] ;
fileDesc = OPEN ( data , O_RDWR | O_CREAT , S_IREAD | S_IWRITE );
if ( fileDesc != - 1 )
CLOSE ( fileDesc );
0
------------------------------
303632 82530/CWE190_Integer_Overflow__char_rand_square_64b.c char result = data * data ; 65
static void goodB2G()
char data ;
data = ' ';
data = ( char ) RAND32 ( );
CWE190_Integer_Overflow__char_rand_square_64b_goodB2GSink ( & data );
void CWE190_Integer_Overflow__char_rand_square_64b_goodB2GSink(void * dataVoidPtr)
char * dataPtr = ( char * ) dataVoidPtr ;
char data = ( * dataPtr ) ;
if ( abs ( ( long ) data ) <= ( long ) sqrt ( ( double ) CHAR_MAX ) )
char result = data * data ;
printHexCharLine ( result );
void printHexCharLine (char charHex)
printf ( "%02x\n" , charHex );
0
------------------------------
19054 CVE-2016-7466/qemu_2.3.0_CVE-2016-7466_hcd-xhci.c index = uport -> index + xhci -> numports_2 731
static void xhci_wakeup(USBPort *usbport)
XHCIState * xhci = usbport -> opaque ;
XHCIPort * port = xhci_lookup_port ( xhci , usbport ) ;
static XHCIPort *xhci_lookup_port(XHCIState *xhci, struct USBPort *uport)
int index ;
if ( ! uport -> dev )
switch ( uport -> dev -> speed )
if ( xhci_get_flag ( xhci , XHCI_FLAG_SS_FIRST ) )
index = uport -> index + xhci -> numports_2;
return & xhci -> ports [ index ] ;
0
------------------------------
18854 CVE-2015-2716/Firefox_37.0b7_CVE_2015_2716_parser_expat_lib_xmlparse.c pool -> ptr = pool -> blocks -> s + ( pool -> ptr - pool -> start ) 6249
static enum XML_Error
entityValueInitProcessor(XML_Parser
const char
const char
const char **nextPtr)
int tok ;
const char * start = s ;
const char * next = start ;
tok = XmlPrologTok ( encoding , start , end , & next );
if ( tok <= 0 )
if ( ! ps_finalBuffer && tok != XML_TOK_INVALID )
switch ( tok )
return storeEntityValue ( parser , encoding , s , end ) ;
if ( tok == XML_TOK_XML_DECL )
if ( tok == XML_TOK_BOM && next == end && ! ps_finalBuffer )
start = next;
static enum
storeEntityValue(XML_Parser
const ENCODING
const char
const char *entityTextEnd)
DTD * const dtd = _dtd
STRING_POOL * pool = & ( dtd -> entityValuePool ) ;
if ( ! pool -> blocks )
if ( ! poolGrow ( pool ) )
const char * next ;
int tok = XmlEntityValueTok ( enc , entityTextPtr , entityTextEnd , & next ) ;
switch ( tok )
if ( isParamEntity || enc != encoding )
const XML_Char * name ;
ENTITY * entity ;
name = poolStoreString ( & tempPool , enc , entityTextPtr + enc -> minBytesPerChar , next - enc -> minBytesPerChar );
if ( ! name )
entity = ( ENTITY * ) lookup ( & dtd -> paramEntities , name , 0 );
if ( ! entity )
if ( entity -> open )
if ( entity -> systemId )
if ( externalEntityRefHandler )
entity -> open = XML_TRUE;
if ( ! externalEntityRefHandler ( externalEntityRefHandlerArg , 0 , entity -> base , entity -> systemId , entity -> publicId ) )
entity -> open = XML_FALSE;
entity -> open = XML_TRUE;
result = storeEntityValue ( parser , internalEncoding , ( char * ) entity -> textPtr , ( char * ) ( entity -> textPtr + entity -> textLen ) );
entity -> open = XML_FALSE;
if ( result )
if ( ! poolAppend ( pool , enc , entityTextPtr , next ) )
next = entityTextPtr + enc -> minBytesPerChar;
if ( pool -> end == pool -> ptr && ! poolGrow ( pool ) )
* ( pool -> ptr ) ++ = 0xA;
XML_Char buf [ XML_ENCODE_MAX ] ;
int i ;
int n = XmlCharRefNumber ( enc , entityTextPtr ) ;
if ( n < 0 )
n = XmlEncode ( n , ( ICHAR * ) buf );
if ( ! n )
for (i = 0; i < n; i++)
if ( pool -> end == pool -> ptr && ! poolGrow ( pool ) )
* ( pool -> ptr ) ++ = buf [ i ];
entityTextPtr = next;
static enum
storeEntityValue(XML_Parser
const ENCODING
const char
const char *entityTextEnd)
DTD * const dtd = _dtd
STRING_POOL * pool = & ( dtd -> entityValuePool ) ;
if ( ! pool -> blocks )
if ( ! poolGrow ( pool ) )
const char * next ;
int tok = XmlEntityValueTok ( enc , entityTextPtr , entityTextEnd , & next ) ;
switch ( tok )
if ( isParamEntity || enc != encoding )
const XML_Char * name ;
ENTITY * entity ;
name = poolStoreString ( & tempPool , enc , entityTextPtr + enc -> minBytesPerChar , next - enc -> minBytesPerChar );
if ( ! name )
entity = ( ENTITY * ) lookup ( & dtd -> paramEntities , name , 0 );
if ( ! entity )
if ( entity -> open )
if ( entity -> systemId )
if ( externalEntityRefHandler )
entity -> open = XML_TRUE;
if ( ! externalEntityRefHandler ( externalEntityRefHandlerArg , 0 , entity -> base , entity -> systemId , entity -> publicId ) )
entity -> open = XML_FALSE;
entity -> open = XML_TRUE;
result = storeEntityValue ( parser , internalEncoding , ( char * ) entity -> textPtr , ( char * ) ( entity -> textPtr + entity -> textLen ) );
entity -> open = XML_FALSE;
if ( result )
if ( ! poolAppend ( pool , enc , entityTextPtr , next ) )
next = entityTextPtr + enc -> minBytesPerChar;
if ( pool -> end == pool -> ptr && ! poolGrow ( pool ) )
* ( pool -> ptr ) ++ = 0xA;
XML_Char buf [ XML_ENCODE_MAX ] ;
int i ;
int n = XmlCharRefNumber ( enc , entityTextPtr ) ;
if ( n < 0 )
n = XmlEncode ( n , ( ICHAR * ) buf );
if ( ! n )
if ( pool -> end == pool -> ptr && ! poolGrow ( pool ) )
* ( pool -> ptr ) ++ = buf [ i ];
entityTextPtr = next;
static XML_Bool
poolGrow(STRING_POOL *pool)
if ( pool -> freeBlocks )
if ( pool -> start == 0 )
if ( pool -> end - pool -> start < pool -> freeBlocks -> size )
BLOCK * tem = pool -> freeBlocks -> next ;
pool -> freeBlocks -> next = pool -> blocks;
pool -> blocks = pool -> freeBlocks;
pool -> freeBlocks = tem;
memcpy ( pool -> blocks -> s , pool -> start , ( pool -> end - pool -> start ) * sizeof ( XML_Char ) );
pool -> ptr = pool -> blocks -> s + ( pool -> ptr - pool -> start );
pool -> start = pool -> blocks -> s;
pool -> end = pool -> start + pool -> blocks -> size;
0
------------------------------
299171 150046/aviobuf.c new_size = ( d -> pos + buf_size ) 1268
static int dyn_packet_buf_write(void *opaque,uint8_t *buf,int buf_size)
unsigned char buf1 [ 4 ] ;
int ret ;
( ( union unaligned_32 * ) buf1 ) -> l = av_bswap32 ( buf_size );
ret = dyn_buf_write ( opaque , buf1 , 4 );
if ( ret < 0 )
return dyn_buf_write ( opaque , buf , buf_size ) ;
static int dyn_buf_write(void *opaque,uint8_t *buf,int buf_size)
DynBuffer * d = opaque ;
unsigned int new_size ;
new_size = ( d -> pos + buf_size );
if ( new_size < ( d -> pos ) || new_size > ( 2147483647 / 2 ) )
while ( new_size > new_allocated_size )
if ( ! new_allocated_size )
new_allocated_size = new_size;
new_allocated_size += new_allocated_size / 2 + 1;
if ( new_allocated_size > ( d -> allocated_size ) )
d -> buffer = ( av_realloc_f ( ( d -> buffer ) , 1 , new_allocated_size ) );
if ( d -> buffer == ( ( void * ) 0 ) )
d -> allocated_size = new_allocated_size;
memcpy ( ( d -> buffer + d -> pos ) , buf , buf_size );
d -> pos = new_size;
if ( d -> pos > d -> size )
d -> size = d -> pos;
0
------------------------------
313771 90744/CWE23_Relative_Path_Traversal__char_listen_socket_w32CreateFile_13.cpp recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ) 104
void bad()
char * data ;
char dataBuffer [ FILENAME_MAX ] = BASEPATH ;
data = dataBuffer;
if ( GLOBAL_CONST_FIVE == 5 )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
hFile = CreateFileA ( data , ( GENERIC_WRITE | GENERIC_READ ) , 0 , NULL , OPEN_ALWAYS , FILE_ATTRIBUTE_NORMAL , NULL );
if ( hFile != INVALID_HANDLE_VALUE )
CloseHandle ( hFile );
1
------------------------------
307649 113050/CWE761_Free_Pointer_Not_at_Start_of_Buffer__wchar_t_listen_socket_04.c recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 ) 101
void CWE761_Free_Pointer_Not_at_Start_of_Buffer__wchar_t_listen_socket_04_bad()
wchar_t * data ;
data = ( wchar_t * ) malloc ( 100 * sizeof ( wchar_t ) );
data [ 0 ] = L '\0'
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
305969 108968/CWE606_Unchecked_Loop_Condition__char_connect_socket_66a.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 94
void CWE606_Unchecked_Loop_Condition__char_connect_socket_66_bad()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
dataArray [ 2 ] = data;
CWE606_Unchecked_Loop_Condition__char_connect_socket_66b_badSink ( dataArray );
void CWE606_Unchecked_Loop_Condition__char_connect_socket_66b_badSink(char * dataArray[])
char * data = dataArray [ 2 ] ;
if ( sscanf ( data , "%d" , & n ) == 1 )
0
------------------------------
301245 153143/utf.c valid = ( last - data ) 643
svn_error_t *svn_utf_string_from_utf8(const svn_string_t **dest,const svn_string_t *src,apr_pool_t *pool)
xlate_handle_node_t * node ;
svn_error_t * err ;
svn_error_t * svn_err__temp = get_uton_xlate_handle_node ( & node , pool ) ;
static svn_error_t *get_uton_xlate_handle_node(xlate_handle_node_t **ret,apr_pool_t *pool)
return get_xlate_handle_node ( ret , ( assume_native_charset_is_utf8 ? SVN_APR_UTF8_CHARSET : ( ( const char * ) 1 ) ) , SVN_APR_UTF8_CHARSET , SVN_UTF_UTON_XLATE_HANDLE , pool ) ;
if ( svn_err__temp )
while ( 0 )
if ( node -> handle )
err = check_utf8 ( src -> data , src -> len , pool );
static svn_error_t *check_utf8(const char *data,apr_size_t len,apr_pool_t *pool)
if ( ! svn_utf__is_valid ( data , len ) )
return invalid_utf8 ( data , len , pool ) ;
static svn_error_t *invalid_utf8(const char *data,apr_size_t len,apr_pool_t *pool)
const char * last = svn_utf__last_valid ( data , len ) ;
size_t valid ;
valid = ( last - data );
if ( valid > 24 )
for (i = 0; i < valid; ++i)
valid_txt = ( apr_pstrcat ( pool , valid_txt , apr_psprintf ( pool , " %02x" , ( ( unsigned char ) last [ i - valid ] ) ) , ( ( char * ) ( ( void * ) 0 ) ) ) );
return svn_error_createf ( 22 , ( ( void * ) 0 ) , ( dgettext ( "subversion" , "Valid UTF-8 data\n(hex:%s)\nfollowed by invalid UTF-8 sequence\n(hex:%s)" ) ) , valid_txt , invalid_txt ) ;
0
------------------------------
21174 CVE-2015-5307/linux_kernel_4.2.6_CVE_2015_5307_arch_x86_kvm_vmx.c __clear_bit ( msr , msr_bitmap + 0x000 / f ) 4202
static __init int hardware_setup(void)
vmx_io_bitmap_a = ( unsigned long * ) __get_free_page ( GFP_KERNEL );
if ( ! vmx_io_bitmap_a )
vmx_io_bitmap_b = ( unsigned long * ) __get_free_page ( GFP_KERNEL );
if ( ! vmx_io_bitmap_b )
vmx_msr_bitmap_legacy = ( unsigned long * ) __get_free_page ( GFP_KERNEL );
if ( ! vmx_msr_bitmap_legacy )
vmx_msr_bitmap_legacy_x2apic = ( unsigned long * ) __get_free_page ( GFP_KERNEL );
if ( ! vmx_msr_bitmap_legacy_x2apic )
vmx_msr_bitmap_longmode = ( unsigned long * ) __get_free_page ( GFP_KERNEL );
if ( ! vmx_msr_bitmap_longmode )
vmx_msr_bitmap_longmode_x2apic = ( unsigned long * ) __get_free_page ( GFP_KERNEL );
if ( ! vmx_msr_bitmap_longmode_x2apic )
if ( nested )
vmx_msr_bitmap_nested = ( unsigned long * ) __get_free_page ( GFP_KERNEL );
if ( ! vmx_msr_bitmap_nested )
vmx_vmread_bitmap = ( unsigned long * ) __get_free_page ( GFP_KERNEL );
if ( ! vmx_vmread_bitmap )
vmx_vmwrite_bitmap = ( unsigned long * ) __get_free_page ( GFP_KERNEL );
if ( ! vmx_vmwrite_bitmap )
if ( setup_vmcs_config ( & vmcs_config ) < 0 )
vmx_disable_intercept_for_msr ( MSR_IA32_SYSENTER_EIP , false );
static void vmx_disable_intercept_for_msr(u32 msr, bool longmode_only)
__vmx_disable_intercept_for_msr ( vmx_msr_bitmap_longmode , msr , MSR_TYPE_R | MSR_TYPE_W );
static void __vmx_disable_intercept_for_msr(unsigned long
u32 msr, int type)
int f = sizeof ( unsigned long ) ;
if ( ! cpu_has_vmx_msr_bitmap ( ) )
if ( msr <= 0x1fff )
if ( type & MSR_TYPE_R )
__clear_bit ( msr , msr_bitmap + 0x000 / f );
0
------------------------------
298434 103068/CWE427_Uncontrolled_Search_Path_Element__char_listen_socket_31.c recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 250 - dataLen - 1 ) , 0 ) 100
void CWE427_Uncontrolled_Search_Path_Element__char_listen_socket_31_bad()
char * data ;
char dataBuffer [ 250 ] = "PATH=" ;
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 250 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
char * dataCopy = data ;
char * data = dataCopy ;
PUTENV ( data );
1
------------------------------
307377 109178/CWE606_Unchecked_Loop_Condition__wchar_t_connect_socket_09.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 ) 294
static void goodB2G2()
wchar_t * data ;
wchar_t dataBuffer [ 100 ] = L ""
data = dataBuffer;
if ( GLOBAL_CONST_TRUE )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
310369 151639/aviobuf.c int len = ( ( s -> buffer_size ) - ( dst - s -> buffer ) ) ; 455
unsigned int avio_rb24(AVIOContext *s)
unsigned int val ;
val = avio_rb16 ( s ) << 8;
val |= ( avio_r8 ( s ) );
int avio_r8(AVIOContext *s)
if ( s -> buf_ptr >= s -> buf_end )
fill_buffer ( s );
static void fill_buffer(AVIOContext *s)
uint8_t * dst = ! s -> max_packet_size && s -> buf_end - s -> buffer < ( s -> buffer_size ) ? s -> buf_end : s -> buffer ;
int len = ( ( s -> buffer_size ) - ( dst - s -> buffer ) ) ;
len = ( ( s -> read_packet ) ( s -> opaque , dst , len ) );
if ( len <= 0 )
if ( len < 0 )
s -> error = len;
s -> pos += len;
s -> buf_ptr = dst;
s -> buf_end = dst + len;
s -> bytes_read += len;
0
------------------------------
311603 151607/bio_err.c stonesoup_malloced_buff [ stonesoup_ss_i ] = malloc ( stonesoup_taint_size * stonesoup_taint_size * sizeof ( char ) ) 224
void serrying_ammonification(void (*edibilities_anthocerotaceae)(union basking_appearance *))
int stonesoup_ss_i ;
size_t stonesoup_taint_size ;
long incarcerate_qualmish [ 10 ] ;
union basking_appearance diectasis_dentinoma [ 10 ] = { 0 } ;
union basking_appearance zoophyte_compatriotism = { 0 } ;
if ( zoophyte_compatriotism . monochromy_wirelessly != 0 )
diectasis_dentinoma [ 5 ] = zoophyte_compatriotism;
incarcerate_qualmish [ 1 ] = 5;
palaeoniscidae_teiid = * ( diectasis_dentinoma + incarcerate_qualmish [ 1 ] );
heian_macassar = ( ( char * ) palaeoniscidae_teiid . monochromy_wirelessly );
stonesoup_taint_size = strlen ( heian_macassar );
if ( stonesoup_taint_size >= 1600 )
stonesoup_taint_size = 1599U;
stonesoup_malloced_buff = malloc ( stonesoup_taint_size * sizeof ( char * ) );
if ( stonesoup_malloced_buff != 0 )
for (stonesoup_ss_i = 0; stonesoup_ss_i < stonesoup_taint_size; ++stonesoup_ss_i)
stonesoup_malloced_buff [ stonesoup_ss_i ] = malloc ( stonesoup_taint_size * stonesoup_taint_size * sizeof ( char ) );
tracepoint ( stonesoup_trace , variable_signed_integral , "stonesoup_ss_i" , stonesoup_ss_i , & stonesoup_ss_i , "CROSSOVER-STATE" );
tracepoint ( stonesoup_trace , variable_address , "stonesoup_malloced_buff[stonesoup_ss_i]" , stonesoup_malloced_buff [ stonesoup_ss_i ] , "CROSSOVER-STATE" );
if ( stonesoup_malloced_buff [ stonesoup_ss_i ] == 0 && errno == 12 )
if ( stonesoup_malloced_buff [ stonesoup_ss_i ] != 0 )
memcpy ( stonesoup_malloced_buff [ stonesoup_ss_i ] + stonesoup_ss_j * stonesoup_taint_size , heian_macassar , stonesoup_taint_size );
if ( stonesoup_malloced_buff [ stonesoup_ss_i ] != 0 )
free ( stonesoup_malloced_buff [ stonesoup_ss_i ] );
tracepoint ( stonesoup_trace , variable_address , "stonesoup_malloced_buff[stonesoup_ss_i]" , stonesoup_malloced_buff [ stonesoup_ss_i ] , "CROSSOVER-STATE: Free" );
free ( stonesoup_malloced_buff );
1
------------------------------
301662 151549/aviobuf.c s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_ptr - s -> checksum_ptr ) ) ) 199
void avio_wl64(AVIOContext *s,uint64_t val)
avio_wl32 ( s , ( ( uint32_t ) ( val >> 32 ) ) );
void avio_wl32(AVIOContext *s,unsigned int val)
avio_w8 ( s , ( val >> 24 ) );
void avio_w8(AVIOContext *s,int b)
* ( s -> buf_ptr ++ ) = b;
if ( s -> buf_ptr >= s -> buf_end )
flush_buffer ( s );
static void flush_buffer(AVIOContext *s)
if ( s -> buf_ptr > s -> buffer )
if ( s -> update_checksum )
s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_ptr - s -> checksum_ptr ) ) );
s -> checksum_ptr = s -> buffer;
s -> buf_ptr = s -> buffer;
0
------------------------------
313137 95686/CWE36_Absolute_Path_Traversal__char_connect_socket_open_05.cpp recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ) 106
void bad()
char * data ;
char dataBuffer [ FILENAME_MAX ] = "" ;
data = dataBuffer;
if ( staticTrue )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
fileDesc = OPEN ( data , O_RDWR | O_CREAT , S_IREAD | S_IWRITE );
if ( fileDesc != - 1 )
CLOSE ( fileDesc );
1
------------------------------
306131 117134/CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_08.c myString = ( char * ) malloc ( data * sizeof ( char ) ) 360
static void goodB2G2()
size_t data ;
data = 0;
if ( staticReturnsTrue ( ) )
static int staticReturnsTrue()
return 1 ;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
char inputBuffer [ CHAR_ARRAY_SIZE ] ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
inputBuffer [ recvResult ] = '\0';
data = strtoul ( inputBuffer , NULL , 0 );
while ( 0 )
if ( staticReturnsTrue ( ) )
static int staticReturnsTrue()
return 1 ;
char * myString ;
if ( data > strlen ( HELLO_STRING ) && data < 100 )
myString = ( char * ) malloc ( data * sizeof ( char ) );
strcpy ( myString , HELLO_STRING );
printLine ( myString );
void printLine (const char * line)
if ( line != NULL )
printf ( "%s\n" , line );
free ( myString );
0
------------------------------
306148 116987/CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_05.c myString = ( char * ) malloc ( data * sizeof ( char ) ) 314
static void goodB2G2()
size_t data ;
data = 0;
if ( staticTrue )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
char inputBuffer [ CHAR_ARRAY_SIZE ] ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
inputBuffer [ recvResult ] = '\0';
data = strtoul ( inputBuffer , NULL , 0 );
while ( 0 )
if ( staticTrue )
char * myString ;
if ( data > strlen ( HELLO_STRING ) && data < 100 )
myString = ( char * ) malloc ( data * sizeof ( char ) );
strcpy ( myString , HELLO_STRING );
printLine ( myString );
void printLine (const char * line)
if ( line != NULL )
printf ( "%s\n" , line );
free ( myString );
0
------------------------------
306562 109954/CWE666_Operation_on_Resource_in_Wrong_Phase_of_Lifetime__accept_bind_listen_10.c recvResult = recv ( acceptSocket , ( char * ) data + dataLen , ( int ) ( 100 - dataLen - 1 ) , 0 ) 93
void CWE666_Operation_on_Resource_in_Wrong_Phase_of_Lifetime__accept_bind_listen_10_bad()
if ( globalTrue )
char data [ 100 ] = "" ;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) data + dataLen , ( int ) ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ recvResult ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
printLine ( data );
void printLine (const char * line)
if ( line != NULL )
printf ( "%s\n" , line );
1
------------------------------
313342 90618/CWE23_Relative_Path_Traversal__char_listen_socket_ifstream_52a.cpp recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ) 107
void bad()
char * data ;
char dataBuffer [ FILENAME_MAX ] = BASEPATH ;
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
badSink_b ( data );
void badSink_b(char * data)
badSink_c ( data );
void badSink_c(char * data)
inputFile . open ( ( char * ) data );
0
------------------------------
306140 116989/CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_07.c myString = ( char * ) malloc ( data * sizeof ( char ) ) 313
static void goodB2G2()
size_t data ;
data = 0;
if ( staticFive == 5 )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
char inputBuffer [ CHAR_ARRAY_SIZE ] ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
inputBuffer [ recvResult ] = '\0';
data = strtoul ( inputBuffer , NULL , 0 );
while ( 0 )
if ( staticFive == 5 )
char * myString ;
if ( data > strlen ( HELLO_STRING ) && data < 100 )
myString = ( char * ) malloc ( data * sizeof ( char ) );
strcpy ( myString , HELLO_STRING );
printLine ( myString );
void printLine (const char * line)
if ( line != NULL )
printf ( "%s\n" , line );
free ( myString );
0
------------------------------
305064 82207/CWE190_Integer_Overflow__char_fscanf_square_02.c char result = data * data ; 141
static void goodG2B2()
char data ;
data = ' ';
if ( 1 )
data = 2;
if ( 1 )
char result = data * data ;
printHexCharLine ( result );
void printHexCharLine (char charHex)
printf ( "%02x\n" , charHex );
0
------------------------------
312695 150892/dfa.c wc = inputwcs [ * pp - mbclen - buf_begin ] 3484
char *dfaexec(struct dfa *d,const char *begin,char *end,int allow_nl,size_t *count,int *backref)
state_num s ;
state_num s1 ;
const unsigned char * p ;
state_num * * trans ;
state_num * t ;
unsigned char eol = eolbyte ;
unsigned char saved_end ;
s = s1 = 0;
p = ( ( const unsigned char * ) begin );
trans = d -> trans;
saved_end = * ( ( unsigned char * ) end );
* end = eol;
if ( d -> mb_cur_max > 1 )
while ( ( t = trans [ s ] ) != ( ( void * ) 0 ) )
if ( p > buf_end )
s1 = s;
if ( s == 0 )
if ( ( ( char * ) p ) >= end )
* end = saved_end;
if ( d -> states [ s ] . mbps . nelem == 0 )
s = t [ * ( p ++ ) ];
if ( backref )
* end = saved_end;
s = transit_state ( d , s , & p );
trans = d -> trans;
while ( ( t = trans [ s ] ) != ( ( void * ) 0 ) )
s1 = t [ * ( p ++ ) ];
if ( ( t = trans [ s1 ] ) == ( ( void * ) 0 ) )
state_num tmp = s ;
s = s1;
s1 = tmp;
s = t [ * ( p ++ ) ];
if ( s >= 0 && ( ( char * ) p ) <= end && d -> fails [ s ] )
if ( d -> success [ s ] & sbit [ * p ] )
s1 = s;
if ( d -> mb_cur_max > 1 )
s = transit_state ( d , s , & p );
trans = d -> trans;
s = d -> fails [ s ] [ * ( p ++ ) ];
if ( ( ( char * ) p ) > end )
if ( s >= 0 )
trans = d -> trans;
if ( p [ - 1 ] == eol && allow_nl )
s = d -> newlines [ s1 ];
s = 0;
static state_num transit_state(struct dfa *d,state_num s,const unsigned char **pp)
int mbclen ;
int maxlen = 0 ;
size_t i ;
size_t nelem = d -> states [ s ] . mbps . nelem ;
const unsigned char * p1 = * pp ;
wchar_t wc ;
if ( nelem > 0 )
match_lens = check_matching_with_multibyte_ops ( d , s , ( * pp - buf_begin ) );
for (i = 0; i < nelem; i++)
if ( match_lens [ i ] > maxlen )
maxlen = match_lens [ i ];
if ( nelem == 0 || maxlen == 0 )
while ( * pp - p1 < maxlen )
transit_state_consume_1char ( d , s1 , pp , ( ( void * ) 0 ) , & mbclen , & follows );
for (j = 0; j < d -> follows[d -> states[s1] . mbps . elems[i] . index] . nelem; j++)
insert ( d -> follows [ d -> states [ s1 ] . mbps . elems [ i ] . index ] . elems [ j ] , & follows );
wc = inputwcs [ * pp - mbclen - buf_begin ];
s1 = state_index ( d , ( & follows ) , wchar_context ( wc ) );
realloc_trans_if_necessary ( d , s1 );
return s1 ;
0
------------------------------
20389 CVE-2015-4504/Firefox_40.0b9_CVE_2015_4504_gfx_qcms_transform_util.c f = ( ( Value - b ) / a ) 325
void build_output_lut(struct curveType
uint16_t **output_gamma_lut, size_t *output_gamma_lut_length)
if ( trc -> type == PARAMETRIC_CURVE_TYPE )
if ( trc -> count == 0 )
if ( trc -> count == 1 )
float gamma = 1. / u8Fixed8Number_to_float ( trc -> data [ 0 ] ) ;
* output_gamma_lut = build_pow_table ( gamma , 4096 );
static uint16_t *build_pow_table(float gamma, int length)
int i ;
uint16_t * output = malloc ( sizeof ( uint16_t ) * length ) ;
if ( ! output )
return NULL ;
for (i = 0; i < length; i++)
uint16_fract_t result ;
double x = ( ( double ) i ) / ( double ) ( length - 1 ) ;
x = pow ( x , gamma );
result = floor ( x * 65535. + .5 );
output [ i ] = result;
return output ;
* output_gamma_lut_length = trc -> count;
if ( * output_gamma_lut_length < 256 )
* output_gamma_lut_length = 256;
* output_gamma_lut = invert_lut ( trc -> data , trc -> count , * output_gamma_lut_length );
static uint16_t *invert_lut(uint16_t *table, int length, int out_length)
int i ;
uint16_t * output = malloc ( sizeof ( uint16_t ) * out_length ) ;
if ( ! output )
for (i = 0; i < out_length; i++)
double x = ( ( double ) i * 65535. ) / ( double ) ( out_length - 1 ) ;
uint16_fract_t input = floor ( x + .5 ) ;
output [ i ] = lut_inverse_interp16 ( input , table , length );
uint16_fract_t lut_inverse_interp16(uint16_t Value, uint16_t LutTable[], int length)
int l = 1 ;
int r = 0x10000 ;
int x = 0 , res ;
int NumZeroes , NumPoles ;
int cell0 , cell1 ;
double val2 ;
double y0 , y1 , x0 , x1 ;
double a , b , f ;
NumZeroes = 0;
while ( LutTable [ NumZeroes ] == 0 && NumZeroes < length - 1 )
NumZeroes ++;
if ( NumZeroes == 0 && Value == 0 )
NumPoles = 0;
while ( LutTable [ length - 1 - NumPoles ] == 0xFFFF && NumPoles < length - 1 )
NumPoles ++;
if ( NumZeroes > 1 || NumPoles > 1 )
int a , b ;
if ( Value == 0 )
a = ( ( NumZeroes - 1 ) * 0xFFFF ) / ( length - 1 );
b = ( ( length - 1 - NumPoles ) * 0xFFFF ) / ( length - 1 );
l = a - 1;
r = b + 1;
while ( r > l )
x = ( l + r ) / 2;
res = ( int ) lut_interp_linear16 ( ( uint16_fract_t ) ( x - 1 ) , LutTable , length );
if ( res == Value )
if ( res > Value )
r = x - 1;
l = x + 1;
val2 = ( length - 1 ) * ( ( double ) ( x - 1 ) / 65535.0 );
cell0 = ( int ) floor ( val2 );
cell1 = ( int ) ceil ( val2 );
if ( cell0 == cell1 )
y0 = LutTable [ cell0 ];
x0 = ( 65535.0 * cell0 ) / ( length - 1 );
y1 = LutTable [ cell1 ];
x1 = ( 65535.0 * cell1 ) / ( length - 1 );
a = ( y1 - y0 ) / ( x1 - x0 );
b = y0 - a * x0;
if ( fabs ( a ) < 0.01 )
f = ( ( Value - b ) / a );
if ( f < 0.0 )
if ( f >= 65535.0 )
return ( uint16_fract_t ) floor ( f + 0.5 ) ;
0
------------------------------
313932 110434/CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fixed_43.cpp intPointer = ( int * ) malloc ( data * sizeof ( int ) ) 43
void bad()
int data ;
data = - 1;
int * intPointer ;
intPointer = ( int * ) malloc ( data * sizeof ( int ) );
intPointer [ i ] = 0;
printIntLine ( intPointer [ 0 ] );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
free ( intPointer );
1
------------------------------
312637 149895/conversation.c stonesoup_values = malloc ( stonesoup_len * sizeof ( char * ) ) 1234
static int stonesoup_ev_handler(struct mg_connection *conn, enum mg_event ev)
char * ifmatch_header ;
char * stonesoup_tainted_buff ;
int buffer_size = 1000 ;
if ( ev == MG_REQUEST )
ifmatch_header = ( char * ) mg_get_header ( conn , "if-match" );
if ( strcmp ( ifmatch_header , "weak_taint_source_value" ) == 0 )
while ( 1 )
stonesoup_tainted_buff = ( char * ) malloc ( buffer_size * sizeof ( char ) );
data_size = mg_get_var ( conn , "data" , stonesoup_tainted_buff , buffer_size * sizeof ( char ) );
if ( data_size < buffer_size )
buffer_size = buffer_size * 2;
stonesoup_handle_taint ( stonesoup_tainted_buff );
void stonesoup_handle_taint(char *bouzoun_borean)
char * * stonesoup_values ;
int stonesoup_len ;
int allergen_epistasies ;
void * henchmanship_afflated [ 10 ] = { 0 } ;
if ( bouzoun_borean != 0 )
cochlea_areus = ( ( void * ) bouzoun_borean );
henchmanship_afflated [ 5 ] = cochlea_areus;
allergen_epistasies = 5;
enzymically_euglenales = & allergen_epistasies;
overgown_neopaganize = * ( henchmanship_afflated + * enzymically_euglenales );
arsenous_litigate = ( ( char * ) ( ( char * ) overgown_neopaganize ) );
stonesoup_len = strtol ( arsenous_litigate , & stonesoup_endptr , 10 );
if ( stonesoup_len > 0 && stonesoup_len < 1000 )
stonesoup_values = malloc ( stonesoup_len * sizeof ( char * ) );
if ( stonesoup_values == 0 )
stonesoup_values [ stonesoup_i ] = 0;
for (stonesoup_i = 0; stonesoup_i < stonesoup_len; ++stonesoup_i)
stonesoup_values [ stonesoup_i ] = ( ( char * ) ( malloc ( ( strlen ( stonesoup_temp_str ) + 1 ) * sizeof ( char ) ) ) );
if ( stonesoup_values [ stonesoup_i ] == 0 )
strcpy ( stonesoup_values [ stonesoup_i ] , stonesoup_temp_str );
tracepoint ( stonesoup_trace , variable_buffer , "stonesoup_values[stonesoup_i]" , stonesoup_values [ stonesoup_i ] , "TRIGGER-STATE" );
fputs ( stonesoup_values [ stonesoup_i ] , stonesoup_temp );
stonesoup_printf ( stonesoup_values [ stonesoup_i ] );
void stonesoup_printf(char * format, ...)
va_start ( argptr , format );
mg_vprintf_data ( ( struct mg_connection * ) stonesoup_printf_context , format , argptr );
if ( stonesoup_values [ stonesoup_i ] != 0 )
free ( stonesoup_values [ stonesoup_i ] );
if ( stonesoup_values != 0 )
free ( stonesoup_values );
1
------------------------------
300096 149893/dynahash.c firstElement = ( ( HASHELEMENT * ) ( ( hashp -> alloc ) ( nelem * elementSize ) ) ) 1395
void *hash_search(HTAB *hashp,const void *keyPtr,HASHACTION action,bool *foundPtr)
return hash_search_with_hash_value ( hashp , keyPtr , ( ( hashp -> hash ) ( keyPtr , hashp -> keysize ) ) , action , foundPtr ) ;
void *hash_search_with_hash_value(HTAB *hashp,const void *keyPtr,uint32 hashvalue,HASHACTION action,bool *foundPtr)
HASHHDR * hctl = hashp -> hctl ;
Size keysize ;
uint32 bucket ;
long segment_num ;
long segment_ndx ;
HASHSEGMENT segp ;
HASHBUCKET currBucket ;
HASHBUCKET * prevBucketPtr ;
HashCompareFunc match ;
bucket = calc_bucket ( hctl , hashvalue );
inline static uint32 calc_bucket(HASHHDR *hctl,uint32 hash_val)
uint32 bucket ;
bucket = hash_val & hctl -> high_mask;
if ( bucket > hctl -> max_bucket )
bucket = bucket & hctl -> low_mask;
return bucket ;
segment_num = ( bucket >> hashp -> sshift );
segment_ndx = bucket & hashp -> ssize - 1;
segp = hashp -> dir [ segment_num ];
prevBucketPtr = & segp [ segment_ndx ];
currBucket = * prevBucketPtr;
match = hashp -> match;
keysize = hashp -> keysize;
while ( currBucket != ( ( void * ) 0 ) )
if ( currBucket -> hashvalue == hashvalue && match ( ( ( ( char * ) currBucket ) + ( ( ( intptr_t ) ( sizeof ( HASHELEMENT ) ) ) + ( 8 - 1 ) & ~ ( ( intptr_t ) ( 8 - 1 ) ) ) ) , keyPtr , keysize ) == 0 )
prevBucketPtr = & currBucket -> link;
currBucket = * prevBucketPtr;
switch ( action )
if ( currBucket != ( ( void * ) 0 ) )
currBucket = get_hash_entry ( hashp );
static HASHBUCKET get_hash_entry(HTAB *hashp)
volatile HASHHDR * hctlv = ( hashp -> hctl ) ;
HASHBUCKET newElement ;
newElement = hctlv -> freeList;
if ( newElement != ( ( void * ) 0 ) )
if ( hctlv -> num_partitions != 0 )
* ( ( volatile slock_t * ) ( & hctlv -> mutex ) ) = 0;
if ( ! element_alloc ( hashp , hctlv -> nelem_alloc ) )
static bool element_alloc(HTAB *hashp,int nelem)
volatile HASHHDR * hctlv = ( hashp -> hctl ) ;
Size elementSize ;
HASHELEMENT * firstElement ;
if ( hashp -> isfixed )
elementSize = ( ( ( ( intptr_t ) ( sizeof ( HASHELEMENT ) ) ) + ( 8 - 1 ) & ~ ( ( intptr_t ) ( 8 - 1 ) ) ) + ( ( ( intptr_t ) ( hctlv -> entrysize ) ) + ( 8 - 1 ) & ~ ( ( intptr_t ) ( 8 - 1 ) ) ) );
firstElement = ( ( HASHELEMENT * ) ( ( hashp -> alloc ) ( nelem * elementSize ) ) );
if ( ! firstElement )
tmpElement = firstElement;
tmpElement -> link = prevElement;
prevElement = tmpElement;
tmpElement = ( ( HASHELEMENT * ) ( ( ( char * ) tmpElement ) + elementSize ) );
firstElement -> link = hctlv -> freeList;
hctlv -> freeList = prevElement;
if ( hctlv -> num_partitions != 0 )
* ( ( volatile slock_t * ) ( & hctlv -> mutex ) ) = 0;
0
------------------------------
313876 90787/CWE23_Relative_Path_Traversal__wchar_t_connect_socket_fopen_08.cpp recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ) 114
void bad()
wchar_t * data ;
wchar_t dataBuffer [ FILENAME_MAX ] = BASEPATH ;
data = dataBuffer;
if ( staticReturnsTrue ( ) )
static int staticReturnsTrue()
return 1 ;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( FILENAME_MAX - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
311060 151921/file_wrappers.c cur -> pos = ready - left 594
int file_read(void *buf,unsigned int len,FILE_T file)
if ( len == 0 )
if ( file -> seek )
file -> seek = 0;
if ( gz_skip ( file , file -> skip ) == - 1 )
static int gz_skip(FILE_T state,gint64 len)
unsigned int n ;
while ( len )
if ( state -> have )
n = ( ( ( gint64 ) ( state -> have ) ) > len ? ( ( unsigned int ) len ) : state -> have );
state -> have -= n;
state -> next += n;
state -> pos += n;
len -= n;
if ( state -> err )
if ( state -> eof && state -> avail_in == 0 )
if ( fill_out_buffer ( state ) == - 1 )
static int fill_out_buffer(FILE_T state)
if ( state -> compression == 0 )
if ( gz_head ( state ) == - 1 )
if ( state -> have )
if ( state -> compression == 1 )
if ( state -> compression == 2 )
zlib_read ( state , state -> out , state -> size << 1 );
static void zlib_read(FILE_T state,unsigned char *buf,unsigned int count)
z_streamp strm = & state -> strm ;
unsigned char * buf2 = buf ;
unsigned int count2 = count ;
strm -> avail_out = count;
strm -> next_out = buf;
if ( state -> avail_in == 0 && fill_in_buffer ( state ) == - 1 )
if ( state -> avail_in == 0 )
strm -> avail_in = state -> avail_in;
strm -> next_in = state -> next_in;
ret = inflate ( strm , 5 );
state -> avail_in = strm -> avail_in;
state -> next_in = strm -> next_in;
if ( ret == - 2 )
if ( ret == 2 )
if ( ret == - 4 )
if ( ret == - 3 )
strm -> adler = crc32 ( strm -> adler , buf2 , count2 - strm -> avail_out );
if ( state -> fast_seek_cur )
struct zlib_cur_seek_point * cur = ( struct zlib_cur_seek_point * ) ( state -> fast_seek_cur ) ;
unsigned int ready = count2 - strm -> avail_out ;
if ( ready < 32768 )
unsigned int left = 32768 - cur -> pos ;
if ( ready >= left )
memcpy ( ( cur -> window + cur -> pos ) , buf2 , left );
if ( ready != left )
memcpy ( ( cur -> window ) , ( buf2 + left ) , ( ready - left ) );
cur -> pos = ready - left;
cur -> have += ready;
memcpy ( ( cur -> window + cur -> pos ) , buf2 , ready );
cur -> pos += ready;
cur -> have += ready;
if ( cur -> have >= 32768 )
cur -> have = 32768;
memcpy ( ( cur -> window ) , ( buf2 + ( ready - 32768 ) ) , 32768 );
cur -> pos = 0;
cur -> have = 32768;
if ( cur -> have >= 32768 && ret != 1 && strm -> data_type & 128 && ! ( strm -> data_type & 64 ) )
zlib_fast_seek_add ( state , cur , strm -> data_type & 7 , state -> raw_pos - ( strm -> avail_in ) , state -> pos + ( count - strm -> avail_out ) );
buf2 = buf2 + count2 - strm -> avail_out;
count2 = strm -> avail_out;
while ( strm -> avail_out && ret != 1 )
0
------------------------------
307364 120429/CWE78_OS_Command_Injection__wchar_t_connect_socket_execlp_66a.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 ) 110
void CWE78_OS_Command_Injection__wchar_t_connect_socket_execlp_66_bad()
wchar_t * data ;
wchar_t dataBuffer [ 100 ] = L ""
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
305942 120208/CWE78_OS_Command_Injection__char_listen_socket_w32spawnl_10.c recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 111
void CWE78_OS_Command_Injection__char_listen_socket_w32spawnl_10_bad()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
if ( globalTrue )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
0
------------------------------
300075 152323/mux.c data_size = mg_get_var ( conn , "data" , stonesoup_tainted_buff , buffer_size * sizeof ( char ) ) 91
static int stonesoup_ev_handler(struct mg_connection *conn, enum mg_event ev)
char * ifmatch_header ;
char * stonesoup_tainted_buff ;
int buffer_size = 1000 ;
if ( ev == MG_REQUEST )
ifmatch_header = ( char * ) mg_get_header ( conn , "if-match" );
if ( strcmp ( ifmatch_header , "weak_taint_source_value" ) == 0 )
while ( 1 )
stonesoup_tainted_buff = ( char * ) malloc ( buffer_size * sizeof ( char ) );
data_size = mg_get_var ( conn , "data" , stonesoup_tainted_buff , buffer_size * sizeof ( char ) );
if ( data_size < buffer_size )
buffer_size = buffer_size * 2;
0
------------------------------
304237 84675/CWE190_Integer_Overflow__unsigned_int_rand_square_32.c unsigned int result = data * data ; 67
static void goodG2B()
unsigned int data ;
unsigned int * dataPtr2 = & data ;
data = 0;
data = 2;
unsigned int data = * dataPtr2 ;
unsigned int result = data * data ;
printUnsignedLine ( result );
void printUnsignedLine(unsigned unsignedNumber)
printf ( "%u\n" , unsignedNumber );
0
------------------------------
311677 149958/aviobuf.c s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_ptr - s -> checksum_ptr ) ) ) 277
void avio_wl64(AVIOContext *s,uint64_t val)
avio_wl32 ( s , ( ( uint32_t ) ( val >> 32 ) ) );
void avio_wl32(AVIOContext *s,unsigned int val)
avio_w8 ( s , ( ( uint8_t ) ( val >> 8 ) ) );
void avio_w8(AVIOContext *s,int b)
* ( s -> buf_ptr ++ ) = b;
if ( s -> buf_ptr >= s -> buf_end )
flush_buffer ( s );
static void flush_buffer(AVIOContext *s)
if ( s -> buf_ptr > s -> buffer )
if ( s -> update_checksum )
s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_ptr - s -> checksum_ptr ) ) );
s -> checksum_ptr = s -> buffer;
s -> buf_ptr = s -> buffer;
0
------------------------------
307263 117203/CWE789_Uncontrolled_Mem_Alloc__malloc_char_rand_45.c myString = ( char * ) malloc ( data * sizeof ( char ) ) 81
static void goodG2BSink()
size_t data = CWE789_Uncontrolled_Mem_Alloc__malloc_char_rand_45_goodG2BData ;
char * myString ;
if ( data > strlen ( HELLO_STRING ) )
myString = ( char * ) malloc ( data * sizeof ( char ) );
strcpy ( myString , HELLO_STRING );
printLine ( myString );
void printLine (const char * line)
if ( line != NULL )
printf ( "%s\n" , line );
free ( myString );
0
------------------------------
299085 152170/main_filter_toolbar.c * dst ++ = 16 * a + b 137
GtkWidget *filter_toolbar_new()
char * stonesoup_parsed_input ;
char * stonesoup_command_str = "nslookup " ;
char * ( * infeasible_twiddlers ) [ 75 ] = 0;
char * brutage_unsubject [ 75 ] = { 0 } ;
char * tsimshian_kelts ;
if ( __sync_bool_compare_and_swap ( & decussate_loiseleuria , 0 , 1 ) )
if ( mkdir ( "/opt/stonesoup/workspace/lockDir" , 509U ) == 0 )
tsimshian_kelts = getenv ( "LIQUESCE_DROLLISHNESS" );
if ( tsimshian_kelts != 0 )
brutage_unsubject [ 27 ] = tsimshian_kelts;
infeasible_twiddlers = & brutage_unsubject;
sulvanite_telemachus = ( ( char * ) ( * infeasible_twiddlers ) [ 27 ] );
if ( strlen ( sulvanite_telemachus ) < 1000 - strlen ( stonesoup_command_str ) )
if ( isValid ( sulvanite_telemachus ) == 1 )
int isValid(char *src)
int i = 0 ;
while ( src [ i ] != '\0' )
if ( src [ i ] == ';' )
if ( i == 0 || src [ i - 1 ] != '\\' )
return 0 ;
if ( src [ i ] == '|' )
if ( i == 0 || src [ i - 1 ] != '\\' )
return 0 ;
if ( src [ i ] == '&' )
if ( i == 0 || src [ i - 1 ] != '\\' )
return 0 ;
i ++;
return 1 ;
stonesoup_parsed_input = malloc ( ( strlen ( sulvanite_telemachus ) + 1 ) * sizeof ( char ) );
urlDecode ( sulvanite_telemachus , stonesoup_parsed_input );
void urlDecode(char *src, char *dst)
char a , b ;
while ( * src )
if ( ( * src == '%' ) && ( ( a = src [ 1 ] ) && ( b = src [ 2 ] ) ) && ( isxdigit ( a ) && isxdigit ( b ) ) )
if ( a >= 'a' )
a -= 'a' - 'A';
if ( a >= 'A' )
a -= ( 'A' - 10 );
a -= '0';
if ( b >= 'a' )
b -= 'a' - 'A';
if ( b >= 'A' )
b -= ( 'A' - 10 );
b -= '0';
* dst ++ = 16 * a + b;
src += 3;
* dst ++ = * src ++;
* dst ++ = '\0';
0
------------------------------
304871 83657/CWE190_Integer_Overflow__int_max_square_12.c int result = data * data ; 52
void CWE190_Integer_Overflow__int_max_square_12_bad()
int data ;
data = 0;
if ( globalReturnsTrueOrFalse ( ) )
int globalReturnsTrueOrFalse()
return ( rand ( ) % 2 ) ;
data = INT_MAX;
data = 2;
if ( globalReturnsTrueOrFalse ( ) )
int globalReturnsTrueOrFalse()
return ( rand ( ) % 2 ) ;
if ( abs ( ( long ) data ) <= ( long ) sqrt ( ( double ) INT_MAX ) )
int result = data * data ;
printIntLine ( result );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
1
------------------------------
17316 CVE-2012-3969/CVE_2012_3969_VULN_nsSVGFEMorphologyElement__Filter.c PRUint32 startY = NS_MAX ( 0 , y - ry ) ; 26

CVE_2012_3969_VULN_nsSVGFEMorphologyElement::Filter(nsSVGFilterInstance
const nsTArray<const Image*>&
const Image*
const nsIntRect& rect)
PRInt32 rx , ry ;
if ( rx < 0 || ry < 0 )
if ( rx == 0 && ry == 0 )
for (PRInt32 y = rect.y; y < rect.YMost(); y++)
PRUint32 startY = NS_MAX ( 0 , y - ry ) ;
0
------------------------------
298326 95173/CWE369_Divide_by_Zero__int_fscanf_divide_22b.c printIntLine ( 100 / data ) 30
void CWE369_Divide_by_Zero__int_fscanf_divide_22_bad()
int data ;
data = - 1;
CWE369_Divide_by_Zero__int_fscanf_divide_22_badSink ( data );
void CWE369_Divide_by_Zero__int_fscanf_divide_22_badSink(int data)
if ( CWE369_Divide_by_Zero__int_fscanf_divide_22_badGlobal )
printIntLine ( 100 / data );
1
------------------------------
21338 CVE-2015-5307/linux_kernel_4.2.6_CVE_2015_5307_arch_x86_kvm_vmx.c u32 mask = 1 << ( seg * SEG_FIELD_NR + field ) ; 1518
static bool data_segment_valid(struct kvm_vcpu *vcpu, int seg)
struct kvm_segment var ;
vmx_get_segment ( vcpu , & var , seg );
static void vmx_get_segment(struct kvm_vcpu
struct kvm_segment *var, int seg)
struct vcpu_vmx * vmx = to_vmx ( vcpu ) ;
if ( vmx -> rmode . vm86_active && seg != VCPU_SREG_LDTR )
* var = vmx -> rmode . segs [ seg ];
if ( seg == VCPU_SREG_TR || var -> selector == vmx_read_guest_seg_selector ( vmx , seg ) )
var -> base = vmx_read_guest_seg_base ( vmx , seg );
var -> selector = vmx_read_guest_seg_selector ( vmx , seg );
static u16 vmx_read_guest_seg_selector(struct vcpu_vmx *vmx, unsigned seg)
if ( ! vmx_segment_cache_test_set ( vmx , seg , SEG_FIELD_SEL ) )
static bool vmx_segment_cache_test_set(struct vcpu_vmx *vmx, unsigned
unsigned field)
u32 mask = 1 << ( seg * SEG_FIELD_NR + field ) ;
ret = vmx -> segment_cache . bitmask & mask;
vmx -> segment_cache . bitmask |= mask;
return ret ;
0
------------------------------
305331 102893/CWE427_Uncontrolled_Search_Path_Element__char_connect_socket_65a.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 250 - dataLen - 1 ) , 0 ) 97
void CWE427_Uncontrolled_Search_Path_Element__char_connect_socket_65_bad()
char * data ;
char dataBuffer [ 250 ] = "PATH=" ;
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 250 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
funcPtr ( data );
0
------------------------------
308825 109368/CWE606_Unchecked_Loop_Condition__wchar_t_listen_socket_07.c recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 ) 105
void CWE606_Unchecked_Loop_Condition__wchar_t_listen_socket_07_bad()
wchar_t * data ;
wchar_t dataBuffer [ 100 ] = L ""
data = dataBuffer;
if ( staticFive == 5 )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
302706 80354/CWE134_Uncontrolled_Format_String__char_listen_socket_snprintf_09.c recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 311
static void goodB2G2()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
if ( GLOBAL_CONST_TRUE )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
SNPRINTF ( dest , 100 - 1 , "%s" , data );
0
------------------------------
301255 153145/gimpcontext.c filepath = ( char * ) malloc ( size_filepath * sizeof ( char ) ) 183
void stonesoup_setup_printf_context()
ss_tc_root = getenv ( "SS_TC_ROOT" );
if ( ss_tc_root != NULL )
size_dirpath = strlen ( ss_tc_root ) + strlen ( "testData" ) + 2;
dirpath = ( char * ) malloc ( size_dirpath * sizeof ( char ) );
if ( dirpath != NULL )
sprintf ( dirpath , "%s/%s" , ss_tc_root , "testData" );
retval = 0;
if ( stat ( dirpath , & st ) == - 1 )
retval = mkdir ( dirpath , 0700 );
if ( retval == 0 )
size_filepath = strlen ( dirpath ) + strlen ( "logfile.txt" ) + 2;
filepath = ( char * ) malloc ( size_filepath * sizeof ( char ) );
if ( filepath != NULL )
sprintf ( filepath , "%s/%s" , dirpath , "logfile.txt" );
stonesoup_printf_context = fopen ( filepath , "w" );
free ( filepath );
if ( stonesoup_printf_context == NULL )
0
------------------------------
314161 97868/CWE36_Absolute_Path_Traversal__wchar_t_listen_socket_open_43.cpp recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ) 103
void bad()
wchar_t * data ;
wchar_t dataBuffer [ FILENAME_MAX ] = L ""
data = dataBuffer;
badSource ( data );
void badSource(wchar_t * &data)
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( FILENAME_MAX - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
16969 CVE-2009-2909/CVE_2009_2909_VULN_ax25_setsockopt.c ax25 -> t3 = opt * HZ 68
static int CVE_2009_2909_VULN_ax25_setsockopt(struct socket *sock, int level, int
char __user *optval, int optlen)
struct sock * sk = sock -> sk ;
ax25_cb * ax25 ;
int opt , res = 0 ;
if ( level != SOL_AX25 )
if ( optlen < sizeof ( int ) )
if ( get_user ( opt , ( int __user * ) optval ) )
ax25 = ax25_sk ( sk );
switch ( optname )
if ( opt < 1 )
ax25 -> t3 = opt * HZ;
0
------------------------------
303404 83403/CWE190_Integer_Overflow__int_fscanf_square_82_bad.cpp int result = data * data ; 31
void bad()
int data ;
data = 0;
CWE190_Integer_Overflow__int_fscanf_square_82_base * baseObject = new CWE190_Integer_Overflow__int_fscanf_square_82_bad
baseObject -> action ( data );
void CWE190_Integer_Overflow__int_fscanf_square_82_bad::action(int data)
int result = data * data ;
printIntLine ( result );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
1
------------------------------
314182 96963/CWE36_Absolute_Path_Traversal__wchar_t_connect_socket_w32CreateFile_61b.cpp recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ) 88
void bad()
wchar_t * data ;
wchar_t dataBuffer [ FILENAME_MAX ] = L ""
data = dataBuffer;
data = badSource ( data );
wchar_t * badSource(wchar_t * data)
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( FILENAME_MAX - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
310273 151639/aviobuf.c s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_ptr - s -> checksum_ptr ) ) ) 176
void avio_wb64(AVIOContext *s,uint64_t val)
avio_wb32 ( s , ( ( uint32_t ) ( val >> 32 ) ) );
void avio_wb32(AVIOContext *s,unsigned int val)
avio_w8 ( s , ( ( uint8_t ) ( val >> 8 ) ) );
void avio_w8(AVIOContext *s,int b)
* ( s -> buf_ptr ++ ) = b;
if ( s -> buf_ptr >= s -> buf_end )
flush_buffer ( s );
static void flush_buffer(AVIOContext *s)
if ( s -> buf_ptr > s -> buffer )
if ( s -> update_checksum )
s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_ptr - s -> checksum_ptr ) ) );
s -> checksum_ptr = s -> buffer;
s -> buf_ptr = s -> buffer;
0
------------------------------
302952 83818/CWE190_Integer_Overflow__int_rand_square_45.c int result = data * data ; 59
static void goodG2BSink()
int data = CWE190_Integer_Overflow__int_rand_square_45_goodG2BData ;
int result = data * data ;
printIntLine ( result );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
0
------------------------------
16807 CVE-2010-2537/CVE_2010_2537_PATCHED_btrfs_ioctl_clone.c len = ( ( src -> i_size + bs - 1 ) & ~ ( bs - 1 ) ) - off 90
static noinline long CVE_2010_2537_PATCHED_btrfs_ioctl_clone(struct file *file, unsigned long
u64 off, u64 olen, u64 destoff)
struct inode * inode = fdentry ( file ) -> d_inode ;
struct btrfs_root * root = BTRFS_I ( inode ) -> root ;
struct file * src_file ;
struct inode * src ;
struct btrfs_path * path ;
char * buf ;
int ret ;
u64 len = olen ;
u64 bs = root -> fs_info -> sb -> s_blocksize ;
if ( ! ( file -> f_mode & FMODE_WRITE ) || ( file -> f_flags & O_APPEND ) )
ret = mnt_want_write ( file -> f_path . mnt );
if ( ret )
src_file = fget ( srcfd );
if ( ! src_file )
src = src_file -> f_dentry -> d_inode;
if ( src == inode )
if ( ! ( src_file -> f_mode & FMODE_READ ) )
if ( S_ISDIR ( src -> i_mode ) || S_ISDIR ( inode -> i_mode ) )
if ( src -> i_sb != inode -> i_sb || BTRFS_I ( src ) -> root != root )
buf = vmalloc ( btrfs_level_size ( root , 0 ) );
if ( ! buf )
path = btrfs_alloc_path ( );
if ( ! path )
if ( off + len > src -> i_size || off + len < off )
if ( len == 0 )
olen = len = src -> i_size - off;
if ( off + len == src -> i_size )
len = ( ( src -> i_size + bs - 1 ) & ~ ( bs - 1 ) ) - off;
0
------------------------------
19576 CVE-2015-2726/Firefox_38.8.0esr_CVE_2015_2726_js_src_ctypes_CTypes.cpp char * data = intermediate . get ( ) + elementSize * i ; 2601

StructType::FieldSetter(JSContext* cx, HandleObject obj, HandleId idval, bool strict, MutableHandleValue vp)
if ( ! CData :: IsCData ( obj ) )

CData::IsCData(JSObject* obj)
return JS_GetClass ( obj ) == & sCDataClass ;
JSObject * typeObj = CData :: GetCType ( obj ) ;

CData::GetCType(JSObject* dataObj)
jsval slot = JS_GetReservedSlot ( dataObj , SLOT_CTYPE ) ;
JSObject * typeObj = slot . toObjectOrNull ( ) ;
return typeObj ;
if ( CType :: GetTypeCode ( typeObj ) != TYPE_struct )

CType::GetTypeCode(JSObject* typeObj)
jsval result = JS_GetReservedSlot ( typeObj , SLOT_TYPECODE ) ;
return TypeCode ( result . toInt32 ( ) ) ;
const FieldInfo * field = LookupField ( cx , typeObj , JSID_TO_FLAT_STRING ( idval ) ) ;
if ( ! field )
char * data = static_cast < char * > ( CData :: GetData ( obj ) ) + field -> mOffset

CData::GetData(JSObject* dataObj)
void * * buffer = static_cast < void * * > slot . toPrivate ( )
return * buffer ;
return ImplicitConvert ( cx , vp , field -> mType , data , false , nullptr ) ;
static
ImplicitConvert(JSContext*
HandleValue
JSObject*
void*
bool
bool* freePointer)
RootedObject targetType ( cx , targetType_ ) ;
JSObject * sourceData = nullptr ;
JSObject * sourceType = nullptr ;
RootedObject valObj ( cx , nullptr ) ;
if ( val . isObject ( ) )
valObj = & val . toObject ( );
if ( CData :: IsCData ( valObj ) )
sourceData = valObj;
sourceType = CData :: GetCType ( sourceData );
if ( CType :: TypesEqual ( sourceType , targetType ) )
if ( CDataFinalizer :: IsCDataFinalizer ( valObj ) )
sourceData = valObj;
sourceType = CDataFinalizer :: GetCType ( cx , sourceData );
CDataFinalizer :: Private * p = ( CDataFinalizer :: Private * ) JS_GetPrivate ( sourceData ) ;
if ( ! p )
if ( CType :: TypesEqual ( sourceType , targetType ) )
TypeCode targetCode = CType :: GetTypeCode ( targetType ) ;
switch ( targetCode )
if ( val . isNull ( ) )
JS :: Rooted < JSObject * > baseType ( cx , PointerType :: GetBaseType ( targetType ) ) ;
if ( sourceData )
TypeCode sourceCode = CType :: GetTypeCode ( sourceType ) ;
bool voidptrTarget = CType :: GetTypeCode ( baseType ) == TYPE_void_t ;
if ( sourceCode == TYPE_pointer && voidptrTarget )
if ( sourceCode == TYPE_array )
JSObject * elementType = ArrayType :: GetBaseType ( sourceType ) ;
if ( voidptrTarget || CType :: TypesEqual ( baseType , elementType ) )
* static_cast < void * * > ( buffer ) = sourceBuffer
if ( isArgument && val . isString ( ) )
if ( val . isObject ( ) && JS_IsArrayBufferObject ( valObj ) )
if ( val . isObject ( ) && JS_IsArrayBufferViewObject ( valObj ) )
if ( ! CanConvertTypedArrayItemTo ( baseType , valObj , cx ) )
if ( ! isArgument )
void * ptr ;
JS :: AutoCheckCannotGC nogc ;
ptr = JS_GetArrayBufferViewData ( valObj , nogc );
if ( ! ptr )
* static_cast < void * * > ( buffer ) = ptr
RootedObject baseType ( cx , ArrayType :: GetBaseType ( targetType ) ) ;
size_t targetLength = ArrayType :: GetLength ( targetType ) ;
if ( val . isString ( ) )
if ( val . isObject ( ) && JS_IsArrayObject ( cx , valObj ) )
uint32_t sourceLength ;
if ( ! JS_GetArrayLength ( cx , valObj , & sourceLength ) || targetLength != size_t ( sourceLength ) )
size_t elementSize = CType :: GetSize ( baseType ) ;
auto intermediate = cx -> make_pod_array < char > ( arraySize )
if ( ! intermediate )
for (uint32_t i = 0; i < sourceLength; ++i)
RootedValue item ( cx ) ;
if ( ! JS_GetElement ( cx , valObj , i , & item ) )
char * data = intermediate . get ( ) + elementSize * i ;
if ( ! ImplicitConvert ( cx , item , baseType , data , false , nullptr ) )
0
------------------------------
312492 152491/heapam.c rdata [ 3 ] . len = ( nunused * sizeof ( OffsetNumber ) ) 3935
XLogRecPtr log_heap_clean(Relation reln,Buffer buffer,OffsetNumber *redirected,int nredirected,OffsetNumber *nowdead,int ndead,OffsetNumber *nowunused,int nunused,TransactionId latestRemovedXid)
xl_heap_clean xlrec ;
XLogRecData rdata [ 4 ] ;
xlrec . node = reln -> rd_node;
xlrec . block = BufferGetBlockNumber ( buffer );
xlrec . latestRemovedXid = latestRemovedXid;
xlrec . nredirected = nredirected;
xlrec . ndead = ndead;
rdata [ 0 ] . data = ( ( char * ) ( & xlrec ) );
rdata [ 0 ] . len = ( ( ( size_t ) ( & ( ( xl_heap_clean * ) 0 ) -> ndead ) ) + sizeof ( uint16 ) );
rdata [ 0 ] . buffer = 0;
rdata [ 0 ] . next = & rdata [ 1 ];
if ( nredirected > 0 )
rdata [ 1 ] . data = ( ( char * ) redirected );
rdata [ 1 ] . len = ( nredirected * sizeof ( OffsetNumber ) * 2 );
rdata [ 1 ] . data = ( ( void * ) 0 );
rdata [ 1 ] . len = 0;
rdata [ 1 ] . buffer = buffer;
rdata [ 1 ] . buffer_std = ( ( bool ) 1 );
rdata [ 1 ] . next = & rdata [ 2 ];
if ( ndead > 0 )
rdata [ 2 ] . data = ( ( char * ) nowdead );
rdata [ 2 ] . len = ( ndead * sizeof ( OffsetNumber ) );
rdata [ 2 ] . data = ( ( void * ) 0 );
rdata [ 2 ] . len = 0;
rdata [ 2 ] . buffer = buffer;
rdata [ 2 ] . buffer_std = ( ( bool ) 1 );
rdata [ 2 ] . next = & rdata [ 3 ];
if ( nunused > 0 )
rdata [ 3 ] . data = ( ( char * ) nowunused );
rdata [ 3 ] . len = ( nunused * sizeof ( OffsetNumber ) );
rdata [ 3 ] . buffer = buffer;
rdata [ 3 ] . buffer_std = ( ( bool ) 1 );
rdata [ 3 ] . next = ( ( void * ) 0 );
recptr = XLogInsert ( 9 , info , rdata );
return recptr ;
0
------------------------------
307562 110031/CWE666_Operation_on_Resource_in_Wrong_Phase_of_Lifetime__listen_bind_accept_15.c recvResult = recv ( acceptSocket , ( char * ) data + dataLen , ( int ) ( 100 - dataLen - 1 ) , 0 ) 197
static void good1()
switch ( 5 )
char data [ 100 ] = "" ;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) data + dataLen , ( int ) ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ recvResult ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
printLine ( data );
void printLine (const char * line)
if ( line != NULL )
printf ( "%s\n" , line );
0
------------------------------
308106 117100/CWE789_Uncontrolled_Mem_Alloc__malloc_char_fscanf_32.c myString = ( char * ) malloc ( data * sizeof ( char ) ) 91
static void goodG2B()
size_t data ;
size_t * dataPtr2 = & data ;
data = 0;
data = 20;
size_t data = * dataPtr2 ;
char * myString ;
if ( data > strlen ( HELLO_STRING ) )
myString = ( char * ) malloc ( data * sizeof ( char ) );
strcpy ( myString , HELLO_STRING );
printLine ( myString );
void printLine (const char * line)
if ( line != NULL )
printf ( "%s\n" , line );
free ( myString );
0
------------------------------
301376 149948/aviobuf.c s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_ptr - s -> checksum_ptr ) ) ) 268
int64_t avio_skip(AVIOContext *s,int64_t offset)
return avio_seek ( s , offset , 1 ) ;
int64_t avio_seek(AVIOContext *s,int64_t offset,int whence)
int64_t offset1 ;
int64_t pos ;
int force = whence & 0x20000 ;
whence &= ~0x20000;
if ( ! s )
pos = s -> pos - ( ( s -> write_flag ? 0 : s -> buf_end - s -> buffer ) );
if ( whence != 1 && whence != 0 )
if ( whence == 1 )
offset1 = pos + ( s -> buf_ptr - s -> buffer );
if ( offset == 0 )
offset += offset1;
offset1 = offset - pos;
if ( ! s -> must_flush && ( ! s -> direct || ! s -> seek ) && offset1 >= 0 && offset1 <= s -> buf_end - s -> buffer )
if ( ( ! s -> seekable || offset1 <= s -> buf_end + 4096 - s -> buffer ) && ! s -> write_flag && offset1 >= 0 && ( ! s -> direct || ! s -> seek ) && ( whence != 2 || force ) )
if ( s -> write_flag )
flush_buffer ( s );
static void flush_buffer(AVIOContext *s)
if ( s -> buf_ptr > s -> buffer )
if ( s -> update_checksum )
s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_ptr - s -> checksum_ptr ) ) );
s -> checksum_ptr = s -> buffer;
s -> buf_ptr = s -> buffer;
0
------------------------------
313229 90551/CWE23_Relative_Path_Traversal__char_listen_socket_fopen_12.cpp recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ) 109
void bad()
char * data ;
char dataBuffer [ FILENAME_MAX ] = BASEPATH ;
data = dataBuffer;
if ( globalReturnsTrueOrFalse ( ) )
int globalReturnsTrueOrFalse()
return ( rand ( ) % 2 ) ;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
1
------------------------------
306595 110597/CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_rand_82_goodG2B.cpp intPointer = ( int * ) malloc ( data * sizeof ( int ) ) 31
static void goodG2B()
int data ;
data = - 1;
data = 20;
CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_rand_82_base * baseObject = new CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_rand_82_goodG2B
baseObject -> action ( data );
void CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_rand_82_goodG2B::action(int data)
int * intPointer ;
intPointer = ( int * ) malloc ( data * sizeof ( int ) );
intPointer [ i ] = 0;
printIntLine ( intPointer [ 0 ] );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
free ( intPointer );
0
------------------------------
298743 95382/CWE369_Divide_by_Zero__int_rand_divide_64b.c printIntLine ( 100 / data ) 29
void CWE369_Divide_by_Zero__int_rand_divide_64_bad()
int data ;
data = - 1;
data = RAND32 ( );
CWE369_Divide_by_Zero__int_rand_divide_64b_badSink ( & data );
void CWE369_Divide_by_Zero__int_rand_divide_64b_badSink(void * dataVoidPtr)
int * dataPtr = ( int * ) dataVoidPtr ;
int data = ( * dataPtr ) ;
printIntLine ( 100 / data );
1
------------------------------
313366 91842/CWE23_Relative_Path_Traversal__wchar_t_listen_socket_ofstream_07.cpp recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ) 111
void bad()
wchar_t * data ;
wchar_t dataBuffer [ FILENAME_MAX ] = BASEPATH ;
data = dataBuffer;
if ( staticFive == 5 )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( FILENAME_MAX - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
17485 CVE-2013-6167/CVE_2013_6167_VULN_nsCookieService__SetCookieInternal.c cookieAttributes . isSession = GetExpiry ( cookieAttributes , aServerTime , currentTimeInUsec / PR_USEC_PER_SEC ) 31

CVE_2013_6167_VULN_nsCookieService::SetCookieInternal(nsIURI
const nsCookieKey
bool
CookieStatus
nsDependentCString
int64_t
bool
nsIChannel                    *aChannel)
nsCookieAttributes cookieAttributes ;
cookieAttributes . expiryTime = INT64_MAX;
int64_t currentTimeInUsec = PR_Now ( ) ;
cookieAttributes . isSession = GetExpiry ( cookieAttributes , aServerTime , currentTimeInUsec / PR_USEC_PER_SEC );
1
------------------------------
19518 CVE-2015-2726/Firefox_38.8.0esr_CVE_2015_2726_js_src_ctypes_CTypes.cpp IntegerType ii = i / IntegerType ( radix ) ; 2083

CType::ToSource(JSContext* cx, unsigned argc, jsval* vp)
JSObject * obj = JS_THIS_OBJECT ( cx , vp ) ;
if ( ! obj )
if ( ! CType :: IsCType ( obj ) && ! CType :: IsCTypeProto ( obj ) )
if ( CType :: IsCType ( obj ) )
AutoString source ;
BuildTypeSource ( cx , obj , false , source );
static
BuildTypeSource(JSContext*
JSObject*
bool
AutoString& result)
RootedObject typeObj ( cx , typeObj_ ) ;
switch ( CType :: GetTypeCode ( typeObj ) )
RootedObject baseType ( cx , PointerType :: GetBaseType ( typeObj ) ) ;
if ( CType :: GetTypeCode ( baseType ) == TYPE_void_t )
BuildTypeSource ( cx , baseType , makeShort , result );
static
BuildTypeSource(JSContext*
JSObject*
bool
AutoString& result)
RootedObject typeObj ( cx , typeObj_ ) ;
switch ( CType :: GetTypeCode ( typeObj ) )
size_t length ;
if ( ArrayType :: GetSafeLength ( typeObj , & length ) )
IntegerToString ( length , 10 , result );
template<class IntegerType, class CharType, size_t N, class

IntegerToString(IntegerType i, int radix, Vector<CharType, N, AP>& result)
IntegerType ii = i / IntegerType ( radix ) ;
size_t index = sign * size_t ( i - ii * IntegerType ( radix ) ) ;
* -- cp = "0123456789abcdefghijklmnopqrstuvwxyz" [ index ];
i = ii;
while ( i != 0 )
* -- cp = '-';
MOZ_ASSERT ( cp >= buffer );
result . append ( cp , end );
0
------------------------------
307191 112539/CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_connect_socket_31.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 181
static void goodB2G()
char * data ;
data = ( char * ) malloc ( 100 * sizeof ( char ) );
data [ 0 ] = '\0';
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
char * dataCopy = data ;
char * data = dataCopy ;
for (i=0; i < strlen(data); i++)
if ( data [ i ] == SEARCH_CHAR )
free ( data );
0
------------------------------
19818 CVE-2016-2522/Wireshark_2.0.1_CVE_2016_2522_epan_dissectors_packet-ber.c end_offset = offset + val_length 2082

dissect_ber_constrained_bitstring(gboolean implicit_tag, asn1_ctx_t *actx, proto_tree *parent_tree, tvbuff_t *tvb, int offset, gint32 min_len, gint32 max_len, const asn_namedbit *named_bits, gint hf_id, gint ett_id, tvbuff_t **out_tvb)
gint8 ber_class ;
gboolean pc , ind ;
gint32 tag ;
guint32 len , byteno ;
int hoffset ;
proto_item * cause ;
if ( ! implicit_tag )
hoffset = offset;
offset = dissect_ber_identifier ( actx -> pinfo , parent_tree , tvb , offset , & ber_class , & pc , & tag );
offset = dissect_ber_length ( actx -> pinfo , parent_tree , tvb , offset , & len , & ind );
if ( ! implicit_tag && ( ber_class != BER_CLASS_APP ) )
if ( ( ber_class != BER_CLASS_UNI ) || ( tag != BER_UNI_TAG_BITSTRING ) )
cause = proto_tree_add_string_format_value ( parent_tree , hf_ber_error , tvb , offset , len , "bitstring_expected" , "BitString expected but class:%s(%d) %s tag:%d was unexpected" , val_to_str_const ( ber_class , ber_class_codes , "Unknown" ) , ber_class , pc ? ber_pc_codes_short . true_string : ber_pc_codes_short . false_string , tag );
if ( decode_unexpected )
proto_tree * unknown_tree = proto_item_add_subtree ( cause , ett_ber_unknown ) ;
dissect_unknown_ber ( actx -> pinfo , tvb , hoffset , unknown_tree );

dissect_unknown_ber(packet_info *pinfo, tvbuff_t *tvb, int offset, proto_tree *tree)
return try_dissect_unknown_ber ( pinfo , tvb , offset , tree , 1 ) ;
static
try_dissect_unknown_ber(packet_info *pinfo, tvbuff_t *tvb, volatile int offset, proto_tree *tree, gint nest_level)
int start_offset ;
gint8 ber_class ;
gboolean pc , ind ;
gint32 tag ;
guint32 len ;
start_offset = offset;
offset = get_ber_identifier ( tvb , offset , & ber_class , & pc , & tag );
offset = get_ber_length ( tvb , offset , & len , & ind );
if ( len > ( guint32 ) tvb_reported_length_remaining ( tvb , offset ) )
switch ( pc )
switch ( ber_class )
switch ( tag )
offset = dissect_ber_real ( FALSE , & asn1_ctx , tree , tvb , start_offset , hf_ber_unknown_REAL , NULL );

dissect_ber_real(gboolean implicit_tag, asn1_ctx_t *actx, proto_tree *tree, tvbuff_t *tvb, int offset, gint hf_id _U_, double *value)
guint32 val_length = 0 , len_remain , end_offset ;
if ( ! implicit_tag )
offset = dissect_ber_identifier ( actx -> pinfo , tree , tvb , offset , & ber_class , & pc , & tag );
offset = dissect_ber_length ( actx -> pinfo , tree , tvb , offset , & val_length , NULL );
end_offset = offset + val_length;
actx -> created_item = proto_tree_add_double ( tree , hf_id , tvb , end_offset - val_length , val_length , val );
return end_offset ;
1
------------------------------
308892 118247/CWE78_OS_Command_Injection__char_connect_socket_w32_spawnlp_17.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 104
void CWE78_OS_Command_Injection__char_connect_socket_w32_spawnlp_17_bad()
int i ;
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
for(i = 0; i < 1; i++)
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
0
------------------------------
300188 149405/aviobuf.c s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_ptr - s -> checksum_ptr ) ) ) 173
int avio_put_str16le(AVIOContext *s,const char *str)
avio_wl16 ( s , 0 );
void avio_wl16(AVIOContext *s,unsigned int val)
avio_w8 ( s , ( ( uint8_t ) val ) );
void avio_w8(AVIOContext *s,int b)
* ( s -> buf_ptr ++ ) = b;
if ( s -> buf_ptr >= s -> buf_end )
flush_buffer ( s );
static void flush_buffer(AVIOContext *s)
if ( s -> buf_ptr > s -> buffer )
if ( s -> update_checksum )
s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_ptr - s -> checksum_ptr ) ) );
s -> checksum_ptr = s -> buffer;
s -> buf_ptr = s -> buffer;
0
------------------------------
304689 83510/CWE190_Integer_Overflow__int_listen_socket_square_09.c int result = data * data ; 369
static void goodG2B2()
int data ;
data = 0;
if ( GLOBAL_CONST_TRUE )
data = 2;
if ( GLOBAL_CONST_TRUE )
int result = data * data ;
printIntLine ( result );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
0
------------------------------
307091 117036/CWE789_Uncontrolled_Mem_Alloc__malloc_char_fgets_06.c myString = ( char * ) malloc ( data * sizeof ( char ) ) 203
static void goodG2B1()
size_t data ;
data = 0;
if ( STATIC_CONST_FIVE != 5 )
data = 20;
if ( STATIC_CONST_FIVE == 5 )
char * myString ;
if ( data > strlen ( HELLO_STRING ) )
myString = ( char * ) malloc ( data * sizeof ( char ) );
strcpy ( myString , HELLO_STRING );
printLine ( myString );
void printLine (const char * line)
if ( line != NULL )
printf ( "%s\n" , line );
free ( myString );
0
------------------------------
314566 110702/CWE680_Integer_Overflow_to_Buffer_Overflow__new_fixed_07.cpp dataBytes = data * sizeof ( int ) 80
static void goodG2B1()
int data ;
data = - 1;
if ( staticFive != 5 )
data = 20;
size_t dataBytes , i ;
dataBytes = data * sizeof ( int );
intPointer = ( int * ) new char [ dataBytes ];
intPointer [ i ] = 0;
printIntLine ( intPointer [ 0 ] );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
delete [ ] intPointer
0
------------------------------
313434 90996/CWE23_Relative_Path_Traversal__wchar_t_connect_socket_w32CreateFile_41.cpp recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ) 113
void bad()
wchar_t * data ;
wchar_t dataBuffer [ FILENAME_MAX ] = BASEPATH ;
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( FILENAME_MAX - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
309168 110025/CWE666_Operation_on_Resource_in_Wrong_Phase_of_Lifetime__listen_bind_accept_09.c recvResult = recv ( acceptSocket , ( char * ) data + dataLen , ( int ) ( 100 - dataLen - 1 ) , 0 ) 93
void CWE666_Operation_on_Resource_in_Wrong_Phase_of_Lifetime__listen_bind_accept_09_bad()
if ( GLOBAL_CONST_TRUE )
char data [ 100 ] = "" ;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) data + dataLen , ( int ) ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ recvResult ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
printLine ( data );
void printLine (const char * line)
if ( line != NULL )
printf ( "%s\n" , line );
1
------------------------------
314796 96599/CWE36_Absolute_Path_Traversal__char_listen_socket_ofstream_06.cpp recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ) 108
void bad()
char * data ;
char dataBuffer [ FILENAME_MAX ] = "" ;
data = dataBuffer;
if ( STATIC_CONST_FIVE == 5 )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
outputFile . open ( ( char * ) data );
1
------------------------------
21258 CVE-2015-5307/linux_kernel_4.2.6_CVE_2015_5307_arch_x86_kvm_vmx.c u32 mask = 1 << ( seg * SEG_FIELD_NR + field ) ; 1518
static bool tr_valid(struct kvm_vcpu *vcpu)
struct kvm_segment tr ;
vmx_get_segment ( vcpu , & tr , VCPU_SREG_TR );
static void vmx_get_segment(struct kvm_vcpu
struct kvm_segment *var, int seg)
struct vcpu_vmx * vmx = to_vmx ( vcpu ) ;
if ( vmx -> rmode . vm86_active && seg != VCPU_SREG_LDTR )
var -> base = vmx_read_guest_seg_base ( vmx , seg );
static ulong vmx_read_guest_seg_base(struct vcpu_vmx *vmx, unsigned seg)
if ( ! vmx_segment_cache_test_set ( vmx , seg , SEG_FIELD_BASE ) )
static bool vmx_segment_cache_test_set(struct vcpu_vmx *vmx, unsigned
unsigned field)
u32 mask = 1 << ( seg * SEG_FIELD_NR + field ) ;
ret = vmx -> segment_cache . bitmask & mask;
vmx -> segment_cache . bitmask |= mask;
return ret ;
0
------------------------------
18099 CVE-2015-5154/Xen_4.5.0_CVE-2015-5154_ide.c data_end = s -> data_end - s -> data_ptr - size 599
static void pmac_ide_writew (void
target_phys_addr_t addr, uint32_t val)
MACIOIDEState * d = opaque ;
addr = ( addr & 0xFFF ) >> 4;
val = bswap16 ( val );
if ( addr == 0 )
ide_data_writew ( d -> ide_if , 0 , val );
static void ide_data_writew(void *opaque, uint32_t addr, uint32_t val)
IDEState * s = ( ( IDEState * ) opaque ) -> cur_drive ;
if ( ! ( s -> status & DRQ_STAT ) )
buffered_pio_write ( s , addr , 2 );
static inline
buffered_pio_write(IDEState *s, uint32_t addr, int size)
struct pio_buffer * piobuf = piobuf_by_addr ( addr ) ;
int data_end ;
if ( ! piobuf )
data_end = s -> data_end - s -> data_ptr - size;
if ( data_end <= 0 )
if ( data_end > piobuf -> buf_size )
piobuf -> data_end = data_end;
piobuf -> opaque = s;
0
------------------------------
305107 94281/CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_67a.c recvResult = recv ( acceptSocket , ( char * ) ( password + passwordLen ) , ( 100 - passwordLen - 1 ) * sizeof ( wchar_t ) , 0 ) 88
void CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_67_bad()
wchar_t * password ;
wchar_t passwordBuffer [ 100 ] = L ""
password = passwordBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t passwordLen = wcslen ( password ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( password + passwordLen ) , ( 100 - passwordLen - 1 ) * sizeof ( wchar_t ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
1
------------------------------
20505 CVE-2016-6513/wireshark_2.0.4_CVE_2016_6513_epan_dissectors_packet-wbxml.c DebugLog ( ( "STAG: level = %u, ThrowException: len = %u (short frame)\n" , * level , off - offset ) ) 7623
static
dissect_uaprof(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree)
dissect_wbxml_common ( tvb , pinfo , tree , & decode_uaprof_wap_248 );
static
dissect_wbxml_common(tvbuff_t *tvb, packet_info *pinfo, proto_tree
const wbxml_decoding *override_content_map)
proto_item * ti ;
proto_tree * wbxml_tree ;
proto_tree * wbxml_content_tree ;
proto_tree * tag_tree ;
guint8 version ;
guint32 len ;
guint32 charset = 0 ;
guint32 charset_len = 0 ;
guint32 publicid ;
guint32 publicid_index = 0 ;
guint32 publicid_len ;
guint32 str_tbl ;
guint32 str_tbl_len ;
guint32 str_tbl_len_len = 0 ;
switch ( version = tvb_get_guint8 ( tvb , 0 ) )
ti = proto_tree_add_item ( tree , proto_wbxml , tvb , 0 , - 1 , ENC_NA );
publicid = tvb_get_guintvar ( tvb , 1 , & publicid_len );
if ( ! publicid )
publicid_index = tvb_get_guintvar ( tvb , 1 + publicid_len , & len );
publicid_len += len;
offset = 1 + publicid_len;
switch ( version )
charset = tvb_get_guintvar ( tvb , offset , & charset_len );
offset += charset_len;
str_tbl = offset + str_tbl_len_len;
if ( publicid )
len = tvb_strsize ( tvb , str_tbl + publicid_index );
ti = proto_tree_add_item ( tree , proto_wbxml , tvb , 0 , - 1 , ENC_NA );
wbxml_tree = proto_item_add_subtree ( ti , ett_wbxml );
offset = 1 + publicid_len;
if ( charset )
offset += charset_len;
str_tbl_len = tvb_get_guintvar ( tvb , offset , & len );
str_tbl = offset + len;
offset += len + str_tbl_len;
wbxml_content_tree = proto_tree_add_subtree ( wbxml_tree , tvb , offset , - 1 , ett_wbxml_content , & ti , "Data representation" );
if ( disable_wbxml_token_parsing )
if ( override_content_map != NULL )
content_map = override_content_map;
content_map = get_wbxml_decoding_from_public_id ( publicid );
if ( ! content_map )
content_map = get_wbxml_decoding_from_content_type ( pinfo -> match_string , tvb , offset );
if ( content_map && skip_wbxml_token_mapping )
content_map = NULL;
tag_tree = proto_tree_add_subtree ( wbxml_content_tree , tvb , offset , - 1 , ett_wbxml_tags , NULL , "Level | State | Codepage | WBXML Token Description         | Rendering" );
len = parse_wbxml_tag_defined ( tag_tree , tvb , offset , str_tbl , & level , & codepage_stag , & codepage_attr , content_map );
static
parse_wbxml_tag_defined (proto_tree *tree, tvbuff_t *tvb, guint32
guint32 str_tbl, guint8 *level, guint8 *codepage_stag, guint8
const wbxml_decoding *map)
guint32 tvb_len = tvb_reported_length ( tvb ) ;
guint32 off = offset ;
guint32 len ;
guint32 idx ;
guint8 peek ;
guint32 tag_len ;
guint8 parsing_tag_content = FALSE ;
while ( off < tvb_len )
peek = tvb_get_guint8 ( tvb , off );
if ( ( peek & 0x3F ) < 4 )
if ( peek )
off += 2;
( * level ) --;
off ++;
off += 1 + len;
len = tvb_strsize ( tvb , off + 1 );
off += 1 + len;
len = tvb_strsize ( tvb , off + 1 );
off += 1 + len;
len = parse_wbxml_attribute_list_defined ( tree , tvb , off , str_tbl , * level , codepage_attr , map );
off += len;
idx = tvb_get_guintvar ( tvb , off + 1 , & len );
off += 1 + len;
idx = tvb_get_guintvar ( tvb , off + 1 , & len );
off += 1 + len;
off ++;
if ( tvb_get_guint8 ( tvb , 0 ) )
if ( map != NULL )
off += 1 + len;
idx = tvb_get_guintvar ( tvb , off + 1 , & len );
off += 1 + len + idx;
tag_len = 0;
if ( ( peek & 0x3F ) == 4 )
tag_new_known = 0;
tag_new_known = peek & 0x3F;
if ( peek & 0x40 )
if ( parsing_tag_content )
( * level ) ++;
len = parse_wbxml_tag_defined ( tree , tvb , off , str_tbl , level , codepage_stag , codepage_attr , map );
off += len;
if ( peek & 0x80 )
if ( tag_new_known )
off ++;
off += 1 + tag_len;
len = parse_wbxml_attribute_list_defined ( tree , tvb , off , str_tbl , * level , codepage_attr , map );
off += len;
if ( tag_new_known )
off ++;
off += 1 + tag_len;
parsing_tag_content = TRUE;
( * level ) ++;
if ( peek & 0x80 )
if ( tag_new_known )
off ++;
len = parse_wbxml_attribute_list_defined ( tree , tvb , off , str_tbl , * level , codepage_attr , map );
off += len;
off += 1 + tag_len;
len = parse_wbxml_attribute_list_defined ( tree , tvb , off , str_tbl , * level , codepage_attr , map );
off += len;
if ( off >= tvb_len )
DebugLog ( ( "STAG: level = %u, ThrowException: len = %u (short frame)\n" , * level , off - offset ) );
if ( tag_new_known )
off ++;
off += 1 + tag_len;
( * level ) --;
0
------------------------------
19439 CVE-2015-2726/Firefox_38.8.0esr_CVE_2015_2726_js_src_ctypes_CTypes.cpp const CharT * end = cp + length ; 1800

UInt64::Construct(JSContext*
unsigned
jsval* vp)
CallArgs args = CallArgsFromVp ( argc , vp ) ;
if ( args . length ( ) != 1 )
if ( ! jsvalToBigInteger ( cx , args [ 0 ] , true , & u ) )
template<class
static
jsvalToBigInteger(JSContext*
jsval
bool
IntegerType* result)
if ( val . isInt32 ( ) )
if ( val . isDouble ( ) )
if ( allowString && val . isString ( ) )
return StringToInteger ( cx , val . toString ( ) , result ) ;
template <class IntegerType, class
static
StringToInteger(JSContext* cx, CharT* cp, size_t length, IntegerType* result)
const CharT * end = cp + length ;
if ( cp == end )
if ( end - cp > 2 && cp [ 0 ] == '0' && ( cp [ 1 ] == 'x' || cp [ 1 ] == 'X' ) )
while ( cp != end )
0
------------------------------
311173 153292/config.c apr_size_t len = ( name_end - name_start ) ; 547
svn_error_t *svn_config_get_yes_no_ask(svn_config_t *cfg,const char **valuep,const char *section,const char *option,const char *default_value)
const char * tmp_value ;
svn_config_get ( cfg , & tmp_value , section , option , ( ( void * ) 0 ) );
void svn_config_get(svn_config_t *cfg,const char **valuep,const char *section,const char *option,const char *default_value)
* valuep = default_value;
if ( cfg )
cfg_section_t * sec ;
cfg_option_t * opt = find_option ( cfg , section , option , & sec ) ;
if ( opt != ( ( void * ) 0 ) )
make_string_from_option ( valuep , cfg , sec , opt , ( ( void * ) 0 ) );
static void make_string_from_option(const char **valuep,svn_config_t *cfg,cfg_section_t *section,cfg_option_t *opt,apr_pool_t *x_pool)
if ( ! opt -> expanded )
if ( opt -> value && strchr ( opt -> value , 37 ) )
apr_pool_t * tmp_pool = x_pool ? x_pool : svn_pool_create_ex ( cfg -> x_pool , ( ( void * ) 0 ) ) ;
expand_option_value ( cfg , section , opt -> value , & opt -> x_value , tmp_pool );
static void expand_option_value(svn_config_t *cfg,cfg_section_t *section,const char *opt_value,const char **opt_x_valuep,apr_pool_t *x_pool)
const char * parse_from = opt_value ;
const char * name_start ;
const char * name_end ;
while ( parse_from != ( ( void * ) 0 ) && ( * parse_from ) != '\0' && ( name_start = ( strstr ( parse_from , "%(" ) ) ) != ( ( void * ) 0 ) )
name_start += sizeof ( "%(" ) - 1;
if ( ( * name_start ) == '\0' )
name_end = ( strstr ( name_start , ")s" ) );
if ( name_end != ( ( void * ) 0 ) )
cfg_option_t * x_opt ;
apr_size_t len = ( name_end - name_start ) ;
char * name = apr_pstrmemdup ( x_pool , name_start , len ) ;
x_opt = find_option ( cfg , section -> name , name , ( ( void * ) 0 ) );
if ( x_opt != ( ( void * ) 0 ) )
make_string_from_option ( & cstring , cfg , section , x_opt , x_pool );
parse_from = name_end + ( sizeof ( ")s" ) - 1 );
parse_from = name_end + ( sizeof ( ")s" ) - 1 );
parse_from = ( ( void * ) 0 );
0
------------------------------
304247 84670/CWE190_Integer_Overflow__unsigned_int_rand_square_17.c unsigned int result = data * data ; 38
void CWE190_Integer_Overflow__unsigned_int_rand_square_17_bad()
int i , j ;
unsigned int data ;
data = 0;
for(i = 0; i < 1; i++)
data = ( unsigned int ) RAND32 ( );
for(j = 0; j < 1; j++)
unsigned int result = data * data ;
printUnsignedLine ( result );
void printUnsignedLine(unsigned unsignedNumber)
printf ( "%u\n" , unsignedNumber );
1
------------------------------
314836 96761/CWE36_Absolute_Path_Traversal__wchar_t_connect_socket_fopen_34.cpp recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ) 103
void bad()
wchar_t * data ;
wchar_t dataBuffer [ FILENAME_MAX ] = L ""
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( FILENAME_MAX - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
312527 152495/oids.c * left = len - i 1161
oid_info_t *oid_get_from_string(const gchar *oid_str,guint32 **subids_p,guint *matched,guint *left)
guint subids_len = oid_string2subid ( oid_str , subids_p ) ;
guint oid_string2subid(const char *str,guint32 **subids_p)
const char * r = str ;
guint32 * subids ;
guint32 * subids_overflow ;
guint n = check_num_oid ( str ) ;
static guint check_num_oid(const char *str)
const char * r = str ;
char c = '\0' ;
guint n = 0 ;
if ( ! r || ( * r ) == '.' || ( * r ) == '\0' )
return 0 ;
switch ( * r )
n ++;
if ( c == '.' )
return 0 ;
n ++;
return 0 ;
while ( c = * ( r ++ ) )
if ( c == '.' )
return 0 ;
return n ;
guint64 subid = 0 ;
if ( ! n )
return 0 ;
* subids_p = subids = ( ep_alloc0 ( sizeof ( guint32 ) * n ) );
subids_overflow = subids + n;
switch ( * r )
subid = 0;
subids ++;
subid *= 10;
subid += ( ( * r ) - 48 );
if ( subids >= subids_overflow || subid > 0xffffffff )
return 0 ;
return 0 ;
while ( * ( r ++ ) )
return n ;
return oid_get ( subids_len , * subids_p , matched , left ) ;
oid_info_t *oid_get(guint len,guint32 *subids,guint *matched,guint *left)
oid_info_t * curr_oid = & oid_root ;
guint i ;
if ( ! ( subids && * subids <= 2 ) )
for (i = 0; i < len; i++)
oid_info_t * next_oid = ( emem_tree_lookup32 ( ( curr_oid -> children ) , subids [ i ] ) ) ;
if ( next_oid )
curr_oid = next_oid;
* left = len - i;
0
------------------------------
307724 113078/CWE761_Free_Pointer_Not_at_Start_of_Buffer__wchar_t_listen_socket_53a.c recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 ) 98
void CWE761_Free_Pointer_Not_at_Start_of_Buffer__wchar_t_listen_socket_53_bad()
wchar_t * data ;
data = ( wchar_t * ) malloc ( 100 * sizeof ( wchar_t ) );
data [ 0 ] = L '\0'
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
298579 102877/CWE427_Uncontrolled_Search_Path_Element__char_connect_socket_32.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 250 - dataLen - 1 ) , 0 ) 96
void CWE427_Uncontrolled_Search_Path_Element__char_connect_socket_32_bad()
char * data ;
char * * dataPtr1 = & data ;
char dataBuffer [ 250 ] = "PATH=" ;
data = dataBuffer;
char * data = * dataPtr1 ;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 250 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
* dataPtr1 = data;
PUTENV ( data );
1
------------------------------
304341 84247/CWE190_Integer_Overflow__short_rand_square_42.c short result = data * data ; 38
void CWE190_Integer_Overflow__short_rand_square_42_bad()
short data ;
data = 0;
data = badSource ( data );
static short badSource(short data)
data = ( short ) RAND32 ( );
return data ;
short result = data * data ;
printIntLine ( result );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
1
------------------------------
18388 CVE-2015-2710/Firefox_37.0b7_CVE_2015_2710_layout_svg_SVGTextFrame.cpp gfxFloat midx = mPositions [ i ] . mPosition . x + sign * halfAdvance + offset ; 4930

SVGTextFrame::DoTextPathLayout()
nsPresContext * context = PresContext ( ) ;
CharIterator it ( this , CharIterator :: eClusterAndLigatureGroupStart ) ;
while ( ! it . AtEnd ( ) )
nsIFrame * textPathFrame = it . TextPathFrame ( ) ;
if ( ! textPathFrame )
RefPtr < Path > path = GetTextPath ( textPathFrame ) ;
if ( ! path )
nsIContent * textPath = textPathFrame -> GetContent ( ) ;
gfxFloat offset = GetStartOffset ( textPathFrame ) ;
Float pathLength = path -> ComputeLength ( ) ;
uint32_t i = it . TextElementCharIndex ( ) ;
gfxFloat halfAdvance = it . GetGlyphAdvance ( context ) / mFontSizeScaleFactor / 2.0 ;
gfxFloat sign = it . TextRun ( ) -> IsRightToLeft ( ) ? - 1.0 : 1.0 ;
bool IsRightToLeft() const
return GetTextRun ( ) -> IsRightToLeft ( ) ;
bool IsRightToLeft() const
return GetTextRun ( ) -> IsRightToLeft ( ) ;
gfxTextRun* GetTextRun() const
return mFrame -> GetTextRun ( nsTextFrame :: eInflated ) ;
gfxFloat midx = mPositions [ i ] . mPosition . x + sign * halfAdvance + offset ;
mPositions [ i ] . mHidden = midx < 0 || midx > pathLength;
Point tangent ;
Point pt = path -> ComputePointAtLength ( Float ( midx ) , & tangent ) ;
Float rotation = atan2f ( tangent . y , tangent . x ) ;
Point normal ( - tangent . y , tangent . x ) ;
Point offsetFromPath = normal * mPositions [ i ] . mPosition . y ;
pt += offsetFromPath;
Point direction = tangent * sign ;
mPositions [ i ] . mPosition = ThebesPoint ( pt ) - ThebesPoint ( direction ) * halfAdvance;
mPositions [ i ] . mAngle += rotation;
for (uint32_t j = i +
j < mPositions.Length() &&
j++)
gfxPoint partialAdvance = ThebesPoint ( direction ) * it . GetGlyphPartialAdvance ( j - i , context ) / mFontSizeScaleFactor ;
mPositions [ j ] . mPosition = mPositions [ i ] . mPosition + partialAdvance;
mPositions [ j ] . mAngle = mPositions [ i ] . mAngle;
mPositions [ j ] . mHidden = mPositions [ i ] . mHidden;
while ( it . TextPathFrame ( ) && it . TextPathFrame ( ) -> GetContent ( ) == textPath )
0
------------------------------
302958 79150/CWE134_Uncontrolled_Format_String__char_connect_socket_printf_05.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 96
void CWE134_Uncontrolled_Format_String__char_connect_socket_printf_05_bad()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
if ( staticTrue )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
printf ( data );
1
------------------------------
302729 82497/CWE190_Integer_Overflow__char_rand_square_04.c char result = data * data ; 98
static void goodB2G2()
char data ;
data = ' ';
if ( STATIC_CONST_TRUE )
data = ( char ) RAND32 ( );
if ( STATIC_CONST_TRUE )
if ( abs ( ( long ) data ) <= ( long ) sqrt ( ( double ) CHAR_MAX ) )
char result = data * data ;
printHexCharLine ( result );
void printHexCharLine (char charHex)
printf ( "%02x\n" , charHex );
0
------------------------------
298668 95366/CWE369_Divide_by_Zero__int_rand_divide_31.c printIntLine ( 100 / data ) 33
void CWE369_Divide_by_Zero__int_rand_divide_31_bad()
int data ;
data = - 1;
data = RAND32 ( );
int dataCopy = data ;
int data = dataCopy ;
printIntLine ( 100 / data );
1
------------------------------
312465 152246/cmdutils.c p = opt + strlen ( opt ) 530
int split_commandline(OptionParseContext *octx,int argc,char *argv[],const OptionDef *options,const OptionGroupDef *groups,int nb_groups)
int optindex = 1 ;
int dashdash = - 2 ;
while ( optindex < argc )
const char * opt = argv [ optindex ++ ] ;
const char * arg ;
const OptionDef * po ;
int ret ;
if ( opt [ 0 ] == '-' && opt [ 1 ] == '-' && ! opt [ 2 ] )
dashdash = optindex;
if ( opt [ 0 ] != '-' || ! opt [ 1 ] || dashdash + 1 == optindex )
opt ++;
while ( 0 )
if ( ( ret = match_group_separator ( groups , nb_groups , opt ) ) >= 0 )
static int match_group_separator(const OptionGroupDef *groups,int nb_groups,const char *opt)
int i ;
for (i = 0; i < nb_groups; i++)
const OptionGroupDef * p = & groups [ i ] ;
if ( p -> sep && ! strcmp ( p -> sep , opt ) )
return i ;
return - 1 ;
arg = argv [ optindex ++ ];
if ( ! arg )
while ( 0 )
po = find_option ( options , opt );
static const OptionDef *find_option(const OptionDef *po,const char *name)
const char * p = ( strchr ( name , ':' ) ) ;
int len = ( p ? ( p - name ) : strlen ( name ) ) ;
while ( po -> name != ( ( void * ) 0 ) )
if ( ! strncmp ( name , po -> name , len ) && strlen ( po -> name ) == len )
po ++;
return po ;
if ( po -> name )
if ( po -> flags & 0x0800 )
arg = argv [ optindex ++ ];
if ( po -> flags & 0x0001 )
arg = argv [ optindex ++ ];
if ( ! arg )
while ( 0 )
if ( argv [ optindex ] )
ret = opt_default ( ( ( void * ) 0 ) , opt , argv [ optindex ] );
if ( ret >= 0 )
optindex ++;
if ( ret != - ( ( int ) ( ( 0xF8 | 'O' << 8 | 'P' << 16 ) | ( ( unsigned int ) 'T' ) << 24 ) ) )
if ( opt [ 0 ] == 'n' && opt [ 1 ] == 'o' && ( po = find_option ( options , opt + 2 ) ) && po -> name && po -> flags & 0x00002 )
static const OptionDef *find_option(const OptionDef *po,const char *name)
const char * p = ( strchr ( name , ':' ) ) ;
int len = ( p ? ( p - name ) : strlen ( name ) ) ;
while ( po -> name != ( ( void * ) 0 ) )
if ( ! strncmp ( name , po -> name , len ) && strlen ( po -> name ) == len )
po ++;
return po ;
int opt_default(void *optctx,const char *opt,const char *arg)
const char * p ;
if ( ! ( p = ( strchr ( opt , ':' ) ) ) )
p = opt + strlen ( opt );
av_strlcpy ( opt_stripped , opt , ( sizeof ( opt_stripped ) > ( p - opt + 1 ) ? ( p - opt + 1 ) : sizeof ( opt_stripped ) ) );
0
------------------------------
313866 89657/CWE23_Relative_Path_Traversal__char_connect_socket_ifstream_51a.cpp recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ) 99
void bad()
char * data ;
char dataBuffer [ FILENAME_MAX ] = BASEPATH ;
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
badSink ( data );
void badSink(char * data)
inputFile . open ( ( char * ) data );
0
------------------------------
312580 149429/dirent_uri.c apr_size_t seglen = ( ptr - seg ) ; 1500
svn_error_t *svn_uri_condense_targets(const char **pcommon,apr_array_header_t **pcondensed_targets,const apr_array_header_t *targets,svn_boolean_t remove_redundancies,apr_pool_t *result_pool,apr_pool_t *scratch_pool)
int i ;
if ( targets -> nelts <= 0 )
* pcommon = svn_uri_canonicalize ( ( ( const char * * ) ( targets -> elts ) ) [ 0 ] , scratch_pool );
if ( targets -> nelts == 1 )
for (i = 1; i < targets -> nelts; ++i)
const char * uri = svn_uri_canonicalize ( ( ( const char * * ) ( targets -> elts ) ) [ i ] , scratch_pool ) ;
if ( ( * ( * pcommon ) ) != '\0' )
* pcommon = ( svn_uri_get_longest_ancestor ( * pcommon , uri , scratch_pool ) );
char *svn_uri_get_longest_ancestor(const char *uri1,const char *uri2,apr_pool_t *pool)
svn_uri_is_canonical ( uri2 , ( ( void * ) 0 ) ) ? ( ( void ) 0 ) : __assert_fail ( "svn_uri_is_canonical(uri2, ((void *)0))" , "dirent_uri.c" , 1374 , __PRETTY_FUNCTION__ );
svn_boolean_t svn_uri_is_canonical(const char *uri,apr_pool_t *scratch_pool)
const char * ptr = uri ;
if ( ( * uri ) == '\0' )
if ( ! svn_path_is_url ( uri ) )
while ( * ptr && ( * ptr ) != 47 && ( * ptr ) != ':' )
ptr ++;
if ( ! ( ( * ptr ) == ':' && ( * ( ptr + 1 ) ) == 47 && ( * ( ptr + 2 ) ) == 47 ) )
ptr = uri;
while ( ( * ptr ) != ':' )
if ( ( * ptr ) >= 65 && ( * ptr ) <= 'Z' )
ptr ++;
ptr += 3;
if ( ! ( * ptr ) )
seg = ptr;
while ( * ptr && ( * ptr ) != 47 && ( * ptr ) != 64 )
ptr ++;
if ( ( * ptr ) == 64 )
seg = ptr + 1;
ptr = seg;
if ( ( * ptr ) == '[' )
ptr ++;
while ( ( * ptr ) == ':' || ( * ptr ) >= 48 && ( * ptr ) <= '9' || ( * ptr ) >= 'a' && ( * ptr ) <= 'f' )
ptr ++;
if ( ( * ptr ) != ']' )
ptr ++;
while ( * ptr && ( * ptr ) != 47 && ( * ptr ) != ':' )
if ( ( * ptr ) >= 65 && ( * ptr ) <= 'Z' )
ptr ++;
if ( ( * ptr ) == ':' )
apr_int64_t port = 0 ;
ptr ++;
schema_data = ptr;
while ( ( * ptr ) >= 48 && ( * ptr ) <= '9' )
port = 10 * port + ( ( * ptr ) - 48 );
ptr ++;
if ( ptr == schema_data )
if ( * ptr && ( * ptr ) != 47 )
if ( port == 80 && strncmp ( uri , "http:" , 5 ) == 0 )
if ( port == 443 && strncmp ( uri , "https:" , 6 ) == 0 )
if ( port == 3690 && strncmp ( uri , "svn:" , 4 ) == 0 )
while ( 1 )
apr_size_t seglen = ( ptr - seg ) ;
if ( seglen == 1 && ( * seg ) == 46 )
if ( ( * ptr ) == 47 && ( * ( ptr + 1 ) ) == 47 )
if ( ! ( * ptr ) && ( * ( ptr - 1 ) ) == 47 && ptr - 1 != uri )
if ( ! ( * ptr ) )
if ( ( * ptr ) == 47 )
ptr ++;
seg = ptr;
while ( * ptr && ( * ptr ) != 47 )
ptr ++;
0
------------------------------
303982 83215/CWE190_Integer_Overflow__int_fgets_square_02.c int result = data * data ; 93
static void goodB2G1()
int data ;
data = 0;
if ( 1 )
char inputBuffer [ CHAR_ARRAY_SIZE ] = "" ;
if ( fgets ( inputBuffer , CHAR_ARRAY_SIZE , stdin ) != NULL )
data = atoi ( inputBuffer );
if ( 0 )
if ( abs ( ( long ) data ) <= ( long ) sqrt ( ( double ) INT_MAX ) )
int result = data * data ;
printIntLine ( result );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
0
------------------------------
305344 95459/CWE369_Divide_by_Zero__int_zero_divide_18.c printIntLine ( 100 / data ) 56
static void goodB2G()
int data ;
data = - 1;
data = 0;
if ( data != 0 )
printIntLine ( 100 / data );
0
------------------------------
311631 149958/aviobuf.c stonesoup_arr [ stonesoup_i ] = dataStruct -> qsize - stonesoup_i 192
void *toPound(void *data)
int stonesoup_i ;
struct stonesoup_data * dataStruct = ( struct stonesoup_data * ) data ;
stonesoup_arr = malloc ( sizeof ( int ) * dataStruct -> qsize );
for (stonesoup_i = 0; stonesoup_i < dataStruct->qsize; stonesoup_i++)
stonesoup_arr [ stonesoup_i ] = dataStruct -> qsize - stonesoup_i;
qsort ( stonesoup_arr , dataStruct -> qsize , sizeof ( int ) , & stonesoup_comp );
free ( stonesoup_arr );
for (stonesoup_i = 0; stonesoup_i < (int)strlen(dataStruct->data) -
stonesoup_i += dataStruct->inc_amount)
dataStruct -> data [ stonesoup_i ] = '#';
1
------------------------------
302129 151543/tile-manager.c ntiles = tm -> ntile_rows * tm -> ntile_cols 305
void tile_manager_write_pixel_data(TileManager *tm,gint x1,gint y1,gint x2,gint y2,const guchar *buffer,guint stride)
guint x ;
guint y ;
for (y = y1; y <= y2; y += 64 - y % 64)
for (x = x1; x <= x2; x += 64 - x % 64)
Tile * tile = tile_manager_get_tile ( tm , x , y , ! 0 , ! 0 ) ;
Tile *tile_manager_get_tile(TileManager *tm,gint xpixel,gint ypixel,gboolean wantread,gboolean wantwrite)
if ( tm != ( ( void * ) 0 ) )
while ( 0 )
return tile_manager_get ( tm , tile_manager_get_tile_num ( tm , xpixel , ypixel ) , wantread , wantwrite ) ;
Tile *tile_manager_get(TileManager *tm,gint tile_num,gboolean wantread,gboolean wantwrite)
gint ntiles ;
if ( tm != ( ( void * ) 0 ) )
while ( 0 )
ntiles = tm -> ntile_rows * tm -> ntile_cols;
if ( tile_num < 0 || tile_num >= ntiles )
0
------------------------------
313690 95713/CWE36_Absolute_Path_Traversal__char_connect_socket_open_53a.cpp recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ) 101
void bad()
char * data ;
char dataBuffer [ FILENAME_MAX ] = "" ;
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
badSink_b ( data );
void badSink_b(char * data)
badSink_c ( data );
void badSink_c(char * data)
badSink_d ( data );
void badSink_d(char * data)
fileDesc = OPEN ( data , O_RDWR | O_CREAT , S_IREAD | S_IWRITE );
if ( fileDesc != - 1 )
CLOSE ( fileDesc );
0
------------------------------
300137 150141/stream.c filepath = ( char * ) malloc ( size_filepath * sizeof ( char ) ) 122
void stonesoup_setup_printf_context()
ss_tc_root = getenv ( "SS_TC_ROOT" );
if ( ss_tc_root != NULL )
size_dirpath = strlen ( ss_tc_root ) + strlen ( "testData" ) + 2;
dirpath = ( char * ) malloc ( size_dirpath * sizeof ( char ) );
if ( dirpath != NULL )
sprintf ( dirpath , "%s/%s" , ss_tc_root , "testData" );
retval = 0;
if ( stat ( dirpath , & st ) == - 1 )
retval = mkdir ( dirpath , 0700 );
if ( retval == 0 )
size_filepath = strlen ( dirpath ) + strlen ( "logfile.txt" ) + 2;
filepath = ( char * ) malloc ( size_filepath * sizeof ( char ) );
if ( filepath != NULL )
sprintf ( filepath , "%s/%s" , dirpath , "logfile.txt" );
stonesoup_printf_context = fopen ( filepath , "w" );
free ( filepath );
if ( stonesoup_printf_context == NULL )
0
------------------------------
305548 62253/CWE114_Process_Control__w32_wchar_t_connect_socket_42.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 ) 83
void CWE114_Process_Control__w32_wchar_t_connect_socket_42_bad()
wchar_t * data ;
wchar_t dataBuffer [ 100 ] = L ""
data = dataBuffer;
data = badSource ( data );
static wchar_t * badSource(wchar_t * data)
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
299041 62245/CWE114_Process_Control__w32_wchar_t_connect_socket_18.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 ) 88
void CWE114_Process_Control__w32_wchar_t_connect_socket_18_bad()
wchar_t * data ;
wchar_t dataBuffer [ 100 ] = L ""
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
305208 94176/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_listen_socket_52a.c recvResult = recv ( acceptSocket , ( char * ) ( password + passwordLen ) , ( 100 - passwordLen - 1 ) * sizeof ( char ) , 0 ) 184
static void goodB2G()
char * password ;
char passwordBuffer [ 100 ] = "" ;
password = passwordBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t passwordLen = strlen ( password ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( password + passwordLen ) , ( 100 - passwordLen - 1 ) * sizeof ( char ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
password [ passwordLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( password , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( password , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
CWE319_Cleartext_Tx_Sensitive_Info__w32_char_listen_socket_52b_goodB2GSink ( password );
void CWE319_Cleartext_Tx_Sensitive_Info__w32_char_listen_socket_52b_goodB2GSink(char * password)
CWE319_Cleartext_Tx_Sensitive_Info__w32_char_listen_socket_52c_goodB2GSink ( password );
void CWE319_Cleartext_Tx_Sensitive_Info__w32_char_listen_socket_52c_goodB2GSink(char * password)
payloadBytes = decodeHexChars ( payload , sizeof ( payload ) , password );
size_t decodeHexChars(unsigned char * bytes, size_t numBytes, const char * hex)
while ( numWritten < numBytes && isxdigit ( hex [ 2 * numWritten ] ) && isxdigit ( hex [ 2 * numWritten + 1 ] ) )
sscanf ( & hex [ 2 * numWritten ] , "%02x" , & byte );
bytes [ numWritten ] = ( unsigned char ) byte;
return numWritten ;
SecureZeroMemory ( password , 100 * sizeof ( char ) );
memcpy ( password , payload , payloadBytes );
password [ payloadBytes / sizeof ( char ) ] = '\0';
if ( LogonUserA ( username , domain , password , LOGON32_LOGON_NETWORK , LOGON32_PROVIDER_DEFAULT , & pHandle ) != 0 )
0
------------------------------
308581 109133/CWE606_Unchecked_Loop_Condition__char_listen_socket_12.c recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 238
static void goodB2G()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
if ( globalReturnsTrueOrFalse ( ) )
int globalReturnsTrueOrFalse()
return ( rand ( ) % 2 ) ;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
0
------------------------------
300879 199325/unused_var.c unused_var_007_uni_001_gbl . s3 . a = unused_var_007_uni_001_gbl . s1 . a + unused_var_007_uni_001_gbl . s1 . b 151
void unused_var_007 ()
unused_var_007_uni_001_gbl . s1 . a = 1;
unused_var_007_uni_001_gbl . s1 . b = 2;
unused_var_007_uni_001_gbl . s3 . a = unused_var_007_uni_001_gbl . s1 . a + unused_var_007_uni_001_gbl . s1 . b;
1
------------------------------
304287 80495/CWE134_Uncontrolled_Format_String__char_listen_socket_w32_vsnprintf_06.c recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 117
void CWE134_Uncontrolled_Format_String__char_listen_socket_w32_vsnprintf_06_bad()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
if ( STATIC_CONST_FIVE == 5 )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
badVaSinkB ( data , data );
static void badVaSinkB(char * data, ...)
va_start ( args , data );
vsnprintf ( dest , 100 - 1 , data , args );
printLine ( dest );
void printLine (const char * line)
if ( line != NULL )
printf ( "%s\n" , line );
1
------------------------------
301960 149942/aviobuf.c s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_ptr - s -> checksum_ptr ) ) ) 244
int avio_close_dyn_buf(AVIOContext *s,uint8_t **pbuffer)
avio_flush ( s );
void avio_flush(AVIOContext *s)
flush_buffer ( s );
static void flush_buffer(AVIOContext *s)
if ( s -> buf_ptr > s -> buffer )
if ( s -> update_checksum )
s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_ptr - s -> checksum_ptr ) ) );
s -> checksum_ptr = s -> buffer;
s -> buf_ptr = s -> buffer;
0
------------------------------
20205 CVE-2016-6508/wireshark_2.0.4_CVE_2016_6508_epan_dissectors_packet-rlc.c ret = a - b 512
static
rlc_am_reassemble(tvbuff_t *tvb, guint8 offs, packet_info
proto_tree *tree, proto_tree
enum rlc_channel_type channel, guint16 seq, gboolean poll_set, struct rlc_li
guint16 num_li, gboolean final, gboolean li_is_on_2_bytes)
guint8 i ;
for (i = 0; i < num_li; i++)
if ( ( ! li_is_on_2_bytes && ( li [ i ] . li == 0x7e ) ) || ( li [ i ] . li == 0x7ffe ) )
if ( ( ! li_is_on_2_bytes && ( li [ i ] . li == 0x7f ) ) || ( li [ i ] . li == 0x7fff ) )
offs += tvb_captured_length_remaining ( tvb , offs );
if ( global_rlc_perform_reassemby )
add_fragment ( RLC_AM , tvb , pinfo , li [ i ] . tree , offs , seq , i , li [ i ] . len , TRUE );
offs += li [ i ] . len;
static struct rlc_frag
add_fragment(enum rlc_mode mode, tvbuff_t *tvb, packet_info
proto_tree *tree, guint16 offset, guint16 seq, guint16
guint16 len, gboolean final)
struct rlc_channel ch_lookup ;
int snmod ;
if ( rlc_channel_assign ( & ch_lookup , mode , pinfo ) == - 1 )
snmod = getChannelSNModulus ( & ch_lookup );
if ( g_hash_table_lookup_extended ( reassembled_table , & frag_lookup , & orig_key , & value ) )
frags = get_frags ( pinfo , & ch_lookup );
endlist = get_endlist ( pinfo , & ch_lookup );
if ( pinfo -> fd -> flags . visited )
if ( tree && len > 0 )
if ( endlist -> list && endlist -> list -> next )
gint16 start = ( GPOINTER_TO_INT ( endlist -> list -> data ) + 1 ) % snmod ;
gint16 end = GPOINTER_TO_INT ( endlist -> list -> next -> data ) ;
gint16 missing = start ;
gboolean wecanreasmmore = TRUE ;
for (; moduloCompare(missing,end,snmod ) <= 0; missing = (missing+1)%snmod)
if ( frags [ missing ] == NULL )
wecanreasmmore = FALSE;
if ( wecanreasmmore )
reassemble_sequence ( frags , endlist , & ch_lookup , start , end );
static
reassemble_sequence(struct rlc_frag ** frags, struct rlc_seqlist *
struct rlc_channel * ch_lookup, guint16 start, guint16 end)
guint16 snmod = getChannelSNModulus ( ch_lookup ) ;
for (; moduloCompare(start,end,snmod ) <= 0; start = (start+1)%snmod)
static int moduloCompare(guint16 a, guint16 b, guint16 modulus)
int ret ;
a = a % modulus;
b = b % modulus;
if ( a <= b )
ret = a - b;
if ( ret == ( 1 - modulus ) )
return ret ;
0
------------------------------
308469 120375/CWE78_OS_Command_Injection__wchar_t_connect_socket_execl_54a.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 ) 109
void CWE78_OS_Command_Injection__wchar_t_connect_socket_execl_54_bad()
wchar_t * data ;
wchar_t dataBuffer [ 100 ] = L ""
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
19825 CVE-2016-2522/Wireshark_2.0.1_CVE_2016_2522_epan_dissectors_packet-ber.c end_offset = offset + lenx - 2 2178

dissect_ber_sequence(gboolean implicit_tag, asn1_ctx_t *actx, proto_tree *parent_tree, tvbuff_t *tvb, int offset, const ber_sequence_t *seq, gint hf_id, gint ett_id)
gboolean pcx , ind = 0 , ind_field , imp_tag = FALSE ;
guint32 lenx ;
proto_tree * tree = parent_tree ;
int hoffset ;
hoffset = offset;
if ( ! implicit_tag )
offset = get_ber_identifier ( tvb , offset , NULL , NULL , NULL );

get_ber_identifier(tvbuff_t *tvb, int offset, gint8 *ber_class, gboolean *pc, gint32 *tag)
guint8 id , t ;
gint32 tmp_tag ;
id = tvb_get_guint8 ( tvb , offset );
offset += 1;
tmp_tag = id & 0x1F;
if ( tmp_tag == 0x1F )
while ( tvb_reported_length_remaining ( tvb , offset ) > 0 )
t = tvb_get_guint8 ( tvb , offset );
offset += 1;
if ( ! ( t & 0x80 ) )
return offset ;
offset = get_ber_length ( tvb , offset , & lenx , NULL );

get_ber_length(tvbuff_t *tvb, int offset, guint32 *length, gboolean *ind)
return try_get_ber_length ( tvb , offset , length , ind , 1 ) ;
static
try_get_ber_length(tvbuff_t *tvb, int offset, guint32 *length, gboolean *ind, gint nest_level)
guint8 oct , len ;
guint32 indef_len ;
int tmp_offset , s_offset ;
oct = tvb_get_guint8 ( tvb , offset );
offset += 1;
if ( ! ( oct & 0x80 ) )
len = oct & 0x7F;
if ( len )
while ( len -- )
offset ++;
tmp_offset = offset;
while ( tvb_get_guint8 ( tvb , offset ) || tvb_get_guint8 ( tvb , offset + 1 ) )
offset = get_ber_identifier ( tvb , offset , & tclass , & tpc , & ttag );

get_ber_identifier(tvbuff_t *tvb, int offset, gint8 *ber_class, gboolean *pc, gint32 *tag)
guint8 id , t ;
gint32 tmp_tag ;
id = tvb_get_guint8 ( tvb , offset );
offset += 1;
tmp_tag = id & 0x1F;
if ( tmp_tag == 0x1F )
while ( tvb_reported_length_remaining ( tvb , offset ) > 0 )
t = tvb_get_guint8 ( tvb , offset );
offset += 1;
if ( ! ( t & 0x80 ) )
return offset ;
offset = try_get_ber_length ( tvb , offset , & indef_len , NULL , nest_level + 1 );
static
try_get_ber_length(tvbuff_t *tvb, int offset, guint32 *length, gboolean *ind, gint nest_level)
guint8 oct , len ;
guint32 indef_len ;
int tmp_offset , s_offset ;
oct = tvb_get_guint8 ( tvb , offset );
offset += 1;
if ( ! ( oct & 0x80 ) )
len = oct & 0x7F;
if ( len )
while ( len -- )
offset ++;
tmp_offset = offset;
while ( tvb_get_guint8 ( tvb , offset ) || tvb_get_guint8 ( tvb , offset + 1 ) )
offset = get_ber_identifier ( tvb , offset , & tclass , & tpc , & ttag );
offset = try_get_ber_length ( tvb , offset , & indef_len , NULL , nest_level + 1 );
offset += indef_len;
offset = tmp_offset;
return offset ;
offset += indef_len;
offset = tmp_offset;
return offset ;
lenx = tvb_reported_length_remaining ( tvb , offset );
if ( hf_id >= 0 )
if ( parent_tree )
item = proto_tree_add_item ( parent_tree , hf_id , tvb , hoffset , lenx + offset - hoffset , ENC_BIG_ENDIAN );
tree = proto_item_add_subtree ( item , ett_id );
offset = hoffset;
if ( ! implicit_tag )
offset = dissect_ber_identifier ( actx -> pinfo , tree , tvb , offset , & classx , & pcx , & tagx );
offset = dissect_ber_length ( actx -> pinfo , tree , tvb , offset , & lenx , & ind );
if ( ind )
end_offset = offset + lenx - 2;
return end_offset ;
if ( offset == end_offset )
while ( offset < end_offset )
return end_offset ;
if ( offset != end_offset )
cause = proto_tree_add_string_format_value ( tree , hf_ber_error , tvb , offset - 2 , 2 , "illegal_length" , "Sequence ate %d too many bytes" , offset - end_offset );
expert_add_info_format ( actx -> pinfo , cause , & ei_ber_error_length , "BER Error: too many bytes in Sequence" );
end_offset += 2;
proto_tree_add_item ( tree , hf_ber_seq_eoc , tvb , end_offset - 2 , 2 , ENC_NA );
return end_offset ;
1
------------------------------
312282 151940/cmdutils.c buf -> data [ i ] = buf -> base [ i ] + ( ( buf -> linesize [ i ] * edge >> v_shift ) + ( pixel_size * edge >> h_shift ) + 32 - 1 & ~ ( 32 - 1 ) ) 2007
int codec_get_buffer(AVCodecContext *s,AVFrame *frame)
FrameBuffer * * pool = ( s -> opaque ) ;
FrameBuffer * buf ;
int ret ;
if ( av_image_check_size ( ( s -> width ) , ( s -> height ) , 0 , s ) || ( s -> pix_fmt ) < 0 )
if ( ! ( * pool ) && ( ret = alloc_buffer ( pool , s , pool ) ) < 0 )
buf = * pool;
* pool = buf -> next;
buf -> next = ( ( void * ) 0 );
if ( buf -> w != s -> width || buf -> h != s -> height || ( buf -> pix_fmt ) != ( s -> pix_fmt ) )
if ( ( ret = alloc_buffer ( pool , s , & buf ) ) < 0 )
static int alloc_buffer(FrameBuffer **pool,AVCodecContext *s,FrameBuffer **pbuf)
const AVPixFmtDescriptor * desc = av_pix_fmt_desc_get ( s -> pix_fmt ) ;
FrameBuffer * buf ;
int i ;
int ret ;
int pixel_size ;
int h_chroma_shift ;
int v_chroma_shift ;
int edge = 32 ;
int w = s -> width ;
int h = s -> height ;
if ( ! desc )
pixel_size = desc -> comp [ 0 ] . step_minus1 + 1;
buf = ( av_mallocz ( sizeof ( ( * buf ) ) ) );
if ( ! buf )
if ( ! ( s -> flags & 0x4000 ) )
w += 2 * edge;
h += 2 * edge;
if ( ( ret = av_image_alloc ( buf -> base , buf -> linesize , w , h , s -> pix_fmt , 32 ) ) < 0 )
for (i = 0; i < sizeof(buf -> data) / sizeof(buf -> data[0]); i++)
const int h_shift = i == 0 ? 0 : h_chroma_shift ;
const int v_shift = i == 0 ? 0 : v_chroma_shift ;
if ( s -> flags & 0x4000 || ! buf -> linesize [ i ] || ! buf -> base [ i ] )
buf -> data [ i ] = buf -> base [ i ];
buf -> data [ i ] = buf -> base [ i ] + ( ( buf -> linesize [ i ] * edge >> v_shift ) + ( pixel_size * edge >> h_shift ) + 32 - 1 & ~ ( 32 - 1 ) );
buf -> w = s -> width;
buf -> h = s -> height;
buf -> pix_fmt = s -> pix_fmt;
buf -> pool = pool;
* pbuf = buf;
0
------------------------------
302339 80652/CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_snprintf_21.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 ) 304
static void goodB2G2()
wchar_t * data ;
wchar_t dataBuffer [ 100 ] = L ""
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
303028 84118/CWE190_Integer_Overflow__short_max_square_68b.c short result = data * data ; 60
void CWE190_Integer_Overflow__short_max_square_68b_goodB2GSink()
short data = CWE190_Integer_Overflow__short_max_square_68_goodB2GData ;
if ( abs ( ( long ) data ) <= ( long ) sqrt ( ( double ) SHRT_MAX ) )
short result = data * data ;
printIntLine ( result );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
0
------------------------------
310969 151426/utf.c invalid = ( data + len - last ) 664
svn_error_t *svn_utf_stringbuf_to_utf8(svn_stringbuf_t **dest,const svn_stringbuf_t *src,apr_pool_t *pool)
xlate_handle_node_t * node ;
svn_error_t * err ;
svn_error_t * svn_err__temp = get_ntou_xlate_handle_node ( & node , pool ) ;
static svn_error_t *get_ntou_xlate_handle_node(xlate_handle_node_t **ret,apr_pool_t *pool)
return get_xlate_handle_node ( ret , SVN_APR_UTF8_CHARSET , ( assume_native_charset_is_utf8 ? SVN_APR_UTF8_CHARSET : ( ( const char * ) 1 ) ) , SVN_UTF_NTOU_XLATE_HANDLE , pool ) ;
if ( svn_err__temp )
while ( 0 )
if ( node -> handle )
err = convert_to_stringbuf ( node , ( src -> data ) , src -> len , dest , pool );
static svn_error_t *convert_to_stringbuf(xlate_handle_node_t *node,const char *src_data,apr_size_t src_length,svn_stringbuf_t **dest,apr_pool_t *pool)
if ( apr_err )
const char * errstr ;
svn_error_t * err ;
if ( node -> frompage == ( ( const char * ) 1 ) )
errstr = ( apr_psprintf ( pool , ( dgettext ( "subversion" , "Can't convert string from native encoding to '%s':" ) ) , node -> topage ) );
if ( node -> topage == ( ( const char * ) 1 ) )
errstr = ( apr_psprintf ( pool , ( dgettext ( "subversion" , "Can't convert string from '%s' to native encoding:" ) ) , node -> frompage ) );
errstr = ( apr_psprintf ( pool , ( dgettext ( "subversion" , "Can't convert string from '%s' to '%s':" ) ) , node -> frompage , node -> topage ) );
err = svn_error_create ( apr_err , ( ( void * ) 0 ) , fuzzy_escape ( src_data , src_length , pool ) );
return svn_error_create ( apr_err , err , errstr ) ;
return 0 ;
if ( ! err )
err = check_utf8 ( ( ( * dest ) -> data ) , ( * dest ) -> len , pool );
static svn_error_t *check_utf8(const char *data,apr_size_t len,apr_pool_t *pool)
if ( ! svn_utf__is_valid ( data , len ) )
return invalid_utf8 ( data , len , pool ) ;
static svn_error_t *invalid_utf8(const char *data,apr_size_t len,apr_pool_t *pool)
const char * last = svn_utf__last_valid ( data , len ) ;
size_t invalid ;
invalid = ( data + len - last );
if ( invalid > 4 )
for (i = 0; i < invalid; ++i)
0
------------------------------
301913 151540/utils.c dirpath = ( char * ) malloc ( size_dirpath * sizeof ( char ) ) 73
void stonesoup_setup_printf_context()
ss_tc_root = getenv ( "SS_TC_ROOT" );
if ( ss_tc_root != NULL )
size_dirpath = strlen ( ss_tc_root ) + strlen ( "testData" ) + 2;
dirpath = ( char * ) malloc ( size_dirpath * sizeof ( char ) );
if ( dirpath != NULL )
sprintf ( dirpath , "%s/%s" , ss_tc_root , "testData" );
if ( stat ( dirpath , & st ) == - 1 )
retval = mkdir ( dirpath , 0700 );
if ( retval == 0 )
size_filepath = strlen ( dirpath ) + strlen ( "logfile.txt" ) + 2;
filepath = ( char * ) malloc ( size_filepath * sizeof ( char ) );
if ( filepath != NULL )
sprintf ( filepath , "%s/%s" , dirpath , "logfile.txt" );
stonesoup_printf_context = fopen ( filepath , "w" );
free ( filepath );
free ( dirpath );
if ( stonesoup_printf_context == NULL )
0
------------------------------
307972 116993/CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_11.c myString = ( char * ) malloc ( data * sizeof ( char ) ) 123
void CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_11_bad()
size_t data ;
data = 0;
if ( globalReturnsTrue ( ) )
int globalReturnsTrue()
return 1 ;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
char inputBuffer [ CHAR_ARRAY_SIZE ] ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
inputBuffer [ recvResult ] = '\0';
data = strtoul ( inputBuffer , NULL , 0 );
while ( 0 )
if ( globalReturnsTrue ( ) )
int globalReturnsTrue()
return 1 ;
char * myString ;
if ( data > strlen ( HELLO_STRING ) )
myString = ( char * ) malloc ( data * sizeof ( char ) );
strcpy ( myString , HELLO_STRING );
printLine ( myString );
void printLine (const char * line)
if ( line != NULL )
printf ( "%s\n" , line );
free ( myString );
1
------------------------------
308811 109176/CWE606_Unchecked_Loop_Condition__wchar_t_connect_socket_07.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 ) 299
static void goodB2G2()
wchar_t * data ;
wchar_t dataBuffer [ 100 ] = L ""
data = dataBuffer;
if ( staticFive == 5 )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
309486 153618/tile-swap.c gint err = ( write ( swap_file -> fd , ( tile -> data + tile -> size - nleft ) , nleft ) ) ; 398
void tile_swap_delete(Tile *tile)
tile_swap_command ( tile , SWAP_DELETE );
static void tile_swap_command(Tile *tile,gint command)
if ( gimp_swap_file -> fd == - 1 )
if ( gimp_swap_file -> fd == - 1 )
switch ( command )
tile_swap_default_out ( gimp_swap_file , tile );
static void tile_swap_default_out(SwapFile *swap_file,Tile *tile)
gint bytes ;
gint nleft ;
gint64 offset ;
gint64 newpos ;
bytes = 64 * 64 * ( tile -> bpp );
if ( tile -> swap_offset == ( - 1 ) )
newpos = tile_swap_find_offset ( swap_file , bytes );
newpos = tile -> swap_offset;
if ( swap_file -> cur_position != newpos )
offset = lseek ( swap_file -> fd , newpos , 0 );
if ( offset == ( - 1 ) )
swap_file -> cur_position = newpos;
nleft = tile -> size;
while ( nleft > 0 )
gint err = ( write ( swap_file -> fd , ( tile -> data + tile -> size - nleft ) , nleft ) ) ;
if ( err <= 0 )
g_log ( "Gimp-Base" , G_LOG_LEVEL_MESSAGE , "unable to write tile data to disk: %s (%d/%d bytes written)" , g_strerror ( * __errno_location ( ) ) , err , nleft );
nleft -= err;
0
------------------------------
309512 153616/mux.c num = f -> num + incr 138
int av_write_frame(AVFormatContext *s,AVPacket *pkt)
int ret ;
if ( ! pkt )
ret = compute_pkt_fields2 ( s , s -> streams [ pkt -> stream_index ] , pkt );
static int compute_pkt_fields2(AVFormatContext *s,AVStream *st,AVPacket *pkt)
int delay = st -> codec -> has_b_frames > ( st -> codec -> max_b_frames > 0 ) ? st -> codec -> has_b_frames : st -> codec -> max_b_frames > 0 ;
int num ;
int den ;
int frame_size ;
int i ;
if ( pkt -> duration == 0 )
if ( den && num )
pkt -> duration = ( av_rescale ( 1 , num * ( ( int64_t ) st -> time_base . den ) * ( st -> codec -> ticks_per_frame ) , den * ( ( int64_t ) st -> time_base . num ) ) );
if ( pkt -> pts == ( ( int64_t ) 0x8000000000000000UL ) && pkt -> dts != ( ( int64_t ) 0x8000000000000000UL ) && delay == 0 )
pkt -> pts = pkt -> dts;
if ( ( pkt -> pts == 0 || pkt -> pts == ( ( int64_t ) 0x8000000000000000UL ) ) && pkt -> dts == ( ( int64_t ) 0x8000000000000000UL ) && ! delay )
pkt -> dts = pkt -> pts = st -> pts . val;
if ( pkt -> pts != ( ( int64_t ) 0x8000000000000000UL ) && pkt -> dts == ( ( int64_t ) 0x8000000000000000UL ) && delay <= 16 )
st -> pts_buffer [ 0 ] = pkt -> pts;
for (i = 1; i < delay + 1 && st -> pts_buffer[i] == ((int64_t )0x8000000000000000UL); i++)
st -> pts_buffer [ i ] = pkt -> pts + ( ( i - delay - 1 ) * pkt -> duration );
for (i = 0; i < delay && st -> pts_buffer[i] > st -> pts_buffer[i + 1]; i++)
int64_t SWAP_tmp = st -> pts_buffer [ i + 1 ] ;
st -> pts_buffer [ i + 1 ] = st -> pts_buffer [ i ];
st -> pts_buffer [ i ] = SWAP_tmp;
while ( 0 )
pkt -> dts = st -> pts_buffer [ 0 ];
if ( st -> cur_dts && st -> cur_dts != ( ( int64_t ) 0x8000000000000000UL ) && ( ! ( s -> oformat -> flags & 0x8020000 ) && st -> cur_dts >= pkt -> dts || st -> cur_dts > pkt -> dts ) )
if ( pkt -> dts != ( ( int64_t ) 0x8000000000000000UL ) && pkt -> pts != ( ( int64_t ) 0x8000000000000000UL ) && pkt -> pts < pkt -> dts )
st -> cur_dts = pkt -> dts;
st -> pts . val = pkt -> dts;
switch ( st -> codec -> codec_type )
frame_size = ff_get_audio_frame_size ( st -> codec , pkt -> size , 1 );
if ( frame_size >= 0 && ( pkt -> size || st -> pts . num != st -> pts . den >> 1 || st -> pts . val ) )
frac_add ( & st -> pts , ( ( int64_t ) st -> time_base . den ) * frame_size );
static void frac_add(AVFrac *f,int64_t incr)
int64_t num ;
num = f -> num + incr;
if ( num < 0 )
f -> val += num / den;
num = num % den;
if ( num < 0 )
num += den;
f -> val --;
if ( num >= den )
f -> val += num / den;
num = num % den;
f -> num = num;
0
------------------------------
20332 CVE-2016-4006/Wireshark_2.0.2_CVE_2016_4006_epan_proto.c ret = ( int ) ( p - fi -> rep -> representation ) 4339
proto_item
proto_tree_add_ipv6_format_value(proto_tree *tree, int hfindex, tvbuff_t
gint start, gint
const struct e_in6_addr
const char *format, ...)
proto_item * pi ;
va_list ap ;
pi = proto_tree_add_ipv6 ( tree , hfindex , tvb , start , length , value_ptr );
proto_item
proto_tree_add_ipv6(proto_tree *tree, int hfindex, tvbuff_t *tvb, gint
gint length, const struct e_in6_addr *value_ptr)
proto_item * pi ;
header_field_info * hfinfo ;
pi = proto_tree_add_pi ( tree , hfinfo , tvb , start , & length );
static proto_item
proto_tree_add_pi(proto_tree *tree, header_field_info *hfinfo, tvbuff_t *tvb, gint
gint *length)
proto_item * pi ;
field_info * fi ;
gint item_length ;
fi = new_field_info ( tree , hfinfo , tvb , start , item_length );
pi = proto_tree_add_node ( tree , fi );
return pi ;
return pi ;
if ( pi != tree )
proto_tree_set_representation_value ( pi , format , ap );
static
proto_tree_set_representation_value(proto_item *pi, const char *format, va_list ap)
if ( PTREE_DATA ( pi ) -> visible && ! PROTO_ITEM_IS_HIDDEN ( pi ) )
field_info * fi = PITEM_FINFO ( pi ) ;
header_field_info * hf ;
hf = fi -> hfinfo;
if ( hf -> bitmask && ( hf -> type == FT_BOOLEAN || IS_FT_UINT ( hf -> type ) ) )
guint64 val ;
char * p ;
if ( IS_FT_UINT ( hf -> type ) )
val = fvalue_get_uinteger ( & fi -> value );
val = fvalue_get_uinteger64 ( & fi -> value );
val <<= hfinfo_bitshift ( hf );
p = decode_bitfield_value ( fi -> rep -> representation , val , hf -> bitmask , hfinfo_bitwidth ( hf ) );
ret = ( int ) ( p - fi -> rep -> representation );
ret += g_snprintf ( fi -> rep -> representation + ret , ITEM_LABEL_LENGTH - ret , "%s: " , hf -> name );
if ( ret < ITEM_LABEL_LENGTH )
ret += g_vsnprintf ( fi -> rep -> representation + ret , ITEM_LABEL_LENGTH - ret , format , ap );
if ( ret >= ITEM_LABEL_LENGTH )
0
------------------------------
298465 95462/CWE369_Divide_by_Zero__int_zero_divide_31.c printIntLine ( 100 / data ) 33
void CWE369_Divide_by_Zero__int_zero_divide_31_bad()
int data ;
data = - 1;
data = 0;
int dataCopy = data ;
int data = dataCopy ;
printIntLine ( 100 / data );
1
------------------------------
308646 117215/CWE789_Uncontrolled_Mem_Alloc__malloc_char_rand_68b.c myString = ( char * ) malloc ( data * sizeof ( char ) ) 70
void CWE789_Uncontrolled_Mem_Alloc__malloc_char_rand_68b_goodG2BSink()
size_t data = CWE789_Uncontrolled_Mem_Alloc__malloc_char_rand_68_goodG2BData ;
char * myString ;
if ( data > strlen ( HELLO_STRING ) )
myString = ( char * ) malloc ( data * sizeof ( char ) );
strcpy ( myString , HELLO_STRING );
printLine ( myString );
void printLine (const char * line)
if ( line != NULL )
printf ( "%s\n" , line );
free ( myString );
0
------------------------------
304839 80326/CWE134_Uncontrolled_Format_String__char_listen_socket_printf_45.c recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 107
void CWE134_Uncontrolled_Format_String__char_listen_socket_printf_45_bad()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
CWE134_Uncontrolled_Format_String__char_listen_socket_printf_45_badData = data;
0
------------------------------
302788 83970/CWE190_Integer_Overflow__short_fscanf_square_64b.c short result = data * data ; 65
static void goodB2G()
short data ;
data = 0;
CWE190_Integer_Overflow__short_fscanf_square_64b_goodB2GSink ( & data );
void CWE190_Integer_Overflow__short_fscanf_square_64b_goodB2GSink(void * dataVoidPtr)
short * dataPtr = ( short * ) dataVoidPtr ;
short data = ( * dataPtr ) ;
if ( abs ( ( long ) data ) <= ( long ) sqrt ( ( double ) SHRT_MAX ) )
short result = data * data ;
printIntLine ( result );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
0
------------------------------
306185 110344/CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_connect_socket_54e.c intPointer = ( int * ) malloc ( data * sizeof ( int ) ) 52
void CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_connect_socket_54b_badSink(int data)
CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_connect_socket_54c_badSink ( data );
void CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_connect_socket_54c_badSink(int data)
CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_connect_socket_54d_badSink ( data );
void CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_connect_socket_54d_badSink(int data)
CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_connect_socket_54e_badSink ( data );
void CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_connect_socket_54e_badSink(int data)
int * intPointer ;
intPointer = ( int * ) malloc ( data * sizeof ( int ) );
intPointer [ i ] = 0;
printIntLine ( intPointer [ 0 ] );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
free ( intPointer );
1
------------------------------
300149 150142/utils.c m = a + b >> 1 1950
static int seek_frame_internal(AVFormatContext *s,int stream_index,int64_t timestamp,int flags)
int ret ;
AVStream * st ;
if ( flags & 2 )
if ( stream_index < 0 )
stream_index = av_find_default_stream_index ( s );
if ( stream_index < 0 )
st = s -> streams [ stream_index ];
timestamp = av_rescale ( timestamp , st -> time_base . den , 1000000 * ( ( int64_t ) st -> time_base . num ) );
if ( s -> iformat -> read_seek )
ret = ( ( s -> iformat -> read_seek ) ( s , stream_index , timestamp , flags ) );
ret = - 1;
if ( ret >= 0 )
if ( s -> iformat -> read_timestamp && ! ( s -> iformat -> flags & 0x2000 ) )
return ff_seek_frame_binary ( s , stream_index , timestamp , flags ) ;
int ff_seek_frame_binary(AVFormatContext *s,int stream_index,int64_t target_ts,int flags)
int index ;
AVStream * st ;
if ( stream_index < 0 )
st = s -> streams [ stream_index ];
if ( st -> index_entries )
index = av_index_search_timestamp ( st , target_ts , flags & ~1 );
int av_index_search_timestamp(AVStream *st,int64_t wanted_timestamp,int flags)
return ff_index_search_timestamp ( ( st -> index_entries ) , st -> nb_index_entries , wanted_timestamp , flags ) ;
int ff_index_search_timestamp(const AVIndexEntry *entries,int nb_entries,int64_t wanted_timestamp,int flags)
int a ;
int b ;
int m ;
int64_t timestamp ;
a = - 1;
b = nb_entries;
if ( b && entries [ b - 1 ] . timestamp < wanted_timestamp )
a = b - 1;
while ( b - a > 1 )
m = a + b >> 1;
timestamp = entries [ m ] . timestamp;
if ( timestamp >= wanted_timestamp )
b = m;
if ( timestamp <= wanted_timestamp )
a = m;
m = ( flags & 1 ? a : b );
while ( m >= 0 && m < nb_entries && ! ( entries [ m ] . flags & 0x1 ) )
m += ( flags & 1 ? - 1 : 1 );
if ( m == nb_entries )
return m ;
0
------------------------------
304527 82242/CWE190_Integer_Overflow__char_fscanf_square_64b.c char result = data * data ; 65
static void goodB2G()
char data ;
data = ' ';
CWE190_Integer_Overflow__char_fscanf_square_64b_goodB2GSink ( & data );
void CWE190_Integer_Overflow__char_fscanf_square_64b_goodB2GSink(void * dataVoidPtr)
char * dataPtr = ( char * ) dataVoidPtr ;
char data = ( * dataPtr ) ;
if ( abs ( ( long ) data ) <= ( long ) sqrt ( ( double ) CHAR_MAX ) )
char result = data * data ;
printHexCharLine ( result );
void printHexCharLine (char charHex)
printf ( "%02x\n" , charHex );
0
------------------------------
305971 110014/CWE666_Operation_on_Resource_in_Wrong_Phase_of_Lifetime__listen_accept_bind_16.c recvResult = recv ( acceptSocket , ( char * ) data + dataLen , ( int ) ( 100 - dataLen - 1 ) , 0 ) 93
void CWE666_Operation_on_Resource_in_Wrong_Phase_of_Lifetime__listen_accept_bind_16_bad()
while ( 1 )
char data [ 100 ] = "" ;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) data + dataLen , ( int ) ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ recvResult ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
printLine ( data );
void printLine (const char * line)
if ( line != NULL )
printf ( "%s\n" , line );
1
------------------------------
302596 80338/CWE134_Uncontrolled_Format_String__char_listen_socket_printf_68a.c recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 212
static void goodB2G()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
CWE134_Uncontrolled_Format_String__char_listen_socket_printf_68_goodB2GData = data;
0
------------------------------
308669 108937/CWE606_Unchecked_Loop_Condition__char_connect_socket_08.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 204
static void goodB2G1()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
if ( staticReturnsTrue ( ) )
static int staticReturnsTrue()
return 1 ;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
if ( sscanf ( data , "%d" , & n ) == 1 )
0
------------------------------
300756 153579/dfa.c wc = inputwcs [ * pp - mbclen - buf_begin ] 3498
char *dfaexec(struct dfa *d,const char *begin,char *end,int allow_nl,size_t *count,int *backref)
state_num s ;
state_num s1 ;
const unsigned char * p ;
state_num * * trans ;
state_num * t ;
unsigned char eol = eolbyte ;
s = s1 = 0;
p = ( ( const unsigned char * ) begin );
trans = d -> trans;
* end = eol;
if ( d -> mb_cur_max > 1 )
while ( ( t = trans [ s ] ) != ( ( void * ) 0 ) )
if ( p > buf_end )
s1 = s;
if ( s == 0 )
if ( ( ( char * ) p ) >= end )
if ( d -> states [ s ] . mbps . nelem == 0 )
s = t [ * ( p ++ ) ];
if ( backref )
s = transit_state ( d , s , & p );
trans = d -> trans;
while ( ( t = trans [ s ] ) != ( ( void * ) 0 ) )
s1 = t [ * ( p ++ ) ];
if ( ( t = trans [ s1 ] ) == ( ( void * ) 0 ) )
state_num tmp = s ;
s = s1;
s1 = tmp;
s = t [ * ( p ++ ) ];
if ( s >= 0 && ( ( char * ) p ) <= end && d -> fails [ s ] )
if ( d -> success [ s ] & sbit [ * p ] )
s1 = s;
if ( d -> mb_cur_max > 1 )
s = transit_state ( d , s , & p );
trans = d -> trans;
s = d -> fails [ s ] [ * ( p ++ ) ];
if ( ( ( char * ) p ) > end )
if ( s >= 0 )
trans = d -> trans;
if ( p [ - 1 ] == eol && allow_nl )
s = d -> newlines [ s1 ];
s = 0;
static state_num transit_state(struct dfa *d,state_num s,const unsigned char **pp)
int mbclen ;
int maxlen = 0 ;
size_t i ;
size_t nelem = d -> states [ s ] . mbps . nelem ;
const unsigned char * p1 = * pp ;
wchar_t wc ;
if ( nelem > 0 )
match_lens = check_matching_with_multibyte_ops ( d , s , ( * pp - buf_begin ) );
for (i = 0; i < nelem; i++)
if ( match_lens [ i ] > maxlen )
maxlen = match_lens [ i ];
if ( nelem == 0 || maxlen == 0 )
while ( * pp - p1 < maxlen )
transit_state_consume_1char ( d , s1 , pp , ( ( void * ) 0 ) , & mbclen , & follows );
for (j = 0; j < d -> follows[d -> states[s1] . mbps . elems[i] . index] . nelem; j++)
insert ( d -> follows [ d -> states [ s1 ] . mbps . elems [ i ] . index ] . elems [ j ] , & follows );
wc = inputwcs [ * pp - mbclen - buf_begin ];
s1 = state_index ( d , ( & follows ) , wchar_context ( wc ) );
realloc_trans_if_necessary ( d , s1 );
return s1 ;
0
------------------------------
18486 CVE-2015-2716/Firefox_37.0b7_CVE_2015_2716_parser_expat_lib_xmlparse.c pool -> end = tem -> s + blockSize 6287
static enum XML_Error
entityValueProcessor(XML_Parser
const char
const char
const char **nextPtr)
const char * start = s ;
const char * next = s ;
const ENCODING * enc = encoding ;
int tok ;
tok = XmlPrologTok ( enc , start , end , & next );
if ( tok <= 0 )
if ( ! ps_finalBuffer && tok != XML_TOK_INVALID )
switch ( tok )
return storeEntityValue ( parser , enc , s , end ) ;
start = next;
static enum
storeEntityValue(XML_Parser
const ENCODING
const char
const char *entityTextEnd)
DTD * const dtd = _dtd
STRING_POOL * pool = & ( dtd -> entityValuePool ) ;
if ( ! pool -> blocks )
if ( ! poolGrow ( pool ) )
const char * next ;
int tok = XmlEntityValueTok ( enc , entityTextPtr , entityTextEnd , & next ) ;
switch ( tok )
if ( isParamEntity || enc != encoding )
const XML_Char * name ;
ENTITY * entity ;
name = poolStoreString ( & tempPool , enc , entityTextPtr + enc -> minBytesPerChar , next - enc -> minBytesPerChar );
if ( ! name )
entity = ( ENTITY * ) lookup ( & dtd -> paramEntities , name , 0 );
if ( ! entity )
if ( entity -> open )
if ( entity -> systemId )
if ( externalEntityRefHandler )
entity -> open = XML_TRUE;
if ( ! externalEntityRefHandler ( externalEntityRefHandlerArg , 0 , entity -> base , entity -> systemId , entity -> publicId ) )
entity -> open = XML_FALSE;
entity -> open = XML_TRUE;
result = storeEntityValue ( parser , internalEncoding , ( char * ) entity -> textPtr , ( char * ) ( entity -> textPtr + entity -> textLen ) );
entity -> open = XML_FALSE;
if ( result )
if ( ! poolAppend ( pool , enc , entityTextPtr , next ) )
next = entityTextPtr + enc -> minBytesPerChar;
if ( pool -> end == pool -> ptr && ! poolGrow ( pool ) )
* ( pool -> ptr ) ++ = 0xA;
XML_Char buf [ XML_ENCODE_MAX ] ;
int i ;
int n = XmlCharRefNumber ( enc , entityTextPtr ) ;
if ( n < 0 )
n = XmlEncode ( n , ( ICHAR * ) buf );
if ( ! n )
for (i = 0; i < n; i++)
if ( pool -> end == pool -> ptr && ! poolGrow ( pool ) )
* ( pool -> ptr ) ++ = buf [ i ];
entityTextPtr = next;
static XML_Char
poolAppend(STRING_POOL *pool, const ENCODING
const char *ptr, const char *end)
if ( ! pool -> ptr && ! poolGrow ( pool ) )
static XML_Bool
poolGrow(STRING_POOL *pool)
if ( pool -> freeBlocks )
if ( pool -> start == 0 )
if ( pool -> end - pool -> start < pool -> freeBlocks -> size )
if ( pool -> blocks && pool -> start == pool -> blocks -> s )
BLOCK * tem ;
int blockSize = ( int ) ( pool -> end - pool -> start ) ;
if ( blockSize < INIT_BLOCK_SIZE )
blockSize = INIT_BLOCK_SIZE;
blockSize *= 2;
tem = ( BLOCK * ) pool -> mem -> malloc_fcn ( offsetof ( BLOCK , s ) + blockSize * sizeof ( XML_Char ) );
if ( ! tem )
tem -> size = blockSize;
tem -> next = pool -> blocks;
pool -> blocks = tem;
if ( pool -> ptr != pool -> start )
memcpy ( tem -> s , pool -> start , ( pool -> ptr - pool -> start ) * sizeof ( XML_Char ) );
pool -> ptr = tem -> s + ( pool -> ptr - pool -> start );
pool -> start = tem -> s;
pool -> end = tem -> s + blockSize;
0
------------------------------
300082 152323/mux.c st -> pts_buffer [ i ] = pkt -> pts + ( ( i - delay - 1 ) * pkt -> duration ) 492
int av_write_frame(AVFormatContext *s,AVPacket *pkt)
int ret ;
if ( ! pkt )
ret = compute_pkt_fields2 ( s , s -> streams [ pkt -> stream_index ] , pkt );
static int compute_pkt_fields2(AVFormatContext *s,AVStream *st,AVPacket *pkt)
int delay = st -> codec -> has_b_frames > ( st -> codec -> max_b_frames > 0 ) ? st -> codec -> has_b_frames : st -> codec -> max_b_frames > 0 ;
int num ;
int den ;
int i ;
if ( pkt -> duration == 0 )
if ( den && num )
pkt -> duration = ( av_rescale ( 1 , num * ( ( int64_t ) st -> time_base . den ) * ( st -> codec -> ticks_per_frame ) , den * ( ( int64_t ) st -> time_base . num ) ) );
if ( pkt -> pts == ( ( int64_t ) 0x8000000000000000UL ) && pkt -> dts != ( ( int64_t ) 0x8000000000000000UL ) && delay == 0 )
pkt -> pts = pkt -> dts;
if ( ( pkt -> pts == 0 || pkt -> pts == ( ( int64_t ) 0x8000000000000000UL ) ) && pkt -> dts == ( ( int64_t ) 0x8000000000000000UL ) && ! delay )
pkt -> dts = pkt -> pts = st -> pts . val;
if ( pkt -> pts != ( ( int64_t ) 0x8000000000000000UL ) && pkt -> dts == ( ( int64_t ) 0x8000000000000000UL ) && delay <= 16 )
st -> pts_buffer [ 0 ] = pkt -> pts;
for (i = 1; i < delay + 1 && st -> pts_buffer[i] == ((int64_t )0x8000000000000000UL); i++)
st -> pts_buffer [ i ] = pkt -> pts + ( ( i - delay - 1 ) * pkt -> duration );
for (i = 0; i < delay && st -> pts_buffer[i] > st -> pts_buffer[i + 1]; i++)
int64_t SWAP_tmp = st -> pts_buffer [ i + 1 ] ;
st -> pts_buffer [ i + 1 ] = st -> pts_buffer [ i ];
st -> pts_buffer [ i ] = SWAP_tmp;
pkt -> dts = st -> pts_buffer [ 0 ];
if ( st -> cur_dts && st -> cur_dts != ( ( int64_t ) 0x8000000000000000UL ) && ( ! ( s -> oformat -> flags & 0x8020000 ) && st -> cur_dts >= pkt -> dts || st -> cur_dts > pkt -> dts ) )
av_log ( s , 16 , "Application provided invalid, non monotonically increasing dts to muxer in stream %d: %s >= %s\n" , st -> index , av_ts_make_string ( ( ( char [ 32 ] ) ( 0 ) ) , st -> cur_dts ) , av_ts_make_string ( ( ( char [ 32 ] ) ( 0 ) ) , pkt -> dts ) )
if ( pkt -> dts != ( ( int64_t ) 0x8000000000000000UL ) && pkt -> pts != ( ( int64_t ) 0x8000000000000000UL ) && pkt -> pts < pkt -> dts )
av_log ( s , 16 , "pts (%s) < dts (%s) in stream %d\n" , av_ts_make_string ( ( ( char [ 32 ] ) ( 0 ) ) , pkt -> pts ) , av_ts_make_string ( ( ( char [ 32 ] ) ( 0 ) ) , pkt -> dts ) , st -> index )
av_log ( s , 48 , "av_write_frame: pts2:%s dts2:%s\n" , av_ts_make_string ( ( ( char [ 32 ] ) ( 0 ) ) , pkt -> pts ) , av_ts_make_string ( ( ( char [ 32 ] ) ( 0 ) ) , pkt -> dts ) )
st -> cur_dts = pkt -> dts;
st -> pts . val = pkt -> dts;
switch ( st -> codec -> codec_type )
frame_size = ff_get_audio_frame_size ( st -> codec , pkt -> size , 1 );
if ( frame_size >= 0 && ( pkt -> size || st -> pts . num != st -> pts . den >> 1 || st -> pts . val ) )
frac_add ( & st -> pts , ( ( int64_t ) st -> time_base . den ) * frame_size );
frac_add ( & st -> pts , ( ( int64_t ) st -> time_base . den ) * st -> codec -> time_base . num );
0
------------------------------
313096 90942/CWE23_Relative_Path_Traversal__wchar_t_connect_socket_open_21.cpp recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ) 103
void bad()
wchar_t * data ;
wchar_t dataBuffer [ FILENAME_MAX ] = BASEPATH ;
data = dataBuffer;
data = badSource ( data );
static wchar_t * badSource(wchar_t * data)
if ( badStatic )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( FILENAME_MAX - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
305790 104485/CWE469_Use_of_Pointer_Subtraction_to_Determine_Size__wchar_t_08.c indexOfSlashInString1 = ( size_t ) ( slashInString1 - string1 ) 83
static void good1()
if ( staticReturnsFalse ( ) )
static int staticReturnsFalse()
return 0 ;
wchar_t string1 [ ] = SOURCE_STRING ;
wchar_t * slashInString1 ;
size_t indexOfSlashInString1 ;
slashInString1 = wcschr ( string1 , L '/' )
indexOfSlashInString1 = ( size_t ) ( slashInString1 - string1 );
printUnsignedLine ( indexOfSlashInString1 );
void printUnsignedLine(unsigned unsignedNumber)
printf ( "%u\n" , unsignedNumber );
0
------------------------------
19138 CVE-2016-7466/qemu_2.3.0_CVE-2016-7466_hcd-xhci.c obuf [ 4 ] = 0x0123c75c + 0x1595 * buf [ 2 ] + 0x19ec * buf [ 3 ] 2684
static void xhci_via_challenge(XHCIState *xhci, uint64_t addr)
uint32_t buf [ 8 ] ;
uint32_t obuf [ 8 ] ;
memcpy ( obuf , buf , sizeof ( obuf ) );
if ( ( buf [ 0 ] & 0xff ) == 2 )
obuf [ 0 ] = 0x49932000 + 0x54dc200 * buf [ 2 ] + 0x7429b578 * buf [ 3 ];
obuf [ 0 ] |= ( buf [ 2 ] * buf [ 3 ] ) & 0xff;
obuf [ 1 ] = 0x0132bb37 + 0xe89 * buf [ 2 ] + 0xf09 * buf [ 3 ];
obuf [ 2 ] = 0x0066c2e9 + 0x2091 * buf [ 2 ] + 0x19bd * buf [ 3 ];
obuf [ 3 ] = 0xd5281342 + 0x2cc9691 * buf [ 2 ] + 0x2367662 * buf [ 3 ];
obuf [ 4 ] = 0x0123c75c + 0x1595 * buf [ 2 ] + 0x19ec * buf [ 3 ];
obuf [ 5 ] = 0x00f695de + 0x26fd * buf [ 2 ] + 0x3e9 * buf [ 3 ];
obuf [ 6 ] = obuf [ 2 ] ^ obuf [ 3 ] ^ 0x29472956;
obuf [ 7 ] = obuf [ 2 ] ^ obuf [ 3 ] ^ 0x65866593;
pci_dma_write ( pci_dev , paddr , & obuf , 32 );
0
------------------------------
301564 150690/aviobuf.c s -> buf_end = dst + len 591
unsigned int avio_rb32(AVIOContext *s)
unsigned int val ;
val = avio_rb16 ( s ) << 16;
unsigned int avio_rb16(AVIOContext *s)
unsigned int val ;
val = ( avio_r8 ( s ) << 8 );
int avio_r8(AVIOContext *s)
if ( s -> buf_ptr >= s -> buf_end )
fill_buffer ( s );
static void fill_buffer(AVIOContext *s)
uint8_t * dst = ! s -> max_packet_size && s -> buf_end - s -> buffer < ( s -> buffer_size ) ? s -> buf_end : s -> buffer ;
int len = ( ( s -> buffer_size ) - ( dst - s -> buffer ) ) ;
int max_buffer_size = s -> max_packet_size ? s -> max_packet_size : 32768 ;
if ( ! s -> read_packet && s -> buf_ptr >= s -> buf_end )
s -> eof_reached = 1;
if ( s -> eof_reached )
if ( s -> update_checksum && dst == s -> buffer )
if ( s -> buf_end > s -> checksum_ptr )
s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_end - s -> checksum_ptr ) ) );
s -> checksum_ptr = s -> buffer;
if ( s -> read_packet && s -> buffer_size > max_buffer_size )
s -> checksum_ptr = dst = s -> buffer;
len = s -> buffer_size;
if ( s -> read_packet )
len = ( ( s -> read_packet ) ( s -> opaque , dst , len ) );
len = 0;
if ( len <= 0 )
s -> eof_reached = 1;
if ( len < 0 )
s -> error = len;
s -> pos += len;
s -> buf_ptr = dst;
s -> buf_end = dst + len;
s -> bytes_read += len;
0
------------------------------
304279 80490/CWE134_Uncontrolled_Format_String__char_listen_socket_w32_vsnprintf_01.c recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 239
static void goodB2G()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
goodB2GVaSink ( data , data );
static void goodB2GVaSink(char * data, ...)
va_start ( args , data );
0
------------------------------
20403 CVE-2015-4504/Firefox_40.0b9_CVE_2015_4504_gfx_qcms_transform_util.c uint32_t upper = ( value + PRECACHE_OUTPUT_MAX - 1 ) / PRECACHE_OUTPUT_MAX ; 58
qcms_bool compute_precache(struct curveType *trc, uint8_t *output)
if ( trc -> type == PARAMETRIC_CURVE_TYPE )
float gamma_table [ 256 ] ;
uint16_t gamma_table_uint [ 256 ] ;
uint16_t i ;
uint16_t * inverted ;
int inverted_size = 256 ;
for(i = 0; i < 256; i++)
gamma_table_uint [ i ] = ( uint16_t ) ( gamma_table [ i ] * 65535 );
if ( inverted_size < 256 )
inverted_size = 256;
inverted = invert_lut ( gamma_table_uint , 256 , inverted_size );
static uint16_t *invert_lut(uint16_t *table, int length, int out_length)
int i ;
uint16_t * output = malloc ( sizeof ( uint16_t ) * out_length ) ;
if ( ! output )
return NULL ;
for (i = 0; i < out_length; i++)
double x = ( ( double ) i * 65535. ) / ( double ) ( out_length - 1 ) ;
uint16_fract_t input = floor ( x + .5 ) ;
output [ i ] = lut_inverse_interp16 ( input , table , length );
return output ;
if ( ! inverted )
compute_precache_lut ( output , inverted , inverted_size );
void compute_precache_lut(uint8_t *output, uint16_t *table, int length)
for (v = 0; v < PRECACHE_OUTPUT_SIZE; v++)
output [ v ] = lut_interp_linear_precache_output ( v , table , length );

uint8_t lut_interp_linear_precache_output(uint32_t input_value, uint16_t *table, int length)
uint32_t value = ( input_value * ( length - 1 ) ) ;
uint32_t upper = ( value + PRECACHE_OUTPUT_MAX - 1 ) / PRECACHE_OUTPUT_MAX ;
value = ( table [ upper ] * ( interp ) + table [ lower ] * ( PRECACHE_OUTPUT_MAX - interp ) );
value += ( PRECACHE_OUTPUT_MAX * 65535 / 255 ) / 2;
value /= ( PRECACHE_OUTPUT_MAX * 65535 / 255 );
return value ;
0
------------------------------
304986 83670/CWE190_Integer_Overflow__int_max_square_41.c int result = data * data ; 52
static void goodG2B()
int data ;
data = 0;
data = 2;
goodG2BSink ( data );
static void goodG2BSink(int data)
int result = data * data ;
printIntLine ( result );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
1
------------------------------
311582 150218/bufmgr.c newPartitionLock = ( ( LWLockId ) ( FirstBufMappingLock + newHash % 16 ) ) 789
Buffer ReadBuffer(Relation reln,BlockNumber blockNum)
return ReadBufferExtended ( reln , MAIN_FORKNUM , blockNum , RBM_NORMAL , ( ( void * ) 0 ) ) ;
Buffer ReadBufferExtended(Relation reln,ForkNumber forkNum,BlockNumber blockNum,ReadBufferMode mode,BufferAccessStrategy strategy)
Buffer buf ;
if ( reln -> pgstat_info != ( ( void * ) 0 ) )
reln -> pgstat_info -> t_counts . t_blocks_fetched ++;
while ( 0 )
buf = ReadBuffer_common ( reln -> rd_smgr , reln -> rd_rel -> relpersistence , forkNum , blockNum , mode , strategy , & hit );
static Buffer ReadBuffer_common(SMgrRelation smgr,char relpersistence,ForkNumber forkNum,BlockNumber blockNum,ReadBufferMode mode,BufferAccessStrategy strategy,bool *hit)
volatile BufferDesc * bufHdr ;
bool isExtend ;
bool isLocalBuf = ( smgr -> smgr_rnode . backend != - 1 ) ;
isExtend = ( blockNum == ( ( BlockNumber ) 0xFFFFFFFF ) );
if ( isExtend )
blockNum = smgrnblocks ( smgr , forkNum );
if ( isLocalBuf )
bufHdr = BufferAlloc ( smgr , relpersistence , forkNum , blockNum , strategy , & found );
static volatile BufferDesc *BufferAlloc(SMgrRelation smgr,char relpersistence,ForkNumber forkNum,BlockNumber blockNum,BufferAccessStrategy strategy,bool *foundPtr)
BufferTag newTag ;
uint32 newHash ;
LWLockId newPartitionLock ;
( newTag . rnode = smgr -> smgr_rnode . node , newTag . forkNum = forkNum ) , newTag . blockNum = blockNum;
newHash = BufTableHashCode ( & newTag );
newPartitionLock = ( ( LWLockId ) ( FirstBufMappingLock + newHash % 16 ) );
LWLockAcquire ( newPartitionLock , LW_SHARED );
LWLockRelease ( newPartitionLock );
LWLockRelease ( newPartitionLock );
if ( oldPartitionLock < newPartitionLock )
LWLockAcquire ( newPartitionLock , LW_EXCLUSIVE );
if ( oldPartitionLock > newPartitionLock )
LWLockAcquire ( newPartitionLock , LW_EXCLUSIVE );
LWLockAcquire ( newPartitionLock , LW_EXCLUSIVE );
LWLockAcquire ( newPartitionLock , LW_EXCLUSIVE );
if ( oldFlags & 1 << 2 && oldPartitionLock != newPartitionLock )
LWLockRelease ( newPartitionLock );
if ( oldFlags & 1 << 2 && oldPartitionLock != newPartitionLock )
LWLockRelease ( newPartitionLock );
if ( oldPartitionLock != newPartitionLock )
LWLockRelease ( newPartitionLock );
0
------------------------------
312734 117266/CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_connect_socket_74b.cpp myString = ( wchar_t * ) malloc ( data * sizeof ( wchar_t ) ) 45
void bad()
size_t data ;
map < int , size_t > dataMap ;
data = 0;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
char inputBuffer [ CHAR_ARRAY_SIZE ] ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
inputBuffer [ recvResult ] = '\0';
data = strtoul ( inputBuffer , NULL , 0 );
while ( 0 )
dataMap [ 0 ] = data;
dataMap [ 1 ] = data;
dataMap [ 2 ] = data;
badSink ( dataMap );
void badSink(map<int, size_t> dataMap)
size_t data = dataMap [ 2 ] ;
wchar_t * myString ;
if ( data > wcslen ( HELLO_STRING ) )
myString = ( wchar_t * ) malloc ( data * sizeof ( wchar_t ) );
wcscpy ( myString , HELLO_STRING );
printWLine ( myString );
void printWLine (const wchar_t * line)
if ( line != NULL )
wprintf ( L "%ls\n" , line )
free ( myString );
1
------------------------------
300475 152633/aviobuf.c s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_ptr - s -> checksum_ptr ) ) ) 189
void avio_wl24(AVIOContext *s,unsigned int val)
avio_wl16 ( s , val & 0xffff );
void avio_wl16(AVIOContext *s,unsigned int val)
avio_w8 ( s , ( ( int ) val ) >> 8 );
void avio_w8(AVIOContext *s,int b)
* ( s -> buf_ptr ++ ) = b;
if ( s -> buf_ptr >= s -> buf_end )
flush_buffer ( s );
static void flush_buffer(AVIOContext *s)
if ( s -> buf_ptr > s -> buffer )
if ( s -> update_checksum )
s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_ptr - s -> checksum_ptr ) ) );
s -> checksum_ptr = s -> buffer;
s -> buf_ptr = s -> buffer;
0
------------------------------
302162 81715/CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_fprintf_42.c recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 ) 93
void CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_fprintf_42_bad()
wchar_t * data ;
wchar_t dataBuffer [ 100 ] = L ""
data = dataBuffer;
data = badSource ( data );
static wchar_t * badSource(wchar_t * data)
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
309640 150551/bufmgr.c stonesoup_arr [ stonesoup_i ] = dataStruct -> qsize - stonesoup_i 250
void *toPound(void *data)
int stonesoup_i ;
struct stonesoup_data * dataStruct = ( struct stonesoup_data * ) data ;
stonesoup_arr = malloc ( sizeof ( int ) * dataStruct -> qsize );
for (stonesoup_i = 0; stonesoup_i < dataStruct->qsize; stonesoup_i++)
stonesoup_arr [ stonesoup_i ] = dataStruct -> qsize - stonesoup_i;
qsort ( stonesoup_arr , dataStruct -> qsize , sizeof ( int ) , & stonesoup_comp );
free ( stonesoup_arr );
for (stonesoup_i = 0; stonesoup_i < (int)strlen(dataStruct->data) -
stonesoup_i += dataStruct->inc_amount)
dataStruct -> data [ stonesoup_i ] = '#';
1
------------------------------
306100 117132/CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_06.c myString = ( char * ) malloc ( data * sizeof ( char ) ) 391
static void goodG2B1()
size_t data ;
data = 0;
if ( STATIC_CONST_FIVE != 5 )
data = 20;
if ( STATIC_CONST_FIVE == 5 )
char * myString ;
if ( data > strlen ( HELLO_STRING ) )
myString = ( char * ) malloc ( data * sizeof ( char ) );
strcpy ( myString , HELLO_STRING );
printLine ( myString );
void printLine (const char * line)
if ( line != NULL )
printf ( "%s\n" , line );
free ( myString );
0
------------------------------
19173 CVE-2016-3062/Ffmpeg_0.11_CVE_2016_3062_libavformat_mov.c c -> next_root_atom = start_pos + a . size 372
static int mov_read_trak(MOVContext *c, AVIOContext *pb, MOVAtom atom)
AVStream * st ;
MOVStreamContext * sc ;
int ret ;
st = avformat_new_stream ( c -> fc , NULL );
if ( ! st )
sc = av_mallocz ( sizeof ( MOVStreamContext ) );
if ( ! sc )
if ( ( ret = mov_read_default ( c , pb , atom ) ) < 0 )
static int mov_read_default(MOVContext *c, AVIOContext *pb, MOVAtom atom)
int64_t total_size = 0 ;
MOVAtom a ;
int i ;
if ( atom . size < 0 )
atom . size = INT64_MAX;
while ( total_size + 8 <= atom . size && ! url_feof ( pb ) )
a . size = atom . size;
a . type = 0;
if ( atom . size >= 8 )
a . size = avio_rb32 ( pb );
a . type = avio_rl32 ( pb );
if ( atom . type != MKTAG ( 'r' , 'o' , 'o' , 't' ) && atom . type != MKTAG ( 'm' , 'o' , 'o' , 'v' ) )
if ( a . type == MKTAG ( 't' , 'r' , 'a' , 'k' ) || a . type == MKTAG ( 'm' , 'd' , 'a' , 't' ) )
total_size += 8;
if ( a . size == 1 )
a . size = avio_rb64 ( pb ) - 8;
total_size += 8;
if ( a . size == 0 )
a . size = atom . size - total_size + 8;
a . size -= 8;
if ( a . size < 0 )
a . size = FFMIN ( a . size , atom . size - total_size );
for (i = 0; mov_default_parse_table[i].type; i++)
if ( mov_default_parse_table [ i ] . type == a . type )
parse = mov_default_parse_table [ i ] . parse;
if ( ! parse && ( atom . type == MKTAG ( 'u' , 'd' , 't' , 'a' ) || atom . type == MKTAG ( 'i' , 'l' , 's' , 't' ) ) )
parse = mov_read_udta_string;
if ( ! parse )
int64_t start_pos = avio_tell ( pb ) ;
int err = parse ( c , pb , a ) ;
if ( err < 0 )
if ( c -> found_moov && c -> found_mdat && ( ( ! pb -> seekable || c -> fc -> flags & AVFMT_FLAG_IGNIDX ) || start_pos + a . size == avio_size ( pb ) ) )
if ( ! pb -> seekable || c -> fc -> flags & AVFMT_FLAG_IGNIDX )
c -> next_root_atom = start_pos + a . size;
total_size += a . size;
0
------------------------------
312335 151947/tile-manager.c cols = x2 - x + 1 850
void tile_manager_write_pixel_data(TileManager *tm,gint x1,gint y1,gint x2,gint y2,const guchar *buffer,guint stride)
guint x ;
guint y ;
for (y = y1; y <= y2; y += 64 - y % 64)
for (x = x1; x <= x2; x += 64 - x % 64)
Tile * tile = tile_manager_get_tile ( tm , x , y , ! 0 , ! 0 ) ;
Tile *tile_manager_get_tile(TileManager *tm,gint xpixel,gint ypixel,gboolean wantread,gboolean wantwrite)
if ( tm != ( ( void * ) 0 ) )
return ( ( void * ) 0 ) ;
while ( 0 )
return tile_manager_get ( tm , tile_manager_get_tile_num ( tm , xpixel , ypixel ) , wantread , wantwrite ) ;
inline static gint tile_manager_get_tile_num(TileManager *tm,gint xpixel,gint ypixel)
if ( xpixel < 0 || xpixel >= tm -> width || ypixel < 0 || ypixel >= tm -> height )
return - 1 ;
return ypixel / 64 * tm -> ntile_cols + xpixel / 64 ;
Tile *tile_manager_get(TileManager *tm,gint tile_num,gboolean wantread,gboolean wantwrite)
Tile * tile ;
gint ntiles ;
if ( tm != ( ( void * ) 0 ) )
return ( ( void * ) 0 ) ;
while ( 0 )
ntiles = tm -> ntile_rows * tm -> ntile_cols;
if ( tile_num < 0 || tile_num >= ntiles )
return ( ( void * ) 0 ) ;
tile = tm -> tiles [ tile_num ];
if ( wantread )
if ( wantwrite )
if ( tile -> share_count > 1 )
Tile * new = tile_new ( ( tile -> bpp )
new -> ewidth = tile ->
new -> eheight = tile ->
new -> valid = ( tile -> valid
new -> size = ( new -> ewidth ) * ( new -> eheight ) * ( new -> bpp
new -> data = ( ( guchar * ) ( g_malloc_n ( ( new -> size ) , sizeof ( guchar ) ) ) )
if ( tile -> data )
memcpy ( ( new -> data ) , ( tile -> data ) , ( new -> size ) )
memcpy ( ( new -> data ) , ( tile -> data ) , ( new -> size ) )
tile_attach ( new , tm , tile_num
tile = new
tile -> write_count ++;
tile -> dirty = ( ! 0 );
return tile ;
guint cols ;
cols = ( tile -> ewidth ) - x % 64;
if ( cols > x2 - x + 1 )
cols = x2 - x + 1;
memcpy ( d , s , ( cols * ( tm -> bpp ) ) );
d += dststride;
0
------------------------------
304995 83675/CWE190_Integer_Overflow__int_max_square_51b.c int result = data * data ; 42
static void goodG2B()
int data ;
data = 0;
data = 2;
CWE190_Integer_Overflow__int_max_square_51b_goodG2BSink ( data );
void CWE190_Integer_Overflow__int_max_square_51b_goodG2BSink(int data)
int result = data * data ;
printIntLine ( result );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
1
------------------------------
300737 153511/dfa.c match_lens = check_matching_with_multibyte_ops ( d , s , ( * pp - buf_begin ) ) 3427
char *dfaexec(struct dfa *d,const char *begin,char *end,int allow_nl,size_t *count,int *backref)
state_num s ;
state_num s1 ;
const unsigned char * p ;
state_num * * trans ;
state_num * t ;
unsigned char eol = eolbyte ;
unsigned char saved_end ;
s = s1 = 0;
p = ( ( const unsigned char * ) begin );
trans = d -> trans;
saved_end = * ( ( unsigned char * ) end );
* end = eol;
if ( d -> mb_cur_max > 1 )
while ( ( t = trans [ s ] ) != ( ( void * ) 0 ) )
if ( p > buf_end )
s1 = s;
if ( s == 0 )
if ( ( ( char * ) p ) >= end )
* end = saved_end;
if ( d -> states [ s ] . mbps . nelem == 0 )
s = t [ * ( p ++ ) ];
if ( backref )
* end = saved_end;
s = transit_state ( d , s , & p );
trans = d -> trans;
while ( ( t = trans [ s ] ) != ( ( void * ) 0 ) )
s1 = t [ * ( p ++ ) ];
if ( ( t = trans [ s1 ] ) == ( ( void * ) 0 ) )
state_num tmp = s ;
s = s1;
s1 = tmp;
s = t [ * ( p ++ ) ];
if ( s >= 0 && ( ( char * ) p ) <= end && d -> fails [ s ] )
if ( d -> success [ s ] & sbit [ * p ] )
s1 = s;
if ( d -> mb_cur_max > 1 )
s = transit_state ( d , s , & p );
trans = d -> trans;
s = d -> fails [ s ] [ * ( p ++ ) ];
if ( ( ( char * ) p ) > end )
if ( s >= 0 )
trans = d -> trans;
if ( p [ - 1 ] == eol && allow_nl )
s = d -> newlines [ s1 ];
s = 0;
static state_num transit_state(struct dfa *d,state_num s,const unsigned char **pp)
size_t nelem = d -> states [ s ] . mbps . nelem ;
if ( nelem > 0 )
match_lens = check_matching_with_multibyte_ops ( d , s , ( * pp - buf_begin ) );
if ( match_lens [ i ] > maxlen )
maxlen = match_lens [ i ];
if ( nelem == 0 || maxlen == 0 )
free ( match_lens );
transit_state_consume_1char ( d , s , pp , match_lens , & mbclen , & follows );
while ( * pp - p1 < maxlen )
if ( match_lens [ i ] == * pp - p1 )
free ( match_lens );
0
------------------------------
307672 117282/CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_fgets_12.c myString = ( wchar_t * ) malloc ( data * sizeof ( wchar_t ) ) 174
static void goodB2G()
size_t data ;
data = 0;
if ( globalReturnsTrueOrFalse ( ) )
int globalReturnsTrueOrFalse()
return ( rand ( ) % 2 ) ;
char inputBuffer [ CHAR_ARRAY_SIZE ] = "" ;
if ( fgets ( inputBuffer , CHAR_ARRAY_SIZE , stdin ) != NULL )
data = strtoul ( inputBuffer , NULL , 0 );
char inputBuffer [ CHAR_ARRAY_SIZE ] = "" ;
if ( fgets ( inputBuffer , CHAR_ARRAY_SIZE , stdin ) != NULL )
data = strtoul ( inputBuffer , NULL , 0 );
if ( globalReturnsTrueOrFalse ( ) )
int globalReturnsTrueOrFalse()
return ( rand ( ) % 2 ) ;
wchar_t * myString ;
wchar_t * myString ;
if ( data > wcslen ( HELLO_STRING ) && data < 100 )
myString = ( wchar_t * ) malloc ( data * sizeof ( wchar_t ) );
wcscpy ( myString , HELLO_STRING );
printWLine ( myString );
void printWLine (const wchar_t * line)
if ( line != NULL )
wprintf ( L "%ls\n" , line )
free ( myString );
0
------------------------------
299092 152171/xact.c rdata [ 1 ] . len = ( nrels * sizeof ( RelFileNode ) ) 1083
static TransactionId RecordTransactionCommit()
TransactionId xid = GetTopTransactionIdIfAny ( ) ;
TransactionId GetTopTransactionIdIfAny()
return TopTransactionStateData . transactionId ;
bool markXidCommitted = ( xid != ( ( TransactionId ) 0 ) ) ;
int nrels ;
RelFileNode * rels ;
int nchildren ;
int nmsgs = 0 ;
bool RelcacheInitFileInval = ( bool ) 0 ;
nrels = smgrGetPendingDeletes ( ( ( bool ) 1 ) , & rels );
nchildren = xactGetCommittedChildren ( & children );
int xactGetCommittedChildren(TransactionId **ptr)
TransactionState s = CurrentTransactionState ;
return s -> nChildXids ;
if ( wal_level >= WAL_LEVEL_HOT_STANDBY )
nmsgs = xactGetCommittedInvalidationMessages ( & invalMessages , & RelcacheInitFileInval );
if ( ! markXidCommitted )
if ( nrels > 0 || nmsgs > 0 || RelcacheInitFileInval || forceSyncCommit )
XLogRecData rdata [ 4 ] ;
xl_xact_commit xlrec ;
xlrec . xinfo = 0;
if ( RelcacheInitFileInval )
xlrec . xinfo |= 0x01;
if ( forceSyncCommit )
xlrec . xinfo |= 0x02;
xlrec . dbId = MyDatabaseId;
xlrec . tsId = MyDatabaseTableSpace;
xlrec . xact_time = xactStopTimestamp;
xlrec . nrels = nrels;
xlrec . nsubxacts = nchildren;
xlrec . nmsgs = nmsgs;
rdata [ 0 ] . data = ( ( char * ) ( & xlrec ) );
rdata [ 0 ] . len = ( ( size_t ) ( & ( ( xl_xact_commit * ) 0 ) -> xnodes ) );
rdata [ 0 ] . buffer = 0;
if ( nrels > 0 )
rdata [ 0 ] . next = & rdata [ 1 ];
rdata [ 1 ] . data = ( ( char * ) rels );
rdata [ 1 ] . len = ( nrels * sizeof ( RelFileNode ) );
rdata [ 1 ] . buffer = 0;
rdata [ lastrdata ] . next = & rdata [ 2 ];
rdata [ 2 ] . data = ( ( char * ) children );
rdata [ 2 ] . len = ( nchildren * sizeof ( TransactionId ) );
rdata [ 2 ] . buffer = 0;
rdata [ lastrdata ] . next = & rdata [ 3 ];
rdata [ 3 ] . data = ( ( char * ) invalMessages );
rdata [ 3 ] . len = ( nmsgs * sizeof ( SharedInvalidationMessage ) );
rdata [ 3 ] . buffer = 0;
rdata [ lastrdata ] . next = ( ( void * ) 0 );
( void ) ( XLogInsert ( 1 , 0 , rdata ) );
0
------------------------------
308419 110361/CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fgets_02.c intPointer = ( int * ) malloc ( data * sizeof ( int ) ) 49
void CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fgets_02_bad()
int data ;
data = - 1;
if ( 1 )
char inputBuffer [ CHAR_ARRAY_SIZE ] = "" ;
if ( fgets ( inputBuffer , CHAR_ARRAY_SIZE , stdin ) != NULL )
data = atoi ( inputBuffer );
int * intPointer ;
intPointer = ( int * ) malloc ( data * sizeof ( int ) );
intPointer [ i ] = 0;
printIntLine ( intPointer [ 0 ] );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
free ( intPointer );
1
------------------------------
311081 151926/tile.c stonesoup_tainted_buff = ( char * ) malloc ( buffer_size * sizeof ( char ) ) 66
static int stonesoup_ev_handler(struct mg_connection *conn, enum mg_event ev)
char * ifmatch_header ;
char * stonesoup_tainted_buff ;
int buffer_size = 1000 ;
if ( ev == MG_REQUEST )
ifmatch_header = ( char * ) mg_get_header ( conn , "if-match" );
if ( strcmp ( ifmatch_header , "weak_taint_source_value" ) == 0 )
while ( 1 )
stonesoup_tainted_buff = ( char * ) malloc ( buffer_size * sizeof ( char ) );
data_size = mg_get_var ( conn , "data" , stonesoup_tainted_buff , buffer_size * sizeof ( char ) );
if ( data_size < buffer_size )
buffer_size = buffer_size * 2;
free ( stonesoup_tainted_buff );
stonesoup_handle_taint ( stonesoup_tainted_buff );
void stonesoup_handle_taint(char *dictatorialism_sphagnales)
if ( dictatorialism_sphagnales != 0 )
naveness_cerusites = ( ( int ) ( strlen ( dictatorialism_sphagnales ) ) );
gastroepiploic_dynametric = ( ( char * ) ( malloc ( naveness_cerusites + 1 ) ) );
if ( gastroepiploic_dynametric == 0 )
memset ( gastroepiploic_dynametric , 0 , naveness_cerusites + 1 );
memcpy ( gastroepiploic_dynametric , dictatorialism_sphagnales , naveness_cerusites );
if ( dictatorialism_sphagnales != 0 )
free ( ( ( char * ) dictatorialism_sphagnales ) );
phosphoresce_hubie = & gastroepiploic_dynametric;
sulphinyl_hemostats = ( ( char * ) ( * phosphoresce_hubie ) );
stonesoup_files = fopen ( sulphinyl_hemostats , "r" );
if ( stonesoup_files != 0 )
while ( fscanf ( stonesoup_files , "%79s" , stonesoup_filename ) == 1 && stonesoup_ssi < 1020 )
if ( stonesoup_files != 0 )
fclose ( stonesoup_files );
if ( * phosphoresce_hubie != 0 )
free ( ( ( char * ) ( * phosphoresce_hubie ) ) );
1
------------------------------
312183 153760/aviobuf.c int len = ( ( s -> buffer_size ) - ( dst - s -> buffer ) ) ; 477
unsigned int avio_rb24(AVIOContext *s)
unsigned int val ;
val = avio_rb16 ( s ) << 8;
unsigned int avio_rb16(AVIOContext *s)
unsigned int val ;
val = ( avio_r8 ( s ) << 8 );
int avio_r8(AVIOContext *s)
if ( s -> buf_ptr >= s -> buf_end )
fill_buffer ( s );
static void fill_buffer(AVIOContext *s)
uint8_t * dst = ! s -> max_packet_size && s -> buf_end - s -> buffer < ( s -> buffer_size ) ? s -> buf_end : s -> buffer ;
int len = ( ( s -> buffer_size ) - ( dst - s -> buffer ) ) ;
len = ( ( s -> read_packet ) ( s -> opaque , dst , len ) );
if ( len <= 0 )
if ( len < 0 )
s -> error = len;
s -> pos += len;
s -> buf_ptr = dst;
s -> buf_end = dst + len;
s -> bytes_read += len;
0
------------------------------
306693 118100/CWE78_OS_Command_Injection__char_connect_socket_system_14.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 99
void CWE78_OS_Command_Injection__char_connect_socket_system_14_bad()
char * data ;
char data_buf [ 100 ] = FULL_COMMAND ;
data = data_buf;
if ( globalFive == 5 )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
if ( SYSTEM ( data ) <= 0 )
1
------------------------------
21021 CVE-2016-1981/qemu_1.6.0_CVE-2016-1981_e1000.c sz = tp -> size + bytes 625
static
set_tctl(E1000State *s, int index, uint32_t val)
s -> mac_reg [ index ] = val;
s -> mac_reg [ TDT ] &= 0xffff;
start_xmit ( s );
static
start_xmit(E1000State *s)
struct e1000_tx_desc desc ;
uint32_t tdh_start = s -> mac_reg [ TDH ] , cause = E1000_ICS_TXQE ;
if ( ! ( s -> mac_reg [ TCTL ] & E1000_TCTL_EN ) )
while ( s -> mac_reg [ TDH ] != s -> mac_reg [ TDT ] )
process_tx_desc ( s , & desc );
if ( ++ s -> mac_reg [ TDH ] * sizeof ( desc ) >= s -> mac_reg [ TDLEN ] )
s -> mac_reg [ TDH ] = 0;
if ( s -> mac_reg [ TDH ] == tdh_start )
static
process_tx_desc(E1000State *s, struct e1000_tx_desc *dp)
uint32_t txd_lower = le32_to_cpu ( dp -> lower . data ) ;
uint32_t dtype = txd_lower & ( E1000_TXD_CMD_DEXT | E1000_TXD_DTYP_D ) ;
unsigned int split_size = txd_lower & 0xffff , bytes , sz , op ;
struct e1000_tx * tp = & s -> tx ;
if ( dtype == E1000_TXD_CMD_DEXT )
if ( dtype == ( E1000_TXD_CMD_DEXT | E1000_TXD_DTYP_D ) )
if ( tp -> size == 0 )
tp -> sum_needed = le32_to_cpu ( dp -> upper . data ) >> 8;
tp -> cptse = ( txd_lower & E1000_TXD_CMD_TSE ) ? 1 : 0;
tp -> cptse = 0;
if ( vlan_enabled ( s ) && is_vlan_txd ( txd_lower ) && ( tp -> cptse || txd_lower & E1000_TXD_CMD_EOP ) )
static inline
is_vlan_txd(uint32_t txd_lower)
return ( ( txd_lower & E1000_TXD_CMD_VLE ) != 0 ) ;
static inline
vlan_enabled(E1000State *s)
return ( ( s -> mac_reg [ CTRL ] & E1000_CTRL_VME ) != 0 ) ;
tp -> vlan_needed = 1;
if ( tp -> tse && tp -> cptse )
msh = tp -> hdr_len + tp -> mss;
bytes = split_size;
if ( tp -> size + bytes > msh )
bytes = msh - tp -> size;
bytes = MIN ( sizeof ( tp -> data ) - tp -> size , bytes );
pci_dma_read ( d , addr , tp -> data + tp -> size , bytes );
sz = tp -> size + bytes;
if ( sz >= tp -> hdr_len && tp -> size < tp -> hdr_len )
memmove ( tp -> header , tp -> data , tp -> hdr_len );
tp -> size = sz;
addr += bytes;
if ( sz == msh )
memmove ( tp -> data , tp -> header , tp -> hdr_len );
tp -> size = tp -> hdr_len;
while ( split_size -= bytes )
if ( ! ( tp -> tse && tp -> cptse && tp -> size < tp -> hdr_len ) )
0
------------------------------
314631 96898/CWE36_Absolute_Path_Traversal__wchar_t_connect_socket_open_17.cpp recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ) 101
void bad()
int i ;
wchar_t * data ;
wchar_t dataBuffer [ FILENAME_MAX ] = L ""
data = dataBuffer;
for(i = 0; i < 1; i++)
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( FILENAME_MAX - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
314032 110734/CWE680_Integer_Overflow_to_Buffer_Overflow__new_fixed_66b.cpp dataBytes = data * sizeof ( int ) 55
static void goodG2B()
int data ;
int dataArray [ 5 ] ;
data = - 1;
data = 20;
dataArray [ 2 ] = data;
goodG2BSink ( dataArray );
void goodG2BSink(int dataArray[])
int data = dataArray [ 2 ] ;
size_t dataBytes , i ;
dataBytes = data * sizeof ( int );
intPointer = ( int * ) new char [ dataBytes ];
intPointer [ i ] = 0;
printIntLine ( intPointer [ 0 ] );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
delete [ ] intPointer
0
------------------------------
311415 152169/aviobuf.c len = ( s -> buf_end - s -> buf_ptr ) 534
int avio_read(AVIOContext *s,unsigned char *buf,int size)
int len ;
while ( size > 0 )
len = ( s -> buf_end - s -> buf_ptr );
if ( len > size )
len = size;
if ( len == 0 || s -> write_flag )
if ( ( s -> direct || size > s -> buffer_size ) && ! s -> update_checksum )
if ( s -> read_packet )
len = ( ( s -> read_packet ) ( s -> opaque , buf , size ) );
if ( len <= 0 )
if ( len < 0 )
s -> error = len;
s -> pos += len;
s -> bytes_read += len;
size -= len;
buf += len;
s -> buf_ptr = s -> buffer;
s -> buf_end = s -> buffer;
len = ( s -> buf_end - s -> buf_ptr );
if ( len == 0 )
memcpy ( buf , ( s -> buf_ptr ) , len );
buf += len;
s -> buf_ptr += len;
size -= len;
if ( size1 == size )
if ( s -> error )
return s -> error ;
if ( url_feof ( s ) )
int url_feof(AVIOContext *s)
if ( ! s )
if ( s -> eof_reached )
s -> eof_reached = 0;
fill_buffer ( s );
static void fill_buffer(AVIOContext *s)
uint8_t * dst = ! s -> max_packet_size && s -> buf_end - s -> buffer < ( s -> buffer_size ) ? s -> buf_end : s -> buffer ;
int len = ( ( s -> buffer_size ) - ( dst - s -> buffer ) ) ;
int max_buffer_size = s -> max_packet_size ? s -> max_packet_size : 32768 ;
if ( ! s -> read_packet && s -> buf_ptr >= s -> buf_end )
s -> eof_reached = 1;
if ( s -> eof_reached )
if ( s -> update_checksum && dst == s -> buffer )
if ( s -> buf_end > s -> checksum_ptr )
s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_end - s -> checksum_ptr ) ) );
s -> checksum_ptr = s -> buffer;
if ( s -> read_packet && s -> buffer_size > max_buffer_size )
ffio_set_buf_size ( s , max_buffer_size );
int ffio_set_buf_size(AVIOContext *s,int buf_size)
buffer = ( av_malloc ( buf_size ) );
if ( ! buffer )
av_free ( ( s -> buffer ) );
s -> buffer = buffer;
s -> buffer_size = buf_size;
s -> buf_ptr = buffer;
url_resetbuf ( s , ( s -> write_flag ? 2 : 1 ) );
static int url_resetbuf(AVIOContext *s,int flags)
if ( flags & 2 )
s -> buf_end = s -> buffer + s -> buffer_size;
s -> write_flag = 1;
s -> buf_end = s -> buffer;
s -> write_flag = 0;
s -> checksum_ptr = dst = s -> buffer;
len = s -> buffer_size;
if ( s -> read_packet )
len = ( ( s -> read_packet ) ( s -> opaque , dst , len ) );
if ( len <= 0 )
s -> eof_reached = 1;
if ( len < 0 )
s -> error = len;
s -> pos += len;
s -> buf_ptr = dst;
s -> buf_end = dst + len;
s -> bytes_read += len;
return s -> eof_reached ;
return size1 - size ;
0
------------------------------
17011 CVE-2006-4813/CVE_2006_4813_VULN___block_prepare_write.c block_end = block_start + blocksize 94
static int CVE_2006_4813_VULN___block_prepare_write(struct inode *inode, struct page
unsigned from, unsigned to, get_block_t *get_block)
unsigned block_start , block_end ;
sector_t block ;
int err = 0 ;
unsigned blocksize , bbits ;
struct buffer_head * bh , * head , * wait [ 2 ] , * * wait_bh = wait ;
blocksize = 1 << inode -> i_blkbits;
head = page_buffers ( page );
bbits = inode -> i_blkbits;
block = ( sector_t ) page -> index << ( PAGE_CACHE_SHIFT - bbits );
for(bh = head, block_start = 0; bh != head ||
block++, block_start=block_end, bh = bh->b_this_page)
block_end = block_start + blocksize;
if ( block_end <= from || block_start >= to )
if ( ! buffer_mapped ( bh ) )
err = get_block ( inode , block , bh , 1 );
if ( err )
if ( buffer_new ( bh ) )
if ( PageUptodate ( page ) )
if ( ! buffer_uptodate ( bh ) && ! buffer_delay ( bh ) && ( block_start < from || block_end > to ) )
* wait_bh ++ = bh;
while ( wait_bh > wait )
if ( ! buffer_uptodate ( * wait_bh ) )
err = - EIO;
if ( ! err )
bh = head;
block_start = 0;
block_end = block_start + blocksize;
if ( block_end <= from )
if ( block_start >= to )
block_start = block_end;
bh = bh -> b_this_page;
while ( bh != head )
0
------------------------------
303449 80393/CWE134_Uncontrolled_Format_String__char_listen_socket_snprintf_84_bad.cpp recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 98
void bad()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
CWE134_Uncontrolled_Format_String__char_listen_socket_snprintf_84_bad * badObject = new CWE134_Uncontrolled_Format_String__char_listen_socket_snprintf_84_bad ( data ) ;
CWE134_Uncontrolled_Format_String__char_listen_socket_snprintf_84_bad::CWE134_Uncontrolled_Format_String__char_listen_socket_snprintf_84_bad(char * dataCopy)
data = dataCopy;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
0
------------------------------
20924 CVE-2015-8962/linux_kernel_4.3_CVE_2015_8962_drivers_scsi_sg.c ret_sz = 1 << ( PAGE_SHIFT + order ) 1857
static
sg_new_write(Sg_fd *sfp, struct file *file, const char __user
size_t count, int blocking, int read_only, int
Sg_request **o_srp)
int k ;
Sg_request * srp ;
sg_io_hdr_t * hp ;
unsigned char cmnd [ SG_MAX_CDB_SIZE ] ;
int timeout ;
unsigned long ul_timeout ;
if ( count < SZ_SG_IO_HDR )
if ( ! access_ok ( VERIFY_READ , buf , count ) )
sfp -> cmd_q = 1;
if ( ! ( srp = sg_add_request ( sfp ) ) )
srp -> sg_io_owned = sg_io_owned;
hp = & srp -> header;
if ( __copy_from_user ( hp , buf , SZ_SG_IO_HDR ) )
if ( hp -> interface_id != 'S' )
if ( hp -> flags & SG_FLAG_MMAP_IO )
if ( hp -> dxfer_len > sfp -> reserve . bufflen )
if ( hp -> flags & SG_FLAG_DIRECT_IO )
if ( sg_res_in_use ( sfp ) )
ul_timeout = msecs_to_jiffies ( srp -> header . timeout );
timeout = ( ul_timeout < INT_MAX ) ? ul_timeout : INT_MAX;
if ( ( ! hp -> cmdp ) || ( hp -> cmd_len < 6 ) || ( hp -> cmd_len > sizeof ( cmnd ) ) )
if ( ! access_ok ( VERIFY_READ , hp -> cmdp , hp -> cmd_len ) )
if ( __copy_from_user ( cmnd , hp -> cmdp , hp -> cmd_len ) )
if ( read_only && sg_allow_access ( file , cmnd ) )
k = sg_common_write ( sfp , srp , cmnd , timeout , blocking );
static
sg_common_write(Sg_fd * sfp, Sg_request *
unsigned char *cmnd, int timeout, int blocking)
int k , at_head ;
srp -> data . cmd_opcode = cmnd [ 0 ];
k = sg_start_req ( srp , cmnd );
static
sg_start_req(Sg_request *srp, unsigned char *cmd)
int res ;
struct request * rq ;
Sg_fd * sfp = srp -> parentfp ;
sg_io_hdr_t * hp = & srp -> header ;
int dxfer_len = ( int ) hp -> dxfer_len ;
int dxfer_dir = hp -> dxfer_direction ;
unsigned int iov_count = hp -> iovec_count ;
Sg_scatter_hold * req_schp = & srp -> data ;
Sg_scatter_hold * rsv_schp = & sfp -> reserve ;
struct request_queue * q = sfp -> parentdp -> device -> request_queue ;
struct rq_map_data * md , map_data ;
int rw = hp -> dxfer_direction == SG_DXFER_TO_DEV ? WRITE : READ ;
if ( hp -> cmd_len > BLK_MAX_CDB )
long_cmdp = kzalloc ( hp -> cmd_len , GFP_KERNEL );
if ( ! long_cmdp )
rq = blk_get_request ( q , rw , GFP_KERNEL );
if ( IS_ERR ( rq ) )
if ( ( dxfer_len <= 0 ) || ( dxfer_dir == SG_DXFER_NONE ) )
if ( sg_allow_dio && hp -> flags & SG_FLAG_DIRECT_IO && dxfer_dir != SG_DXFER_UNKNOWN && ! iov_count && ! sfp -> parentdp -> device -> host -> unchecked_isa_dma && blk_rq_aligned ( q , ( unsigned long ) hp -> dxferp , dxfer_len ) )
md = NULL;
md = & map_data;
if ( md )
if ( ! sg_res_in_use ( sfp ) && dxfer_len <= rsv_schp -> bufflen )
res = sg_build_indirect ( req_schp , sfp , dxfer_len );
static
sg_build_indirect(Sg_scatter_hold * schp, Sg_fd * sfp, int buff_size)
int sg_tablesize = sfp -> parentdp -> sg_tablesize ;
int blk_size = buff_size , order ;
gfp_t gfp_mask = GFP_ATOMIC | __GFP_COMP | __GFP_NOWARN ;
if ( blk_size < 0 )
blk_size = ALIGN ( blk_size , SG_SECTOR_SZ );
mx_sc_elems = sg_build_sgat ( schp , sfp , sg_tablesize );
if ( mx_sc_elems < 0 )
num = scatter_elem_sz;
if ( sfp -> low_dma )
gfp_mask |= GFP_DMA;
if ( ! capable ( CAP_SYS_ADMIN ) || ! capable ( CAP_SYS_RAWIO ) )
gfp_mask |= __GFP_ZERO;
order = get_order ( num );
ret_sz = 1 << ( PAGE_SHIFT + order );
for (k = 0, rem_sz = blk_size; rem_sz > 0 && k <
k++, rem_sz -= ret_sz)
num = ( rem_sz > scatter_elem_sz_prev ) ? scatter_elem_sz_prev : rem_sz;
schp -> pages [ k ] = alloc_pages ( gfp_mask , order );
if ( ! schp -> pages [ k ] )
if ( num == scatter_elem_sz_prev )
if ( unlikely ( ret_sz > scatter_elem_sz_prev ) )
scatter_elem_sz = ret_sz;
scatter_elem_sz_prev = ret_sz;
SCSI_LOG_TIMEOUT ( 5 , sg_printk ( KERN_INFO , sfp -> parentdp , "sg_build_indirect: k=%d, num=%d, ret_sz=%d\n" , k , num , ret_sz ) );
schp -> page_order = order;
schp -> k_use_sg = k;
SCSI_LOG_TIMEOUT ( 5 , sg_printk ( KERN_INFO , sfp -> parentdp , "sg_build_indirect: k_use_sg=%d, rem_sz=%d\n" , k , rem_sz ) );
schp -> bufflen = blk_size;
if ( rem_sz > 0 )
for (i = 0; i < k; i++)
__free_pages ( schp -> pages [ i ] , order );
if ( -- order >= 0 )
0
------------------------------
20634 CVE-2016-8910/qemu_2.3.0_CVE-2016-8910_rtl8139.c ret = s -> phys [ addr - MAC0 ] 2968
static uint64_t rtl8139_ioport_read(void *opaque, hwaddr
unsigned size)
switch ( size )
return rtl8139_io_readb ( opaque , addr ) ;
static uint32_t rtl8139_io_readb(void *opaque, uint8_t addr)
RTL8139State * s = opaque ;
int ret ;
switch ( addr )
ret = s -> phys [ addr - MAC0 ];
DPRINTF ( "MediaStatus read 0x%x\n" , ret );
DPRINTF ( "HltClk read 0x%x\n" , ret );
DPRINTF ( "PCI Revision ID read 0x%x\n" , ret );
DPRINTF ( "C+ TxThresh read(b) val=0x%02x\n" , ret );
DPRINTF ( "RTL8139C TxConfig at 0x43 read(b) val=0x%02x\n" , ret );
return ret ;
0
------------------------------
308695 110417/CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fixed_10.c intPointer = ( int * ) malloc ( data * sizeof ( int ) ) 99
static void goodG2B2()
int data ;
data = - 1;
if ( globalTrue )
data = 20;
int * intPointer ;
intPointer = ( int * ) malloc ( data * sizeof ( int ) );
intPointer [ i ] = 0;
printIntLine ( intPointer [ 0 ] );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
free ( intPointer );
0
------------------------------
309469 149306/resowner.c owner -> catrefs = ( ( HeapTuple * ) ( MemoryContextAlloc ( TopMemoryContext , newmax * sizeof ( HeapTuple ) ) ) ) 627
void ResourceOwnerEnlargeCatCacheRefs(ResourceOwner owner)
int newmax ;
if ( owner -> ncatrefs < owner -> maxcatrefs )
if ( owner -> catrefs == ( ( void * ) 0 ) )
newmax = 16;
owner -> catrefs = ( ( HeapTuple * ) ( MemoryContextAlloc ( TopMemoryContext , newmax * sizeof ( HeapTuple ) ) ) );
owner -> maxcatrefs = newmax;
newmax = owner -> maxcatrefs * 2;
owner -> catrefs = ( ( HeapTuple * ) ( repalloc ( ( owner -> catrefs ) , newmax * sizeof ( HeapTuple ) ) ) );
owner -> maxcatrefs = newmax;
0
------------------------------
311869 150151/pgstat.c len = ( ( ( size_t ) ( & ( ( PgStat_MsgTabstat * ) 0 ) -> m_entry [ 0 ] ) ) + n * sizeof ( PgStat_TableEntry ) ) 765
static void pgstat_beshutdown_hook(int code,Datum arg)
if ( ( bool ) ( MyDatabaseId != ( ( Oid ) 0 ) ) )
pgstat_report_stat ( ( ( bool ) 1 ) );
void pgstat_report_stat(bool force)
static const PgStat_TableCounts all_zeroes ;
static TimestampTz last_report = 0 ;
TimestampTz now ;
PgStat_MsgTabstat regular_msg ;
PgStat_MsgTabstat shared_msg ;
TabStatusArray * tsa ;
int i ;
if ( ( pgStatTabList == ( ( void * ) 0 ) || pgStatTabList -> tsa_used == 0 ) && ! have_function_stats && ! force )
now = GetCurrentTransactionStopTimestamp ( );
if ( ! force && ! TimestampDifferenceExceeds ( last_report , now , 500 ) )
regular_msg . m_databaseid = MyDatabaseId;
shared_msg . m_databaseid = ( ( Oid ) 0 );
regular_msg . m_nentries = 0;
shared_msg . m_nentries = 0;
for (tsa = pgStatTabList; tsa != ((void *)0); tsa = tsa -> tsa_next)
for (i = 0; i < tsa -> tsa_used; i++)
PgStat_TableStatus * entry = & tsa -> tsa_entries [ i ] ;
PgStat_MsgTabstat * this_msg ;
if ( memcmp ( ( & entry -> t_counts ) , ( & all_zeroes ) , sizeof ( PgStat_TableCounts ) ) == 0 )
this_msg = ( entry -> t_shared ? & shared_msg : & regular_msg );
if ( ( ++ this_msg -> m_nentries ) >= ( 1000 - sizeof ( PgStat_MsgHdr ) - sizeof ( Oid ) - 3 * sizeof ( int ) ) / sizeof ( PgStat_TableEntry ) )
pgstat_send_tabstat ( this_msg );
this_msg -> m_nentries = 0;
tsa -> tsa_used = 0;
static void pgstat_send_tabstat(PgStat_MsgTabstat *tsmsg)
int n ;
int len ;
if ( pgStatSock == - 1 )
if ( ( bool ) ( tsmsg -> m_databaseid != ( ( Oid ) 0 ) ) )
tsmsg -> m_xact_commit = pgStatXactCommit;
tsmsg -> m_xact_rollback = pgStatXactRollback;
tsmsg -> m_block_read_time = pgStatBlockReadTime;
tsmsg -> m_block_write_time = pgStatBlockWriteTime;
tsmsg -> m_xact_commit = 0;
tsmsg -> m_xact_rollback = 0;
tsmsg -> m_block_read_time = 0;
tsmsg -> m_block_write_time = 0;
n = tsmsg -> m_nentries;
len = ( ( ( size_t ) ( & ( ( PgStat_MsgTabstat * ) 0 ) -> m_entry [ 0 ] ) ) + n * sizeof ( PgStat_TableEntry ) );
pgstat_send ( tsmsg , len );
0
------------------------------
314198 96940/CWE36_Absolute_Path_Traversal__wchar_t_connect_socket_w32CreateFile_11.cpp recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ) 93
void bad()
wchar_t * data ;
wchar_t dataBuffer [ FILENAME_MAX ] = L ""
data = dataBuffer;
if ( globalReturnsTrue ( ) )
int globalReturnsTrue()
return 1 ;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( FILENAME_MAX - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
302661 83526/CWE190_Integer_Overflow__int_listen_socket_square_41.c int result = data * data ; 141
static void goodG2B()
int data ;
data = 0;
data = 2;
goodG2BSink ( data );
static void goodG2BSink(int data)
int result = data * data ;
printIntLine ( result );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
0
------------------------------
21190 CVE-2015-5307/linux_kernel_4.2.6_CVE_2015_5307_arch_x86_kvm_vmx.c __clear_bit ( msr , msr_bitmap + 0x000 / f ) 4202
static __init int hardware_setup(void)
vmx_io_bitmap_a = ( unsigned long * ) __get_free_page ( GFP_KERNEL );
if ( ! vmx_io_bitmap_a )
vmx_io_bitmap_b = ( unsigned long * ) __get_free_page ( GFP_KERNEL );
if ( ! vmx_io_bitmap_b )
vmx_msr_bitmap_legacy = ( unsigned long * ) __get_free_page ( GFP_KERNEL );
if ( ! vmx_msr_bitmap_legacy )
vmx_msr_bitmap_legacy_x2apic = ( unsigned long * ) __get_free_page ( GFP_KERNEL );
if ( ! vmx_msr_bitmap_legacy_x2apic )
vmx_msr_bitmap_longmode = ( unsigned long * ) __get_free_page ( GFP_KERNEL );
if ( ! vmx_msr_bitmap_longmode )
vmx_msr_bitmap_longmode_x2apic = ( unsigned long * ) __get_free_page ( GFP_KERNEL );
if ( ! vmx_msr_bitmap_longmode_x2apic )
if ( nested )
vmx_msr_bitmap_nested = ( unsigned long * ) __get_free_page ( GFP_KERNEL );
if ( ! vmx_msr_bitmap_nested )
vmx_vmread_bitmap = ( unsigned long * ) __get_free_page ( GFP_KERNEL );
if ( ! vmx_vmread_bitmap )
vmx_vmwrite_bitmap = ( unsigned long * ) __get_free_page ( GFP_KERNEL );
if ( ! vmx_vmwrite_bitmap )
if ( setup_vmcs_config ( & vmcs_config ) < 0 )
if ( ! cpu_has_vmx_apicv ( ) )
enable_apicv = 0;
if ( enable_apicv )
vmx_disable_intercept_msr_write_x2apic ( 0x808 );
static void vmx_disable_intercept_msr_write_x2apic(u32 msr)
__vmx_disable_intercept_for_msr ( vmx_msr_bitmap_longmode_x2apic , msr , MSR_TYPE_W );
static void __vmx_disable_intercept_for_msr(unsigned long
u32 msr, int type)
int f = sizeof ( unsigned long ) ;
if ( ! cpu_has_vmx_msr_bitmap ( ) )
if ( msr <= 0x1fff )
if ( type & MSR_TYPE_R )
__clear_bit ( msr , msr_bitmap + 0x000 / f );
0
------------------------------
16278 CVE-2012-3972/CVE_2012_3972_PATCHED_txFormatNumberFunctionCall__evaluate.c res . SetLength ( res . Length ( ) + intDigits + 1 + maxFractionSize + ( intDigits - 1 ) / groupSize ) 249

CVE_2012_3972_PATCHED_txFormatNumberFunctionCall::evaluate(txIEvalContext*
txAExprResult** aResult)
if ( ! requireParams ( 2 , 3 , aContext ) )
double value ;
txExpandedName formatName ;
nsAutoString formatStr ;
txDecimalFormat * format = mStylesheet -> getDecimalFormat ( formatName ) ;
if ( ! format )
if ( MOZ_DOUBLE_IS_NaN ( value ) )
if ( value == MOZ_DOUBLE_POSITIVE_INFINITY ( ) )
if ( value == MOZ_DOUBLE_NEGATIVE_INFINITY ( ) )
nsAutoString res ;
int minIntegerSize = 0 ;
int maxFractionSize = 0 ;
int multiplier = 1 ;
int groupSize = - 1 ;
PRUint32 pos = 0 ;
PRUint32 formatLen = formatStr . Length ( ) ;
bool inQuote ;
inQuote = false;
if ( MOZ_DOUBLE_IS_NEGATIVE ( value ) )
while ( pos < formatLen && ( inQuote || formatStr . CharAt ( pos ) != format -> mPatternSeparator ) )
if ( formatStr . CharAt ( pos ) == FORMAT_QUOTE )
inQuote = ! inQuote;
pos ++;
if ( pos == formatLen )
pos = 0;
pos ++;
FormatParseState pState = Prefix ;
inQuote = false;
PRUnichar c = 0 ;
while ( pos < formatLen && pState != Finished )
c = formatStr . CharAt ( pos ++ );
switch ( pState )
if ( ! inQuote )
if ( c == format -> mPercent )
if ( multiplier == 1 )
multiplier = 100;
if ( c == format -> mPerMille )
if ( multiplier == 1 )
multiplier = 1000;
if ( c == format -> mDecimalSeparator || c == format -> mGroupingSeparator || c == format -> mZeroDigit || c == format -> mDigit || c == format -> mPatternSeparator )
pState = pState == Prefix ? IntDigit : Finished;
pos --;
if ( c == FORMAT_QUOTE )
inQuote = ! inQuote;
if ( c == format -> mGroupingSeparator )
groupSize = 0;
if ( c == format -> mDigit )
if ( groupSize >= 0 )
groupSize ++;
pState = IntZero;
pos --;
if ( c == format -> mGroupingSeparator )
groupSize = 0;
if ( c == format -> mZeroDigit )
if ( groupSize >= 0 )
groupSize ++;
minIntegerSize ++;
if ( c == format -> mDecimalSeparator )
pState = FracZero;
pState = Suffix;
pos --;
if ( c == format -> mZeroDigit )
maxFractionSize ++;
pState = FracDigit;
pos --;
if ( c == format -> mDigit )
maxFractionSize ++;
pState = Suffix;
pos --;
if ( ( c != format -> mPatternSeparator && pos < formatLen ) || inQuote || groupSize == 0 )
nsAutoString res ( prefix ) ;
PRIntn bufIntDigits , sign ;
int intDigits ;
intDigits = bufIntDigits > minIntegerSize ? bufIntDigits : minIntegerSize;
if ( groupSize < 0 )
groupSize = intDigits + 10;
res . SetLength ( res . Length ( ) + intDigits + 1 + maxFractionSize + ( intDigits - 1 ) / groupSize );
0
------------------------------
18575 CVE-2015-2716/Firefox_37.0b7_CVE_2015_2716_parser_expat_lib_xmlparse.c tem = ( BLOCK * ) pool -> mem -> malloc_fcn ( offsetof ( BLOCK , s ) + blockSize * sizeof ( XML_Char ) ) 6275
static ATTRIBUTE_ID
getAttributeId(XML_Parser parser, const ENCODING
const char *start, const char *end)
DTD * const dtd = _dtd
const XML_Char * name ;
if ( ! poolAppendChar ( & dtd -> pool , XML_T ( '\0' ) ) )
name = poolStoreString ( & dtd -> pool , enc , start , end );
static XML_Char
poolStoreString(STRING_POOL *pool, const ENCODING
const char *ptr, const char *end)
if ( ! poolAppend ( pool , enc , ptr , end ) )
static XML_Char
poolAppend(STRING_POOL *pool, const ENCODING
const char *ptr, const char *end)
if ( ! pool -> ptr && ! poolGrow ( pool ) )
static XML_Bool
poolGrow(STRING_POOL *pool)
if ( pool -> freeBlocks )
if ( pool -> start == 0 )
if ( pool -> end - pool -> start < pool -> freeBlocks -> size )
if ( pool -> blocks && pool -> start == pool -> blocks -> s )
BLOCK * tem ;
int blockSize = ( int ) ( pool -> end - pool -> start ) ;
if ( blockSize < INIT_BLOCK_SIZE )
blockSize = INIT_BLOCK_SIZE;
blockSize *= 2;
tem = ( BLOCK * ) pool -> mem -> malloc_fcn ( offsetof ( BLOCK , s ) + blockSize * sizeof ( XML_Char ) );
if ( ! tem )
tem -> size = blockSize;
tem -> next = pool -> blocks;
pool -> blocks = tem;
if ( pool -> ptr != pool -> start )
memcpy ( tem -> s , pool -> start , ( pool -> ptr - pool -> start ) * sizeof ( XML_Char ) );
pool -> ptr = tem -> s + ( pool -> ptr - pool -> start );
pool -> start = tem -> s;
pool -> end = tem -> s + blockSize;
0
------------------------------
307648 113052/CWE761_Free_Pointer_Not_at_Start_of_Buffer__wchar_t_listen_socket_06.c recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 ) 100
void CWE761_Free_Pointer_Not_at_Start_of_Buffer__wchar_t_listen_socket_06_bad()
wchar_t * data ;
data = ( wchar_t * ) malloc ( 100 * sizeof ( wchar_t ) );
data [ 0 ] = L '\0'
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
17763 CVE-2016-5107/qemu_2.3.0_CVE-2016-5107_megasas.c cmd -> iov_size = dcmd_size - resid 1256
static void megasas_command_complete(SCSIRequest *req, uint32_t
size_t resid)
MegasasCmd * cmd = req -> hba_private ;
if ( cmd -> req != req )
cmd_status = megasas_finish_internal_command ( cmd , req , resid );
static int megasas_finish_internal_command(MegasasCmd
SCSIRequest *req, size_t resid)
if ( cmd -> frame -> header . frame_cmd == MFI_CMD_DCMD )
cmd -> iov_size -= resid;
retval = megasas_finish_internal_dcmd ( cmd , req );
static int megasas_finish_internal_dcmd(MegasasCmd
SCSIRequest *req)
int opcode ;
int lun = req -> lun ;
opcode = le32_to_cpu ( cmd -> frame -> dcmd . opcode );
switch ( opcode )
retval = megasas_ld_get_info_submit ( req -> dev , lun , cmd );
static int megasas_ld_get_info_submit(SCSIDevice *sdev, int
MegasasCmd *cmd)
size_t dcmd_size = sizeof ( struct mfi_ld_info ) ;
uint8_t cdb [ 6 ] ;
SCSIRequest * req ;
ssize_t len , resid ;
if ( ! cmd -> iov_buf )
cmd -> iov_buf = g_malloc0 ( dcmd_size );
req = scsi_req_new ( sdev , cmd -> index , lun , cdb , cmd );
if ( ! req )
len = scsi_req_enqueue ( req );
if ( len > 0 )
cmd -> iov_size = len;
resid = dma_buf_read ( cmd -> iov_buf , dcmd_size , & cmd -> qsg );
cmd -> iov_size = dcmd_size - resid;
cmd -> iov_buf = NULL;
0
------------------------------
313506 91802/CWE23_Relative_Path_Traversal__wchar_t_listen_socket_ifstream_15.cpp recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ) 107
void bad()
wchar_t * data ;
wchar_t dataBuffer [ FILENAME_MAX ] = BASEPATH ;
data = dataBuffer;
switch ( 6 )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( FILENAME_MAX - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
16729 CVE-2012-5669/CVE_2012_5669_PATCHED__bdf_parse_glyphs.c glyph -> swidth = ( unsigned short ) FT_MulDiv ( glyph -> dwidth , 72000L , ( FT_Long ) ( font -> point_size * font -> resolution_x ) ) 361
static
CVE_2012_5669_PATCHED__bdf_parse_glyphs( char*
unsigned long
unsigned long
void*
void*          client_data )
_bdf_parse_t * p ;
bdf_glyph_t * glyph ;
bdf_font_t * font ;
p = ( _bdf_parse_t * ) client_data;
font = p -> font;
if ( ft_memcmp ( line , "COMMENT" , 7 ) == 0 )
if ( ! ( p -> flags & _BDF_GLYPHS ) )
if ( ft_memcmp ( line , "ENDFONT" , 7 ) == 0 )
if ( ft_memcmp ( line , "ENDCHAR" , 7 ) == 0 )
if ( ( p -> flags & _BDF_GLYPH ) && p -> glyph_enc == - 1 && p -> opts -> keep_unencoded == 0 )
if ( ft_memcmp ( line , "STARTCHAR" , 9 ) == 0 )
if ( ft_memcmp ( line , "ENCODING" , 8 ) == 0 )
if ( p -> glyph_enc == - 1 )
glyph = font -> unencoded + ( font -> unencoded_used - 1 );
glyph = font -> glyphs + ( font -> glyphs_used - 1 );
if ( p -> flags & _BDF_BITMAP )
if ( ft_memcmp ( line , "SWIDTH" , 6 ) == 0 )
if ( ft_memcmp ( line , "DWIDTH" , 6 ) == 0 )
if ( ! ( p -> flags & _BDF_ENCODING ) )
error = _bdf_list_split ( & p -> list , ( char * ) " +" , line , linelen );
if ( error )
glyph -> dwidth = ( unsigned short ) _bdf_atoul ( p -> list . field [ 1 ] , 0 , 10 );
if ( ! ( p -> flags & _BDF_SWIDTH ) )
glyph -> swidth = ( unsigned short ) FT_MulDiv ( glyph -> dwidth , 72000L , ( FT_Long ) ( font -> point_size * font -> resolution_x ) );
0
------------------------------
303314 80456/CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_15.c recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 232
static void goodB2G1()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
switch ( 6 )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
goodB2G1VaSinkG ( data , data );
static void goodB2G1VaSinkG(char * data, ...)
va_start ( args , data );
0
------------------------------
307588 110521/CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_listen_socket_18.c intPointer = ( int * ) malloc ( data * sizeof ( int ) ) 153
static void goodG2B()
int data ;
data = - 1;
data = 20;
int * intPointer ;
intPointer = ( int * ) malloc ( data * sizeof ( int ) );
intPointer [ i ] = 0;
printIntLine ( intPointer [ 0 ] );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
free ( intPointer );
0
------------------------------
21206 CVE-2015-5307/linux_kernel_4.2.6_CVE_2015_5307_arch_x86_kvm_vmx.c __set_bit ( msr , msr_bitmap + 0x400 / f ) 4247
static int nested_vmx_run(struct kvm_vcpu *vcpu, bool launch)
struct vmcs12 * vmcs12 ;
int cpu ;
struct loaded_vmcs * vmcs02 ;
bool ia32e ;
if ( ! nested_vmx_check_permission ( vcpu ) || ! nested_vmx_check_vmcs12 ( vcpu ) )
vmcs12 = get_vmcs12 ( vcpu );
if ( vmcs12 -> vm_entry_controls & VM_ENTRY_LOAD_IA32_EFER )
ia32e = ( vmcs12 -> vm_entry_controls & VM_ENTRY_IA32E_MODE ) != 0;
if ( ! kvm_valid_efer ( vcpu , vmcs12 -> guest_ia32_efer ) || ia32e != ! ! ( vmcs12 -> guest_ia32_efer & EFER_LMA ) || ( ( vmcs12 -> guest_cr0 & X86_CR0_PG ) && ia32e != ! ! ( vmcs12 -> guest_ia32_efer & EFER_LME ) ) )
if ( vmcs12 -> vm_exit_controls & VM_EXIT_LOAD_IA32_EFER )
ia32e = ( vmcs12 -> vm_exit_controls & VM_EXIT_HOST_ADDR_SPACE_SIZE ) != 0;
if ( ! kvm_valid_efer ( vcpu , vmcs12 -> host_ia32_efer ) || ia32e != ! ! ( vmcs12 -> host_ia32_efer & EFER_LMA ) || ia32e != ! ! ( vmcs12 -> host_ia32_efer & EFER_LME ) )
vmcs02 = nested_get_current_vmcs02 ( vmx );
if ( ! vmcs02 )
cpu = get_cpu ( );
vcpu -> cpu = cpu;
prepare_vmcs02 ( vcpu , vmcs12 );
static void prepare_vmcs02(struct kvm_vcpu *vcpu, struct vmcs12 *vmcs12)
struct vcpu_vmx * vmx = to_vmx ( vcpu ) ;
u32 exec_control ;
exec_control = vmcs12 -> pin_based_vm_exec_control;
exec_control |= vmcs_config . pin_based_exec_ctrl;
exec_control &= ~PIN_BASED_VMX_PREEMPTION_TIMER;
if ( nested_cpu_has_posted_intr ( vmcs12 ) )
vmx -> nested . posted_intr_nv = vmcs12 -> posted_intr_nv;
vmx -> nested . pi_pending = false;
exec_control &= ~PIN_BASED_POSTED_INTR;
vmx -> nested . preemption_timer_expired = false;
if ( cpu_has_secondary_exec_ctrls ( ) )
exec_control = vmx_secondary_exec_control ( vmx );
if ( ! vmx -> rdtscp_enabled )
exec_control &= ~SECONDARY_EXEC_RDTSCP;
exec_control &= ~ ( SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES | SECONDARY_EXEC_RDTSCP | SECONDARY_EXEC_VIRTUAL_INTR_DELIVERY | SECONDARY_EXEC_APIC_REGISTER_VIRT );
if ( nested_cpu_has ( vmcs12 , CPU_BASED_ACTIVATE_SECONDARY_CONTROLS ) )
exec_control |= vmcs12 -> secondary_vm_exec_control;
if ( exec_control & SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES )
if ( ! ( nested_cpu_has_virt_x2apic_mode ( vmcs12 ) ) && ( vm_need_virtualize_apic_accesses ( vmx -> vcpu . kvm ) ) )
exec_control |= SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES;
vmx -> host_rsp = 0;
exec_control = vmx_exec_control ( vmx );
exec_control &= ~CPU_BASED_VIRTUAL_INTR_PENDING;
exec_control &= ~CPU_BASED_VIRTUAL_NMI_PENDING;
exec_control &= ~CPU_BASED_TPR_SHADOW;
exec_control |= vmcs12 -> cpu_based_vm_exec_control;
if ( cpu_has_vmx_msr_bitmap ( ) && exec_control & CPU_BASED_USE_MSR_BITMAPS )
nested_vmx_merge_msr_bitmap ( vcpu , vmcs12 );
static inline bool nested_vmx_merge_msr_bitmap(struct kvm_vcpu
struct vmcs12 *vmcs12)
struct page * page ;
unsigned long * msr_bitmap ;
if ( ! nested_cpu_has_virt_x2apic_mode ( vmcs12 ) )
page = nested_get_page ( vcpu , vmcs12 -> msr_bitmap );
if ( ! page )
msr_bitmap = ( unsigned long * ) kmap ( page );
if ( ! msr_bitmap )
if ( nested_cpu_has_virt_x2apic_mode ( vmcs12 ) )
__vmx_enable_intercept_for_msr ( vmx_msr_bitmap_nested , APIC_BASE_MSR + ( APIC_SELF_IPI >> 4 ) , MSR_TYPE_W );
static void __vmx_enable_intercept_for_msr(unsigned long
u32 msr, int type)
int f = sizeof ( unsigned long ) ;
if ( ! cpu_has_vmx_msr_bitmap ( ) )
if ( msr <= 0x1fff )
if ( ( msr >= 0xc0000000 ) && ( msr <= 0xc0001fff ) )
msr &= 0x1fff;
if ( type & MSR_TYPE_R )
__set_bit ( msr , msr_bitmap + 0x400 / f );
0
------------------------------
302233 80504/CWE134_Uncontrolled_Format_String__char_listen_socket_w32_vsnprintf_15.c recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 113
void CWE134_Uncontrolled_Format_String__char_listen_socket_w32_vsnprintf_15_bad()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
switch ( 6 )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
badVaSinkB ( data , data );
static void badVaSinkB(char * data, ...)
va_start ( args , data );
vsnprintf ( dest , 100 - 1 , data , args );
printLine ( dest );
void printLine (const char * line)
if ( line != NULL )
printf ( "%s\n" , line );
1
------------------------------
302983 79303/CWE134_Uncontrolled_Format_String__char_connect_socket_vprintf_14.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 102
void CWE134_Uncontrolled_Format_String__char_connect_socket_vprintf_14_bad()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
if ( globalFive == 5 )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
badVaSinkB ( data , data );
static void badVaSinkB(char * data, ...)
va_start ( args , data );
vprintf ( data , args );
1
------------------------------
303288 84540/CWE190_Integer_Overflow__unsigned_int_max_square_52c.c unsigned int result = data * data ; 42
static void goodG2B()
unsigned int data ;
data = 0;
data = 2;
CWE190_Integer_Overflow__unsigned_int_max_square_52b_goodG2BSink ( data );
void CWE190_Integer_Overflow__unsigned_int_max_square_52b_goodG2BSink(unsigned int data)
CWE190_Integer_Overflow__unsigned_int_max_square_52c_goodG2BSink ( data );
void CWE190_Integer_Overflow__unsigned_int_max_square_52c_goodG2BSink(unsigned int data)
unsigned int result = data * data ;
printUnsignedLine ( result );
void printUnsignedLine(unsigned unsignedNumber)
printf ( "%u\n" , unsignedNumber );
0
------------------------------
17683 CVE-2013-1678/CVE_2013_1678_VULN__cairo_xlib_surface_add_glyph.c int c = glyph_surface -> stride * glyph_surface -> height ; 123
static
CVE_2013_1678_VULN__cairo_xlib_surface_add_glyph (cairo_xlib_display_t
cairo_scaled_font_t
cairo_scaled_glyph_t **pscaled_glyph)
unsigned long glyph_index ;
cairo_scaled_glyph_t * scaled_glyph = * pscaled_glyph ;
cairo_image_surface_t * glyph_surface = scaled_glyph -> surface ;
cairo_xlib_font_glyphset_info_t * glyphset_info ;
glyph_index = _cairo_scaled_glyph_index ( scaled_glyph );
glyphset_info = _cairo_xlib_scaled_font_get_glyphset_info_for_pending_free_glyph ( scaled_font , glyph_index , glyph_surface );
if ( glyphset_info != NULL )
if ( ! glyph_surface )
status = _cairo_scaled_glyph_lookup ( scaled_font , glyph_index , CAIRO_SCALED_GLYPH_INFO_METRICS | CAIRO_SCALED_GLYPH_INFO_SURFACE , pscaled_glyph );
if ( unlikely ( status ) )
scaled_glyph = * pscaled_glyph;
glyph_surface = scaled_glyph -> surface;
if ( scaled_font -> surface_private == NULL )
status = _cairo_xlib_surface_font_init ( display , scaled_font );
if ( unlikely ( status ) )
glyphset_info = _cairo_xlib_scaled_font_get_glyphset_info_for_format ( scaled_font , glyph_surface -> format );
int len = cairo_format_stride_for_width ( glyphset_info -> format , glyph_surface -> width ) * glyph_surface -> height ;
int max_request_size = ( XExtendedMaxRequestSize ( display -> display ) ? XExtendedMaxRequestSize ( display -> display ) : XMaxRequestSize ( display -> display ) ) * 4 - sz_xRenderAddGlyphsReq - sz_xGlyphInfo - 8 ;
if ( len >= max_request_size )
if ( glyph_surface -> width == 0 || glyph_surface -> height == 0 )
cairo_surface_t * tmp_surface ;
tmp_surface = cairo_image_surface_create ( glyphset_info -> format , 1 , 1 );
status = tmp_surface -> status;
if ( unlikely ( status ) )
tmp_surface -> device_transform = glyph_surface -> base . device_transform;
tmp_surface -> device_transform_inverse = glyph_surface -> base . device_transform_inverse;
glyph_surface = ( cairo_image_surface_t * ) tmp_surface;
if ( glyph_surface -> format != glyphset_info -> format )
cairo_surface_pattern_t pattern ;
cairo_surface_t * tmp_surface ;
tmp_surface = cairo_image_surface_create ( glyphset_info -> format , glyph_surface -> width , glyph_surface -> height );
status = tmp_surface -> status;
if ( unlikely ( status ) )
tmp_surface -> device_transform = glyph_surface -> base . device_transform;
tmp_surface -> device_transform_inverse = glyph_surface -> base . device_transform_inverse;
status = _cairo_surface_paint ( tmp_surface , CAIRO_OPERATOR_SOURCE , & pattern . base , NULL );
glyph_surface = ( cairo_image_surface_t * ) tmp_surface;
if ( unlikely ( status ) )
switch ( _cairo_xlib_get_glyphset_index_for_format ( scaled_glyph -> surface -> format ) )
if ( _native_byte_order_lsb ( ) != ( BitmapBitOrder ( display -> display ) == LSBFirst ) )
int c = glyph_surface -> stride * glyph_surface -> height ;
0
------------------------------
17934 CVE-2016-5275/Firefox_49.0b1_CVE_2016_5275_gfx_src_FilterSupport.cpp aOutMatrix [ 1 ] = aAmount * aToMatrix [ 1 ] 384
static
ComputeColorMatrix(uint32_t aColorMatrixType, const nsTArray<float>&
float aOutMatrix[20])
static const float lumR = 0.2126f ;
static const float lumG = 0.7152f ;
static const float lumB = 0.0722f ;
static const float saturateMatrix [ ] = { lumR , lumG , lumB , 0 , 0 , lumR , lumG , lumB , 0 , 0 , lumR , lumG , lumB , 0 , 0 , 0 , 0 , 0 , 1 , 0 } ;
switch ( aColorMatrixType )
if ( aValues . Length ( ) != 1 )
float s = aValues [ 0 ] ;
if ( s < 0 )
InterpolateFromIdentityMatrix ( saturateMatrix , 1 - s , aOutMatrix );
static
InterpolateFromIdentityMatrix(const float aToMatrix[20], float
float aOutMatrix[20])
float oneMinusAmount = 1 - aAmount ;
aOutMatrix [ 0 ] = aAmount * aToMatrix [ 0 ] + oneMinusAmount;
aOutMatrix [ 1 ] = aAmount * aToMatrix [ 1 ];
aOutMatrix [ 2 ] = aAmount * aToMatrix [ 2 ];
aOutMatrix [ 5 ] = aAmount * aToMatrix [ 5 ];
aOutMatrix [ 6 ] = aAmount * aToMatrix [ 6 ] + oneMinusAmount;
aOutMatrix [ 7 ] = aAmount * aToMatrix [ 7 ];
aOutMatrix [ 10 ] = aAmount * aToMatrix [ 10 ];
aOutMatrix [ 11 ] = aAmount * aToMatrix [ 11 ];
aOutMatrix [ 12 ] = aAmount * aToMatrix [ 12 ] + oneMinusAmount;
0
------------------------------
19488 CVE-2015-2726/Firefox_38.8.0esr_CVE_2015_2726_js_src_ctypes_CTypes.cpp size_t index = sign * size_t ( i - ii * IntegerType ( radix ) ) ; 2084
static
BuildTypeSource(JSContext*
JSObject*
bool
AutoString& result)
RootedObject typeObj ( cx , typeObj_ ) ;
switch ( CType :: GetTypeCode ( typeObj ) )
FunctionInfo * fninfo = FunctionType :: GetFunctionInfo ( typeObj ) ;
if ( fninfo -> mArgTypes . length ( ) > 0 )
size_t length ;
if ( makeShort )
if ( ! CType :: IsSizeDefined ( typeObj ) )
const FieldInfoHash * fields = StructType :: GetFieldInfo ( typeObj ) ;
size_t length = fields -> count ( ) ;
Array < const FieldInfoHash :: Entry * , 64 > fieldsArray ;
if ( ! fieldsArray . resize ( length ) )
for (FieldInfoHash::Range r = fields->all(); !r.empty(); r.popFront())
fieldsArray [ r . front ( ) . value ( ) . mIndex ] = & r . front ( );
for (size_t i = 0; i < length; ++i)
const FieldInfoHash :: Entry * entry = fieldsArray [ i ] ;
BuildTypeSource ( cx , entry -> value ( ) . mType , true , result );
static
BuildTypeSource(JSContext*
JSObject*
bool
AutoString& result)
RootedObject typeObj ( cx , typeObj_ ) ;
switch ( CType :: GetTypeCode ( typeObj ) )
FunctionInfo * fninfo = FunctionType :: GetFunctionInfo ( typeObj ) ;
BuildTypeSource ( cx , fninfo -> mReturnType , true , result );
static
BuildTypeSource(JSContext*
JSObject*
bool
AutoString& result)
RootedObject typeObj ( cx , typeObj_ ) ;
switch ( CType :: GetTypeCode ( typeObj ) )
size_t length ;
if ( ArrayType :: GetSafeLength ( typeObj , & length ) )
IntegerToString ( length , 10 , result );
template<class IntegerType, class CharType, size_t N, class

IntegerToString(IntegerType i, int radix, Vector<CharType, N, AP>& result)
const bool isNegative = IsNegative ( i ) ;
size_t sign = isNegative ? - 1 : 1 ;
IntegerType ii = i / IntegerType ( radix ) ;
size_t index = sign * size_t ( i - ii * IntegerType ( radix ) ) ;
* -- cp = "0123456789abcdefghijklmnopqrstuvwxyz" [ index ];
i = ii;
while ( i != 0 )
* -- cp = '-';
MOZ_ASSERT ( cp >= buffer );
result . append ( cp , end );
0
------------------------------
18586 CVE-2015-2716/Firefox_37.0b7_CVE_2015_2716_parser_expat_lib_xmlparse.c tem = ( BLOCK * ) pool -> mem -> malloc_fcn ( offsetof ( BLOCK , s ) + blockSize * sizeof ( XML_Char ) ) 6275
static enum XML_Error
entityValueProcessor(XML_Parser
const char
const char
const char **nextPtr)
const char * start = s ;
const char * next = s ;
const ENCODING * enc = encoding ;
int tok ;
tok = XmlPrologTok ( enc , start , end , & next );
if ( tok <= 0 )
if ( ! ps_finalBuffer && tok != XML_TOK_INVALID )
switch ( tok )
return storeEntityValue ( parser , enc , s , end ) ;
start = next;
static enum
storeEntityValue(XML_Parser
const ENCODING
const char
const char *entityTextEnd)
DTD * const dtd = _dtd
STRING_POOL * pool = & ( dtd -> entityValuePool ) ;
if ( ! pool -> blocks )
if ( ! poolGrow ( pool ) )
const char * next ;
int tok = XmlEntityValueTok ( enc , entityTextPtr , entityTextEnd , & next ) ;
switch ( tok )
if ( isParamEntity || enc != encoding )
const XML_Char * name ;
ENTITY * entity ;
name = poolStoreString ( & tempPool , enc , entityTextPtr + enc -> minBytesPerChar , next - enc -> minBytesPerChar );
if ( ! name )
entity = ( ENTITY * ) lookup ( & dtd -> paramEntities , name , 0 );
if ( ! entity )
if ( entity -> open )
if ( entity -> systemId )
if ( externalEntityRefHandler )
entity -> open = XML_TRUE;
if ( ! externalEntityRefHandler ( externalEntityRefHandlerArg , 0 , entity -> base , entity -> systemId , entity -> publicId ) )
entity -> open = XML_FALSE;
entity -> open = XML_TRUE;
result = storeEntityValue ( parser , internalEncoding , ( char * ) entity -> textPtr , ( char * ) ( entity -> textPtr + entity -> textLen ) );
entity -> open = XML_FALSE;
if ( result )
if ( ! poolAppend ( pool , enc , entityTextPtr , next ) )
next = entityTextPtr + enc -> minBytesPerChar;
if ( pool -> end == pool -> ptr && ! poolGrow ( pool ) )
* ( pool -> ptr ) ++ = 0xA;
XML_Char buf [ XML_ENCODE_MAX ] ;
int i ;
int n = XmlCharRefNumber ( enc , entityTextPtr ) ;
if ( n < 0 )
n = XmlEncode ( n , ( ICHAR * ) buf );
if ( ! n )
for (i = 0; i < n; i++)
if ( pool -> end == pool -> ptr && ! poolGrow ( pool ) )
* ( pool -> ptr ) ++ = buf [ i ];
entityTextPtr = next;
static XML_Char
poolStoreString(STRING_POOL *pool, const ENCODING
const char *ptr, const char *end)
if ( ! poolAppend ( pool , enc , ptr , end ) )
if ( pool -> ptr == pool -> end && ! poolGrow ( pool ) )
static XML_Bool
poolGrow(STRING_POOL *pool)
if ( pool -> freeBlocks )
if ( pool -> start == 0 )
if ( pool -> end - pool -> start < pool -> freeBlocks -> size )
if ( pool -> blocks && pool -> start == pool -> blocks -> s )
BLOCK * tem ;
int blockSize = ( int ) ( pool -> end - pool -> start ) ;
if ( blockSize < INIT_BLOCK_SIZE )
blockSize = INIT_BLOCK_SIZE;
blockSize *= 2;
tem = ( BLOCK * ) pool -> mem -> malloc_fcn ( offsetof ( BLOCK , s ) + blockSize * sizeof ( XML_Char ) );
if ( ! tem )
tem -> size = blockSize;
tem -> next = pool -> blocks;
pool -> blocks = tem;
if ( pool -> ptr != pool -> start )
memcpy ( tem -> s , pool -> start , ( pool -> ptr - pool -> start ) * sizeof ( XML_Char ) );
pool -> ptr = tem -> s + ( pool -> ptr - pool -> start );
pool -> start = tem -> s;
pool -> end = tem -> s + blockSize;
0
------------------------------
16532 CVE-2008-5134/CVE_2008_5134_PATCHED_lbs_process_bss.c n_ex_rates = MAX_RATES - n_basic_rates 168
static int CVE_2008_5134_PATCHED_lbs_process_bss(struct bss_descriptor
uint8_t **pbeaconinfo, int *bytesleft)
struct ieeetypes_countryinfoset * pcountryinfo ;
uint8_t * pos , * end , * p ;
uint8_t n_ex_rates = 0 , got_basic_rates = 0 , n_basic_rates = 0 ;
uint16_t beaconsize = 0 ;
if ( * bytesleft >= sizeof ( beaconsize ) )
beaconsize = get_unaligned_le16 ( * pbeaconinfo );
* bytesleft -= sizeof ( beaconsize );
* pbeaconinfo += sizeof ( beaconsize );
if ( beaconsize == 0 || beaconsize > * bytesleft )
pos = * pbeaconinfo;
end = pos + beaconsize;
pos += ETH_ALEN;
if ( ( end - pos ) < 12 )
pos ++;
pos += 8;
pos += 2;
pos += 2;
while ( pos <= end - 2 )
struct ieee80211_info_element * elem = ( void * ) pos ;
if ( pos + elem -> len > end )
switch ( elem -> id )
n_basic_rates = min_t ( uint8_t , MAX_RATES , elem -> len );
got_basic_rates = 1;
pcountryinfo = ( struct ieeetypes_countryinfoset * ) pos;
if ( pcountryinfo -> len < sizeof ( pcountryinfo -> countrycode ) || pcountryinfo -> len > 254 )
if ( ! got_basic_rates )
n_ex_rates = elem -> len;
if ( n_basic_rates + n_ex_rates > MAX_RATES )
n_ex_rates = MAX_RATES - n_basic_rates;
pos += elem -> len + 2;
0
------------------------------
310196 152045/resowner.c owner -> buffers = ( ( Buffer * ) ( MemoryContextAlloc ( TopMemoryContext , newmax * sizeof ( Buffer ) ) ) ) 563
void ResourceOwnerEnlargeBuffers(ResourceOwner owner)
int newmax ;
if ( owner == ( ( void * ) 0 ) || owner -> nbuffers < owner -> maxbuffers )
if ( owner -> buffers == ( ( void * ) 0 ) )
newmax = 16;
owner -> buffers = ( ( Buffer * ) ( MemoryContextAlloc ( TopMemoryContext , newmax * sizeof ( Buffer ) ) ) );
owner -> maxbuffers = newmax;
newmax = owner -> maxbuffers * 2;
owner -> buffers = ( ( Buffer * ) ( repalloc ( ( owner -> buffers ) , newmax * sizeof ( Buffer ) ) ) );
owner -> maxbuffers = newmax;
0
------------------------------
301511 150690/aviobuf.c s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_ptr - s -> checksum_ptr ) ) ) 273
int avio_put_str16le(AVIOContext *s,const char *str)
avio_wl16 ( s , 0 );
void avio_wl16(AVIOContext *s,unsigned int val)
avio_w8 ( s , ( ( uint8_t ) val ) );
void avio_w8(AVIOContext *s,int b)
* ( s -> buf_ptr ++ ) = b;
if ( s -> buf_ptr >= s -> buf_end )
flush_buffer ( s );
static void flush_buffer(AVIOContext *s)
if ( s -> buf_ptr > s -> buffer )
if ( s -> update_checksum )
s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_ptr - s -> checksum_ptr ) ) );
s -> checksum_ptr = s -> buffer;
s -> buf_ptr = s -> buffer;
0
------------------------------
305274 103075/CWE427_Uncontrolled_Search_Path_Element__char_listen_socket_44.c recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 250 - dataLen - 1 ) , 0 ) 108
void CWE427_Uncontrolled_Search_Path_Element__char_listen_socket_44_bad()
char * data ;
char dataBuffer [ 250 ] = "PATH=" ;
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 250 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
funcPtr ( data );
0
------------------------------
303581 82505/CWE190_Integer_Overflow__char_rand_square_12.c char result = data * data ; 42
void CWE190_Integer_Overflow__char_rand_square_12_bad()
char data ;
data = ' ';
if ( globalReturnsTrueOrFalse ( ) )
int globalReturnsTrueOrFalse()
return ( rand ( ) % 2 ) ;
data = ( char ) RAND32 ( );
data = 2;
if ( globalReturnsTrueOrFalse ( ) )
int globalReturnsTrueOrFalse()
return ( rand ( ) % 2 ) ;
char result = data * data ;
printHexCharLine ( result );
void printHexCharLine (char charHex)
printf ( "%02x\n" , charHex );
1
------------------------------
301380 149948/aviobuf.c s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_ptr - s -> checksum_ptr ) ) ) 268
int avio_close_dyn_buf(AVIOContext *s,uint8_t **pbuffer)
static const char padbuf [ 16 ] = { ( 0 ) } ;
if ( ! s -> max_packet_size )
avio_write ( s , padbuf , ( sizeof ( padbuf ) ) );
void avio_write(AVIOContext *s,const unsigned char *buf,int size)
if ( s -> direct && ! s -> update_checksum )
while ( size > 0 )
int len = ( s -> buf_end - s -> buf_ptr > size ? size : s -> buf_end - s -> buf_ptr ) ;
memcpy ( ( s -> buf_ptr ) , buf , len );
s -> buf_ptr += len;
if ( s -> buf_ptr >= s -> buf_end )
flush_buffer ( s );
buf += len;
size -= len;
static void flush_buffer(AVIOContext *s)
if ( s -> buf_ptr > s -> buffer )
if ( s -> update_checksum )
s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_ptr - s -> checksum_ptr ) ) );
s -> checksum_ptr = s -> buffer;
s -> buf_ptr = s -> buffer;
0
------------------------------
314315 110546/CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_listen_socket_73b.cpp intPointer = ( int * ) malloc ( data * sizeof ( int ) ) 36
void bad()
list < int > dataList ;
badSink ( dataList );
void badSink(list<int> dataList)
int data = dataList . back ( ) ;
int * intPointer ;
intPointer = ( int * ) malloc ( data * sizeof ( int ) );
intPointer [ i ] = 0;
printIntLine ( intPointer [ 0 ] );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
free ( intPointer );
1
------------------------------
19084 CVE-2016-7466/qemu_2.3.0_CVE-2016-7466_hcd-xhci.c dp_idx = ( erdp - intr -> er_start ) / TRB_SIZE 963
static void xhci_oper_write(void *ptr, hwaddr
uint64_t val, unsigned size)
XHCIState * xhci = ptr ;
switch ( reg )
if ( val & USBCMD_CSS )
xhci -> usbsts &= ~USBSTS_SRE;
if ( val & USBCMD_CRS )
xhci -> usbsts |= USBSTS_SRE;
xhci -> usbcmd = val & 0xc0f;
xhci -> usbsts &= ~ ( val & ( USBSTS_HSE | USBSTS_EINT | USBSTS_PCD | USBSTS_SRE ) );
xhci -> dnctrl = val & 0xffff;
xhci -> crcr_low = ( val & 0xffffffcf ) | ( xhci -> crcr_low & CRCR_CRR );
xhci -> crcr_high = val;
if ( xhci -> crcr_low & ( CRCR_CA | CRCR_CS ) && ( xhci -> crcr_low & CRCR_CRR ) )
xhci -> crcr_low &= ~CRCR_CRR;
xhci_event ( xhci , & event , 0 );
static void xhci_event(XHCIState *xhci, XHCIEvent *event, int v)
XHCIInterrupter * intr ;
dma_addr_t erdp ;
unsigned int dp_idx ;
if ( v >= xhci -> numintrs )
intr = & xhci -> intr [ v ];
if ( intr -> er_full )
erdp = xhci_addr64 ( intr -> erdp_low , intr -> erdp_high );
static inline dma_addr_t xhci_addr64(uint32_t low, uint32_t high)
if ( sizeof ( dma_addr_t ) == 4 )
return low ;
return low | ( ( ( dma_addr_t ) high << 16 ) << 16 ) ;
if ( erdp < intr -> er_start || erdp >= ( intr -> er_start + TRB_SIZE * intr -> er_size ) )
dp_idx = ( erdp - intr -> er_start ) / TRB_SIZE;
assert ( dp_idx < intr -> er_size );
if ( ( intr -> er_ep_idx + 1 ) % intr -> er_size == dp_idx )
0
------------------------------
299682 150889/dfa.c mblen_buf = ( ( sizeof ( ( * mblen_buf ) ) == 1 ? xmalloc ( ( end - begin + 2 ) ) : xnmalloc ( ( end - begin + 2 ) , sizeof ( ( * mblen_buf ) ) ) ) ) 3541
char *dfaexec(struct dfa *d,const char *begin,char *end,int allow_nl,size_t *count,int *backref)
unsigned char eol = eolbyte ;
* end = eol;
if ( d -> mb_cur_max > 1 )
mblen_buf = ( ( sizeof ( ( * mblen_buf ) ) == 1 ? xmalloc ( ( end - begin + 2 ) ) : xnmalloc ( ( end - begin + 2 ) , sizeof ( ( * mblen_buf ) ) ) ) );
while ( 0 )
while ( inputwcs [ p - buf_begin ] == 0 && mblen_buf [ p - buf_begin ] > 0 && ( ( const unsigned char * ) p ) < buf_end )
free ( mblen_buf );
free ( mblen_buf );
free ( mblen_buf );
free ( mblen_buf );
0
------------------------------
19098 CVE-2016-7466/qemu_2.3.0_CVE-2016-7466_hcd-xhci.c dp_idx = ( erdp - intr -> er_start ) / TRB_SIZE 963
static int xhci_ep_nuke_xfers(XHCIState *xhci, unsigned int
unsigned int epid, TRBCCode report)
XHCISlot * slot ;
XHCIEPContext * epctx ;
int i , xferi , killed = 0 ;
slot = & xhci -> slots [ slotid - 1 ];
if ( ! slot -> eps [ epid - 1 ] )
epctx = slot -> eps [ epid - 1 ];
xferi = epctx -> next_xfer;
for (i = 0; i < TD_QUEUE; i++)
killed += xhci_ep_nuke_one_xfer ( & epctx -> transfers [ xferi ] , report );
if ( killed )
report = 0;
epctx -> transfers [ xferi ] . packet . ep = NULL;
xferi = ( xferi + 1 ) % TD_QUEUE;
static int xhci_ep_nuke_one_xfer(XHCITransfer *t, TRBCCode report)
if ( report && ( t -> running_async || t -> running_retry ) )
t -> status = report;
xhci_xfer_report ( t );
static void xhci_xfer_report(XHCITransfer *xfer)
uint32_t edtla = 0 ;
unsigned int left ;
bool reported = 0 ;
bool shortpkt = 0 ;
XHCIEvent event = { ER_TRANSFER , CC_SUCCESS } ;
XHCIState * xhci = xfer -> xhci ;
int i ;
left = xfer -> packet . actual_length;
for (i = 0; i < xfer->trb_count; i++)
XHCITRB * trb = & xfer -> trbs [ i ] ;
unsigned int chunk = 0 ;
switch ( TRB_TYPE ( * trb ) )
chunk = trb -> status & 0x1ffff;
if ( chunk > left )
chunk = left;
if ( xfer -> status == CC_SUCCESS )
shortpkt = 1;
left -= chunk;
edtla += chunk;
reported = 0;
shortpkt = 0;
if ( ( trb -> control & TRB_TR_IOC ) || ( ! reported && ( ( shortpkt && ( trb -> control & TRB_TR_ISP ) ) || ( xfer -> status != CC_SUCCESS && left == 0 ) ) ) )
event . slotid = xfer -> slotid;
event . epid = xfer -> epid;
event . length = ( trb -> status & 0x1ffff ) - chunk;
event . flags = 0;
event . ptr = trb -> addr;
if ( xfer -> status == CC_SUCCESS )
event . ccode = shortpkt ? CC_SHORT_PACKET : CC_SUCCESS;
event . ccode = xfer -> status;
if ( TRB_TYPE ( * trb ) == TR_EVDATA )
event . ptr = trb -> parameter;
event . flags |= TRB_EV_ED;
event . length = edtla & 0xffffff;
edtla = 0;
xhci_event ( xhci , & event , TRB_INTR ( * trb ) );
reported = 1;
if ( xfer -> status != CC_SUCCESS )
static void xhci_event(XHCIState *xhci, XHCIEvent *event, int v)
XHCIInterrupter * intr ;
dma_addr_t erdp ;
unsigned int dp_idx ;
if ( v >= xhci -> numintrs )
intr = & xhci -> intr [ v ];
if ( intr -> er_full )
erdp = xhci_addr64 ( intr -> erdp_low , intr -> erdp_high );
if ( erdp < intr -> er_start || erdp >= ( intr -> er_start + TRB_SIZE * intr -> er_size ) )
dp_idx = ( erdp - intr -> er_start ) / TRB_SIZE;
assert ( dp_idx < intr -> er_size );
if ( ( intr -> er_ep_idx + 1 ) % intr -> er_size == dp_idx )
0
------------------------------
312575 149429/dirent_uri.c apr_size_t seglen = ( ptr - seg ) ; 1500
svn_error_t *svn_uri_get_dirent_from_file_url(const char **dirent,const char *url,apr_pool_t *pool)
if ( ! svn_uri_is_canonical ( url , pool ) )
svn_error_t * svn_err__temp = svn_error__malfunction ( ! 0 , "dirent_uri.c" , 2304 , "svn_uri_is_canonical(url, pool)" ) ;
if ( svn_err__temp )
while ( 0 )
while ( 0 )
svn_boolean_t svn_uri_is_canonical(const char *uri,apr_pool_t *scratch_pool)
const char * ptr = uri ;
if ( ( * uri ) == '\0' )
if ( ! svn_path_is_url ( uri ) )
while ( * ptr && ( * ptr ) != 47 && ( * ptr ) != ':' )
ptr ++;
if ( ! ( ( * ptr ) == ':' && ( * ( ptr + 1 ) ) == 47 && ( * ( ptr + 2 ) ) == 47 ) )
ptr = uri;
while ( ( * ptr ) != ':' )
if ( ( * ptr ) >= 65 && ( * ptr ) <= 'Z' )
ptr ++;
ptr += 3;
if ( ! ( * ptr ) )
seg = ptr;
while ( * ptr && ( * ptr ) != 47 && ( * ptr ) != 64 )
ptr ++;
if ( ( * ptr ) == 64 )
seg = ptr + 1;
ptr = seg;
if ( ( * ptr ) == '[' )
ptr ++;
while ( ( * ptr ) == ':' || ( * ptr ) >= 48 && ( * ptr ) <= '9' || ( * ptr ) >= 'a' && ( * ptr ) <= 'f' )
ptr ++;
if ( ( * ptr ) != ']' )
ptr ++;
while ( * ptr && ( * ptr ) != 47 && ( * ptr ) != ':' )
if ( ( * ptr ) >= 65 && ( * ptr ) <= 'Z' )
ptr ++;
if ( ( * ptr ) == ':' )
apr_int64_t port = 0 ;
ptr ++;
schema_data = ptr;
while ( ( * ptr ) >= 48 && ( * ptr ) <= '9' )
port = 10 * port + ( ( * ptr ) - 48 );
ptr ++;
if ( ptr == schema_data )
if ( * ptr && ( * ptr ) != 47 )
if ( port == 80 && strncmp ( uri , "http:" , 5 ) == 0 )
if ( port == 443 && strncmp ( uri , "https:" , 6 ) == 0 )
if ( port == 3690 && strncmp ( uri , "svn:" , 4 ) == 0 )
while ( 1 )
apr_size_t seglen = ( ptr - seg ) ;
if ( seglen == 1 && ( * seg ) == 46 )
if ( ( * ptr ) == 47 && ( * ( ptr + 1 ) ) == 47 )
if ( ! ( * ptr ) && ( * ( ptr - 1 ) ) == 47 && ptr - 1 != uri )
if ( ! ( * ptr ) )
if ( ( * ptr ) == 47 )
ptr ++;
seg = ptr;
while ( * ptr && ( * ptr ) != 47 )
ptr ++;
0
------------------------------
19551 CVE-2015-2726/Firefox_38.8.0esr_CVE_2015_2726_js_src_ctypes_CTypes.cpp size_t arraySize = elementSize * targetLength ; 2630

FunctionType::Call(JSContext*
unsigned
jsval* vp)
CallArgs args = CallArgsFromVp ( argc , vp ) ;
RootedObject obj ( cx , & args . callee ( ) ) ;
if ( ! CData :: IsCData ( obj ) )

CData::IsCData(JSObject* obj)
return JS_GetClass ( obj ) == & sCDataClass ;
RootedObject typeObj ( cx , CData :: GetCType ( obj ) ) ;

CData::GetCType(JSObject* dataObj)
jsval slot = JS_GetReservedSlot ( dataObj , SLOT_CTYPE ) ;
JSObject * typeObj = slot . toObjectOrNull ( ) ;
return typeObj ;
if ( CType :: GetTypeCode ( typeObj ) != TYPE_pointer )

CType::GetTypeCode(JSObject* typeObj)
jsval result = JS_GetReservedSlot ( typeObj , SLOT_TYPECODE ) ;
return TypeCode ( result . toInt32 ( ) ) ;
typeObj = PointerType :: GetBaseType ( typeObj );

PointerType::GetBaseType(JSObject* obj)
jsval type = JS_GetReservedSlot ( obj , SLOT_TARGET_T ) ;
return & type . toObject ( ) ;
if ( CType :: GetTypeCode ( typeObj ) != TYPE_function )

CType::GetTypeCode(JSObject* typeObj)
jsval result = JS_GetReservedSlot ( typeObj , SLOT_TYPECODE ) ;
return TypeCode ( result . toInt32 ( ) ) ;
FunctionInfo * fninfo = GetFunctionInfo ( typeObj ) ;
uint32_t argcFixed = fninfo -> mArgTypes . length ( ) ;
if ( ( ! fninfo -> mIsVariadic && args . length ( ) != argcFixed ) || ( fninfo -> mIsVariadic && args . length ( ) < argcFixed ) )
jsval slot = JS_GetReservedSlot ( obj , SLOT_REFERENT ) ;
if ( ! slot . isUndefined ( ) && Library :: IsLibrary ( & slot . toObject ( ) ) )
PRLibrary * library = Library :: GetLibrary ( & slot . toObject ( ) ) ;
if ( ! library )
AutoValueAutoArray values ;
AutoValueAutoArray strings ;
if ( ! values . resize ( args . length ( ) ) )
for (unsigned i = 0; i < argcFixed; ++i)
if ( ! ConvertArgument ( cx , args [ i ] , fninfo -> mArgTypes [ i ] , & values [ i ] , & strings ) )
if ( fninfo -> mIsVariadic )
if ( ! fninfo -> mFFITypes . resize ( args . length ( ) ) )
RootedObject obj ( cx ) ;
RootedObject type ( cx ) ;
for (uint32_t i = argcFixed; i < args.length(); ++i)
if ( args [ i ] . isPrimitive ( ) || ! CData :: IsCData ( obj = & args [ i ] . toObject ( ) ) )

CData::IsCData(JSObject* obj)
return JS_GetClass ( obj ) == & sCDataClass ;
if ( ! ( type = CData :: GetCType ( obj ) ) || ! ( type = PrepareType ( cx , OBJECT_TO_JSVAL ( type ) ) ) || ! ConvertArgument ( cx , args [ i ] , type , & values [ i ] , & strings ) || ! ( fninfo -> mFFITypes [ i ] = CType :: GetFFIType ( cx , type ) ) )
static
ConvertArgument(JSContext*
HandleValue
JSObject*
AutoValue*
AutoValueAutoArray* strings)
if ( ! value -> SizeToType ( cx , type ) )
if ( ! ImplicitConvert ( cx , arg , type , value -> mData , true , & freePointer ) )
static
ImplicitConvert(JSContext*
HandleValue
JSObject*
void*
bool
bool* freePointer)
RootedObject targetType ( cx , targetType_ ) ;
RootedObject valObj ( cx , nullptr ) ;
if ( val . isObject ( ) )
valObj = & val . toObject ( );
if ( CData :: IsCData ( valObj ) )
sourceData = valObj;
sourceType = CData :: GetCType ( sourceData );
if ( CType :: TypesEqual ( sourceType , targetType ) )
if ( CDataFinalizer :: IsCDataFinalizer ( valObj ) )
sourceData = valObj;
sourceType = CDataFinalizer :: GetCType ( cx , sourceData );
CDataFinalizer :: Private * p = ( CDataFinalizer :: Private * ) JS_GetPrivate ( sourceData ) ;
if ( ! p )
if ( CType :: TypesEqual ( sourceType , targetType ) )
TypeCode targetCode = CType :: GetTypeCode ( targetType ) ;
switch ( targetCode )
if ( val . isNull ( ) )
JS :: Rooted < JSObject * > baseType ( cx , PointerType :: GetBaseType ( targetType ) ) ;
RootedObject baseType ( cx , ArrayType :: GetBaseType ( targetType ) ) ;
size_t targetLength = ArrayType :: GetLength ( targetType ) ;
if ( val . isString ( ) )
if ( val . isObject ( ) && JS_IsArrayObject ( cx , valObj ) )
if ( val . isObject ( ) && JS_IsArrayBufferObject ( valObj ) )
if ( val . isObject ( ) && JS_IsTypedArrayObject ( valObj ) )
if ( ! CanConvertTypedArrayItemTo ( baseType , valObj , cx ) )
size_t elementSize = CType :: GetSize ( baseType ) ;
size_t arraySize = elementSize * targetLength ;
if ( arraySize != size_t ( sourceLength ) )
0
------------------------------
17889 CVE-2016-5275/Firefox_49.0b1_CVE_2016_5275_dom_canvas_CanvasRenderingContext2D.cpp inlinePos = baselineOriginInline + advanceSum 3742
virtual void DrawText(nscoord aXOffset, nscoord aWidth)
gfxPoint point = mPt ;
bool rtl = mTextRun -> IsRightToLeft ( ) ;
if ( mOp == CanvasRenderingContext2D :: TextDrawOperation :: FILL && mState -> StyleIsColor ( CanvasRenderingContext2D :: Style :: FILL ) )
uint32_t numRuns ;
const gfxTextRun :: GlyphRun * runs = mTextRun -> GetGlyphRuns ( & numRuns ) ;
const int32_t appUnitsPerDevUnit = mAppUnitsPerDevPixel ;
const double devUnitsPerAppUnit = 1.0 / double ( appUnitsPerDevUnit ) ;
Point baselineOrigin = Point ( point . x * devUnitsPerAppUnit , point . y * devUnitsPerAppUnit ) ;
float advanceSum = 0 ;
for (uint32_t c = 0; c < numRuns; c++)
gfxFont * font = runs [ c ] . mFont ;
bool verticalFont = runs [ c ] . mOrientation == gfxTextRunFactory :: TEXT_ORIENT_VERTICAL_UPRIGHT ;
const float & baselineOriginInline = verticalFont ? baselineOrigin . y : baselineOrigin . x ;
if ( c + 1 < numRuns )
endRun = runs [ c + 1 ] . mCharacterOffset;
endRun = mTextRun -> GetLength ( );
const gfxTextRun :: CompressedGlyph * glyphs = mTextRun -> GetCharacterGlyphs ( ) ;
RefPtr < ScaledFont > scaledFont = gfxPlatform :: GetPlatform ( ) -> GetScaledFontForFont ( mCtx -> mTarget , font ) ;
if ( ! scaledFont )
std :: vector < Glyph > glyphBuf ;
for (uint32_t i = runs[c].mCharacterOffset; i < endRun; i++)
if ( glyphs [ i ] . IsSimpleGlyph ( ) )
advanceSum += glyphs [ i ] . GetSimpleAdvance ( ) * devUnitsPerAppUnit;
if ( ! glyphs [ i ] . GetGlyphCount ( ) )
const gfxTextRun :: DetailedGlyph * d = mTextRun -> GetDetailedGlyphs ( i ) ;
if ( glyphs [ i ] . IsMissing ( ) )
if ( d -> mAdvance > 0 )
advanceSum += d -> mAdvance * devUnitsPerAppUnit;
for (uint32_t c = 0; c < glyphs[i].GetGlyphCount(); c++, d++)
if ( rtl )
inlinePos = baselineOriginInline + advanceSum;
inlinePos += d -> mXOffset * devUnitsPerAppUnit;
advanceSum += d -> mAdvance * devUnitsPerAppUnit;
if ( ! glyphBuf . size ( ) )
0
------------------------------
303854 84082/CWE190_Integer_Overflow__short_max_square_05.c short result = data * data ; 43
void CWE190_Integer_Overflow__short_max_square_05_bad()
short data ;
data = 0;
if ( staticTrue )
data = SHRT_MAX;
if ( staticTrue )
short result = data * data ;
printIntLine ( result );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
1
------------------------------
302341 80654/CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_snprintf_31.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 ) 94
void CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_snprintf_31_bad()
wchar_t * data ;
wchar_t dataBuffer [ 100 ] = L ""
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
17060 CVE-2013-4264/CVE_2013_4264_VULN_kempf_decode_tile.c const uint8_t * src_end = src + src_size ; 7
static int CVE_2013_4264_VULN_kempf_decode_tile(G2MContext *c, int tile_x, int
const uint8_t *src, int src_size)
const uint8_t * src_end = src + src_size ;
0
------------------------------
312554 149429/dirent_uri.c apr_size_t seglen = ( ptr - seg ) ; 1363
void svn_relpath_split(const char **dirpath,const char **base_name,const char *relpath,apr_pool_t *pool)
if ( base_name )
* base_name = svn_relpath_basename ( relpath , pool );
const char *svn_relpath_basename(const char *relpath,apr_pool_t *pool)
relpath_is_canonical ( relpath ) ? ( ( void ) 0 ) : __assert_fail ( "relpath_is_canonical(relpath)" , "dirent_uri.c" , 1269 , __PRETTY_FUNCTION__ );
static svn_boolean_t relpath_is_canonical(const char *relpath)
const char * ptr = relpath ;
const char * seg = relpath ;
if ( ( * relpath ) == '\0' )
if ( ( * ptr ) == 47 )
while ( 1 )
apr_size_t seglen = ( ptr - seg ) ;
if ( seglen == 1 && ( * seg ) == 46 )
if ( ( * ptr ) == 47 && ( * ( ptr + 1 ) ) == 47 )
if ( ! ( * ptr ) && ( * ( ptr - 1 ) ) == 47 )
if ( ! ( * ptr ) )
if ( ( * ptr ) == 47 )
ptr ++;
seg = ptr;
while ( * ptr && ( * ptr ) != 47 )
ptr ++;
0
------------------------------
306164 117131/CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_05.c myString = ( char * ) malloc ( data * sizeof ( char ) ) 142
void CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_05_bad()
size_t data ;
data = 0;
if ( staticTrue )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
char inputBuffer [ CHAR_ARRAY_SIZE ] ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
inputBuffer [ recvResult ] = '\0';
data = strtoul ( inputBuffer , NULL , 0 );
while ( 0 )
if ( staticTrue )
char * myString ;
if ( data > strlen ( HELLO_STRING ) )
myString = ( char * ) malloc ( data * sizeof ( char ) );
strcpy ( myString , HELLO_STRING );
printLine ( myString );
void printLine (const char * line)
if ( line != NULL )
printf ( "%s\n" , line );
free ( myString );
1
------------------------------
305217 95393/CWE369_Divide_by_Zero__int_rand_divide_84_bad.cpp printIntLine ( 100 / data ) 34
void bad()
int data ;
data = - 1;
CWE369_Divide_by_Zero__int_rand_divide_84_bad * badObject = new CWE369_Divide_by_Zero__int_rand_divide_84_bad ( data ) ;
CWE369_Divide_by_Zero__int_rand_divide_84_bad::CWE369_Divide_by_Zero__int_rand_divide_84_bad(int dataCopy)
data = dataCopy;
data = RAND32 ( );
delete badObject
CWE369_Divide_by_Zero__int_rand_divide_84_bad::~CWE369_Divide_by_Zero__int_rand_divide_84_bad()
printIntLine ( 100 / data );
1
------------------------------
302616 81880/CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_vfprintf_83_bad.cpp recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 ) 93
CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_vfprintf_83_bad::CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_vfprintf_83_bad(wchar_t * dataCopy)
data = dataCopy;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
17799 CVE-2016-4454/qemu_2.3.0_CVE-2016-4454_vmware_vga.c ptr [ 0 ] = vram + bypp * x0 + bypl * y0 432
static void vmsvga_io_write(void *opaque, hwaddr
uint64_t data, unsigned size)
struct vmsvga_state_s * s = opaque ;
switch ( addr )
vmsvga_value_write ( s , addr , data );
static void vmsvga_value_write(void *opaque, uint32_t address, uint32_t value)
struct vmsvga_state_s * s = opaque ;
switch ( s -> index )
if ( value == SVGA_ID_2 || value == SVGA_ID_1 || value == SVGA_ID_0 )
s -> svgaid = value;
s -> enable = ! ! value;
s -> invalidated = 1;
if ( value <= SVGA_MAX_WIDTH )
s -> new_width = value;
s -> invalidated = 1;
if ( value <= SVGA_MAX_HEIGHT )
s -> new_height = value;
s -> invalidated = 1;
if ( value != 32 )
s -> config = 0;
s -> invalidated = 1;
if ( value )
s -> fifo = ( uint32_t * ) s -> fifo_ptr;
if ( ( CMD ( min ) | CMD ( max ) | CMD ( next_cmd ) | CMD ( stop ) ) & 3 )
if ( CMD ( min ) < ( uint8_t * ) s -> cmd -> fifo - ( uint8_t * ) s -> fifo )
if ( CMD ( max ) > SVGA_FIFO_SIZE )
if ( CMD ( max ) < CMD ( min ) + 10 * 1024 )
s -> config = ! ! value;
s -> syncing = 1;
vmsvga_fifo_run ( s );
static void vmsvga_fifo_run(struct vmsvga_state_s *s)
uint32_t cmd , colour ;
int args , len ;
int x , y , dx , dy , width , height ;
struct vmsvga_cursor_definition_s cursor ;
len = vmsvga_fifo_length ( s );
while ( len > 0 )
switch ( cmd = vmsvga_fifo_read ( s ) )
len -= 5;
len -= 6;
if ( len < 0 )
colour = vmsvga_fifo_read ( s );
x = vmsvga_fifo_read ( s );
y = vmsvga_fifo_read ( s );
width = vmsvga_fifo_read ( s );
height = vmsvga_fifo_read ( s );
if ( vmsvga_fill_rect ( s , colour , x , y , width , height ) == 0 )
args = 0;
len -= 7;
if ( len < 0 )
x = vmsvga_fifo_read ( s );
y = vmsvga_fifo_read ( s );
dx = vmsvga_fifo_read ( s );
dy = vmsvga_fifo_read ( s );
width = vmsvga_fifo_read ( s );
height = vmsvga_fifo_read ( s );
if ( vmsvga_copy_rect ( s , x , y , dx , dy , width , height ) == 0 )
args = 0;
len -= 8;
if ( len < 0 )
cursor . id = vmsvga_fifo_read ( s );
cursor . hot_x = vmsvga_fifo_read ( s );
cursor . hot_y = vmsvga_fifo_read ( s );
cursor . width = x = vmsvga_fifo_read ( s );
cursor . height = y = vmsvga_fifo_read ( s );
cursor . bpp = vmsvga_fifo_read ( s );
args = SVGA_BITMAP_SIZE ( x , y ) + SVGA_PIXMAP_SIZE ( x , y , cursor . bpp );
if ( SVGA_BITMAP_SIZE ( x , y ) > sizeof cursor . mask || SVGA_PIXMAP_SIZE ( x , y , cursor . bpp ) > sizeof cursor . image )
len -= args;
if ( len < 0 )
for (args = 0; args < SVGA_BITMAP_SIZE(x, y); args++)
cursor . mask [ args ] = vmsvga_fifo_read_raw ( s );
for (args = 0; args < SVGA_PIXMAP_SIZE(x, y, cursor.bpp); args++)
cursor . image [ args ] = vmsvga_fifo_read_raw ( s );
len -= 6;
if ( len < 0 )
x = vmsvga_fifo_read ( s );
y = vmsvga_fifo_read ( s );
args = x * y;
args = 6;
args = 7;
len -= 4;
if ( len < 0 )
args = 7 + ( vmsvga_fifo_read ( s ) >> 2 );
args = 12;
args = 0;
len -= args;
if ( len < 0 )
while ( args -- )
static inline int vmsvga_copy_rect(struct vmsvga_state_s
int x0, int y0, int x1, int y1, int w, int h)
DisplaySurface * surface = qemu_console_surface ( s -> vga . con ) ;
uint8_t * vram = s -> vga . vram_ptr ;
int bypl = surface_stride ( surface ) ;
int bypp = surface_bytes_per_pixel ( surface ) ;
uint8_t * ptr [ 2 ] ;
if ( ! vmsvga_verify_rect ( surface , "vmsvga_copy_rect/src" , x0 , y0 , w , h ) )
if ( ! vmsvga_verify_rect ( surface , "vmsvga_copy_rect/dst" , x1 , y1 , w , h ) )
if ( y1 > y0 )
ptr [ 0 ] = vram + bypp * x0 + bypl * y0;
ptr [ 1 ] = vram + bypp * x1 + bypl * y1;
for (; line > 0; line --, ptr[0] += bypl, ptr[1] += bypl)
memmove ( ptr [ 1 ] , ptr [ 0 ] , width );
0
------------------------------
313605 95698/CWE36_Absolute_Path_Traversal__char_connect_socket_open_17.cpp recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ) 101
void bad()
int i ;
char * data ;
char dataBuffer [ FILENAME_MAX ] = "" ;
data = dataBuffer;
for(i = 0; i < 1; i++)
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
fileDesc = OPEN ( data , O_RDWR | O_CREAT , S_IREAD | S_IWRITE );
if ( fileDesc != - 1 )
CLOSE ( fileDesc );
1
------------------------------
19176 CVE-2016-3062/Ffmpeg_0.11_CVE_2016_3062_libavformat_mov.c a . size = FFMIN ( a . size , atom . size - total_size ) 347
static int mov_read_cmov(MOVContext *c, AVIOContext *pb, MOVAtom atom)
AVIOContext ctx ;
uint8_t * cmov_data ;
uint8_t * moov_data ;
long cmov_len , moov_len ;
if ( avio_rl32 ( pb ) != MKTAG ( 'd' , 'c' , 'o' , 'm' ) )
if ( avio_rl32 ( pb ) != MKTAG ( 'z' , 'l' , 'i' , 'b' ) )
if ( avio_rl32 ( pb ) != MKTAG ( 'c' , 'm' , 'v' , 'd' ) )
moov_len = avio_rb32 ( pb );
cmov_len = atom . size - 6 * 4;
cmov_data = av_malloc ( cmov_len );
if ( ! cmov_data )
moov_data = av_malloc ( moov_len );
if ( ! moov_data )
if ( uncompress ( moov_data , ( uLongf * ) & moov_len , ( const Bytef * ) cmov_data , cmov_len ) != Z_OK )
if ( ffio_init_context ( & ctx , moov_data , moov_len , 0 , NULL , NULL , NULL , NULL ) != 0 )
atom . type = MKTAG ( 'm' , 'o' , 'o' , 'v' );
atom . size = moov_len;
ret = mov_read_default ( c , & ctx , atom );
static int mov_read_default(MOVContext *c, AVIOContext *pb, MOVAtom atom)
int64_t total_size = 0 ;
MOVAtom a ;
int i ;
if ( atom . size < 0 )
atom . size = INT64_MAX;
while ( total_size + 8 <= atom . size && ! url_feof ( pb ) )
a . size = atom . size;
a . type = 0;
if ( atom . size >= 8 )
a . size = avio_rb32 ( pb );
a . type = avio_rl32 ( pb );
if ( atom . type != MKTAG ( 'r' , 'o' , 'o' , 't' ) && atom . type != MKTAG ( 'm' , 'o' , 'o' , 'v' ) )
if ( a . type == MKTAG ( 't' , 'r' , 'a' , 'k' ) || a . type == MKTAG ( 'm' , 'd' , 'a' , 't' ) )
total_size += 8;
if ( a . size == 1 )
a . size = avio_rb64 ( pb ) - 8;
total_size += 8;
av_dlog ( c -> fc , "type: %08x '%.4s' parent:'%.4s' sz: %" PRId64 " %" PRId64 " %" PRId64 "\n"
a . type , ( char * ) & a . type , ( char * ) & atom . type , a . size , total_size , atom . size )
if ( a . size == 0 )
a . size = atom . size - total_size + 8;
a . size -= 8;
if ( a . size < 0 )
a . size = FFMIN ( a . size , atom . size - total_size );
for (i = 0; mov_default_parse_table[i].type; i++)
if ( mov_default_parse_table [ i ] . type == a . type )
parse = mov_default_parse_table [ i ] . parse;
if ( ! parse && ( atom . type == MKTAG ( 'u' , 'd' , 't' , 'a' ) || atom . type == MKTAG ( 'i' , 'l' , 's' , 't' ) ) )
parse = mov_read_udta_string;
if ( ! parse )
avio_skip ( pb , a . size );
int64_t start_pos = avio_tell ( pb ) ;
int err = parse ( c , pb , a ) ;
if ( err < 0 )
return err ;
if ( c -> found_moov && c -> found_mdat && ( ( ! pb -> seekable || c -> fc -> flags & AVFMT_FLAG_IGNIDX ) || start_pos + a . size == avio_size ( pb ) ) )
c -> next_root_atom = start_pos + a . size;
left = a . size - avio_tell ( pb ) + start_pos;
if ( left > 0 )
avio_skip ( pb , left );
total_size += a . size;
if ( total_size < atom . size && atom . size < 0x7ffff )
avio_skip ( pb , atom . size - total_size );
0
------------------------------
298426 95376/CWE369_Divide_by_Zero__int_rand_divide_52c.c printIntLine ( 100 / data ) 36
static void goodG2B()
int data ;
data = - 1;
data = 7;
CWE369_Divide_by_Zero__int_rand_divide_52b_goodG2BSink ( data );
void CWE369_Divide_by_Zero__int_rand_divide_52b_goodG2BSink(int data)
CWE369_Divide_by_Zero__int_rand_divide_52c_goodG2BSink ( data );
void CWE369_Divide_by_Zero__int_rand_divide_52c_goodG2BSink(int data)
printIntLine ( 100 / data );
0
------------------------------
19108 CVE-2016-7466/qemu_2.3.0_CVE-2016-7466_hcd-xhci.c dp_idx = ( erdp - intr -> er_start ) / TRB_SIZE 963
static void xhci_complete(USBPort *port, USBPacket *packet)
XHCITransfer * xfer = container_of ( packet , XHCITransfer , packet ) ;
if ( packet -> status == USB_RET_REMOVE_FROM_QUEUE )
xhci_complete_packet ( xfer );
static int xhci_complete_packet(XHCITransfer *xfer)
if ( xfer -> packet . status == USB_RET_ASYNC )
if ( xfer -> packet . status == USB_RET_NAK )
xfer -> running_async = 0;
xfer -> running_retry = 0;
xfer -> complete = 1;
if ( xfer -> packet . status == USB_RET_SUCCESS )
xfer -> status = CC_SUCCESS;
switch ( xfer -> packet . status )
xfer -> status = CC_STALL_ERROR;
xfer -> status = CC_BABBLE_DETECTED;
xhci_xfer_report ( xfer );
static void xhci_xfer_report(XHCITransfer *xfer)
uint32_t edtla = 0 ;
unsigned int left ;
bool reported = 0 ;
bool shortpkt = 0 ;
XHCIEvent event = { ER_TRANSFER , CC_SUCCESS } ;
XHCIState * xhci = xfer -> xhci ;
int i ;
left = xfer -> packet . actual_length;
for (i = 0; i < xfer->trb_count; i++)
XHCITRB * trb = & xfer -> trbs [ i ] ;
unsigned int chunk = 0 ;
switch ( TRB_TYPE ( * trb ) )
chunk = trb -> status & 0x1ffff;
if ( chunk > left )
chunk = left;
if ( xfer -> status == CC_SUCCESS )
shortpkt = 1;
left -= chunk;
edtla += chunk;
reported = 0;
shortpkt = 0;
if ( ( trb -> control & TRB_TR_IOC ) || ( ! reported && ( ( shortpkt && ( trb -> control & TRB_TR_ISP ) ) || ( xfer -> status != CC_SUCCESS && left == 0 ) ) ) )
event . slotid = xfer -> slotid;
event . epid = xfer -> epid;
event . length = ( trb -> status & 0x1ffff ) - chunk;
event . flags = 0;
event . ptr = trb -> addr;
if ( xfer -> status == CC_SUCCESS )
event . ccode = shortpkt ? CC_SHORT_PACKET : CC_SUCCESS;
event . ccode = xfer -> status;
if ( TRB_TYPE ( * trb ) == TR_EVDATA )
event . ptr = trb -> parameter;
event . flags |= TRB_EV_ED;
event . length = edtla & 0xffffff;
edtla = 0;
xhci_event ( xhci , & event , TRB_INTR ( * trb ) );
reported = 1;
if ( xfer -> status != CC_SUCCESS )
static void xhci_event(XHCIState *xhci, XHCIEvent *event, int v)
XHCIInterrupter * intr ;
dma_addr_t erdp ;
unsigned int dp_idx ;
if ( v >= xhci -> numintrs )
intr = & xhci -> intr [ v ];
if ( intr -> er_full )
erdp = xhci_addr64 ( intr -> erdp_low , intr -> erdp_high );
if ( erdp < intr -> er_start || erdp >= ( intr -> er_start + TRB_SIZE * intr -> er_size ) )
dp_idx = ( erdp - intr -> er_start ) / TRB_SIZE;
assert ( dp_idx < intr -> er_size );
if ( ( intr -> er_ep_idx + 1 ) % intr -> er_size == dp_idx )
0
------------------------------
18485 CVE-2015-2716/Firefox_37.0b7_CVE_2015_2716_parser_expat_lib_xmlparse.c pool -> end = tem -> s + blockSize 6287
static enum
storeAttributeValue(XML_Parser parser, const ENCODING *enc, XML_Bool
const char *ptr, const char
STRING_POOL *pool)
enum XML_Error result = appendAttributeValue ( parser , enc , isCdata , ptr , end , pool ) ;
static enum
appendAttributeValue(XML_Parser parser, const ENCODING *enc, XML_Bool
const char *ptr, const char
STRING_POOL *pool)
DTD * const dtd = _dtd
const char * next ;
int tok = XmlAttributeValueTok ( enc , ptr , end , & next ) ;
switch ( tok )
XML_Char buf [ XML_ENCODE_MAX ] ;
int i ;
int n = XmlCharRefNumber ( enc , ptr ) ;
if ( n < 0 )
if ( ! isCdata && n == 0x20 && ( poolLength ( pool ) == 0 || poolLastChar ( pool ) == 0x20 ) )
n = XmlEncode ( n , ( ICHAR * ) buf );
if ( ! n )
for (i = 0; i < n; i++)
if ( ! poolAppendChar ( pool , buf [ i ] ) )
if ( ! poolAppend ( pool , enc , ptr , next ) )
next = ptr + enc -> minBytesPerChar;
if ( ! isCdata && ( poolLength ( pool ) == 0 || poolLastChar ( pool ) == 0x20 ) )
if ( ! poolAppendChar ( pool , 0x20 ) )
const XML_Char * name ;
ENTITY * entity ;
char checkEntityDecl ;
XML_Char ch = ( XML_Char ) XmlPredefinedEntityName ( enc , ptr + enc -> minBytesPerChar , next - enc -> minBytesPerChar ) ;
if ( ch )
if ( ! poolAppendChar ( pool , ch ) )
name = poolStoreString ( & temp2Pool , enc , ptr + enc -> minBytesPerChar , next - enc -> minBytesPerChar );
if ( ! name )
entity = ( ENTITY * ) lookup ( & dtd -> generalEntities , name , 0 );
if ( pool == & dtd -> pool )
checkEntityDecl = ! dtd -> hasParamEntityRefs || dtd -> standalone;
if ( checkEntityDecl )
if ( ! entity )
if ( ! entity -> is_internal )
if ( ! entity )
if ( entity -> open )
if ( entity -> notation )
if ( ! entity -> textPtr )
enum XML_Error result ;
const XML_Char * textEnd = entity -> textPtr + entity -> textLen ;
entity -> open = XML_TRUE;
result = appendAttributeValue ( parser , internalEncoding , isCdata , ( char * ) entity -> textPtr , ( char * ) textEnd , pool );
entity -> open = XML_FALSE;
if ( result )
ptr = next;
static XML_Char
poolAppend(STRING_POOL *pool, const ENCODING
const char *ptr, const char *end)
if ( ! pool -> ptr && ! poolGrow ( pool ) )
static XML_Bool
poolGrow(STRING_POOL *pool)
if ( pool -> freeBlocks )
if ( pool -> start == 0 )
if ( pool -> end - pool -> start < pool -> freeBlocks -> size )
if ( pool -> blocks && pool -> start == pool -> blocks -> s )
BLOCK * tem ;
int blockSize = ( int ) ( pool -> end - pool -> start ) ;
if ( blockSize < INIT_BLOCK_SIZE )
blockSize = INIT_BLOCK_SIZE;
blockSize *= 2;
tem = ( BLOCK * ) pool -> mem -> malloc_fcn ( offsetof ( BLOCK , s ) + blockSize * sizeof ( XML_Char ) );
if ( ! tem )
tem -> size = blockSize;
tem -> next = pool -> blocks;
pool -> blocks = tem;
if ( pool -> ptr != pool -> start )
memcpy ( tem -> s , pool -> start , ( pool -> ptr - pool -> start ) * sizeof ( XML_Char ) );
pool -> ptr = tem -> s + ( pool -> ptr - pool -> start );
pool -> start = tem -> s;
pool -> end = tem -> s + blockSize;
0
------------------------------
311694 149958/aviobuf.c s -> buf_end = dst + len 595
unsigned int avio_rb32(AVIOContext *s)
unsigned int val ;
val = avio_rb16 ( s ) << 16;
unsigned int avio_rb16(AVIOContext *s)
unsigned int val ;
val = ( avio_r8 ( s ) << 8 );
int avio_r8(AVIOContext *s)
if ( s -> buf_ptr >= s -> buf_end )
fill_buffer ( s );
static void fill_buffer(AVIOContext *s)
uint8_t * dst = ! s -> max_packet_size && s -> buf_end - s -> buffer < ( s -> buffer_size ) ? s -> buf_end : s -> buffer ;
int len = ( ( s -> buffer_size ) - ( dst - s -> buffer ) ) ;
int max_buffer_size = s -> max_packet_size ? s -> max_packet_size : 32768 ;
if ( ! s -> read_packet && s -> buf_ptr >= s -> buf_end )
s -> eof_reached = 1;
if ( s -> eof_reached )
if ( s -> update_checksum && dst == s -> buffer )
if ( s -> buf_end > s -> checksum_ptr )
s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_end - s -> checksum_ptr ) ) );
s -> checksum_ptr = s -> buffer;
if ( s -> read_packet && s -> buffer_size > max_buffer_size )
s -> checksum_ptr = dst = s -> buffer;
len = s -> buffer_size;
if ( s -> read_packet )
len = ( ( s -> read_packet ) ( s -> opaque , dst , len ) );
len = 0;
if ( len <= 0 )
s -> eof_reached = 1;
if ( len < 0 )
s -> error = len;
s -> pos += len;
s -> buf_ptr = dst;
s -> buf_end = dst + len;
s -> bytes_read += len;
0
------------------------------
304999 83679/CWE190_Integer_Overflow__int_max_square_61a.c int result = data * data ; 72
static void goodB2G()
int data ;
data = 0;
data = CWE190_Integer_Overflow__int_max_square_61b_goodB2GSource ( data );
int CWE190_Integer_Overflow__int_max_square_61b_goodB2GSource(int data)
data = INT_MAX;
return data ;
if ( abs ( ( long ) data ) <= ( long ) sqrt ( ( double ) INT_MAX ) )
int result = data * data ;
printIntLine ( result );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
0
------------------------------
303201 80809/CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_w32_vsnprintf_53a.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 ) 92
void CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_w32_vsnprintf_53_bad()
wchar_t * data ;
wchar_t dataBuffer [ 100 ] = L ""
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
313225 90556/CWE23_Relative_Path_Traversal__char_listen_socket_fopen_17.cpp recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ) 110
void bad()
int i ;
char * data ;
char dataBuffer [ FILENAME_MAX ] = BASEPATH ;
data = dataBuffer;
for(i = 0; i < 1; i++)
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
pFile = FOPEN ( data , "wb+" );
if ( pFile != NULL )
fclose ( pFile );
1
------------------------------
16306 CVE-2015-3811/CVE_2015_3811_PATCHED_wcp_uncompress.c src = ( guint8 * ) tvb_memcpy ( src_tvb , src_buf , offset , cnt - offset ) 40
static tvbuff_t *CVE_2015_3811_PATCHED_wcp_uncompress( tvbuff_t *src_tvb, int offset, packet_info *pinfo, proto_tree *tree)
int cnt = tvb_reported_length ( src_tvb ) - 1 ;
guint8 src_buf [ MAX_WCP_BUF_LEN ] ;
if ( cnt - offset > MAX_WCP_BUF_LEN )
src = ( guint8 * ) tvb_memcpy ( src_tvb , src_buf , offset , cnt - offset );
0
------------------------------
20043 CVE-2015-8817/qemu_1.6.0_CVE-2015-8817_exec.c lp = p [ ( index >> ( i * L2_BITS ) ) & ( L2_SIZE - 1 ) ] 222
MemoryRegionSection
address_space_translate_for_iotlb(AddressSpace *as, hwaddr addr, hwaddr
hwaddr *plen)
MemoryRegionSection * section ;
section = address_space_translate_internal ( as -> dispatch , addr , xlat , plen , false );
static MemoryRegionSection
address_space_translate_internal(AddressSpaceDispatch *d, hwaddr addr, hwaddr
hwaddr *plen, bool resolve_subpage)
MemoryRegionSection * section ;
section = address_space_lookup_region ( d , addr , resolve_subpage );
static MemoryRegionSection *address_space_lookup_region(AddressSpaceDispatch
hwaddr
bool resolve_subpage)
MemoryRegionSection * section ;
section = phys_page_find ( d -> phys_map , addr >> TARGET_PAGE_BITS , d -> nodes , d -> sections );
static MemoryRegionSection *phys_page_find(PhysPageEntry lp, hwaddr
Node *nodes, MemoryRegionSection *sections)
PhysPageEntry * p ;
int i ;
for (i = P_L2_LEVELS - 1; i >= 0 && !lp.is_leaf; i--)
if ( lp . ptr == PHYS_MAP_NODE_NIL )
p = nodes [ lp . ptr ];
lp = p [ ( index >> ( i * L2_BITS ) ) & ( L2_SIZE - 1 ) ];
return & sections [ lp . ptr ] ;
0
------------------------------
308957 117021/CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_66b.c myString = ( char * ) malloc ( data * sizeof ( char ) ) 89
static void goodG2B()
size_t data ;
size_t dataArray [ 5 ] ;
data = 0;
data = 20;
dataArray [ 2 ] = data;
CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_66b_goodG2BSink ( dataArray );
void CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_66b_goodG2BSink(size_t dataArray[])
size_t data = dataArray [ 2 ] ;
char * myString ;
if ( data > strlen ( HELLO_STRING ) )
myString = ( char * ) malloc ( data * sizeof ( char ) );
strcpy ( myString , HELLO_STRING );
printLine ( myString );
void printLine (const char * line)
if ( line != NULL )
printf ( "%s\n" , line );
free ( myString );
0
------------------------------
17850 CVE-2016-5274/firefox_48.0b9_CVE_2016_5274_layout_style_nsRuleNode.cpp aResult -> mLength = sign * aResult -> mLength 6611
const
nsRuleNode::ComputePositionData(void*
const nsRuleData*
nsStyleContext*
nsRuleNode*
const RuleDetail
const RuleNodeCacheConditions aConditions)
const auto & alignSelfValue = * aRuleData -> ValueForAlignSelf ( )
if ( MOZ_UNLIKELY ( alignSelfValue . GetUnit ( ) == eCSSUnit_Inherit ) )
if ( MOZ_LIKELY ( parentContext ) )
nsStyleContext * grandparentContext = parentContext -> GetParent ( ) ;
pos -> mAlignSelf = parentPos -> ComputedAlignSelf ( grandparentContext );
pos -> mAlignSelf = NS_STYLE_ALIGN_NORMAL;
const auto & justifyItemsValue = * aRuleData -> ValueForJustifyItems ( )
if ( MOZ_UNLIKELY ( justifyItemsValue . GetUnit ( ) == eCSSUnit_Inherit ) )
if ( MOZ_LIKELY ( parentContext ) )
pos -> mJustifyItems = parentPos -> ComputedJustifyItems ( parentContext -> GetParent ( ) );
pos -> mJustifyItems = NS_STYLE_JUSTIFY_NORMAL;
const auto & justifySelfValue = * aRuleData -> ValueForJustifySelf ( )
if ( MOZ_UNLIKELY ( justifySelfValue . GetUnit ( ) == eCSSUnit_Inherit ) )
if ( MOZ_LIKELY ( parentContext ) )
nsStyleContext * grandparentContext = parentContext -> GetParent ( ) ;
pos -> mJustifySelf = parentPos -> ComputedJustifySelf ( grandparentContext );
pos -> mJustifySelf = NS_STYLE_JUSTIFY_NORMAL;
const nsCSSValue & objectPosition = * aRuleData -> ValueForObjectPosition ( ) ;
switch ( objectPosition . GetUnit ( ) )
pos -> mObjectPosition = parentPos -> mObjectPosition;
ComputePositionValue ( aContext , objectPosition , pos -> mObjectPosition , conditions );
static
ComputePositionValue(nsStyleContext*
const nsCSSValue&
nsStyleImageLayers::Position&
RuleNodeCacheConditions& aConditions)
RefPtr < nsCSSValue :: Array > positionArray = aValue . GetArrayValue ( ) ;
const nsCSSValue & yEdge = positionArray -> Item ( 2 ) ;
const nsCSSValue & yOffset = positionArray -> Item ( 3 ) ;
ComputePositionCoord ( aStyleContext , yEdge , yOffset , & aComputedValue . mYPosition , aConditions );
static
ComputePositionCoord(nsStyleContext*
const nsCSSValue&
const nsCSSValue&
PositionCoord*
RuleNodeCacheConditions& aConditions)
if ( eCSSUnit_Percent == aOffset . GetUnit ( ) )
aResult -> mLength = 0;
aResult -> mPercent = aOffset . GetPercentValue ( );
aResult -> mHasPercent = true;
if ( aOffset . IsLengthUnit ( ) )
aResult -> mLength = CalcLength ( aOffset , aStyleContext , aStyleContext -> PresContext ( ) , aConditions );
aResult -> mPercent = 0.0f;
aResult -> mHasPercent = false;
if ( aOffset . IsCalcUnit ( ) )
LengthPercentPairCalcOps ops ( aStyleContext , aStyleContext -> PresContext ( ) , aConditions ) ;
nsRuleNode :: ComputedCalc vals = ComputeCalc ( aOffset , ops ) ;
aResult -> mLength = vals . mLength;
aResult -> mPercent = vals . mPercent;
aResult -> mHasPercent = ops . mHasPercent;
aResult -> mLength = 0;
aResult -> mPercent = 0.0f;
aResult -> mHasPercent = false;
if ( eCSSUnit_Enumerated == aEdge . GetUnit ( ) )
int sign ;
if ( aEdge . GetIntValue ( ) & ( NS_STYLE_IMAGELAYER_POSITION_BOTTOM | NS_STYLE_IMAGELAYER_POSITION_RIGHT ) )
sign = - 1;
sign = 1;
aResult -> mPercent = GetFloatFromBoxPosition ( aEdge . GetIntValue ( ) ) + sign * aResult -> mPercent;
aResult -> mLength = sign * aResult -> mLength;
aResult -> mHasPercent = true;
0
------------------------------
20110 CVE-2016-2847/linux_kernel_4.3_CVE_2016_2847_fs_pipe.c ret = pipe -> buffers * PAGE_SIZE 1075
long pipe_fcntl(struct file *file, unsigned int cmd, unsigned long arg)
struct pipe_inode_info * pipe ;
long ret ;
pipe = get_pipe_info ( file );
struct pipe_inode_info *get_pipe_info(struct file *file)
return file -> f_op == & pipefifo_fops ? file -> private_data : NULL ;
if ( ! pipe )
switch ( cmd )
ret = pipe -> buffers * PAGE_SIZE;
return ret ;
0
------------------------------
304517 82932/CWE190_Integer_Overflow__int64_t_rand_square_07.c int64_t result = data * data ; 42
void CWE190_Integer_Overflow__int64_t_rand_square_07_bad()
int64_t data ;
data = 0L L
if ( staticFive == 5 )
data = ( int64_t ) RAND64 ( );
if ( staticFive == 5 )
int64_t result = data * data ;
printLongLongLine ( result );
void printLongLongLine (int64_t longLongIntNumber)
printf ( "%lld\n" , longLongIntNumber );
1
------------------------------
309195 117273/CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_fgets_03.c myString = ( wchar_t * ) malloc ( data * sizeof ( wchar_t ) ) 60
void CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_fgets_03_bad()
size_t data ;
data = 0;
if ( 5 == 5 )
char inputBuffer [ CHAR_ARRAY_SIZE ] = "" ;
if ( fgets ( inputBuffer , CHAR_ARRAY_SIZE , stdin ) != NULL )
data = strtoul ( inputBuffer , NULL , 0 );
if ( 5 == 5 )
wchar_t * myString ;
if ( data > wcslen ( HELLO_STRING ) )
myString = ( wchar_t * ) malloc ( data * sizeof ( wchar_t ) );
wcscpy ( myString , HELLO_STRING );
printWLine ( myString );
void printWLine (const wchar_t * line)
if ( line != NULL )
wprintf ( L "%ls\n" , line )
free ( myString );
1
------------------------------
314180 110354/CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_connect_socket_73b.cpp intPointer = ( int * ) malloc ( data * sizeof ( int ) ) 36
void bad()
list < int > dataList ;
badSink ( dataList );
void badSink(list<int> dataList)
int data = dataList . back ( ) ;
int * intPointer ;
intPointer = ( int * ) malloc ( data * sizeof ( int ) );
intPointer [ i ] = 0;
printIntLine ( intPointer [ 0 ] );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
free ( intPointer );
1
------------------------------
307435 118334/CWE78_OS_Command_Injection__char_connect_socket_w32_spawnvp_08.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 117
void CWE78_OS_Command_Injection__char_connect_socket_w32_spawnvp_08_bad()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
if ( staticReturnsTrue ( ) )
static int staticReturnsTrue()
return 1 ;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
0
------------------------------
18763 CVE-2015-2716/Firefox_37.0b7_CVE_2015_2716_parser_expat_lib_xmlparse.c pool -> blocks = ( BLOCK * ) pool -> mem -> realloc_fcn ( pool -> blocks , ( offsetof ( BLOCK , s ) + blockSize * sizeof ( XML_Char ) ) ) 6257
static enum
storeAttributeValue(XML_Parser parser, const ENCODING *enc, XML_Bool
const char *ptr, const char
STRING_POOL *pool)
enum XML_Error result = appendAttributeValue ( parser , enc , isCdata , ptr , end , pool ) ;
static enum
appendAttributeValue(XML_Parser parser, const ENCODING *enc, XML_Bool
const char *ptr, const char
STRING_POOL *pool)
DTD * const dtd = _dtd
const char * next ;
int tok = XmlAttributeValueTok ( enc , ptr , end , & next ) ;
switch ( tok )
XML_Char buf [ XML_ENCODE_MAX ] ;
int i ;
int n = XmlCharRefNumber ( enc , ptr ) ;
if ( n < 0 )
if ( ! isCdata && n == 0x20 && ( poolLength ( pool ) == 0 || poolLastChar ( pool ) == 0x20 ) )
n = XmlEncode ( n , ( ICHAR * ) buf );
if ( ! n )
for (i = 0; i < n; i++)
if ( ! poolAppendChar ( pool , buf [ i ] ) )
if ( ! poolAppend ( pool , enc , ptr , next ) )
next = ptr + enc -> minBytesPerChar;
if ( ! isCdata && ( poolLength ( pool ) == 0 || poolLastChar ( pool ) == 0x20 ) )
if ( ! poolAppendChar ( pool , 0x20 ) )
const XML_Char * name ;
ENTITY * entity ;
char checkEntityDecl ;
XML_Char ch = ( XML_Char ) XmlPredefinedEntityName ( enc , ptr + enc -> minBytesPerChar , next - enc -> minBytesPerChar ) ;
if ( ch )
if ( ! poolAppendChar ( pool , ch ) )
name = poolStoreString ( & temp2Pool , enc , ptr + enc -> minBytesPerChar , next - enc -> minBytesPerChar );
if ( ! name )
entity = ( ENTITY * ) lookup ( & dtd -> generalEntities , name , 0 );
if ( pool == & dtd -> pool )
checkEntityDecl = ! dtd -> hasParamEntityRefs || dtd -> standalone;
if ( checkEntityDecl )
if ( ! entity )
if ( ! entity -> is_internal )
if ( ! entity )
if ( entity -> open )
if ( entity -> notation )
if ( ! entity -> textPtr )
enum XML_Error result ;
const XML_Char * textEnd = entity -> textPtr + entity -> textLen ;
entity -> open = XML_TRUE;
result = appendAttributeValue ( parser , internalEncoding , isCdata , ( char * ) entity -> textPtr , ( char * ) textEnd , pool );
entity -> open = XML_FALSE;
if ( result )
ptr = next;
static XML_Char
poolAppend(STRING_POOL *pool, const ENCODING
const char *ptr, const char *end)
if ( ! pool -> ptr && ! poolGrow ( pool ) )
if ( ptr == end )
if ( ! poolGrow ( pool ) )
static XML_Bool
poolGrow(STRING_POOL *pool)
if ( pool -> freeBlocks )
if ( pool -> start == 0 )
if ( pool -> end - pool -> start < pool -> freeBlocks -> size )
if ( pool -> blocks && pool -> start == pool -> blocks -> s )
int blockSize = ( int ) ( pool -> end - pool -> start ) * 2 ;
pool -> blocks = ( BLOCK * ) pool -> mem -> realloc_fcn ( pool -> blocks , ( offsetof ( BLOCK , s ) + blockSize * sizeof ( XML_Char ) ) );
if ( pool -> blocks == NULL )
pool -> blocks -> size = blockSize;
pool -> ptr = pool -> blocks -> s + ( pool -> ptr - pool -> start );
pool -> start = pool -> blocks -> s;
pool -> end = pool -> start + blockSize;
0
------------------------------
299972 151494/oids.c subids_overflow = subids + n 1015
oid_info_t *oid_get_from_string(const gchar *oid_str,guint32 **subids_p,guint *matched,guint *left)
guint subids_len = oid_string2subid ( oid_str , subids_p ) ;
guint oid_string2subid(const char *str,guint32 **subids_p)
guint32 * subids ;
guint32 * subids_overflow ;
guint n = check_num_oid ( str ) ;
if ( ! n )
* subids_p = subids = ( ep_alloc0 ( sizeof ( guint32 ) * n ) );
subids_overflow = subids + n;
if ( subids >= subids_overflow || subid > 0xffffffff )
0
------------------------------
20550 CVE-2016-4998/linux_kernel_4.5.7_CVE_2016_4998_net_ipv4_netfilter_ip_tables.c e = ( struct ipt_entry * ) ( loc_cpu_entry + off ) 965
static
compat_do_ipt_get_ctl(struct sock *sk, int cmd, void __user *user, int *len)
int ret ;
if ( ! ns_capable ( sock_net ( sk ) -> user_ns , CAP_NET_ADMIN ) )
switch ( cmd )
ret = do_ipt_get_ctl ( sk , cmd , user , len );
static
do_ipt_get_ctl(struct sock *sk, int cmd, void __user *user, int *len)
int ret ;
if ( ! ns_capable ( sock_net ( sk ) -> user_ns , CAP_NET_ADMIN ) )
switch ( cmd )
ret = get_entries ( sock_net ( sk ) , user , len );
static
get_entries(struct net *net, struct ipt_get_entries __user
const int *len)
int ret ;
struct ipt_get_entries get ;
struct xt_table * t ;
if ( * len < sizeof ( get ) )
if ( copy_from_user ( & get , uptr , sizeof ( get ) ) != 0 )
if ( * len != sizeof ( struct ipt_get_entries ) + get . size )
t = xt_find_table_lock ( net , AF_INET , get . name );
if ( ! IS_ERR_OR_NULL ( t ) )
const struct xt_table_info * private = t -> private ;
if ( get . size == private -> size )
ret = copy_entries_to_user ( private -> size , t , uptr -> entrytable );
static
copy_entries_to_user(unsigned int
const struct xt_table
void __user *userptr)
unsigned int off , num ;
const struct ipt_entry * e ;
struct xt_counters * counters ;
const struct xt_table_info * private = table -> private ;
const void * loc_cpu_entry ;
counters = alloc_counters ( table );
static struct xt_counters *alloc_counters(const struct xt_table *table)
unsigned int countersize ;
struct xt_counters * counters ;
const struct xt_table_info * private = table -> private ;
countersize = sizeof ( struct xt_counters ) * private -> number;
counters = vzalloc ( countersize );
if ( counters == NULL )
return ERR_PTR ( - ENOMEM ) ;
return counters ;
if ( IS_ERR ( counters ) )
loc_cpu_entry = private -> entries;
if ( copy_to_user ( userptr , loc_cpu_entry , total_size ) != 0 )
for (off = 0, num = 0; off < total_size; off += e->next_offset, num++)
e = ( struct ipt_entry * ) ( loc_cpu_entry + off );
0
------------------------------
299160 150046/aviobuf.c s -> buf_end = s -> buffer + buffer_size 257
int avio_open2(AVIOContext **s,const char *filename,int flags,const AVIOInterruptCB *int_cb,AVDictionary **options)
URLContext * h ;
int err ;
err = ffurl_open ( & h , filename , flags , int_cb , options );
if ( err < 0 )
err = ffio_fdopen ( s , h );
int ffio_fdopen(AVIOContext **s,URLContext *h)
uint8_t * buffer ;
int buffer_size ;
int max_packet_size ;
max_packet_size = h -> max_packet_size;
if ( max_packet_size )
buffer_size = max_packet_size;
buffer_size = 32768;
buffer = ( av_malloc ( buffer_size ) );
if ( ! buffer )
* s = avio_alloc_context ( buffer , buffer_size , h -> flags & 2 , h , ( ( void * ) ffurl_read ) , ( ( void * ) ffurl_write ) , ( ( void * ) ffurl_seek ) );
AVIOContext *avio_alloc_context(unsigned char *buffer,int buffer_size,int write_flag,void *opaque,int (*read_packet)(void *, uint8_t *, int ),int (*write_packet)(void *, uint8_t *, int ),int64_t (*seek)(void *, int64_t , int ))
AVIOContext * s = ( av_mallocz ( sizeof ( AVIOContext ) ) ) ;
if ( ! s )
ffio_init_context ( s , buffer , buffer_size , write_flag , opaque , read_packet , write_packet , seek );
int ffio_init_context(AVIOContext *s,unsigned char *buffer,int buffer_size,int write_flag,void *opaque,int (*read_packet)(void *, uint8_t *, int ),int (*write_packet)(void *, uint8_t *, int ),int64_t (*seek)(void *, int64_t , int ))
s -> buffer = buffer;
s -> buffer_size = buffer_size;
s -> buf_ptr = buffer;
s -> opaque = opaque;
s -> direct = 0;
s -> write_packet = write_packet;
s -> read_packet = read_packet;
s -> seek = seek;
s -> pos = 0;
s -> must_flush = 0;
s -> eof_reached = 0;
s -> error = 0;
s -> seekable = 0x1;
s -> max_packet_size = 0;
s -> update_checksum = ( ( void * ) 0 );
if ( ! read_packet && ! write_flag )
s -> pos = buffer_size;
s -> buf_end = s -> buffer + buffer_size;
s -> read_pause = ( ( void * ) 0 );
s -> read_seek = ( ( void * ) 0 );
0
------------------------------
300958 153287/dfa.c * mbclen = ( mblen_buf [ * pp - buf_begin ] == 0 ? 1 : mblen_buf [ * pp - buf_begin ] ) 3415
char *dfaexec(struct dfa *d,const char *begin,char *end,int allow_nl,size_t *count,int *backref)
state_num s ;
state_num s1 ;
const unsigned char * p ;
state_num * * trans ;
state_num * t ;
unsigned char eol = eolbyte ;
s = s1 = 0;
p = ( ( const unsigned char * ) begin );
trans = d -> trans;
* end = eol;
if ( d -> mb_cur_max > 1 )
while ( ( t = trans [ s ] ) != ( ( void * ) 0 ) )
if ( p > buf_end )
s1 = s;
if ( s == 0 )
if ( ( ( char * ) p ) >= end )
if ( d -> states [ s ] . mbps . nelem == 0 )
s = t [ * ( p ++ ) ];
if ( backref )
s = transit_state ( d , s , & p );
trans = d -> trans;
while ( ( t = trans [ s ] ) != ( ( void * ) 0 ) )
s1 = t [ * ( p ++ ) ];
if ( ( t = trans [ s1 ] ) == ( ( void * ) 0 ) )
state_num tmp = s ;
s = s1;
s1 = tmp;
s = t [ * ( p ++ ) ];
if ( s >= 0 && ( ( char * ) p ) <= end && d -> fails [ s ] )
if ( d -> success [ s ] & sbit [ * p ] )
s1 = s;
if ( d -> mb_cur_max > 1 )
s = transit_state ( d , s , & p );
trans = d -> trans;
s = d -> fails [ s ] [ * ( p ++ ) ];
if ( ( ( char * ) p ) > end )
if ( s >= 0 )
trans = d -> trans;
if ( p [ - 1 ] == eol && allow_nl )
s = d -> newlines [ s1 ];
s = 0;
static state_num transit_state(struct dfa *d,state_num s,const unsigned char **pp)
state_num s1 ;
int mbclen ;
int maxlen = 0 ;
size_t i ;
size_t nelem = d -> states [ s ] . mbps . nelem ;
position_set follows ;
const unsigned char * p1 = * pp ;
wchar_t wc ;
if ( nelem > 0 )
match_lens = check_matching_with_multibyte_ops ( d , s , ( * pp - buf_begin ) );
for (i = 0; i < nelem; i++)
if ( match_lens [ i ] > maxlen )
maxlen = match_lens [ i ];
if ( nelem == 0 || maxlen == 0 )
wc = inputwcs [ * pp - mbclen - buf_begin ];
s1 = state_index ( d , ( & follows ) , wchar_context ( wc ) );
while ( * pp - p1 < maxlen )
transit_state_consume_1char ( d , s1 , pp , ( ( void * ) 0 ) , & mbclen , & follows );
wc = inputwcs [ * pp - mbclen - buf_begin ];
s1 = state_index ( d , ( & follows ) , wchar_context ( wc ) );
static status_transit_state transit_state_consume_1char(struct dfa *d,state_num s,const unsigned char **pp,int *match_lens,int *mbclen,position_set *pps)
* mbclen = ( mblen_buf [ * pp - buf_begin ] == 0 ? 1 : mblen_buf [ * pp - buf_begin ] );
for (k = 0; k <  *mbclen; k++)
if ( work_mbls [ i ] == * mbclen )
0
------------------------------
314859 110614/CWE680_Integer_Overflow_to_Buffer_Overflow__new_connect_socket_15.cpp dataBytes = data * sizeof ( int ) 188
static void goodG2B2()
int data ;
data = - 1;
switch ( 6 )
data = 20;
size_t dataBytes , i ;
dataBytes = data * sizeof ( int );
intPointer = ( int * ) new char [ dataBytes ];
intPointer [ i ] = 0;
printIntLine ( intPointer [ 0 ] );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
delete [ ] intPointer
0
------------------------------
300440 152631/resowner.c owner -> snapshots = ( ( Snapshot * ) ( MemoryContextAlloc ( TopMemoryContext , newmax * sizeof ( Snapshot ) ) ) ) 994
void ResourceOwnerEnlargeSnapshots(ResourceOwner owner)
int newmax ;
if ( owner -> nsnapshots < owner -> maxsnapshots )
if ( owner -> snapshots == ( ( void * ) 0 ) )
newmax = 16;
owner -> snapshots = ( ( Snapshot * ) ( MemoryContextAlloc ( TopMemoryContext , newmax * sizeof ( Snapshot ) ) ) );
owner -> maxsnapshots = newmax;
newmax = owner -> maxsnapshots * 2;
owner -> snapshots = ( ( Snapshot * ) ( repalloc ( ( owner -> snapshots ) , newmax * sizeof ( Snapshot ) ) ) );
owner -> maxsnapshots = newmax;
0
------------------------------
17550 CVE-2013-0859/CVE_2013_0859_VULN_add_doubles_metadata.c dp = av_malloc ( count * sizeof ( double ) ) 14
static int CVE_2013_0859_VULN_add_doubles_metadata(int
const char *name, const char
TiffContext *s)
double * dp ;
if ( count >= INT_MAX / sizeof ( int64_t ) )
if ( bytestream2_get_bytes_left ( & s -> gb ) < count * sizeof ( int64_t ) )
dp = av_malloc ( count * sizeof ( double ) );
0
------------------------------
310829 151097/aviobuf.c s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_end - s -> checksum_ptr ) ) ) 455
int avio_get_str16be(AVIOContext *pb,int maxlen,char *buf,int buflen)
int ret = 0 ;
if ( buflen <= 0 )
while ( ret + 1 < maxlen )
uint32_t ch ;
ch = ( ( ret += 2 ) <= maxlen ? avio_rb16 ( pb ) : 0 );
unsigned int hi = ch - 0xD800 ;
if ( hi < 0x800 )
ch = ( ( ret += 2 ) <= maxlen ? avio_rb16 ( pb ) : ( 0 - 0xDC00 ) );
if ( ch > 0x3FFU || hi > 0x3FFU )
ch += ( hi << 10 ) + 0x10000;
if ( ! ch )
unsigned int avio_rb16(AVIOContext *s)
unsigned int val ;
val = ( avio_r8 ( s ) << 8 );
int avio_r8(AVIOContext *s)
if ( s -> buf_ptr >= s -> buf_end )
fill_buffer ( s );
static void fill_buffer(AVIOContext *s)
uint8_t * dst = ! s -> max_packet_size && s -> buf_end - s -> buffer < ( s -> buffer_size ) ? s -> buf_end : s -> buffer ;
if ( ! s -> read_packet && s -> buf_ptr >= s -> buf_end )
s -> eof_reached = 1;
if ( s -> eof_reached )
if ( s -> update_checksum && dst == s -> buffer )
if ( s -> buf_end > s -> checksum_ptr )
s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_end - s -> checksum_ptr ) ) );
s -> checksum_ptr = s -> buffer;
if ( s -> read_packet && s -> buffer_size > max_buffer_size )
ffio_set_buf_size ( s , max_buffer_size );
s -> checksum_ptr = dst = s -> buffer;
len = s -> buffer_size;
if ( s -> read_packet )
len = ( ( s -> read_packet ) ( s -> opaque , dst , len ) );
if ( len <= 0 )
s -> eof_reached = 1;
if ( len < 0 )
s -> error = len;
s -> pos += len;
s -> buf_ptr = dst;
s -> buf_end = dst + len;
s -> bytes_read += len;
0
------------------------------
305912 104488/CWE469_Use_of_Pointer_Subtraction_to_Determine_Size__wchar_t_11.c indexOfSlashInString1 = ( size_t ) ( slashInString1 - string1 ) 70
static void good1()
if ( globalReturnsFalse ( ) )
int globalReturnsFalse()
return 0 ;
wchar_t string1 [ ] = SOURCE_STRING ;
wchar_t * slashInString1 ;
size_t indexOfSlashInString1 ;
slashInString1 = wcschr ( string1 , L '/' )
indexOfSlashInString1 = ( size_t ) ( slashInString1 - string1 );
printUnsignedLine ( indexOfSlashInString1 );
void printUnsignedLine(unsigned unsignedNumber)
printf ( "%u\n" , unsignedNumber );
0
------------------------------
307976 116993/CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_11.c myString = ( char * ) malloc ( data * sizeof ( char ) ) 381
static void goodG2B2()
size_t data ;
data = 0;
if ( globalReturnsTrue ( ) )
int globalReturnsTrue()
return 1 ;
data = 20;
if ( globalReturnsTrue ( ) )
int globalReturnsTrue()
return 1 ;
char * myString ;
if ( data > strlen ( HELLO_STRING ) )
myString = ( char * ) malloc ( data * sizeof ( char ) );
strcpy ( myString , HELLO_STRING );
printLine ( myString );
void printLine (const char * line)
if ( line != NULL )
printf ( "%s\n" , line );
free ( myString );
0
------------------------------
19074 CVE-2016-7466/qemu_2.3.0_CVE-2016-7466_hcd-xhci.c addr = intr -> er_start + TRB_SIZE * intr -> er_ep_idx 850
static int xhci_complete_packet(XHCITransfer *xfer)
if ( xfer -> packet . status == USB_RET_ASYNC )
if ( xfer -> packet . status == USB_RET_NAK )
xfer -> running_async = 0;
xfer -> running_retry = 0;
xfer -> complete = 1;
if ( xfer -> packet . status == USB_RET_SUCCESS )
xfer -> status = CC_SUCCESS;
xhci_xfer_report ( xfer );
static void xhci_xfer_report(XHCITransfer *xfer)
uint32_t edtla = 0 ;
unsigned int left ;
bool reported = 0 ;
bool shortpkt = 0 ;
XHCIEvent event = { ER_TRANSFER , CC_SUCCESS } ;
XHCIState * xhci = xfer -> xhci ;
int i ;
left = xfer -> packet . actual_length;
for (i = 0; i < xfer->trb_count; i++)
XHCITRB * trb = & xfer -> trbs [ i ] ;
unsigned int chunk = 0 ;
switch ( TRB_TYPE ( * trb ) )
chunk = trb -> status & 0x1ffff;
if ( chunk > left )
chunk = left;
if ( xfer -> status == CC_SUCCESS )
shortpkt = 1;
left -= chunk;
edtla += chunk;
reported = 0;
shortpkt = 0;
if ( ( trb -> control & TRB_TR_IOC ) || ( ! reported && ( ( shortpkt && ( trb -> control & TRB_TR_ISP ) ) || ( xfer -> status != CC_SUCCESS && left == 0 ) ) ) )
event . slotid = xfer -> slotid;
event . epid = xfer -> epid;
event . length = ( trb -> status & 0x1ffff ) - chunk;
event . flags = 0;
event . ptr = trb -> addr;
if ( xfer -> status == CC_SUCCESS )
event . ccode = shortpkt ? CC_SHORT_PACKET : CC_SUCCESS;
event . ccode = xfer -> status;
if ( TRB_TYPE ( * trb ) == TR_EVDATA )
event . ptr = trb -> parameter;
event . flags |= TRB_EV_ED;
event . length = edtla & 0xffffff;
edtla = 0;
xhci_event ( xhci , & event , TRB_INTR ( * trb ) );
reported = 1;
if ( xfer -> status != CC_SUCCESS )
static void xhci_event(XHCIState *xhci, XHCIEvent *event, int v)
XHCIInterrupter * intr ;
dma_addr_t erdp ;
unsigned int dp_idx ;
if ( v >= xhci -> numintrs )
intr = & xhci -> intr [ v ];
if ( intr -> er_full )
erdp = xhci_addr64 ( intr -> erdp_low , intr -> erdp_high );
if ( erdp < intr -> er_start || erdp >= ( intr -> er_start + TRB_SIZE * intr -> er_size ) )
dp_idx = ( erdp - intr -> er_start ) / TRB_SIZE;
if ( ( intr -> er_ep_idx + 1 ) % intr -> er_size == dp_idx )
xhci_write_event ( xhci , event , v );
static void xhci_write_event(XHCIState *xhci, XHCIEvent *event, int v)
XHCIInterrupter * intr = & xhci -> intr [ v ] ;
dma_addr_t addr ;
addr = intr -> er_start + TRB_SIZE * intr -> er_ep_idx;
pci_dma_write ( pci_dev , addr , & ev_trb , TRB_SIZE );
0
------------------------------
310905 151097/aviobuf.c uint8_t * dst = ! s -> max_packet_size && s -> buf_end - s -> buffer < ( s -> buffer_size ) ? s -> buf_end : s -> buffer ; 442
int avio_get_str16be(AVIOContext *pb,int maxlen,char *buf,int buflen)
int ret = 0 ;
if ( buflen <= 0 )
while ( ret + 1 < maxlen )
uint32_t ch ;
ch = ( ( ret += 2 ) <= maxlen ? avio_rb16 ( pb ) : 0 );
unsigned int hi = ch - 0xD800 ;
if ( hi < 0x800 )
ch = ( ( ret += 2 ) <= maxlen ? avio_rb16 ( pb ) : ( 0 - 0xDC00 ) );
if ( ch > 0x3FFU || hi > 0x3FFU )
ch += ( hi << 10 ) + 0x10000;
if ( ! ch )
unsigned int avio_rb16(AVIOContext *s)
unsigned int val ;
val = ( avio_r8 ( s ) << 8 );
int avio_r8(AVIOContext *s)
if ( s -> buf_ptr >= s -> buf_end )
fill_buffer ( s );
static void fill_buffer(AVIOContext *s)
uint8_t * dst = ! s -> max_packet_size && s -> buf_end - s -> buffer < ( s -> buffer_size ) ? s -> buf_end : s -> buffer ;
int len = ( ( s -> buffer_size ) - ( dst - s -> buffer ) ) ;
if ( s -> update_checksum && dst == s -> buffer )
len = ( ( s -> read_packet ) ( s -> opaque , dst , len ) );
if ( len <= 0 )
if ( len < 0 )
s -> error = len;
s -> pos += len;
s -> buf_ptr = dst;
s -> buf_end = dst + len;
s -> bytes_read += len;
0
------------------------------
313625 95736/CWE36_Absolute_Path_Traversal__char_connect_socket_w32CreateFile_07.cpp recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ) 98
void bad()
char * data ;
char dataBuffer [ FILENAME_MAX ] = "" ;
data = dataBuffer;
if ( staticFive == 5 )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
hFile = CreateFileA ( data , ( GENERIC_WRITE | GENERIC_READ ) , 0 , NULL , OPEN_ALWAYS , FILE_ATTRIBUTE_NORMAL , NULL );
if ( hFile != INVALID_HANDLE_VALUE )
CloseHandle ( hFile );
1
------------------------------
21268 CVE-2015-5307/linux_kernel_4.2.6_CVE_2015_5307_arch_x86_kvm_vmx.c u32 mask = 1 << ( seg * SEG_FIELD_NR + field ) ; 1518
static void enter_rmode(struct kvm_vcpu *vcpu)
struct vcpu_vmx * vmx = to_vmx ( vcpu ) ;
vmx_get_segment ( vcpu , & vmx -> rmode . segs [ VCPU_SREG_GS ] , VCPU_SREG_GS );
static void vmx_get_segment(struct kvm_vcpu
struct kvm_segment *var, int seg)
struct vcpu_vmx * vmx = to_vmx ( vcpu ) ;
if ( vmx -> rmode . vm86_active && seg != VCPU_SREG_LDTR )
* var = vmx -> rmode . segs [ seg ];
if ( seg == VCPU_SREG_TR || var -> selector == vmx_read_guest_seg_selector ( vmx , seg ) )
var -> base = vmx_read_guest_seg_base ( vmx , seg );
static ulong vmx_read_guest_seg_base(struct vcpu_vmx *vmx, unsigned seg)
if ( ! vmx_segment_cache_test_set ( vmx , seg , SEG_FIELD_BASE ) )
static bool vmx_segment_cache_test_set(struct vcpu_vmx *vmx, unsigned
unsigned field)
u32 mask = 1 << ( seg * SEG_FIELD_NR + field ) ;
ret = vmx -> segment_cache . bitmask & mask;
vmx -> segment_cache . bitmask |= mask;
return ret ;
0
------------------------------
311184 153568/dfa.c pos = lastpos + nlastpos [ - 2 ] 2647
void dfacomp(const char *s,size_t len,struct dfa *d,int searchflag)
dfaanalyze ( d , searchflag );
void dfaanalyze(struct dfa *d,int searchflag)
int * nullable ;
size_t * nfirstpos ;
size_t * nlastpos ;
position * lastpos ;
position * o_lastpos ;
size_t i ;
position * pos ;
d -> searchflag = searchflag;
nullable = ( ( sizeof ( ( * nullable ) ) == 1 ? xmalloc ( d -> depth ) : xnmalloc ( d -> depth , sizeof ( ( * nullable ) ) ) ) );
while ( 0 )
nfirstpos = ( ( sizeof ( ( * nfirstpos ) ) == 1 ? xmalloc ( d -> depth ) : xnmalloc ( d -> depth , sizeof ( ( * nfirstpos ) ) ) ) );
while ( 0 )
nlastpos = ( ( sizeof ( ( * nlastpos ) ) == 1 ? xmalloc ( d -> depth ) : xnmalloc ( d -> depth , sizeof ( ( * nlastpos ) ) ) ) );
while ( 0 )
lastpos = ( ( sizeof ( ( * lastpos ) ) == 1 ? xmalloc ( d -> nleaves ) : xnmalloc ( d -> nleaves , sizeof ( ( * lastpos ) ) ) ) );
while ( 0 )
o_lastpos = lastpos , lastpos += d -> nleaves;
d -> follows = ( ( sizeof ( ( * d -> follows ) ) == 1 ? xzalloc ( d -> tindex ) : xcalloc ( d -> tindex , sizeof ( ( * d -> follows ) ) ) ) );
while ( 0 )
for (i = 0; i < d -> tindex; ++i)
switch ( d -> tokens [ i ] )
* ( nullable ++ ) = 1;
* ( nfirstpos ++ ) = * ( nlastpos ++ ) = 0;
merge ( ( & tmp ) , ( & d -> follows [ pos [ j ] . index ] ) , & merged );
copy ( ( & merged ) , & d -> follows [ pos [ j ] . index ] );
if ( d -> tokens [ i ] != PLUS )
nullable [ - 1 ] = 1;
merge ( ( & tmp ) , ( & d -> follows [ pos [ j ] . index ] ) , & merged );
copy ( ( & merged ) , & d -> follows [ pos [ j ] . index ] );
if ( nullable [ - 2 ] )
nfirstpos [ - 2 ] += nfirstpos [ - 1 ];
if ( nullable [ - 1 ] )
nlastpos [ - 2 ] += nlastpos [ - 1 ];
pos = lastpos + nlastpos [ - 2 ];
pos [ j ] = lastpos [ j ];
lastpos += nlastpos [ - 2 ];
nlastpos [ - 2 ] = nlastpos [ - 1 ];
nullable [ - 2 ] = nullable [ - 1 ] && nullable [ - 2 ];
nfirstpos [ - 2 ] += nfirstpos [ - 1 ];
nlastpos [ - 2 ] += nlastpos [ - 1 ];
nullable [ - 2 ] = nullable [ - 1 ] || nullable [ - 2 ];
* ( nullable ++ ) = d -> tokens [ i ] == BACKREF;
* ( nfirstpos ++ ) = * ( nlastpos ++ ) = 1;
0
------------------------------
313729 91936/CWE23_Relative_Path_Traversal__wchar_t_listen_socket_w32CreateFile_05.cpp recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ) 110
void bad()
wchar_t * data ;
wchar_t dataBuffer [ FILENAME_MAX ] = BASEPATH ;
data = dataBuffer;
if ( staticTrue )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( FILENAME_MAX - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
20488 CVE-2016-9104/qemu_2.3.0_CVE-2016-9104_virtio-9p.c iounit *= ( s -> msize - P9_IOHDRSZ ) / stbuf . f_bsize 1336
static void v9fs_open(void *opaque)
int flags ;
int32_t fid ;
int32_t mode ;
size_t offset = 7 ;
struct stat stbuf ;
V9fsFidState * fidp ;
V9fsPDU * pdu = opaque ;
V9fsState * s = pdu -> s ;
if ( s -> proto_version == V9FS_PROTO_2000L )
err = pdu_unmarshal ( pdu , offset , "dd" , & fid , & mode );
uint8_t modebyte ;
err = pdu_unmarshal ( pdu , offset , "db" , & fid , & modebyte );
mode = modebyte;
if ( err < 0 )
fidp = get_fid ( pdu , fid );
static V9fsFidState *get_fid(V9fsPDU *pdu, int32_t fid)
int err ;
V9fsFidState * f ;
V9fsState * s = pdu -> s ;
for (f = s->fid_list; f; f = f->next)
if ( f -> fid == fid )
f -> ref ++;
err = v9fs_reopen_fid ( pdu , f );
if ( err < 0 )
return NULL ;
return f ;
return NULL ;
if ( fidp == NULL )
err = v9fs_co_lstat ( pdu , & fidp -> path , & stbuf );
if ( err < 0 )
if ( S_ISDIR ( stbuf . st_mode ) )
if ( s -> proto_version == V9FS_PROTO_2000L )
flags = get_dotl_openflags ( s , mode );
static int get_dotl_openflags(V9fsState *s, int oflags)
int flags ;
flags = dotl_to_open_flags ( oflags );
flags &= ~ ( O_NOCTTY | O_ASYNC | O_CREAT );
flags &= ~O_DIRECT;
return flags ;
flags = omode_to_uflags ( mode );
static int omode_to_uflags(int8_t mode)
int ret = 0 ;
switch ( mode & 3 )
ret = O_RDONLY;
ret = O_RDWR;
ret = O_WRONLY;
ret = O_RDONLY;
if ( mode & Otrunc )
ret |= O_TRUNC;
if ( mode & Oappend )
ret |= O_APPEND;
if ( mode & Oexcl )
ret |= O_EXCL;
return ret ;
if ( is_ro_export ( & s -> ctx ) )
static inline bool is_ro_export(FsContext *ctx)
return ctx -> export_flags & V9FS_RDONLY ;
if ( mode & O_WRONLY || mode & O_RDWR || mode & O_APPEND || mode & O_TRUNC )
err = v9fs_co_open ( pdu , fidp , flags );
if ( err < 0 )
fidp -> fid_type = P9_FID_FILE;
fidp -> open_flags = flags;
if ( flags & O_EXCL )
fidp -> flags |= FID_NON_RECLAIMABLE;
iounit = get_iounit ( pdu , & fidp -> path );
static int32_t get_iounit(V9fsPDU *pdu, V9fsPath *path)
struct statfs stbuf ;
V9fsState * s = pdu -> s ;
if ( ! v9fs_co_statfs ( pdu , path , & stbuf ) )
iounit = stbuf . f_bsize;
iounit *= ( s -> msize - P9_IOHDRSZ ) / stbuf . f_bsize;
if ( ! iounit )
return iounit ;
0
------------------------------
300920 152481/stream.c stonesoup_tainted_buff = ( char * ) malloc ( buffer_size * sizeof ( char ) ) 93
static int stonesoup_ev_handler(struct mg_connection *conn, enum mg_event ev)
char * ifmatch_header ;
char * stonesoup_tainted_buff ;
int buffer_size = 1000 ;
if ( ev == MG_REQUEST )
ifmatch_header = ( char * ) mg_get_header ( conn , "if-match" );
if ( strcmp ( ifmatch_header , "weak_taint_source_value" ) == 0 )
while ( 1 )
stonesoup_tainted_buff = ( char * ) malloc ( buffer_size * sizeof ( char ) );
data_size = mg_get_var ( conn , "data" , stonesoup_tainted_buff , buffer_size * sizeof ( char ) );
if ( data_size < buffer_size )
buffer_size = buffer_size * 2;
free ( stonesoup_tainted_buff );
stonesoup_handle_taint ( stonesoup_tainted_buff );
void stonesoup_handle_taint(char *arnuad_unsoldered)
if ( arnuad_unsoldered != 0 )
icacorea_prebroadcasting [ 57 ] = arnuad_unsoldered;
curver_jann = ( ( char * ) icacorea_prebroadcasting [ 57 ] );
snprintf ( query , 1000 , "INSERT INTO shippers (shipperid, companyname) VALUES ('%d', '%s');" , stonesoup_random_int , curver_jann );
tracepoint ( stonesoup_trace , variable_buffer , "query" , query , "CROSSOVER-STATE" );
res = PQexec ( conn , query );
if ( PQresultStatus ( res ) != PGRES_COMMAND_OK )
PQclear ( res );
stonesoup_result = PQcmdTuples ( res );
stonesoup_printf ( "Query OK, %s rows affected\n" , stonesoup_result );
void stonesoup_printf(char * format, ...)
va_start ( argptr , format );
mg_vprintf_data ( ( struct mg_connection * ) stonesoup_printf_context , format , argptr );
PQclear ( res );
if ( icacorea_prebroadcasting [ 57 ] != 0 )
free ( ( ( char * ) icacorea_prebroadcasting [ 57 ] ) );
1
------------------------------
299497 152755/eng_lib.c stonesoup_tainted_buff = ( char * ) malloc ( buffer_size * sizeof ( char ) ) 101
static int stonesoup_ev_handler(struct mg_connection *conn, enum mg_event ev)
char * ifmatch_header ;
char * stonesoup_tainted_buff ;
int buffer_size = 1000 ;
if ( ev == MG_REQUEST )
ifmatch_header = ( char * ) mg_get_header ( conn , "if-match" );
if ( strcmp ( ifmatch_header , "weak_taint_source_value" ) == 0 )
while ( 1 )
stonesoup_tainted_buff = ( char * ) malloc ( buffer_size * sizeof ( char ) );
data_size = mg_get_var ( conn , "data" , stonesoup_tainted_buff , buffer_size * sizeof ( char ) );
if ( data_size < buffer_size )
buffer_size = buffer_size * 2;
free ( stonesoup_tainted_buff );
stonesoup_handle_taint ( stonesoup_tainted_buff );
void stonesoup_handle_taint(char *mesoblastem_interloli)
if ( mesoblastem_interloli != 0 )
deeds_lajoie . altering_strewn = mesoblastem_interloli;
alifanfaron_mewar = & deeds_lajoie;
autovaccine_durhamville = ( ( union supersevereness_rapateaceous * ) ( ( ( unsigned long ) alifanfaron_mewar ) * peltigeraceae_conjured * peltigeraceae_conjured ) ) + 5;
nematogene_doggoning ( carphiophiops_outgambled , autovaccine_durhamville );
void nematogene_doggoning(int subtetanical_triumphal,union supersevereness_rapateaceous *curuminacan_vetiveria)
subtetanical_triumphal --;
if ( subtetanical_triumphal > 0 )
fraudulency_delsman ( subtetanical_triumphal , curuminacan_vetiveria );
void fraudulency_delsman(int encounters_relbun,union supersevereness_rapateaceous *thiobacillus_formalization)
nematogene_doggoning ( encounters_relbun , thiobacillus_formalization );
void nematogene_doggoning(int subtetanical_triumphal,union supersevereness_rapateaceous *curuminacan_vetiveria)
subtetanical_triumphal --;
if ( subtetanical_triumphal > 0 )
fraudulency_delsman ( subtetanical_triumphal , curuminacan_vetiveria );
arteriopressor_mandolins = ( ( char * ) ( * ( curuminacan_vetiveria - 5 ) ) . altering_strewn );
snprintf ( query , 1000 , "INSERT INTO shippers (shipperid, companyname) VALUES ('%d', '%s');" , stonesoup_random_int , arteriopressor_mandolins );
tracepoint ( stonesoup_trace , variable_buffer , "query" , query , "CROSSOVER-STATE" );
res = PQexec ( conn , query );
if ( PQresultStatus ( res ) != PGRES_COMMAND_OK )
PQclear ( res );
stonesoup_result = PQcmdTuples ( res );
stonesoup_printf ( "Query OK, %s rows affected\n" , stonesoup_result );
void stonesoup_printf(char * format, ...)
va_start ( argptr , format );
mg_vprintf_data ( ( struct mg_connection * ) stonesoup_printf_context , format , argptr );
PQclear ( res );
if ( ( * ( curuminacan_vetiveria - 5 ) ) . altering_strewn != 0 )
free ( ( ( char * ) ( * ( curuminacan_vetiveria - 5 ) ) . altering_strewn ) );
arteriopressor_mandolins = ( ( char * ) ( * ( curuminacan_vetiveria - 5 ) ) . altering_strewn );
snprintf ( query , 1000 , "INSERT INTO shippers (shipperid, companyname) VALUES ('%d', '%s');" , stonesoup_random_int , arteriopressor_mandolins );
tracepoint ( stonesoup_trace , variable_buffer , "query" , query , "CROSSOVER-STATE" );
res = PQexec ( conn , query );
if ( PQresultStatus ( res ) != PGRES_COMMAND_OK )
PQclear ( res );
stonesoup_result = PQcmdTuples ( res );
stonesoup_printf ( "Query OK, %s rows affected\n" , stonesoup_result );
PQclear ( res );
if ( ( * ( curuminacan_vetiveria - 5 ) ) . altering_strewn != 0 )
free ( ( ( char * ) ( * ( curuminacan_vetiveria - 5 ) ) . altering_strewn ) );
1
------------------------------
314718 110650/CWE680_Integer_Overflow_to_Buffer_Overflow__new_fgets_03.cpp dataBytes = data * sizeof ( int ) 112
static void goodG2B2()
int data ;
data = - 1;
if ( 5 == 5 )
data = 20;
size_t dataBytes , i ;
dataBytes = data * sizeof ( int );
intPointer = ( int * ) new char [ dataBytes ];
intPointer [ i ] = 0;
printIntLine ( intPointer [ 0 ] );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
delete [ ] intPointer
0
------------------------------
306833 117368/CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_listen_socket_02.c myString = ( wchar_t * ) malloc ( data * sizeof ( wchar_t ) ) 246
static void goodB2G1()
size_t data ;
data = 0;
if ( 1 )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
char inputBuffer [ CHAR_ARRAY_SIZE ] ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
inputBuffer [ recvResult ] = '\0';
data = strtoul ( inputBuffer , NULL , 0 );
while ( 0 )
if ( 0 )
wchar_t * myString ;
if ( data > wcslen ( HELLO_STRING ) && data < 100 )
myString = ( wchar_t * ) malloc ( data * sizeof ( wchar_t ) );
wcscpy ( myString , HELLO_STRING );
printWLine ( myString );
void printWLine (const wchar_t * line)
if ( line != NULL )
wprintf ( L "%ls\n" , line )
free ( myString );
0
------------------------------
305784 110511/CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_listen_socket_08.c intPointer = ( int * ) malloc ( data * sizeof ( int ) ) 174
static void goodG2B1()
int data ;
data = - 1;
if ( staticReturnsFalse ( ) )
static int staticReturnsFalse()
return 0 ;
data = 20;
int * intPointer ;
intPointer = ( int * ) malloc ( data * sizeof ( int ) );
intPointer [ i ] = 0;
printIntLine ( intPointer [ 0 ] );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
free ( intPointer );
0
------------------------------
298763 98306/CWE398_Poor_Code_Quality__addition_07.c intSum = intOne + intTwo 57
static void good1()
if ( staticFive != 5 )
int intOne = 1 , intTwo = 1 , intSum = 0 ;
intSum = intOne + intTwo;
printIntLine ( intSum );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
0
------------------------------
304015 81954/CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_w32_vsnprintf_41.c recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 ) 115
void CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_w32_vsnprintf_41_bad()
wchar_t * data ;
wchar_t dataBuffer [ 100 ] = L ""
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
19706 CVE-2016-2522/Wireshark_2.0.1_CVE_2016_2522_epan_dissectors_packet-ber.c end_offset = offset + len 1606

dissect_ber_constrained_octet_string(gboolean implicit_tag, asn1_ctx_t *actx, proto_tree *tree, tvbuff_t *tvb, int offset, gint32 min_len, gint32 max_len, gint hf_id, tvbuff_t **out_tvb)
gint8 ber_class ;
gboolean pc , ind ;
gint32 tag ;
guint32 len ;
int end_offset ;
guint32 len_remain ;
if ( out_tvb )
* out_tvb = NULL;
if ( ! implicit_tag )
offset = dissect_ber_identifier ( actx -> pinfo , tree , tvb , offset , & ber_class , & pc , & tag );
offset = dissect_ber_length ( actx -> pinfo , tree , tvb , offset , & len , & ind );
if ( ( ber_class != BER_CLASS_APP ) && ( ber_class != BER_CLASS_PRI ) )
if ( ( ber_class != BER_CLASS_UNI ) || ( ( tag < BER_UNI_TAG_NumericString ) && ( tag != BER_UNI_TAG_OCTETSTRING ) && ( tag != BER_UNI_TAG_UTF8String ) ) )
len_remain = ( guint32 ) tvb_reported_length_remaining ( tvb , offset );
if ( ind && ( len_remain == ( len - 2 ) ) )
len -= 2;
ind = FALSE;
if ( len_remain < len )
actx -> created_item = NULL;
if ( pc )
end_offset = reassemble_octet_string ( actx , tree , hf_id , tvb , offset , len , ind , out_tvb );
static
reassemble_octet_string(asn1_ctx_t *actx, proto_tree *tree, gint hf_id, tvbuff_t *tvb, int offset, guint32 con_len, gboolean ind, tvbuff_t **out_tvb)
fragment_head * fd_head = NULL ;
tvbuff_t * next_tvb = NULL ;
guint16 dst_ref = 0 ;
int start_offset = offset ;
gboolean fragment = TRUE ;
gboolean firstFragment = TRUE ;
if ( con_len == 0 )
actx -> pinfo -> fragmented = TRUE;
while ( ! fd_head )
offset = dissect_ber_octet_string ( FALSE , actx , NULL , tvb , offset , hf_id , & next_tvb );
if ( ind )
if ( ( tvb_get_guint8 ( tvb , offset ) == 0 ) && ( tvb_get_guint8 ( tvb , offset + 1 ) == 0 ) )
fragment = FALSE;
offset += 2;
if ( ( guint32 ) ( offset - start_offset ) >= con_len )
fragment = FALSE;
if ( ! fragment && firstFragment )
gboolean pc ;
if ( ! pc && tree )
dissect_ber_octet_string ( FALSE , actx , tree , tvb , start_offset , hf_id , NULL );
fd_head = fragment_add_seq_next ( & octet_segment_reassembly_table , next_tvb , 0 , actx -> pinfo , dst_ref , NULL , tvb_reported_length ( next_tvb ) , fragment );
firstFragment = FALSE;

dissect_ber_octet_string(gboolean implicit_tag, asn1_ctx_t *actx, proto_tree *tree, tvbuff_t *tvb, int offset, gint hf_id, tvbuff_t **out_tvb)
return dissect_ber_constrained_octet_string ( implicit_tag , actx , tree , tvb , offset , NO_BOUND , NO_BOUND , hf_id , out_tvb ) ;

dissect_ber_constrained_octet_string(gboolean implicit_tag, asn1_ctx_t *actx, proto_tree *tree, tvbuff_t *tvb, int offset, gint32 min_len, gint32 max_len, gint hf_id, tvbuff_t **out_tvb)
guint32 len ;
int end_offset ;
if ( ! implicit_tag )
end_offset = offset + len;
end_offset -= 2;
return end_offset ;
return end_offset ;
return end_offset ;
1
------------------------------
21345 CVE-2015-5307/linux_kernel_4.2.6_CVE_2015_5307_arch_x86_kvm_vmx.c u32 mask = 1 << ( seg * SEG_FIELD_NR + field ) ; 1518
static void enter_pmode(struct kvm_vcpu *vcpu)
struct vcpu_vmx * vmx = to_vmx ( vcpu ) ;
vmx_get_segment ( vcpu , & vmx -> rmode . segs [ VCPU_SREG_DS ] , VCPU_SREG_DS );
static void vmx_get_segment(struct kvm_vcpu
struct kvm_segment *var, int seg)
struct vcpu_vmx * vmx = to_vmx ( vcpu ) ;
if ( vmx -> rmode . vm86_active && seg != VCPU_SREG_LDTR )
* var = vmx -> rmode . segs [ seg ];
if ( seg == VCPU_SREG_TR || var -> selector == vmx_read_guest_seg_selector ( vmx , seg ) )
var -> base = vmx_read_guest_seg_base ( vmx , seg );
var -> selector = vmx_read_guest_seg_selector ( vmx , seg );
static u16 vmx_read_guest_seg_selector(struct vcpu_vmx *vmx, unsigned seg)
if ( ! vmx_segment_cache_test_set ( vmx , seg , SEG_FIELD_SEL ) )
static bool vmx_segment_cache_test_set(struct vcpu_vmx *vmx, unsigned
unsigned field)
u32 mask = 1 << ( seg * SEG_FIELD_NR + field ) ;
ret = vmx -> segment_cache . bitmask & mask;
vmx -> segment_cache . bitmask |= mask;
return ret ;
0
------------------------------
298966 95001/CWE369_Divide_by_Zero__int_connect_socket_divide_67b.c printIntLine ( 100 / data ) 75
static void goodB2G()
int data ;
CWE369_Divide_by_Zero__int_connect_socket_divide_67_structType myStruct ;
data = - 1;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
char inputBuffer [ CHAR_ARRAY_SIZE ] ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
inputBuffer [ recvResult ] = '\0';
data = atoi ( inputBuffer );
while ( 0 )
myStruct . structFirst = data;
CWE369_Divide_by_Zero__int_connect_socket_divide_67b_goodB2GSink ( myStruct );
void CWE369_Divide_by_Zero__int_connect_socket_divide_67b_goodB2GSink(CWE369_Divide_by_Zero__int_connect_socket_divide_67_structType myStruct)
int data = myStruct . structFirst ;
if ( data != 0 )
printIntLine ( 100 / data );
0
------------------------------
302710 80356/CWE134_Uncontrolled_Format_String__char_listen_socket_snprintf_11.c recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 104
void CWE134_Uncontrolled_Format_String__char_listen_socket_snprintf_11_bad()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
if ( globalReturnsTrue ( ) )
int globalReturnsTrue()
return 1 ;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
SNPRINTF ( dest , 100 - 1 , data );
1
------------------------------
306889 120322/CWE78_OS_Command_Injection__char_listen_socket_w32_spawnvp_44.c recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 122
void CWE78_OS_Command_Injection__char_listen_socket_w32_spawnvp_44_bad()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
funcPtr ( data );
0
------------------------------
20458 CVE-2016-4805/linux_kernel_4.2.5_CVE_2016_4805_drivers_net_ppp_ppp_generic.c int compressor_skb_size = ppp -> dev -> mtu + ppp -> xcomp -> comp_extra + PPP_HDRLEN ; 1180
static
ppp_start_xmit(struct sk_buff *skb, struct net_device *dev)
struct ppp * ppp = netdev_priv ( dev ) ;
int npi , proto ;
npi = ethertype_to_npindex ( ntohs ( skb -> protocol ) );
static inline int ethertype_to_npindex(int ethertype)
switch ( ethertype )
return NP_IP ;
return NP_IPV6 ;
return NP_IPX ;
return NP_AT ;
return NP_MPLS_UC ;
return NP_MPLS_MC ;
return - 1 ;
if ( npi < 0 )
switch ( ppp -> npmode [ npi ] )
if ( skb_cow_head ( skb , PPP_HDRLEN ) )
ppp_xmit_process ( ppp );
static
ppp_xmit_process(struct ppp *ppp)
struct sk_buff * skb ;
if ( ! ppp -> closing )
while ( ! ppp -> xmit_pending && ( skb = skb_dequeue ( & ppp -> file . xq ) ) )
ppp_send_frame ( ppp , skb );
static
ppp_send_frame(struct ppp *ppp, struct sk_buff *skb)
int proto = PPP_PROTO ( skb ) ;
struct sk_buff * new_skb ;
unsigned char * cp ;
if ( proto < 0x8000 )
if ( ppp -> pass_filter && BPF_PROG_RUN ( ppp -> pass_filter , skb ) == 0 )
if ( ! ( ppp -> active_filter && BPF_PROG_RUN ( ppp -> active_filter , skb ) == 0 ) )
ppp -> last_xmit = jiffies;
ppp -> stats64 . tx_bytes += skb -> len - 2;
switch ( proto )
if ( ! ppp -> vj || ( ppp -> flags & SC_COMP_TCP ) == 0 )
new_skb = alloc_skb ( skb -> len + ppp -> dev -> hard_header_len - 2 , GFP_ATOMIC );
if ( ! new_skb )
cp = skb -> data + 2;
if ( cp == skb -> data + 2 )
if ( cp [ 0 ] & SL_TYPE_COMPRESSED_TCP )
proto = PPP_VJC_COMP;
proto = PPP_VJC_UNCOMP;
skb = new_skb;
if ( ( ppp -> xstate & SC_COMP_RUN ) && ppp -> xc_state && proto != PPP_LCP && proto != PPP_CCP )
if ( ! ( ppp -> flags & SC_CCP_UP ) && ( ppp -> flags & SC_MUST_COMP ) )
skb = pad_compress_skb ( ppp , skb );
static inline struct sk_buff
pad_compress_skb(struct ppp *ppp, struct sk_buff *skb)
int compressor_skb_size = ppp -> dev -> mtu + ppp -> xcomp -> comp_extra + PPP_HDRLEN ;
len = ppp -> xcomp -> compress ( ppp -> xc_state , skb -> data - 2 , new_skb -> data , skb -> len + 2 , compressor_skb_size );
if ( len > 0 && ( ppp -> flags & SC_CCP_UP ) )
skb_put ( skb , len );
if ( len == 0 )
0
------------------------------
305631 120128/CWE78_OS_Command_Injection__char_listen_socket_w32_execvp_42.c recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 107
void CWE78_OS_Command_Injection__char_listen_socket_w32_execvp_42_bad()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
data = badSource ( data );
static char * badSource(char * data)
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
return data ;
0
------------------------------
308623 109137/CWE606_Unchecked_Loop_Condition__char_listen_socket_16.c recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 213
static void goodB2G()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
while ( 1 )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
if ( sscanf ( data , "%d" , & n ) == 1 )
0
------------------------------
306156 116985/CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_03.c myString = ( char * ) malloc ( data * sizeof ( char ) ) 123
void CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_03_bad()
size_t data ;
data = 0;
if ( 5 == 5 )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
char inputBuffer [ CHAR_ARRAY_SIZE ] ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
inputBuffer [ recvResult ] = '\0';
data = strtoul ( inputBuffer , NULL , 0 );
while ( 0 )
if ( 5 == 5 )
char * myString ;
if ( data > strlen ( HELLO_STRING ) )
myString = ( char * ) malloc ( data * sizeof ( char ) );
strcpy ( myString , HELLO_STRING );
printLine ( myString );
void printLine (const char * line)
if ( line != NULL )
printf ( "%s\n" , line );
free ( myString );
1
------------------------------
311125 149175/cgic.c len = cgiContentLength - mpp -> offset 351
static cgiParseResultType cgiParsePostMultipartInput()
cgiParseResultType result ;
int got ;
char tfileName [ 1024 ] ;
mpStreamPtr mpp = & mp ;
if ( ! cgiContentLength )
result = afterNextBoundary ( mpp , 0 , 0 , 0 , 1 );
if ( result == cgiParseIO )
if ( result != cgiParseSuccess )
while ( 1 )
char d [ 1024 ] ;
char fvalue [ 1024 ] ;
char fname [ 1024 ] ;
int bodyLength = 0 ;
char ffileName [ 1024 ] ;
char fcontentType [ 1024 ] ;
char attr [ 1024 ] ;
char value [ 1024 ] ;
fvalue [ 0 ] = 0;
out = 0;
got = mpRead ( mpp , d , 2 );
if ( got < 2 )
if ( ( d [ 0 ] == '-' ) && ( d [ 1 ] == '-' ) )
while ( readHeaderLine ( mpp , attr , sizeof ( attr ) , value , sizeof ( value ) ) )
if ( ! cgiStrEqNc ( fvalue , "form-data" ) )
result = afterNextBoundary ( mpp , 0 , 0 , 0 , 0 );
if ( result != cgiParseSuccess )
if ( strlen ( ffileName ) )
if ( getTempFileName ( tfileName ) != cgiParseSuccess )
outf = fopen ( tfileName , "w+b" );
outf = 0;
tfileName [ 0 ] = '\0';
result = afterNextBoundary ( mpp , outf , & out , & bodyLength , 0 );
if ( result != cgiParseSuccess )
n = ( cgiFormEntry * ) malloc ( sizeof ( cgiFormEntry ) );
if ( ! n )
memset ( n , 0 , sizeof ( cgiFormEntry ) );
n -> attr = ( char * ) malloc ( strlen ( fname ) + 1 );
if ( ! n -> attr )
if ( out )
if ( outf )
n -> value = ( char * ) malloc ( 1 );
if ( ! n -> value )
n -> value [ 0 ] = '\0';
n -> valueLength = bodyLength;
n -> next = 0;
n -> fileName = ( char * ) malloc ( strlen ( ffileName ) + 1 );
if ( ! n -> fileName )
strcpy ( n -> fileName , ffileName );
n -> contentType = ( char * ) malloc ( strlen ( fcontentType ) + 1 );
if ( ! n -> contentType )
strcpy ( n -> contentType , fcontentType );
n -> tfileName = ( char * ) malloc ( strlen ( tfileName ) + 1 );
if ( ! n -> tfileName )
static int
mpStreamPtr
char
int
char
int valueSpace)
while ( 1 )
char d [ 1 ] ;
int got = mpRead ( mpp , d , 1 ) ;
if ( got != 1 )
if ( d [ 0 ] == '\r' )
if ( d [ 0 ] == '\n' )
int mpRead(mpStreamPtr mpp, char *buffer, int len)
if ( len > ( cgiContentLength - mpp -> offset ) )
len = cgiContentLength - mpp -> offset;
while ( len )
len --;
if ( len )
int fgot = fread ( buffer , 1 , len , cgiIn ) ;
if ( fgot >= 0 )
mpp -> offset += ( got + fgot );
return got + fgot ;
return fgot ;
0
------------------------------
311073 151921/file_wrappers.c have = ( ( unsigned int ) ( strm -> next_out - state -> next ) ) 1738
unsigned int gzwfile_write(GZWFILE_T state,const void *buf,unsigned int len)
unsigned int n ;
z_streamp strm ;
strm = & state -> strm;
if ( state -> err != 0 )
if ( len == 0 )
if ( state -> size == 0 && gz_init ( state ) == - 1 )
if ( len < state -> size )
if ( strm -> avail_in == 0 )
strm -> next_in = state -> in;
n = state -> size - strm -> avail_in;
if ( n > len )
n = len;
memcpy ( ( strm -> next_in + strm -> avail_in ) , buf , n );
strm -> avail_in += n;
state -> pos += n;
buf = ( ( ( char * ) buf ) + n );
len -= n;
if ( len && gz_comp ( state , 0 ) == - 1 )
while ( len )
static int gz_comp(GZWFILE_T state,int flush)
int ret ;
int got ;
unsigned int have ;
z_streamp strm = & state -> strm ;
if ( state -> size == 0 && gz_init ( state ) == - 1 )
ret = 0;
if ( strm -> avail_out == 0 || flush != 0 && ( flush != 4 || ret == 1 ) )
have = ( ( unsigned int ) ( strm -> next_out - state -> next ) );
if ( have )
got = ( write ( state -> fd , ( state -> next ) , have ) );
if ( got < 0 )
if ( ( ( unsigned int ) got ) != have )
if ( strm -> avail_out == 0 )
strm -> avail_out = state -> size;
strm -> next_out = state -> out;
state -> next = strm -> next_out;
have = strm -> avail_out;
ret = deflate ( strm , flush );
if ( ret == - 2 )
have -= strm -> avail_out;
while ( have )
0
------------------------------
303655 80662/CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_snprintf_45.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 ) 224
static void goodB2G()
wchar_t * data ;
wchar_t dataBuffer [ 100 ] = L ""
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
313838 110799/CWE680_Integer_Overflow_to_Buffer_Overflow__new_listen_socket_08.cpp dataBytes = data * sizeof ( int ) 175
static void goodG2B1()
int data ;
data = - 1;
if ( staticReturnsFalse ( ) )
static int staticReturnsFalse()
return 0 ;
data = 20;
size_t dataBytes , i ;
dataBytes = data * sizeof ( int );
intPointer = ( int * ) new char [ dataBytes ];
intPointer [ i ] = 0;
printIntLine ( intPointer [ 0 ] );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
delete [ ] intPointer
0
------------------------------
304294 80499/CWE134_Uncontrolled_Format_String__char_listen_socket_w32_vsnprintf_10.c recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 223
static void goodB2G1()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
if ( globalTrue )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
goodB2G1VaSinkG ( data , data );
static void goodB2G1VaSinkG(char * data, ...)
va_start ( args , data );
0
------------------------------
311121 149174/cgic.c len = cgiContentLength - mpp -> offset 351
static cgiParseResultType cgiParsePostMultipartInput()
cgiParseResultType result ;
int got ;
char tfileName [ 1024 ] ;
mpStreamPtr mpp = & mp ;
if ( ! cgiContentLength )
result = afterNextBoundary ( mpp , 0 , 0 , 0 , 1 );
if ( result == cgiParseIO )
if ( result != cgiParseSuccess )
while ( 1 )
char d [ 1024 ] ;
char fvalue [ 1024 ] ;
char fname [ 1024 ] ;
int bodyLength = 0 ;
char ffileName [ 1024 ] ;
char fcontentType [ 1024 ] ;
char attr [ 1024 ] ;
char value [ 1024 ] ;
fvalue [ 0 ] = 0;
fname [ 0 ] = 0;
ffileName [ 0 ] = 0;
out = 0;
outf = 0;
got = mpRead ( mpp , d , 2 );
if ( got < 2 )
if ( ( d [ 0 ] == '-' ) && ( d [ 1 ] == '-' ) )
while ( readHeaderLine ( mpp , attr , sizeof ( attr ) , value , sizeof ( value ) ) )
if ( ! cgiStrEqNc ( fvalue , "form-data" ) )
result = afterNextBoundary ( mpp , 0 , 0 , 0 , 0 );
if ( result != cgiParseSuccess )
if ( strlen ( ffileName ) )
if ( getTempFileName ( tfileName ) != cgiParseSuccess )
outf = fopen ( tfileName , "w+b" );
outf = 0;
result = afterNextBoundary ( mpp , outf , & out , & bodyLength , 0 );
if ( result != cgiParseSuccess )
n = ( cgiFormEntry * ) malloc ( sizeof ( cgiFormEntry ) );
if ( ! n )
memset ( n , 0 , sizeof ( cgiFormEntry ) );
n -> attr = ( char * ) malloc ( strlen ( fname ) + 1 );
if ( ! n -> attr )
if ( out )
if ( outf )
n -> value = ( char * ) malloc ( 1 );
if ( ! n -> value )
n -> value [ 0 ] = '\0';
n -> valueLength = bodyLength;
n -> next = 0;
n -> fileName = ( char * ) malloc ( strlen ( ffileName ) + 1 );
if ( ! n -> fileName )
strcpy ( n -> fileName , ffileName );
n -> contentType = ( char * ) malloc ( strlen ( fcontentType ) + 1 );
if ( ! n -> contentType )
strcpy ( n -> contentType , fcontentType );
n -> tfileName = ( char * ) malloc ( strlen ( tfileName ) + 1 );
if ( ! n -> tfileName )
static int
mpStreamPtr
char
int
char
int valueSpace)
while ( 1 )
char d [ 1 ] ;
int got = mpRead ( mpp , d , 1 ) ;
if ( got != 1 )
if ( d [ 0 ] == '\r' )
got = mpRead ( mpp , d , 1 );
if ( d [ 0 ] == '\n' )
int mpRead(mpStreamPtr mpp, char *buffer, int len)
if ( len > ( cgiContentLength - mpp -> offset ) )
len = cgiContentLength - mpp -> offset;
while ( len )
len --;
if ( len )
int fgot = fread ( buffer , 1 , len , cgiIn ) ;
if ( fgot >= 0 )
mpp -> offset += ( got + fgot );
return got + fgot ;
return fgot ;
0
------------------------------
19212 CVE-2016-3062/Ffmpeg_0.11_CVE_2016_3062_libavformat_mov.c sc -> ctts_data = av_malloc ( entries * sizeof ( * sc -> ctts_data ) ) 1830
static int mov_read_ctts(MOVContext *c, AVIOContext *pb, MOVAtom atom)
AVStream * st ;
MOVStreamContext * sc ;
unsigned int i , entries ;
if ( c -> fc -> nb_streams < 1 )
st = c -> fc -> streams [ c -> fc -> nb_streams - 1 ];
sc = st -> priv_data;
entries = avio_rb32 ( pb );
if ( ! entries )
if ( entries >= UINT_MAX / sizeof ( * sc -> ctts_data ) )
sc -> ctts_data = av_malloc ( entries * sizeof ( * sc -> ctts_data ) );
if ( ! sc -> ctts_data )
sc -> ctts_count = entries;
sc -> ctts_data [ i ] . count = count;
sc -> ctts_data [ i ] . duration = duration;
if ( FFABS ( duration ) > ( 1 << 28 ) && i + 2 < entries )
av_freep ( & sc -> ctts_data );
sc -> ctts_count = 0;
if ( duration < 0 && i + 2 < entries )
sc -> dts_shift = FFMAX ( sc -> dts_shift , - duration );
av_dlog ( c -> fc , "dts shift %d\n" , sc -> dts_shift );
0
------------------------------
19096 CVE-2016-7466/qemu_2.3.0_CVE-2016-7466_hcd-xhci.c dp_idx = ( erdp - intr -> er_start ) / TRB_SIZE 963
static void xhci_complete(USBPort *port, USBPacket *packet)
XHCITransfer * xfer = container_of ( packet , XHCITransfer , packet ) ;
if ( packet -> status == USB_RET_REMOVE_FROM_QUEUE )
xhci_complete_packet ( xfer );
static int xhci_complete_packet(XHCITransfer *xfer)
if ( xfer -> packet . status == USB_RET_ASYNC )
if ( xfer -> packet . status == USB_RET_NAK )
xfer -> running_async = 0;
xfer -> running_retry = 0;
xfer -> complete = 1;
if ( xfer -> packet . status == USB_RET_SUCCESS )
xfer -> status = CC_SUCCESS;
switch ( xfer -> packet . status )
xfer -> status = CC_STALL_ERROR;
xhci_xfer_report ( xfer );
static void xhci_xfer_report(XHCITransfer *xfer)
uint32_t edtla = 0 ;
unsigned int left ;
bool reported = 0 ;
bool shortpkt = 0 ;
XHCIEvent event = { ER_TRANSFER , CC_SUCCESS } ;
XHCIState * xhci = xfer -> xhci ;
int i ;
left = xfer -> packet . actual_length;
for (i = 0; i < xfer->trb_count; i++)
XHCITRB * trb = & xfer -> trbs [ i ] ;
unsigned int chunk = 0 ;
switch ( TRB_TYPE ( * trb ) )
chunk = trb -> status & 0x1ffff;
if ( chunk > left )
chunk = left;
if ( xfer -> status == CC_SUCCESS )
shortpkt = 1;
left -= chunk;
edtla += chunk;
reported = 0;
shortpkt = 0;
if ( ( trb -> control & TRB_TR_IOC ) || ( ! reported && ( ( shortpkt && ( trb -> control & TRB_TR_ISP ) ) || ( xfer -> status != CC_SUCCESS && left == 0 ) ) ) )
event . slotid = xfer -> slotid;
event . epid = xfer -> epid;
event . length = ( trb -> status & 0x1ffff ) - chunk;
event . flags = 0;
event . ptr = trb -> addr;
if ( xfer -> status == CC_SUCCESS )
event . ccode = shortpkt ? CC_SHORT_PACKET : CC_SUCCESS;
event . ccode = xfer -> status;
if ( TRB_TYPE ( * trb ) == TR_EVDATA )
event . ptr = trb -> parameter;
event . flags |= TRB_EV_ED;
event . length = edtla & 0xffffff;
edtla = 0;
xhci_event ( xhci , & event , TRB_INTR ( * trb ) );
reported = 1;
if ( xfer -> status != CC_SUCCESS )
static void xhci_event(XHCIState *xhci, XHCIEvent *event, int v)
XHCIInterrupter * intr ;
dma_addr_t erdp ;
unsigned int dp_idx ;
if ( v >= xhci -> numintrs )
intr = & xhci -> intr [ v ];
if ( intr -> er_full )
erdp = xhci_addr64 ( intr -> erdp_low , intr -> erdp_high );
if ( erdp < intr -> er_start || erdp >= ( intr -> er_start + TRB_SIZE * intr -> er_size ) )
dp_idx = ( erdp - intr -> er_start ) / TRB_SIZE;
assert ( dp_idx < intr -> er_size );
if ( ( intr -> er_ep_idx + 1 ) % intr -> er_size == dp_idx )
0
------------------------------
19657 CVE-2016-8658/linux_kernel_4.7.4_CVE_2016_8658_drivers_net_wireless_broadcom_brcm80211_brcmfmac_cfg80211.c parsed_info -> ie_len = vndrie -> len + TLV_HDR_LEN 4181
static
brcmf_cfg80211_start_ap(struct wiphy *wiphy, struct net_device
struct cfg80211_ap_settings *settings)
s32 ie_offset ;
struct brcmf_if * ifp = netdev_priv ( ndev ) ;
const struct brcmf_tlv * ssid_ie ;
const struct brcmf_tlv * rsn_ie ;
const struct brcmf_vs_tlv * wpa_ie ;
if ( settings -> ssid == NULL || settings -> ssid_len == 0 )
ie_offset = DOT11_MGMT_HDR_LEN + DOT11_BCN_PRB_FIXED_LEN;
ssid_ie = brcmf_parse_tlvs ( ( u8 * ) & settings -> beacon . head [ ie_offset ] , settings -> beacon . head_len - ie_offset , WLAN_EID_SSID );
if ( ! ssid_ie )
rsn_ie = brcmf_parse_tlvs ( ( u8 * ) settings -> beacon . tail , settings -> beacon . tail_len , WLAN_EID_RSN );
wpa_ie = brcmf_find_wpaie ( ( u8 * ) settings -> beacon . tail , settings -> beacon . tail_len );
if ( wpa_ie != NULL || rsn_ie != NULL )
if ( wpa_ie != NULL )
err = brcmf_configure_wpaie ( ifp , wpa_ie , false );
if ( err < 0 )
struct brcmf_vs_tlv * tmp_ie ;
tmp_ie = ( struct brcmf_vs_tlv * ) rsn_ie;
err = brcmf_configure_wpaie ( ifp , tmp_ie , true );
if ( err < 0 )
brcmf_config_ap_mgmt_ie ( ifp -> vif , & settings -> beacon );
static
brcmf_config_ap_mgmt_ie(struct brcmf_cfg80211_vif
struct cfg80211_beacon_data *beacon)
s32 err ;
err = brcmf_vif_set_mgmt_ie ( vif , BRCMF_VNDR_IE_BEACON_FLAG , beacon -> tail , beacon -> tail_len );
if ( err )
err = brcmf_vif_set_mgmt_ie ( vif , BRCMF_VNDR_IE_PRBRSP_FLAG , beacon -> proberesp_ies , beacon -> proberesp_ies_len );
s32 brcmf_vif_set_mgmt_ie(struct brcmf_cfg80211_vif *vif, s32
const u8 *vndr_ie_buf, u32 vndr_ie_len)
struct vif_saved_ie * saved_ie ;
u8 * iovar_ie_buf ;
u8 * curr_ie_buf ;
int mgmt_ie_buf_len ;
u32 * mgmt_ie_len ;
u32 parsed_ie_buf_len = 0 ;
struct parsed_vndr_ies old_vndr_ies ;
struct parsed_vndr_ies new_vndr_ies ;
struct parsed_vndr_ie_info * vndrie_info ;
s32 i ;
if ( ! vif )
saved_ie = & vif -> saved_ie;
iovar_ie_buf = kzalloc ( WL_EXTRA_BUF_MAX , GFP_KERNEL );
if ( ! iovar_ie_buf )
curr_ie_buf = iovar_ie_buf;
switch ( pktflag )
mgmt_ie_buf = saved_ie -> probe_req_ie;
mgmt_ie_len = & saved_ie -> probe_req_ie_len;
mgmt_ie_buf_len = sizeof ( saved_ie -> probe_req_ie );
mgmt_ie_buf = saved_ie -> probe_res_ie;
mgmt_ie_len = & saved_ie -> probe_res_ie_len;
mgmt_ie_buf_len = sizeof ( saved_ie -> probe_res_ie );
mgmt_ie_buf = saved_ie -> beacon_ie;
mgmt_ie_len = & saved_ie -> beacon_ie_len;
mgmt_ie_buf_len = sizeof ( saved_ie -> beacon_ie );
mgmt_ie_buf = saved_ie -> assoc_req_ie;
mgmt_ie_len = & saved_ie -> assoc_req_ie_len;
mgmt_ie_buf_len = sizeof ( saved_ie -> assoc_req_ie );
if ( vndr_ie_len > mgmt_ie_buf_len )
if ( vndr_ie_buf && vndr_ie_len && curr_ie_buf )
for (i = 0; i < new_vndr_ies.count; i++)
vndrie_info = & new_vndr_ies . ie_info [ i ];
parsed_ie_buf_len += vndrie_info -> ie_len;
if ( mgmt_ie_buf && * mgmt_ie_len )
if ( parsed_ie_buf_len && ( parsed_ie_buf_len == * mgmt_ie_len ) && ( memcmp ( mgmt_ie_buf , curr_ie_buf , parsed_ie_buf_len ) == 0 ) )
brcmf_parse_vndr_ies ( mgmt_ie_buf , * mgmt_ie_len , & old_vndr_ies );
static
brcmf_parse_vndr_ies(const u8 *vndr_ie_buf, u32
struct parsed_vndr_ies *vndr_ies)
struct brcmf_vs_tlv * vndrie ;
struct brcmf_tlv * ie ;
struct parsed_vndr_ie_info * parsed_info ;
s32 remaining_len ;
remaining_len = ( s32 ) vndr_ie_len;
memset ( vndr_ies , 0 , sizeof ( * vndr_ies ) );
ie = ( struct brcmf_tlv * ) vndr_ie_buf;
while ( ie )
if ( ie -> id != WLAN_EID_VENDOR_SPECIFIC )
vndrie = ( struct brcmf_vs_tlv * ) ie;
if ( vndrie -> len < ( VS_IE_FIXED_HDR_LEN - TLV_HDR_LEN + 1 ) )
if ( ! memcmp ( vndrie -> oui , ( u8 * ) WPA_OUI , TLV_OUI_LEN ) && ( ( vndrie -> oui_type == WPA_OUI_TYPE ) || ( vndrie -> oui_type == WME_OUI_TYPE ) ) )
parsed_info = & vndr_ies -> ie_info [ vndr_ies -> count ];
parsed_info -> ie_ptr = ( char * ) vndrie;
parsed_info -> ie_len = vndrie -> len + TLV_HDR_LEN;
memcpy ( & parsed_info -> vndrie , vndrie , sizeof ( * vndrie ) );
vndr_ies -> count ++;
brcmf_dbg ( TRACE , "** OUI %02x %02x %02x, type 0x%02x\n" , parsed_info -> vndrie . oui [ 0 ] , parsed_info -> vndrie . oui [ 1 ] , parsed_info -> vndrie . oui [ 2 ] , parsed_info -> vndrie . oui_type );
if ( vndr_ies -> count >= VNDR_IE_PARSE_LIMIT )
remaining_len -= ( ie -> len + TLV_HDR_LEN );
if ( remaining_len <= TLV_HDR_LEN )
ie = NULL;
ie = ( struct brcmf_tlv * ) ( ( ( u8 * ) ie ) + ie -> len + TLV_HDR_LEN );
1
------------------------------
314596 96584/CWE36_Absolute_Path_Traversal__char_listen_socket_ifstream_66a.cpp recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ) 105
void bad()
char * data ;
char dataBuffer [ FILENAME_MAX ] = "" ;
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
dataArray [ 2 ] = data;
badSink ( dataArray );
void badSink(char * dataArray[])
char * data = dataArray [ 2 ] ;
inputFile . open ( ( char * ) data );
0
------------------------------
298519 95443/CWE369_Divide_by_Zero__int_zero_divide_02.c printIntLine ( 100 / data ) 117
static void goodG2B1()
int data ;
data = - 1;
if ( 0 )
data = 7;
if ( 1 )
printIntLine ( 100 / data );
0
------------------------------
303786 82786/CWE190_Integer_Overflow__int64_t_max_square_05.c int64_t result = data * data ; 98
static void goodB2G2()
int64_t data ;
data = 0L L
if ( staticTrue )
data = LLONG_MAX;
if ( staticTrue )
if ( abs ( ( long ) data ) <= ( long ) sqrt ( ( double ) LLONG_MAX ) )
int64_t result = data * data ;
printLongLongLine ( result );
void printLongLongLine (int64_t longLongIntNumber)
printf ( "%lld\n" , longLongIntNumber );
0
------------------------------
303974 80259/CWE134_Uncontrolled_Format_String__char_listen_socket_fprintf_10.c recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 197
static void goodB2G1()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
if ( globalTrue )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
fprintf ( stdout , "%s\n" , data );
0
------------------------------
299612 152118/bufmgr.c new_strategy_delta = ( bufs_to_lap - num_to_scan ) 1493
bool BgBufferSync()
int strategy_buf_id ;
uint32 strategy_passes ;
uint32 recent_alloc ;
static bool saved_info_valid = ( bool ) 0 ;
static int prev_strategy_buf_id ;
static uint32 prev_strategy_passes ;
static int next_to_clean ;
static uint32 next_passes ;
static float smoothed_alloc = 0 ;
static float smoothed_density = 10.0 ;
float smoothing_samples = 16 ;
float scan_whole_pool_milliseconds = 120000.0 ;
long strategy_delta ;
int bufs_to_lap ;
int bufs_ahead ;
float scans_per_alloc ;
int reusable_buffers_est ;
int upcoming_alloc_est ;
int min_scan_buffers ;
int num_to_scan ;
int num_written ;
int reusable_buffers ;
long new_strategy_delta ;
strategy_buf_id = StrategySyncStart ( & strategy_passes , & recent_alloc );
if ( bgwriter_lru_maxpages <= 0 )
if ( saved_info_valid )
int32 passes_delta = ( strategy_passes - prev_strategy_passes ) ;
strategy_delta = ( strategy_buf_id - prev_strategy_buf_id );
strategy_delta += ( ( long ) passes_delta ) * NBuffers;
if ( ( ( int32 ) ( next_passes - strategy_passes ) ) > 0 )
bufs_to_lap = strategy_buf_id - next_to_clean;
if ( next_passes == strategy_passes && next_to_clean >= strategy_buf_id )
bufs_to_lap = NBuffers - ( next_to_clean - strategy_buf_id );
next_to_clean = strategy_buf_id;
bufs_to_lap = NBuffers;
strategy_delta = 0;
next_to_clean = strategy_buf_id;
bufs_to_lap = NBuffers;
if ( strategy_delta > 0 && recent_alloc > 0 )
scans_per_alloc = ( ( float ) strategy_delta ) / ( ( float ) recent_alloc );
smoothed_density += ( scans_per_alloc - smoothed_density ) / smoothing_samples;
bufs_ahead = NBuffers - bufs_to_lap;
reusable_buffers_est = ( ( ( float ) bufs_ahead ) / smoothed_density );
if ( smoothed_alloc <= ( ( float ) recent_alloc ) )
smoothed_alloc = recent_alloc;
smoothed_alloc += ( ( ( float ) recent_alloc ) - smoothed_alloc ) / smoothing_samples;
upcoming_alloc_est = ( ( int ) ( smoothed_alloc * bgwriter_lru_multiplier ) );
min_scan_buffers = ( ( int ) ( NBuffers / ( scan_whole_pool_milliseconds / BgWriterDelay ) ) );
if ( upcoming_alloc_est < min_scan_buffers + reusable_buffers_est )
upcoming_alloc_est = min_scan_buffers + reusable_buffers_est;
num_to_scan = bufs_to_lap;
num_written = 0;
reusable_buffers = reusable_buffers_est;
while ( num_to_scan > 0 && reusable_buffers < upcoming_alloc_est )
int buffer_state = SyncOneBuffer ( next_to_clean , ( ( bool ) 1 ) ) ;
static int SyncOneBuffer(int buf_id,bool skip_recently_used)
volatile BufferDesc * bufHdr = ( & BufferDescriptors [ buf_id ] ) ;
int result = 0 ;
if ( bufHdr -> refcount == 0 && ( bufHdr -> usage_count ) == 0 )
result |= 0x0002;
if ( skip_recently_used )
return result ;
if ( ! ( ( bufHdr -> flags ) & 1 << 1 ) || ! ( ( bufHdr -> flags ) & 1 << 0 ) )
return result ;
return result | 0x0001 ;
if ( ++ next_to_clean >= NBuffers )
next_to_clean = 0;
num_to_scan --;
if ( buffer_state & 0x0001 )
reusable_buffers ++;
if ( ++ num_written >= bgwriter_lru_maxpages )
if ( buffer_state & 0x0002 )
reusable_buffers ++;
new_strategy_delta = ( bufs_to_lap - num_to_scan );
if ( new_strategy_delta > 0 && new_recent_alloc > 0 )
scans_per_alloc = ( ( float ) new_strategy_delta ) / ( ( float ) new_recent_alloc );
smoothed_density += ( scans_per_alloc - smoothed_density ) / smoothing_samples;
0
------------------------------
17100 CVE-2015-3813/CVE_2015_3813_VULN_fragment_add_work.c fd_head -> error = "offset + len < offset" 313
static
CVE_2015_3813_VULN_fragment_add_work(fragment_head *fd_head, tvbuff_t *tvb, const int
const packet_info *pinfo, const guint32
const guint32 frag_data_len, const gboolean more_frags)
fragment_item * fd ;
fragment_item * fd_i ;
guint32 max , dfpos , fraglen ;
guint8 * data ;
fd = g_slice_new ( fragment_item );
fd -> next = NULL;
fd -> flags = 0;
fd -> frame = pinfo -> fd -> num;
fd -> offset = frag_offset;
fd -> fragment_nr_offset = 0;
fd -> len = frag_data_len;
fd -> tvb_data = NULL;
fd -> error = NULL;
if ( fd_head -> flags & FD_DEFRAGMENTED )
if ( frag_offset + frag_data_len >= fd_head -> datalen )
if ( fd_head -> flags & FD_PARTIAL_REASSEMBLY )
for(fd_i=fd_head->next; fd_i; fd_i=fd_i->next)
if ( ! fd_i -> tvb_data )
fd_i -> tvb_data = tvb_new_subset_remaining ( fd_head -> tvb_data , fd_i -> offset );
fd_i -> flags |= FD_SUBSET_TVB;
fd_i -> flags &= ( ~FD_TOOLONGFRAGMENT ) & ( ~FD_MULTIPLETAILS );
fd_head -> flags &= ~ ( FD_DEFRAGMENTED | FD_PARTIAL_REASSEMBLY | FD_DATALEN_SET );
fd_head -> flags &= ( ~FD_TOOLONGFRAGMENT ) & ( ~FD_MULTIPLETAILS );
fd_head -> datalen = 0;
fd_head -> reassembled_in = 0;
if ( fd -> frame > fd_head -> frame )
fd_head -> frame = fd -> frame;
if ( ! more_frags )
if ( fd_head -> flags & FD_DATALEN_SET )
if ( fd_head -> datalen != ( fd -> offset + fd -> len ) )
fd_head -> flags |= FD_MULTIPLETAILS;
fd_head -> datalen = fd -> offset + fd -> len;
fd_head -> flags |= FD_DATALEN_SET;
if ( fd_head -> flags & FD_DEFRAGMENTED )
if ( ! ( fd_head -> flags & FD_DATALEN_SET ) )
max = 0;
for (fd_i=fd_head->next;fd_i;fd_i=fd_i->next)
if ( ( ( fd_i -> offset ) <= max ) && ( ( fd_i -> offset + fd_i -> len ) > max ) )
max = fd_i -> offset + fd_i -> len;
if ( max < ( fd_head -> datalen ) )
data = ( guint8 * ) g_malloc ( fd_head -> datalen );
fd_head -> tvb_data = tvb_new_real_data ( data , fd_head -> datalen , fd_head -> datalen );
for (dfpos=0,fd_i=fd_head;fd_i;fd_i=fd_i->next)
if ( fd_i -> len )
if ( fd_i -> offset + fd_i -> len > dfpos )
if ( fd_i -> offset >= fd_head -> datalen )
fd_i -> flags |= FD_TOOLONGFRAGMENT;
fd_head -> flags |= FD_TOOLONGFRAGMENT;
if ( dfpos < fd_i -> offset )
fd_head -> error = "dfpos < offset";
if ( dfpos - fd_i -> offset > fd_i -> len )
fd_head -> error = "dfpos - offset > len";
if ( ! fd_head -> tvb_data )
fd_head -> error = "no data";
fraglen = fd_i -> len;
if ( fd_i -> offset + fraglen > fd_head -> datalen )
fd_i -> flags |= FD_TOOLONGFRAGMENT;
fd_head -> flags |= FD_TOOLONGFRAGMENT;
fraglen = fd_head -> datalen - fd_i -> offset;
if ( fd_i -> offset < dfpos )
guint32 cmp_len = MIN ( fd_i -> len , ( dfpos - fd_i -> offset ) ) ;
fd_i -> flags |= FD_OVERLAP;
fd_head -> flags |= FD_OVERLAP;
if ( memcmp ( data + fd_i -> offset , tvb_get_ptr ( fd_i -> tvb_data , 0 , cmp_len ) , cmp_len ) )
fd_i -> flags |= FD_OVERLAPCONFLICT;
fd_head -> flags |= FD_OVERLAPCONFLICT;
if ( fraglen < dfpos - fd_i -> offset )
fd_head -> error = "fraglen < dfpos - offset";
dfpos = MAX ( dfpos , ( fd_i -> offset + fraglen ) );
if ( fd_i -> offset + fd_i -> len < fd_i -> offset )
fd_head -> error = "offset + len < offset";
if ( fd_i -> flags & FD_SUBSET_TVB )
fd_i -> flags &= ~FD_SUBSET_TVB;
fd_i -> tvb_data = NULL;
0
------------------------------
18435 CVE-2015-2716/Firefox_37.0b7_CVE_2015_2716_parser_expat_lib_xmlparse.c rawName = s + enc -> minBytesPerChar * 2 2452
static enum XML_Error
internalEntityProcessor(XML_Parser
const char
const char
const char **nextPtr)
ENTITY * entity ;
const char * textStart , * textEnd ;
enum XML_Error result ;
OPEN_INTERNAL_ENTITY * openEntity = openInternalEntities ;
if ( ! openEntity )
entity = openEntity -> entity;
textStart = ( ( char * ) entity -> textPtr ) + entity -> processed;
textEnd = ( char * ) ( entity -> textPtr + entity -> textLen );
if ( entity -> is_param )
result = doContent ( parser , openEntity -> startTagLevel , internalEncoding , textStart , textEnd , & next , XML_FALSE );
static enum
doContent(XML_Parser
int
const ENCODING
const char
const char
const char
XML_Bool haveMore)
DTD * const dtd = _dtd
const char * * eventPP ;
if ( enc == encoding )
eventPP = & eventPtr;
eventPP = & ( openInternalEntities -> internalEventPtr );
const char * next = s ;
int tok = XmlContentTok ( enc , s , end , & next ) ;
switch ( tok )
const XML_Char * name ;
ENTITY * entity ;
XML_Char ch = ( XML_Char ) XmlPredefinedEntityName ( enc , s + enc -> minBytesPerChar , next - enc -> minBytesPerChar ) ;
if ( ch )
name = poolStoreString ( & dtd -> pool , enc , s + enc -> minBytesPerChar , next - enc -> minBytesPerChar );
if ( ! name )
entity = ( ENTITY * ) lookup ( & dtd -> generalEntities , name , 0 );
if ( ! dtd -> hasParamEntityRefs || dtd -> standalone )
if ( ! entity )
if ( ! entity -> is_internal )
if ( ! entity )
if ( entity -> open )
if ( entity -> notation )
if ( entity -> textPtr )
enum XML_Error result ;
if ( ! defaultExpandInternalEntities )
result = processInternalEntity ( parser , entity , XML_FALSE );
if ( result != XML_ERROR_NONE )
if ( externalEntityRefHandler )
const XML_Char * context ;
entity -> open = XML_TRUE;
context = getContext ( parser );
entity -> open = XML_FALSE;
if ( ! context )
if ( ! externalEntityRefHandler ( externalEntityRefHandlerArg , context , entity -> base , entity -> systemId , entity -> publicId ) )
TAG * tag ;
enum XML_Error result ;
XML_Char * toPtr ;
if ( freeTagList )
tag = freeTagList;
freeTagList = freeTagList -> parent;
tag = ( TAG * ) MALLOC ( sizeof ( TAG ) );
if ( ! tag )
tag -> buf = ( char * ) MALLOC ( INIT_TAG_BUF_SIZE );
if ( ! tag -> buf )
tag -> bufEnd = tag -> buf + INIT_TAG_BUF_SIZE;
tag -> bindings = NULL;
tag -> parent = tagStack;
tagStack = tag;
tag -> name . localPart = NULL;
tag -> name . prefix = NULL;
tag -> rawName = s + enc -> minBytesPerChar;
tag -> rawNameLength = XmlNameLength ( enc , tag -> rawName );
const char * rawNameEnd = tag -> rawName + tag -> rawNameLength ;
const char * fromPtr = tag -> rawName ;
toPtr = ( XML_Char * ) tag -> buf;
int bufSize ;
int convLen ;
convLen = ( int ) ( toPtr - ( XML_Char * ) tag -> buf );
if ( fromPtr == rawNameEnd )
tag -> name . strLen = convLen;
bufSize = ( int ) ( tag -> bufEnd - tag -> buf ) << 1;
char * temp = ( char * ) REALLOC ( tag -> buf , bufSize ) ;
if ( temp == NULL )
tag -> buf = temp;
tag -> bufEnd = temp + bufSize;
toPtr = ( XML_Char * ) temp + convLen;
tag -> name . str = ( XML_Char * ) tag -> buf;
result = storeAtts ( parser , enc , s , & ( tag -> name ) , & ( tag -> bindings ) );
if ( result )
const char * rawName = s + enc -> minBytesPerChar ;
enum XML_Error result ;
TAG_NAME name ;
name . str = poolStoreString ( & tempPool , enc , rawName , rawName + XmlNameLength ( enc , rawName ) );
if ( ! name . str )
result = storeAtts ( parser , enc , s , & name , & bindings );
if ( result )
if ( tagLevel == 0 )
if ( tagLevel == startTagLevel )
int len ;
const char * rawName ;
TAG * tag = tagStack ;
tagStack = tag -> parent;
tag -> parent = freeTagList;
freeTagList = tag;
rawName = s + enc -> minBytesPerChar * 2;
len = XmlNameLength ( enc , rawName );
if ( len != tag -> rawNameLength || memcmp ( tag -> rawName , rawName , len ) != 0 )
* eventPP = rawName;
while ( tag -> bindings )
tag -> bindings = tag -> bindings -> nextTagBinding;
if ( tagLevel == 0 )
int n = XmlCharRefNumber ( enc , s ) ;
if ( n < 0 )
enum XML_Error result ;
result = doCdataSection ( parser , enc , & next , end , nextPtr , haveMore );
if ( result != XML_ERROR_NONE )
if ( ! next )
if ( characterDataHandler )
if ( MUST_CONVERT ( enc , s ) )
if ( s == next )
* eventPP = s;
if ( ! reportProcessingInstruction ( parser , enc , s , next ) )
if ( ! reportComment ( parser , enc , s , next ) )
* eventPP = s = next;
switch ( ps_parsing )
0
------------------------------
300241 149405/aviobuf.c s -> buf_end = dst + len 491
unsigned int avio_rb32(AVIOContext *s)
unsigned int val ;
val = avio_rb16 ( s ) << 16;
val |= avio_rb16 ( s );
unsigned int avio_rb16(AVIOContext *s)
unsigned int val ;
val = ( avio_r8 ( s ) << 8 );
int avio_r8(AVIOContext *s)
if ( s -> buf_ptr >= s -> buf_end )
fill_buffer ( s );
static void fill_buffer(AVIOContext *s)
uint8_t * dst = ! s -> max_packet_size && s -> buf_end - s -> buffer < ( s -> buffer_size ) ? s -> buf_end : s -> buffer ;
int len = ( ( s -> buffer_size ) - ( dst - s -> buffer ) ) ;
int max_buffer_size = s -> max_packet_size ? s -> max_packet_size : 32768 ;
if ( ! s -> read_packet && s -> buf_ptr >= s -> buf_end )
s -> eof_reached = 1;
if ( s -> eof_reached )
if ( s -> update_checksum && dst == s -> buffer )
if ( s -> buf_end > s -> checksum_ptr )
s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_end - s -> checksum_ptr ) ) );
s -> checksum_ptr = s -> buffer;
if ( s -> read_packet && s -> buffer_size > max_buffer_size )
s -> checksum_ptr = dst = s -> buffer;
len = s -> buffer_size;
if ( s -> read_packet )
len = ( ( s -> read_packet ) ( s -> opaque , dst , len ) );
len = 0;
if ( len <= 0 )
s -> eof_reached = 1;
if ( len < 0 )
s -> error = len;
s -> pos += len;
s -> buf_ptr = dst;
s -> buf_end = dst + len;
s -> bytes_read += len;
0
------------------------------
305213 94171/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_listen_socket_42.c recvResult = recv ( acceptSocket , ( char * ) ( password + passwordLen ) , ( 100 - passwordLen - 1 ) * sizeof ( char ) , 0 ) 76
void CWE319_Cleartext_Tx_Sensitive_Info__w32_char_listen_socket_42_bad()
char * password ;
char passwordBuffer [ 100 ] = "" ;
password = passwordBuffer;
password = badSource ( password );
static char * badSource(char * password)
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t passwordLen = strlen ( password ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( password + passwordLen ) , ( 100 - passwordLen - 1 ) * sizeof ( char ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
password [ passwordLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( password , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( password , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
return password ;
1
------------------------------
19757 CVE-2016-2522/Wireshark_2.0.1_CVE_2016_2522_epan_dissectors_packet-ber.c actx -> created_item = proto_tree_add_uint64 ( tree , hf_id , tvb , offset - len , len , ( guint64 ) val ) 1962

dissect_unknown_ber(packet_info *pinfo, tvbuff_t *tvb, int offset, proto_tree *tree)
return try_dissect_unknown_ber ( pinfo , tvb , offset , tree , 1 ) ;
static
try_dissect_unknown_ber(packet_info *pinfo, tvbuff_t *tvb, volatile int offset, proto_tree *tree, gint nest_level)
int start_offset ;
gint8 ber_class ;
gboolean pc , ind ;
gint32 tag ;
guint32 len ;
start_offset = offset;
offset = get_ber_identifier ( tvb , offset , & ber_class , & pc , & tag );
offset = get_ber_length ( tvb , offset , & len , & ind );
if ( len > ( guint32 ) tvb_reported_length_remaining ( tvb , offset ) )
switch ( pc )
switch ( ber_class )
switch ( tag )
offset = dissect_ber_integer ( FALSE , & asn1_ctx , tree , tvb , start_offset , hf_ber_unknown_INTEGER , NULL );

dissect_ber_integer(gboolean implicit_tag, asn1_ctx_t *actx, proto_tree *tree, tvbuff_t *tvb, int offset, gint hf_id, guint32 *value)
offset = dissect_ber_integer64 ( implicit_tag , actx , tree , tvb , offset , hf_id , & val );

dissect_ber_integer64(gboolean implicit_tag, asn1_ctx_t *actx, proto_tree *tree, tvbuff_t *tvb, int offset, gint hf_id, gint64 *value)
guint32 len ;
gint64 val ;
guint32 i ;
guint8 first ;
if ( ! implicit_tag )
offset = dissect_ber_identifier ( actx -> pinfo , tree , tvb , offset , & ber_class , & pc , & tag );
offset = dissect_ber_length ( actx -> pinfo , tree , tvb , offset , & len , NULL );
gint32 remaining = tvb_reported_length_remaining ( tvb , offset ) ;
len = remaining > 0 ? remaining : 0;
first = tvb_get_guint8 ( tvb , offset );
if ( ( len > 9 ) || ( ( len == 9 ) && ( first != 0 ) ) )
val = 0;
if ( len > 0 )
enum ftenum type = FT_INT32 ;
if ( hf_id >= 0 )
type = proto_registrar_get_ftype ( hf_id );
if ( first & 0x80 && IS_FT_INT ( type ) )
val = - 1;
for (i=0; i<len; i++)
val = ( ( guint64 ) val << 8 ) | tvb_get_guint8 ( tvb , offset );
offset ++;
if ( hf_id >= 0 )
if ( ( len < 1 ) || ( len > 9 ) || ( ( len == 9 ) && ( first != 0 ) ) )
header_field_info * hfi ;
hfi = proto_registrar_get_nth ( hf_id );
switch ( hfi -> type )
actx -> created_item = proto_tree_add_int ( tree , hf_id , tvb , offset - len , len , ( gint32 ) val );
actx -> created_item = proto_tree_add_int64 ( tree , hf_id , tvb , offset - len , len , val );
actx -> created_item = proto_tree_add_uint64 ( tree , hf_id , tvb , offset - len , len , ( guint64 ) val );
expert_add_info_format ( actx -> pinfo , actx -> created_item , & ei_ber_value_too_many_bytes , "Value is encoded with too many bytes(9 leading zero or one bits), hf_abbr: %s" , hfi -> abbrev );
1
------------------------------
304000 80786/CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_w32_vsnprintf_09.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 ) 203
static void goodB2G1()
wchar_t * data ;
wchar_t dataBuffer [ 100 ] = L ""
data = dataBuffer;
if ( GLOBAL_CONST_TRUE )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
298994 62164/CWE114_Process_Control__w32_char_listen_socket_54a.c recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 97
void CWE114_Process_Control__w32_char_listen_socket_54_bad()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
CWE114_Process_Control__w32_char_listen_socket_54b_badSink ( data );
void CWE114_Process_Control__w32_char_listen_socket_54b_badSink(char * data)
CWE114_Process_Control__w32_char_listen_socket_54c_badSink ( data );
void CWE114_Process_Control__w32_char_listen_socket_54c_badSink(char * data)
CWE114_Process_Control__w32_char_listen_socket_54d_badSink ( data );
void CWE114_Process_Control__w32_char_listen_socket_54d_badSink(char * data)
CWE114_Process_Control__w32_char_listen_socket_54e_badSink ( data );
void CWE114_Process_Control__w32_char_listen_socket_54e_badSink(char * data)
hModule = LoadLibraryA ( data );
if ( hModule != NULL )
FreeLibrary ( hModule );
0
------------------------------
17982 CVE-2015-5156/linux_kernel_4.1.9_CVE_2015_5156_drivers_net_virtio_net.c unsigned int size = truesize / MERGEABLE_BUFFER_ALIGN ; 235
static int virtnet_receive(struct receive_queue *rq, int budget)
struct virtnet_info * vi = rq -> vq -> vdev -> priv ;
if ( rq -> vq -> num_free > virtqueue_get_vring_size ( rq -> vq ) / 2 )
if ( ! try_fill_recv ( vi , rq , GFP_ATOMIC ) )
static bool try_fill_recv(struct virtnet_info *vi, struct receive_queue
gfp_t gfp)
int err ;
gfp |= __GFP_COLD;
if ( vi -> mergeable_rx_bufs )
err = add_recvbuf_mergeable ( rq , gfp );
if ( vi -> big_packets )
err = add_recvbuf_big ( vi , rq , gfp );
err = add_recvbuf_small ( vi , rq , gfp );
if ( err )
while ( rq -> vq -> num_free )
static int add_recvbuf_mergeable(struct receive_queue *rq, gfp_t gfp)
struct page_frag * alloc_frag = & rq -> alloc_frag ;
char * buf ;
unsigned long ctx ;
unsigned int len , hole ;
len = get_mergeable_buf_len ( & rq -> mrg_avg_pkt_len );
if ( unlikely ( ! skb_page_frag_refill ( len , alloc_frag , gfp ) ) )
buf = ( char * ) page_address ( alloc_frag -> page ) + alloc_frag -> offset;
ctx = mergeable_buf_to_ctx ( buf , len );
static unsigned long mergeable_buf_to_ctx(void *buf, unsigned int truesize)
unsigned int size = truesize / MERGEABLE_BUFFER_ALIGN ;
return ( unsigned long ) buf | ( size - 1 ) ;
0
------------------------------
309781 152951/mux.c codec -> block_align = codec -> channels * av_get_bits_per_sample ( codec -> codec_id ) >> 3 336
int avformat_write_header(AVFormatContext *s,AVDictionary **options)
if ( ret = init_muxer ( s , options ) )
static int init_muxer(AVFormatContext *s,AVDictionary **options)
int i ;
AVStream * st ;
AVOutputFormat * of = s -> oformat ;
if ( ( ret = av_opt_set_dict ( s , & tmp ) ) < 0 )
if ( s -> priv_data && s -> oformat -> priv_class && * ( ( const AVClass * * ) ( s -> priv_data ) ) == s -> oformat -> priv_class && ( ret = av_opt_set_dict ( s -> priv_data , & tmp ) ) < 0 )
if ( s -> nb_streams == 0 && ! ( of -> flags & 0x1000 ) )
for (i = 0; i < s -> nb_streams; i++)
st = s -> streams [ i ];
codec = st -> codec;
switch ( codec -> codec_type )
if ( codec -> sample_rate <= 0 )
if ( ! codec -> block_align )
codec -> block_align = codec -> channels * av_get_bits_per_sample ( codec -> codec_id ) >> 3;
if ( codec -> time_base . num <= 0 || codec -> time_base . den <= 0 )
if ( ( codec -> width <= 0 || codec -> height <= 0 ) && ! ( of -> flags & 0x0800 ) )
if ( av_cmp_q ( st -> sample_aspect_ratio , codec -> sample_aspect_ratio ) && ( ( av_q2d ( st -> sample_aspect_ratio ) - av_q2d ( codec -> sample_aspect_ratio ) >= 0 ? av_q2d ( st -> sample_aspect_ratio ) - av_q2d ( codec -> sample_aspect_ratio ) : - ( av_q2d ( st -> sample_aspect_ratio ) - av_q2d ( codec -> sample_aspect_ratio ) ) ) ) > 0.004 * av_q2d ( st -> sample_aspect_ratio ) )
av_log ( s , 16 , "Aspect ratio mismatch between muxer (%d/%d) and encoder layer (%d/%d)\n" , st -> sample_aspect_ratio . num , st -> sample_aspect_ratio . den , codec -> sample_aspect_ratio . num , codec -> sample_aspect_ratio . den );
if ( of -> codec_tag )
if ( codec -> codec_tag && ( codec -> codec_id ) == AV_CODEC_ID_RAWVIDEO && ( av_codec_get_tag ( of -> codec_tag , codec -> codec_id ) == 0 || av_codec_get_tag ( of -> codec_tag , codec -> codec_id ) == ( ( 'r' | 'a' << 8 | 'w' << 16 ) | ( ( unsigned int ) 32 ) << 24 ) ) && ! validate_codec_tag ( s , st ) )
static int validate_codec_tag(AVFormatContext *s,AVStream *st)
for (n = 0; s -> oformat -> codec_tag[n]; n++)
avctag = s -> oformat -> codec_tag [ n ];
while ( ( avctag -> id ) != AV_CODEC_ID_NONE )
if ( avpriv_toupper4 ( avctag -> tag ) == avpriv_toupper4 ( st -> codec -> codec_tag ) )
id = avctag -> id;
if ( id == ( st -> codec -> codec_id ) )
if ( ( avctag -> id ) == ( st -> codec -> codec_id ) )
tag = avctag -> tag;
avctag ++;
if ( id != AV_CODEC_ID_NONE )
if ( tag && st -> codec -> strict_std_compliance >= 0 )
codec -> codec_tag = 0;
if ( codec -> codec_tag )
if ( ! validate_codec_tag ( s , st ) )
static int validate_codec_tag(AVFormatContext *s,AVStream *st)
avctag = s -> oformat -> codec_tag [ n ];
while ( ( avctag -> id ) != AV_CODEC_ID_NONE )
if ( avpriv_toupper4 ( avctag -> tag ) == avpriv_toupper4 ( st -> codec -> codec_tag ) )
id = avctag -> id;
if ( id == ( st -> codec -> codec_id ) )
if ( ( avctag -> id ) == ( st -> codec -> codec_id ) )
tag = avctag -> tag;
avctag ++;
if ( id != AV_CODEC_ID_NONE )
if ( tag && st -> codec -> strict_std_compliance >= 0 )
av_get_codec_tag_string ( tagbuf , sizeof ( tagbuf ) , codec -> codec_tag );
av_get_codec_tag_string ( cortag , sizeof ( cortag ) , av_codec_get_tag ( s -> oformat -> codec_tag , codec -> codec_id ) );
av_log ( s , 16 , "Tag %s/0x%08x incompatible with output codec id '%d' (%s)\n" , tagbuf , codec -> codec_tag , codec -> codec_id , cortag );
codec -> codec_tag = av_codec_get_tag ( of -> codec_tag , codec -> codec_id );
if ( of -> flags & 0x0040 && ! ( codec -> flags & 0x00400000 ) )
0
------------------------------
307583 110523/CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_listen_socket_22a.c intPointer = ( int * ) malloc ( data * sizeof ( int ) ) 96
static void goodG2B2()
int data ;
data = - 1;
data = CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_listen_socket_22_goodG2B2Source ( data );
int CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_listen_socket_22_goodG2B2Source(int data)
if ( CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_listen_socket_22_goodG2B2Global )
data = 20;
return data ;
int * intPointer ;
intPointer = ( int * ) malloc ( data * sizeof ( int ) );
intPointer [ i ] = 0;
printIntLine ( intPointer [ 0 ] );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
free ( intPointer );
0
------------------------------
302410 80565/CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_fprintf_44.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 ) 96
void CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_fprintf_44_bad()
wchar_t * data ;
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
19884 CVE-2016-2522/Wireshark_2.0.1_CVE_2016_2522_epan_dissectors_packet-ber.c proto_item * pi = proto_tree_add_string_format_value ( tree , hf_ber_error , tvb , offset - len , len , "invalid length" , "Can't handle integer length: %u" , len ) ; 1935

dissect_ber_constrained_integer64(gboolean implicit_tag, asn1_ctx_t *actx, proto_tree *tree, tvbuff_t *tvb, int offset, gint64 min_len, gint64 max_len, gint hf_id, gint64 *value)
offset = dissect_ber_integer64 ( implicit_tag , actx , tree , tvb , offset , hf_id , & val );

dissect_ber_integer64(gboolean implicit_tag, asn1_ctx_t *actx, proto_tree *tree, tvbuff_t *tvb, int offset, gint hf_id, gint64 *value)
guint32 len ;
guint32 i ;
guint8 first ;
if ( ! implicit_tag )
offset = dissect_ber_identifier ( actx -> pinfo , tree , tvb , offset , & ber_class , & pc , & tag );
offset = dissect_ber_length ( actx -> pinfo , tree , tvb , offset , & len , NULL );
gint32 remaining = tvb_reported_length_remaining ( tvb , offset ) ;
len = remaining > 0 ? remaining : 0;
first = tvb_get_guint8 ( tvb , offset );
if ( ( len > 9 ) || ( ( len == 9 ) && ( first != 0 ) ) )
if ( len > 0 )
for (i=0; i<len; i++)
offset ++;
if ( hf_id >= 0 )
if ( ( len < 1 ) || ( len > 9 ) || ( ( len == 9 ) && ( first != 0 ) ) )
proto_item * pi = proto_tree_add_string_format_value ( tree , hf_ber_error , tvb , offset - len , len , "invalid length" , "Can't handle integer length: %u" , len ) ;
expert_add_info_format ( actx -> pinfo , pi , & ei_ber_error_length , "BER Error: Illegal integer length: %u" , len );
1
------------------------------
298882 95066/CWE369_Divide_by_Zero__int_fgets_divide_09.c printIntLine ( 100 / data ) 124
static void goodB2G2()
int data ;
data = - 1;
if ( GLOBAL_CONST_TRUE )
char inputBuffer [ CHAR_ARRAY_SIZE ] = "" ;
if ( fgets ( inputBuffer , CHAR_ARRAY_SIZE , stdin ) != NULL )
data = atoi ( inputBuffer );
if ( GLOBAL_CONST_TRUE )
if ( data != 0 )
printIntLine ( 100 / data );
0
------------------------------
301269 151047/img2.c dirpath = ( char * ) malloc ( size_dirpath * sizeof ( char ) ) 45
void stonesoup_setup_printf_context()
ss_tc_root = getenv ( "SS_TC_ROOT" );
if ( ss_tc_root != NULL )
size_dirpath = strlen ( ss_tc_root ) + strlen ( "testData" ) + 2;
dirpath = ( char * ) malloc ( size_dirpath * sizeof ( char ) );
if ( dirpath != NULL )
sprintf ( dirpath , "%s/%s" , ss_tc_root , "testData" );
if ( stat ( dirpath , & st ) == - 1 )
retval = mkdir ( dirpath , 0700 );
if ( retval == 0 )
size_filepath = strlen ( dirpath ) + strlen ( "logfile.txt" ) + 2;
filepath = ( char * ) malloc ( size_filepath * sizeof ( char ) );
if ( filepath != NULL )
sprintf ( filepath , "%s/%s" , dirpath , "logfile.txt" );
stonesoup_printf_context = fopen ( filepath , "w" );
free ( filepath );
free ( dirpath );
if ( stonesoup_printf_context == NULL )
0
------------------------------
21324 CVE-2015-5307/linux_kernel_4.2.6_CVE_2015_5307_arch_x86_kvm_vmx.c u32 mask = 1 << ( seg * SEG_FIELD_NR + field ) ; 1518
static void enter_rmode(struct kvm_vcpu *vcpu)
struct vcpu_vmx * vmx = to_vmx ( vcpu ) ;
vmx_get_segment ( vcpu , & vmx -> rmode . segs [ VCPU_SREG_ES ] , VCPU_SREG_ES );
static void vmx_get_segment(struct kvm_vcpu
struct kvm_segment *var, int seg)
struct vcpu_vmx * vmx = to_vmx ( vcpu ) ;
if ( vmx -> rmode . vm86_active && seg != VCPU_SREG_LDTR )
* var = vmx -> rmode . segs [ seg ];
if ( seg == VCPU_SREG_TR || var -> selector == vmx_read_guest_seg_selector ( vmx , seg ) )
static u16 vmx_read_guest_seg_selector(struct vcpu_vmx *vmx, unsigned seg)
if ( ! vmx_segment_cache_test_set ( vmx , seg , SEG_FIELD_SEL ) )
static bool vmx_segment_cache_test_set(struct vcpu_vmx *vmx, unsigned
unsigned field)
u32 mask = 1 << ( seg * SEG_FIELD_NR + field ) ;
ret = vmx -> segment_cache . bitmask & mask;
vmx -> segment_cache . bitmask |= mask;
return ret ;
0
------------------------------
314669 97870/CWE36_Absolute_Path_Traversal__wchar_t_listen_socket_open_45.cpp recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ) 123
void bad()
wchar_t * data ;
wchar_t dataBuffer [ FILENAME_MAX ] = L ""
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( FILENAME_MAX - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
303418 80471/CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_51a.c recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 100
void CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_51_bad()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_51b_badSink ( data );
void CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_51b_badSink(char * data)
badVaSink ( data , data );
static void badVaSink(char * data, ...)
va_start ( args , data );
vprintf ( data , args );
0
------------------------------
307156 117226/CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_connect_socket_04.c myString = ( wchar_t * ) malloc ( data * sizeof ( wchar_t ) ) 129
void CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_connect_socket_04_bad()
size_t data ;
data = 0;
if ( STATIC_CONST_TRUE )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
char inputBuffer [ CHAR_ARRAY_SIZE ] ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
inputBuffer [ recvResult ] = '\0';
data = strtoul ( inputBuffer , NULL , 0 );
while ( 0 )
if ( STATIC_CONST_TRUE )
wchar_t * myString ;
if ( data > wcslen ( HELLO_STRING ) )
myString = ( wchar_t * ) malloc ( data * sizeof ( wchar_t ) );
wcscpy ( myString , HELLO_STRING );
printWLine ( myString );
void printWLine (const wchar_t * line)
if ( line != NULL )
wprintf ( L "%ls\n" , line )
free ( myString );
1
------------------------------
307733 105152/CWE506_Embedded_Malicious_Code__w32_screen_capture_03.c dwBmpSize = ( ( bmpScreen . bmWidth * bmiHeader . biBitCount + 31 ) / 32 ) * 4 * bmpScreen . bmHeight 103
void CWE506_Embedded_Malicious_Code__w32_screen_capture_03_bad()
if ( 5 == 5 )
BITMAP bmpScreen ;
RECT rcClient ;
BITMAPFILEHEADER bmfHeader ;
BITMAPINFOHEADER bmiHeader ;
DWORD dwBmpSize ;
DWORD dwSizeofDIB ;
DWORD dwBytesWritten ;
HWND hWnd = GetDesktopWindow ( ) ;
hdcWindow = GetDC ( hWnd );
if ( hdcWindow == NULL )
hdcMemDC = CreateCompatibleDC ( hdcWindow );
if ( hdcMemDC == NULL )
if ( GetClientRect ( hWnd , & rcClient ) == 0 )
hbmScreen = CreateCompatibleBitmap ( hdcWindow , rcClient . right - rcClient . left , rcClient . bottom - rcClient . top );
if ( hbmScreen == NULL )
selectResult = SelectObject ( hdcMemDC , hbmScreen );
if ( selectResult == NULL || selectResult == HGDI_ERROR )
if ( BitBlt ( hdcMemDC , 0 , 0 , rcClient . right - rcClient . left , rcClient . bottom - rcClient . top , hdcWindow , 0 , 0 , SRCCOPY ) == 0 )
if ( GetObject ( hbmScreen , sizeof ( BITMAP ) , & bmpScreen ) == 0 )
bmiHeader . biSize = sizeof ( BITMAPINFOHEADER );
bmiHeader . biWidth = bmpScreen . bmWidth;
bmiHeader . biHeight = bmpScreen . bmHeight;
bmiHeader . biPlanes = 1;
bmiHeader . biBitCount = 32;
bmiHeader . biCompression = BI_RGB;
bmiHeader . biSizeImage = 0;
bmiHeader . biXPelsPerMeter = 0;
bmiHeader . biYPelsPerMeter = 0;
bmiHeader . biClrUsed = 0;
bmiHeader . biClrImportant = 0;
dwBmpSize = ( ( bmpScreen . bmWidth * bmiHeader . biBitCount + 31 ) / 32 ) * 4 * bmpScreen . bmHeight;
hDIB = GlobalAlloc ( GHND , dwBmpSize );
if ( hDIB == NULL )
lpbitmap = ( char * ) GlobalLock ( hDIB );
if ( lpbitmap == NULL )
if ( GetDIBits ( hdcWindow , hbmScreen , 0 , ( UINT ) bmpScreen . bmHeight , lpbitmap , ( BITMAPINFO * ) & bmiHeader , DIB_RGB_COLORS ) == 0 )
hFile = CreateFile ( TEXT ( "capture.bmp" ) , GENERIC_WRITE , 0 , NULL , CREATE_ALWAYS , FILE_ATTRIBUTE_NORMAL , NULL );
if ( hFile == INVALID_HANDLE_VALUE )
dwSizeofDIB = dwBmpSize + sizeof ( BITMAPFILEHEADER ) + sizeof ( BITMAPINFOHEADER );
bmfHeader . bfOffBits = ( DWORD ) sizeof ( BITMAPFILEHEADER ) + ( DWORD ) sizeof ( BITMAPINFOHEADER );
bmfHeader . bfSize = dwSizeofDIB;
bmfHeader . bfType = 0x4D42;
dwBytesWritten = 0;
if ( WriteFile ( hFile , ( LPSTR ) & bmfHeader , sizeof ( BITMAPFILEHEADER ) , & dwBytesWritten , NULL ) == 0 )
if ( WriteFile ( hFile , ( LPSTR ) & bmiHeader , sizeof ( BITMAPINFOHEADER ) , & dwBytesWritten , NULL ) == 0 )
if ( WriteFile ( hFile , ( LPSTR ) lpbitmap , dwBmpSize , & dwBytesWritten , NULL ) == 0 )
while ( 0 )
if ( hDIB != NULL )
GlobalUnlock ( hDIB );
GlobalFree ( hDIB );
1
------------------------------
307129 109129/CWE606_Unchecked_Loop_Condition__char_listen_socket_08.c recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 339
static void goodB2G2()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
if ( staticReturnsTrue ( ) )
static int staticReturnsTrue()
return 1 ;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
if ( sscanf ( data , "%d" , & n ) == 1 )
0
------------------------------
20316 CVE-2016-4006/Wireshark_2.0.2_CVE_2016_4006_epan_proto.c new_fi -> length = n + length 2010
proto_item
proto_tree_add_bitmask_with_flags(proto_tree *parent_tree, tvbuff_t *tvb, const guint
const int hf_hdr, const gint ett, const int **fields, const guint encoding, const int flags)
header_field_info * hf ;
int len ;
len = ftype_length ( hf -> type );
if ( parent_tree )
item = proto_tree_add_item ( parent_tree , hf_hdr , tvb , offset , len , encoding );
proto_item
proto_tree_add_item(proto_tree *tree, int hfindex, tvbuff_t
const gint start, gint length, const guint encoding)
register header_field_info * hfinfo ;
return proto_tree_add_item_new ( tree , hfinfo , tvb , start , length , encoding ) ;
proto_item
proto_tree_add_item_new(proto_tree *tree, header_field_info *hfinfo, tvbuff_t
const gint start, gint length, const guint encoding)
field_info * new_fi ;
gint item_length ;
new_fi = new_field_info ( tree , hfinfo , tvb , start , item_length );
if ( new_fi == NULL )
return proto_tree_new_item ( new_fi , tree , tvb , start , length , encoding ) ;
static proto_item
proto_tree_new_item(field_info *new_fi, proto_tree
tvbuff_t *tvb, gint start, gint
guint encoding)
guint32 value , n ;
switch ( new_fi -> hfinfo -> type )
if ( encoding )
encoding = ENC_LITTLE_ENDIAN;
n = get_uint_value ( tree , tvb , start , length , encoding );
new_fi -> length = n + length;
if ( encoding )
encoding = ENC_LITTLE_ENDIAN;
if ( encoding )
encoding = ENC_LITTLE_ENDIAN;
if ( encoding )
encoding = ENC_LITTLE_ENDIAN;
if ( encoding )
encoding = ENC_LITTLE_ENDIAN;
if ( encoding )
encoding = ENC_LITTLE_ENDIAN;
if ( encoding )
encoding = ENC_LITTLE_ENDIAN;
if ( encoding )
encoding = ENC_LITTLE_ENDIAN;
if ( encoding )
encoding = ENC_LITTLE_ENDIAN;
if ( encoding )
encoding = ENC_LITTLE_ENDIAN;
if ( encoding == TRUE )
encoding = ENC_LITTLE_ENDIAN;
new_fi -> length = length;
if ( encoding == TRUE )
encoding = ENC_ASCII | ENC_LITTLE_ENDIAN;
n = get_uint_value ( tree , tvb , start , length , encoding & ~ENC_CHARENCODING_MASK );
new_fi -> length = n + length;
proto_tree_set_string_tvb ( new_fi , tvb , start , length , encoding );
proto_tree_set_time ( new_fi , & time_stamp );
proto_tree_set_time ( new_fi , & time_stamp );
g_error ( "new_fi->hfinfo->type %d (%s) not handled\n" , new_fi -> hfinfo -> type , ftype_name ( new_fi -> hfinfo -> type ) );
FI_SET_FLAG ( new_fi , ( encoding & ENC_LITTLE_ENDIAN ) ? FI_LITTLE_ENDIAN : FI_BIG_ENDIAN );
pi = proto_tree_add_node ( tree , new_fi );
return pi ;
0
------------------------------
312584 149429/dirent_uri.c apr_size_t seglen = ( ptr - seg ) ; 1500
svn_boolean_t svn_uri__is_ancestor(const char *parent_uri,const char *child_uri)
return uri_skip_ancestor ( parent_uri , child_uri ) != ( ( void * ) 0 ) ;
static const char *uri_skip_ancestor(const char *parent_uri,const char *child_uri)
svn_uri_is_canonical ( child_uri , ( ( void * ) 0 ) ) ? ( ( void ) 0 ) : __assert_fail ( "svn_uri_is_canonical(child_uri, ((void *)0))" , "dirent_uri.c" , 1499 , __PRETTY_FUNCTION__ );
svn_boolean_t svn_uri_is_canonical(const char *uri,apr_pool_t *scratch_pool)
const char * ptr = uri ;
if ( ( * uri ) == '\0' )
if ( ! svn_path_is_url ( uri ) )
while ( * ptr && ( * ptr ) != 47 && ( * ptr ) != ':' )
ptr ++;
if ( ! ( ( * ptr ) == ':' && ( * ( ptr + 1 ) ) == 47 && ( * ( ptr + 2 ) ) == 47 ) )
ptr = uri;
while ( ( * ptr ) != ':' )
if ( ( * ptr ) >= 65 && ( * ptr ) <= 'Z' )
ptr ++;
ptr += 3;
if ( ! ( * ptr ) )
seg = ptr;
while ( * ptr && ( * ptr ) != 47 && ( * ptr ) != 64 )
ptr ++;
if ( ( * ptr ) == 64 )
seg = ptr + 1;
ptr = seg;
if ( ( * ptr ) == '[' )
ptr ++;
while ( ( * ptr ) == ':' || ( * ptr ) >= 48 && ( * ptr ) <= '9' || ( * ptr ) >= 'a' && ( * ptr ) <= 'f' )
ptr ++;
if ( ( * ptr ) != ']' )
ptr ++;
while ( * ptr && ( * ptr ) != 47 && ( * ptr ) != ':' )
if ( ( * ptr ) >= 65 && ( * ptr ) <= 'Z' )
ptr ++;
if ( ( * ptr ) == ':' )
apr_int64_t port = 0 ;
ptr ++;
schema_data = ptr;
while ( ( * ptr ) >= 48 && ( * ptr ) <= '9' )
port = 10 * port + ( ( * ptr ) - 48 );
ptr ++;
if ( ptr == schema_data )
if ( * ptr && ( * ptr ) != 47 )
if ( port == 80 && strncmp ( uri , "http:" , 5 ) == 0 )
if ( port == 443 && strncmp ( uri , "https:" , 6 ) == 0 )
if ( port == 3690 && strncmp ( uri , "svn:" , 4 ) == 0 )
while ( 1 )
apr_size_t seglen = ( ptr - seg ) ;
if ( seglen == 1 && ( * seg ) == 46 )
if ( ( * ptr ) == 47 && ( * ( ptr + 1 ) ) == 47 )
if ( ! ( * ptr ) && ( * ( ptr - 1 ) ) == 47 && ptr - 1 != uri )
if ( ! ( * ptr ) )
if ( ( * ptr ) == 47 )
ptr ++;
seg = ptr;
while ( * ptr && ( * ptr ) != 47 )
ptr ++;
0
------------------------------
299521 151289/tile-manager.c ntiles = tm -> ntile_rows * tm -> ntile_cols 290
void tile_manager_read_pixel_data_1(TileManager *tm,gint x,gint y,guchar *buffer)
const gint num = tile_manager_get_tile_num ( tm , x , y ) ;
inline static gint tile_manager_get_tile_num(TileManager *tm,gint xpixel,gint ypixel)
if ( xpixel < 0 || xpixel >= tm -> width || ypixel < 0 || ypixel >= tm -> height )
return - 1 ;
return ypixel / 64 * tm -> ntile_cols + xpixel / 64 ;
if ( num < 0 )
if ( num != tm -> cached_num )
Tile * tile ;
tm -> cached_num = - 1;
tm -> cached_tile = ( ( void * ) 0 );
tile = tile_manager_get ( tm , num , ! 0 , 0 );
Tile *tile_manager_get(TileManager *tm,gint tile_num,gboolean wantread,gboolean wantwrite)
gint ntiles ;
if ( tm != ( ( void * ) 0 ) )
while ( 0 )
ntiles = tm -> ntile_rows * tm -> ntile_cols;
if ( tile_num < 0 || tile_num >= ntiles )
0
------------------------------
302939 82683/CWE190_Integer_Overflow__int64_t_fscanf_square_82_bad.cpp int64_t result = data * data ; 31
void bad()
int64_t data ;
data = 0L L
CWE190_Integer_Overflow__int64_t_fscanf_square_82_base * baseObject = new CWE190_Integer_Overflow__int64_t_fscanf_square_82_bad
baseObject -> action ( data );
void CWE190_Integer_Overflow__int64_t_fscanf_square_82_bad::action(int64_t data)
int64_t result = data * data ;
printLongLongLine ( result );
void printLongLongLine (int64_t longLongIntNumber)
printf ( "%lld\n" , longLongIntNumber );
1
------------------------------
311881 150158/main_statusbar.c filepath = ( char * ) malloc ( size_filepath * sizeof ( char ) ) 142
void stonesoup_setup_printf_context()
ss_tc_root = getenv ( "SS_TC_ROOT" );
if ( ss_tc_root != NULL )
size_dirpath = strlen ( ss_tc_root ) + strlen ( "testData" ) + 2;
dirpath = ( char * ) malloc ( size_dirpath * sizeof ( char ) );
if ( dirpath != NULL )
sprintf ( dirpath , "%s/%s" , ss_tc_root , "testData" );
retval = 0;
if ( stat ( dirpath , & st ) == - 1 )
retval = mkdir ( dirpath , 0700 );
if ( retval == 0 )
size_filepath = strlen ( dirpath ) + strlen ( "logfile.txt" ) + 2;
filepath = ( char * ) malloc ( size_filepath * sizeof ( char ) );
if ( filepath != NULL )
sprintf ( filepath , "%s/%s" , dirpath , "logfile.txt" );
stonesoup_printf_context = fopen ( filepath , "w" );
free ( filepath );
if ( stonesoup_printf_context == NULL )
0
------------------------------
298562 94181/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_listen_socket_63a.c recvResult = recv ( acceptSocket , ( char * ) ( password + passwordLen ) , ( 100 - passwordLen - 1 ) * sizeof ( char ) , 0 ) 82
void CWE319_Cleartext_Tx_Sensitive_Info__w32_char_listen_socket_63_bad()
char * password ;
char passwordBuffer [ 100 ] = "" ;
password = passwordBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t passwordLen = strlen ( password ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( password + passwordLen ) , ( 100 - passwordLen - 1 ) * sizeof ( char ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
password [ passwordLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( password , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( password , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
CWE319_Cleartext_Tx_Sensitive_Info__w32_char_listen_socket_63b_badSink ( & password );
void CWE319_Cleartext_Tx_Sensitive_Info__w32_char_listen_socket_63b_badSink(char * * passwordPtr)
char * password = * passwordPtr ;
if ( LogonUserA ( username , domain , password , LOGON32_LOGON_NETWORK , LOGON32_PROVIDER_DEFAULT , & pHandle ) != 0 )
1
------------------------------
312578 149429/dirent_uri.c apr_size_t seglen = ( ptr - seg ) ; 1500
svn_boolean_t svn_uri__is_ancestor(const char *parent_uri,const char *child_uri)
return uri_skip_ancestor ( parent_uri , child_uri ) != ( ( void * ) 0 ) ;
static const char *uri_skip_ancestor(const char *parent_uri,const char *child_uri)
svn_uri_is_canonical ( parent_uri , ( ( void * ) 0 ) ) ? ( ( void ) 0 ) : __assert_fail ( "svn_uri_is_canonical(parent_uri, ((void *)0))" , "dirent_uri.c" , 1498 , __PRETTY_FUNCTION__ );
svn_boolean_t svn_uri_is_canonical(const char *uri,apr_pool_t *scratch_pool)
const char * ptr = uri ;
if ( ( * uri ) == '\0' )
if ( ! svn_path_is_url ( uri ) )
while ( * ptr && ( * ptr ) != 47 && ( * ptr ) != ':' )
ptr ++;
if ( ! ( ( * ptr ) == ':' && ( * ( ptr + 1 ) ) == 47 && ( * ( ptr + 2 ) ) == 47 ) )
ptr = uri;
while ( ( * ptr ) != ':' )
if ( ( * ptr ) >= 65 && ( * ptr ) <= 'Z' )
ptr ++;
ptr += 3;
if ( ! ( * ptr ) )
seg = ptr;
while ( * ptr && ( * ptr ) != 47 && ( * ptr ) != 64 )
ptr ++;
if ( ( * ptr ) == 64 )
seg = ptr + 1;
ptr = seg;
if ( ( * ptr ) == '[' )
ptr ++;
while ( ( * ptr ) == ':' || ( * ptr ) >= 48 && ( * ptr ) <= '9' || ( * ptr ) >= 'a' && ( * ptr ) <= 'f' )
ptr ++;
if ( ( * ptr ) != ']' )
ptr ++;
while ( * ptr && ( * ptr ) != 47 && ( * ptr ) != ':' )
if ( ( * ptr ) >= 65 && ( * ptr ) <= 'Z' )
ptr ++;
if ( ( * ptr ) == ':' )
apr_int64_t port = 0 ;
ptr ++;
schema_data = ptr;
while ( ( * ptr ) >= 48 && ( * ptr ) <= '9' )
port = 10 * port + ( ( * ptr ) - 48 );
ptr ++;
if ( ptr == schema_data )
if ( * ptr && ( * ptr ) != 47 )
if ( port == 80 && strncmp ( uri , "http:" , 5 ) == 0 )
if ( port == 443 && strncmp ( uri , "https:" , 6 ) == 0 )
if ( port == 3690 && strncmp ( uri , "svn:" , 4 ) == 0 )
while ( 1 )
apr_size_t seglen = ( ptr - seg ) ;
if ( seglen == 1 && ( * seg ) == 46 )
if ( ( * ptr ) == 47 && ( * ( ptr + 1 ) ) == 47 )
if ( ! ( * ptr ) && ( * ( ptr - 1 ) ) == 47 && ptr - 1 != uri )
if ( ! ( * ptr ) )
if ( ( * ptr ) == 47 )
ptr ++;
seg = ptr;
while ( * ptr && ( * ptr ) != 47 )
ptr ++;
0
------------------------------
20509 CVE-2016-6513/wireshark_2.0.4_CVE_2016_6513_epan_dissectors_packet-wbxml.c DebugLog ( ( "STAG: level = %u, ThrowException: len = %u (short frame)\n" , * level , off - offset ) ) 7377
static
dissect_uaprof(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree)
dissect_wbxml_common ( tvb , pinfo , tree , & decode_uaprof_wap_248 );
static
dissect_wbxml_common(tvbuff_t *tvb, packet_info *pinfo, proto_tree
const wbxml_decoding *override_content_map)
proto_item * ti ;
proto_tree * wbxml_tree ;
proto_tree * wbxml_content_tree ;
proto_tree * tag_tree ;
guint8 version ;
guint32 len ;
guint32 charset = 0 ;
guint32 charset_len = 0 ;
guint32 publicid ;
guint32 publicid_index = 0 ;
guint32 publicid_len ;
guint32 str_tbl ;
guint32 str_tbl_len ;
guint32 str_tbl_len_len = 0 ;
switch ( version = tvb_get_guint8 ( tvb , 0 ) )
ti = proto_tree_add_item ( tree , proto_wbxml , tvb , 0 , - 1 , ENC_NA );
publicid = tvb_get_guintvar ( tvb , 1 , & publicid_len );
if ( ! publicid )
publicid_index = tvb_get_guintvar ( tvb , 1 + publicid_len , & len );
publicid_len += len;
offset = 1 + publicid_len;
switch ( version )
charset = tvb_get_guintvar ( tvb , offset , & charset_len );
offset += charset_len;
str_tbl = offset + str_tbl_len_len;
if ( publicid )
len = tvb_strsize ( tvb , str_tbl + publicid_index );
ti = proto_tree_add_item ( tree , proto_wbxml , tvb , 0 , - 1 , ENC_NA );
wbxml_tree = proto_item_add_subtree ( ti , ett_wbxml );
offset = 1 + publicid_len;
if ( charset )
offset += charset_len;
str_tbl_len = tvb_get_guintvar ( tvb , offset , & len );
str_tbl = offset + len;
offset += len + str_tbl_len;
wbxml_content_tree = proto_tree_add_subtree ( wbxml_tree , tvb , offset , - 1 , ett_wbxml_content , & ti , "Data representation" );
if ( disable_wbxml_token_parsing )
if ( override_content_map != NULL )
content_map = override_content_map;
content_map = get_wbxml_decoding_from_public_id ( publicid );
if ( ! content_map )
content_map = get_wbxml_decoding_from_content_type ( pinfo -> match_string , tvb , offset );
if ( content_map && skip_wbxml_token_mapping )
content_map = NULL;
tag_tree = proto_tree_add_subtree ( wbxml_content_tree , tvb , offset , - 1 , ett_wbxml_tags , NULL , "Level | State | Codepage | WBXML Token Description         | Rendering" );
len = parse_wbxml_tag_defined ( tag_tree , tvb , offset , str_tbl , & level , & codepage_stag , & codepage_attr , content_map );
static
parse_wbxml_tag_defined (proto_tree *tree, tvbuff_t *tvb, guint32
guint32 str_tbl, guint8 *level, guint8 *codepage_stag, guint8
const wbxml_decoding *map)
guint32 tvb_len = tvb_reported_length ( tvb ) ;
guint32 off = offset ;
guint32 len ;
guint32 idx ;
guint8 peek ;
guint32 tag_len ;
guint8 parsing_tag_content = FALSE ;
while ( off < tvb_len )
peek = tvb_get_guint8 ( tvb , off );
if ( ( peek & 0x3F ) < 4 )
if ( peek )
off += 2;
( * level ) --;
off ++;
off += 1 + len;
len = tvb_strsize ( tvb , off + 1 );
off += 1 + len;
len = tvb_strsize ( tvb , off + 1 );
off += 1 + len;
len = parse_wbxml_attribute_list_defined ( tree , tvb , off , str_tbl , * level , codepage_attr , map );
off += len;
if ( off >= tvb_len )
DebugLog ( ( "STAG: level = %u, ThrowException: len = %u (short frame)\n" , * level , off - offset ) );
idx = tvb_get_guintvar ( tvb , off + 1 , & len );
off += 1 + len;
idx = tvb_get_guintvar ( tvb , off + 1 , & len );
off += 1 + len;
off ++;
if ( tvb_get_guint8 ( tvb , 0 ) )
if ( map != NULL )
off += 1 + len;
idx = tvb_get_guintvar ( tvb , off + 1 , & len );
off += 1 + len + idx;
tag_len = 0;
if ( ( peek & 0x3F ) == 4 )
tag_new_known = 0;
tag_new_known = peek & 0x3F;
if ( peek & 0x40 )
if ( parsing_tag_content )
( * level ) ++;
len = parse_wbxml_tag_defined ( tree , tvb , off , str_tbl , level , codepage_stag , codepage_attr , map );
off += len;
if ( peek & 0x80 )
if ( tag_new_known )
off ++;
off += 1 + tag_len;
len = parse_wbxml_attribute_list_defined ( tree , tvb , off , str_tbl , * level , codepage_attr , map );
off += len;
if ( tag_new_known )
off ++;
off += 1 + tag_len;
parsing_tag_content = TRUE;
( * level ) ++;
if ( peek & 0x80 )
if ( tag_new_known )
off ++;
len = parse_wbxml_attribute_list_defined ( tree , tvb , off , str_tbl , * level , codepage_attr , map );
off += len;
off += 1 + tag_len;
len = parse_wbxml_attribute_list_defined ( tree , tvb , off , str_tbl , * level , codepage_attr , map );
off += len;
if ( tag_new_known )
off ++;
off += 1 + tag_len;
( * level ) --;
0
------------------------------
305595 117252/CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_connect_socket_51b.c myString = ( wchar_t * ) malloc ( data * sizeof ( wchar_t ) ) 109
static void goodB2G()
size_t data ;
data = 0;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
char inputBuffer [ CHAR_ARRAY_SIZE ] ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
inputBuffer [ recvResult ] = '\0';
data = strtoul ( inputBuffer , NULL , 0 );
while ( 0 )
CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_connect_socket_51b_goodB2GSink ( data );
void CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_connect_socket_51b_goodB2GSink(size_t data)
wchar_t * myString ;
if ( data > wcslen ( HELLO_STRING ) && data < 100 )
myString = ( wchar_t * ) malloc ( data * sizeof ( wchar_t ) );
wcscpy ( myString , HELLO_STRING );
printWLine ( myString );
void printWLine (const wchar_t * line)
if ( line != NULL )
wprintf ( L "%ls\n" , line )
free ( myString );
0
------------------------------
305647 117254/CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_connect_socket_53d.c myString = ( wchar_t * ) malloc ( data * sizeof ( wchar_t ) ) 59
void CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_connect_socket_53_bad()
size_t data ;
data = 0;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
char inputBuffer [ CHAR_ARRAY_SIZE ] ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
inputBuffer [ recvResult ] = '\0';
data = strtoul ( inputBuffer , NULL , 0 );
while ( 0 )
CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_connect_socket_53b_badSink ( data );
void CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_connect_socket_53b_badSink(size_t data)
CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_connect_socket_53c_badSink ( data );
void CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_connect_socket_53c_badSink(size_t data)
CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_connect_socket_53d_badSink ( data );
void CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_connect_socket_53d_badSink(size_t data)
wchar_t * myString ;
if ( data > wcslen ( HELLO_STRING ) )
myString = ( wchar_t * ) malloc ( data * sizeof ( wchar_t ) );
wcscpy ( myString , HELLO_STRING );
printWLine ( myString );
void printWLine (const wchar_t * line)
if ( line != NULL )
wprintf ( L "%ls\n" , line )
free ( myString );
1
------------------------------
298780 95353/CWE369_Divide_by_Zero__int_rand_divide_08.c printIntLine ( 100 / data ) 48
void CWE369_Divide_by_Zero__int_rand_divide_08_bad()
int data ;
data = - 1;
if ( staticReturnsTrue ( ) )
static int staticReturnsTrue()
return 1 ;
data = RAND32 ( );
if ( staticReturnsTrue ( ) )
static int staticReturnsTrue()
return 1 ;
printIntLine ( 100 / data );
1
------------------------------
309267 120664/CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_spawnlp_61b.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 ) 98
void CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_spawnlp_61_bad()
wchar_t * data ;
wchar_t dataBuffer [ 100 ] = L ""
data = dataBuffer;
data = CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_spawnlp_61b_badSource ( data );
wchar_t * CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_spawnlp_61b_badSource(wchar_t * data)
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
302126 151543/tile-manager.c ntiles = tm -> ntile_rows * tm -> ntile_cols 305
TileManager *tile_manager_duplicate(TileManager *tm)
gint n_tiles ;
gint i ;
if ( tm != ( ( void * ) 0 ) )
while ( 0 )
n_tiles = tm -> ntile_rows * tm -> ntile_cols;
for (i = 0; i < n_tiles; i++)
Tile * tile ;
tile = tile_manager_get ( tm , i , ! 0 , 0 );
Tile *tile_manager_get(TileManager *tm,gint tile_num,gboolean wantread,gboolean wantwrite)
gint ntiles ;
if ( tm != ( ( void * ) 0 ) )
while ( 0 )
ntiles = tm -> ntile_rows * tm -> ntile_cols;
if ( tile_num < 0 || tile_num >= ntiles )
0
------------------------------
308270 120571/CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_execv_64a.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 ) 105
void CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_execv_64_bad()
wchar_t * data ;
wchar_t dataBuffer [ 100 ] = L ""
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
306924 117385/CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_listen_socket_21.c myString = ( wchar_t * ) malloc ( data * sizeof ( wchar_t ) ) 64
void CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_listen_socket_21_bad()
size_t data ;
data = 0;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
char inputBuffer [ CHAR_ARRAY_SIZE ] ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
inputBuffer [ recvResult ] = '\0';
data = strtoul ( inputBuffer , NULL , 0 );
while ( 0 )
badSink ( data );
static void badSink(size_t data)
if ( badStatic )
wchar_t * myString ;
if ( data > wcslen ( HELLO_STRING ) )
myString = ( wchar_t * ) malloc ( data * sizeof ( wchar_t ) );
wcscpy ( myString , HELLO_STRING );
printWLine ( myString );
void printWLine (const wchar_t * line)
if ( line != NULL )
wprintf ( L "%ls\n" , line )
free ( myString );
1
------------------------------
18562 CVE-2015-2716/Firefox_37.0b7_CVE_2015_2716_parser_expat_lib_xmlparse.c pool -> ptr = tem -> s + ( pool -> ptr - pool -> start ) 6285
static ATTRIBUTE_ID
getAttributeId(XML_Parser parser, const ENCODING
const char *start, const char *end)
DTD * const dtd = _dtd
const XML_Char * name ;
if ( ! poolAppendChar ( & dtd -> pool , XML_T ( '\0' ) ) )
name = poolStoreString ( & dtd -> pool , enc , start , end );
static XML_Char
poolStoreString(STRING_POOL *pool, const ENCODING
const char *ptr, const char *end)
if ( ! poolAppend ( pool , enc , ptr , end ) )
static XML_Char
poolAppend(STRING_POOL *pool, const ENCODING
const char *ptr, const char *end)
if ( ! pool -> ptr && ! poolGrow ( pool ) )
if ( ptr == end )
if ( ! poolGrow ( pool ) )
static XML_Bool
poolGrow(STRING_POOL *pool)
if ( pool -> freeBlocks )
if ( pool -> start == 0 )
if ( pool -> end - pool -> start < pool -> freeBlocks -> size )
if ( pool -> blocks && pool -> start == pool -> blocks -> s )
BLOCK * tem ;
int blockSize = ( int ) ( pool -> end - pool -> start ) ;
if ( blockSize < INIT_BLOCK_SIZE )
blockSize = INIT_BLOCK_SIZE;
blockSize *= 2;
tem = ( BLOCK * ) pool -> mem -> malloc_fcn ( offsetof ( BLOCK , s ) + blockSize * sizeof ( XML_Char ) );
if ( ! tem )
tem -> size = blockSize;
tem -> next = pool -> blocks;
pool -> blocks = tem;
if ( pool -> ptr != pool -> start )
memcpy ( tem -> s , pool -> start , ( pool -> ptr - pool -> start ) * sizeof ( XML_Char ) );
pool -> ptr = tem -> s + ( pool -> ptr - pool -> start );
pool -> start = tem -> s;
pool -> end = tem -> s + blockSize;
0
------------------------------
300196 149405/aviobuf.c s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_ptr - s -> checksum_ptr ) ) ) 173
int avio_put_str16le(AVIOContext *s,const char *str)
const uint8_t * q = str ;
while ( * q )
uint32_t ch ;
uint16_t tmp ;
ch = ( * ( q ++ ) );
uint32_t top = ( ch & 128 ) >> 1 ;
if ( ( ch & 0xc0 ) == 0x80 )
while ( ch & top )
int tmp = ( * ( q ++ ) ) - 128 ;
if ( tmp >> 6 )
ch = ( ch << 6 ) + tmp;
top <<= 5;
ch &= ( top << 1 ) - 1;
uint32_t in = ch ;
if ( in < 0x10000 )
tmp = ( 0xD800 | in - 0x10000 >> 10 );
tmp = ( 0xDC00 | in - 0x10000 & 0x3FF );
avio_wl16 ( s , tmp );
void avio_wl16(AVIOContext *s,unsigned int val)
avio_w8 ( s , ( ( int ) val ) >> 8 );
void avio_w8(AVIOContext *s,int b)
* ( s -> buf_ptr ++ ) = b;
if ( s -> buf_ptr >= s -> buf_end )
flush_buffer ( s );
static void flush_buffer(AVIOContext *s)
if ( s -> buf_ptr > s -> buffer )
if ( s -> update_checksum )
s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_ptr - s -> checksum_ptr ) ) );
s -> checksum_ptr = s -> buffer;
s -> buf_ptr = s -> buffer;
0
------------------------------
17203 CVE-2012-6062/CVE_2012_6062_VULN_dissect_rtcp_app.c packet_len = packet_len - item_len - 1 246
static
CVE_2012_6062_VULN_dissect_rtcp_app( tvbuff_t *tvb,packet_info *pinfo, int offset, proto_tree
unsigned int padding, unsigned int packet_len, guint
guint32 app_length )
unsigned int counter ;
char ascii_name [ 5 ] ;
guint sdes_type ;
guint item_len ;
static const char poc1_app_name_str [ ] = "PoC1" ;
offset += 4;
packet_len -= 4;
for( counter = 0; counter < 4; counter++ )
ascii_name [ counter ] = tvb_get_guint8 ( tvb , offset + counter );
ascii_name [ 4 ] = '\0';
if ( g_ascii_strncasecmp ( ascii_name , poc1_app_name_str , 4 ) == 0 )
guint8 t2timer_code , participants_code ;
offset += 4;
packet_len -= 4;
if ( packet_len == 0 )
if ( padding )
packet_len -= tvb_get_guint8 ( tvb , offset + packet_len - 1 );
switch ( rtcp_subtype )
guint8 code ;
if ( tvb_reported_length_remaining ( tvb , offset ) == 0 )
code = tvb_get_guint8 ( tvb , offset );
offset += 1;
packet_len -= 1;
if ( code == 102 )
item_len = tvb_get_guint8 ( tvb , offset );
offset += 1;
packet_len -= 1;
if ( item_len != 2 )
offset += 2;
packet_len -= 2;
if ( tvb_reported_length_remaining ( tvb , offset ) == 0 )
code = tvb_get_guint8 ( tvb , offset );
offset += 1;
packet_len -= 1;
if ( code == 103 )
item_len = tvb_get_guint8 ( tvb , offset );
offset += 1;
packet_len -= 1;
if ( item_len != 8 )
offset += 8;
packet_len -= 8;
t2timer_code = tvb_get_guint8 ( tvb , offset );
offset += 1;
packet_len -= 1;
if ( t2timer_code != 101 )
item_len = tvb_get_guint8 ( tvb , offset );
offset += 1;
packet_len -= 1;
if ( item_len != 2 )
offset += item_len;
packet_len -= item_len;
if ( tvb_reported_length_remaining ( tvb , offset ) == 0 )
participants_code = tvb_get_guint8 ( tvb , offset );
offset += 1;
packet_len -= 1;
if ( participants_code != 100 )
item_len = tvb_get_guint8 ( tvb , offset );
offset += 1;
packet_len -= 1;
if ( item_len != 2 )
offset += item_len;
packet_len -= item_len;
offset += 4;
packet_len -= 4;
sdes_type = tvb_get_guint8 ( tvb , offset );
offset ++;
packet_len --;
if ( sdes_type != RTCP_SDES_CNAME )
item_len = tvb_get_guint8 ( tvb , offset );
packet_len = packet_len - item_len - 1;
0
------------------------------
312718 120569/CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_execv_62b.cpp recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 ) 99
void bad()
wchar_t * data ;
wchar_t dataBuffer [ 100 ] = L ""
data = dataBuffer;
badSource ( data );
void badSource(wchar_t * &data)
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
300246 149405/aviobuf.c s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_end - s -> checksum_ptr ) ) ) 464
unsigned int avio_rb24(AVIOContext *s)
unsigned int val ;
val = avio_rb16 ( s ) << 8;
val |= ( avio_r8 ( s ) );
int avio_r8(AVIOContext *s)
if ( s -> buf_ptr >= s -> buf_end )
fill_buffer ( s );
static void fill_buffer(AVIOContext *s)
uint8_t * dst = ! s -> max_packet_size && s -> buf_end - s -> buffer < ( s -> buffer_size ) ? s -> buf_end : s -> buffer ;
if ( ! s -> read_packet && s -> buf_ptr >= s -> buf_end )
s -> eof_reached = 1;
if ( s -> eof_reached )
if ( s -> update_checksum && dst == s -> buffer )
if ( s -> buf_end > s -> checksum_ptr )
s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_end - s -> checksum_ptr ) ) );
s -> checksum_ptr = s -> buffer;
if ( s -> read_packet && s -> buffer_size > max_buffer_size )
ffio_set_buf_size ( s , max_buffer_size );
s -> checksum_ptr = dst = s -> buffer;
len = s -> buffer_size;
if ( s -> read_packet )
len = ( ( s -> read_packet ) ( s -> opaque , dst , len ) );
if ( len <= 0 )
s -> eof_reached = 1;
if ( len < 0 )
s -> error = len;
s -> pos += len;
s -> buf_ptr = dst;
s -> buf_end = dst + len;
s -> bytes_read += len;
0
------------------------------
304050 83944/CWE190_Integer_Overflow__short_fscanf_square_11.c short result = data * data ; 121
static void goodG2B1()
short data ;
data = 0;
if ( globalReturnsFalse ( ) )
int globalReturnsFalse()
return 0 ;
data = 2;
if ( globalReturnsTrue ( ) )
int globalReturnsTrue()
return 1 ;
short result = data * data ;
printIntLine ( result );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
0
------------------------------
313730 91935/CWE23_Relative_Path_Traversal__wchar_t_listen_socket_w32CreateFile_04.cpp recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ) 110
void bad()
wchar_t * data ;
wchar_t dataBuffer [ FILENAME_MAX ] = BASEPATH ;
data = dataBuffer;
if ( STATIC_CONST_TRUE )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( FILENAME_MAX - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
298050 95286/CWE369_Divide_by_Zero__int_listen_socket_divide_64b.c printIntLine ( 100 / data ) 51
void CWE369_Divide_by_Zero__int_listen_socket_divide_64_bad()
int data ;
data = - 1;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
char inputBuffer [ CHAR_ARRAY_SIZE ] ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
inputBuffer [ recvResult ] = '\0';
data = atoi ( inputBuffer );
while ( 0 )
CWE369_Divide_by_Zero__int_listen_socket_divide_64b_badSink ( & data );
void CWE369_Divide_by_Zero__int_listen_socket_divide_64b_badSink(void * dataVoidPtr)
int * dataPtr = ( int * ) dataVoidPtr ;
int data = ( * dataPtr ) ;
printIntLine ( 100 / data );
1
------------------------------
311602 150156/color.c stonesoup_arr [ stonesoup_i ] = dataStruct -> qsize - stonesoup_i 202
void *toPound(void *data)
int stonesoup_i ;
struct stonesoup_data * dataStruct = ( struct stonesoup_data * ) data ;
stonesoup_arr = malloc ( sizeof ( int ) * dataStruct -> qsize );
for (stonesoup_i = 0; stonesoup_i < dataStruct->qsize; stonesoup_i++)
stonesoup_arr [ stonesoup_i ] = dataStruct -> qsize - stonesoup_i;
qsort ( stonesoup_arr , dataStruct -> qsize , sizeof ( int ) , & stonesoup_comp );
free ( stonesoup_arr );
for (stonesoup_i = 0; stonesoup_i < (int)strlen(dataStruct->data) -
stonesoup_i += dataStruct->inc_amount)
dataStruct -> data [ stonesoup_i ] = '#';
1
------------------------------
21419 CVE-2016-9376/wireshark_2.0.5_CVE_2016_9376_epan_dissectors_packet-openflow_v5.c msg_end = offset + length 5842
static
dissect_openflow_message_v5(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, int offset)
guint16 length ;
gint32 msg_end ;
length = tvb_get_ntohs ( tvb , offset + 2 );
msg_end = offset + length;
return msg_end ;
0
------------------------------
20690 CVE-2016-8910/qemu_2.3.0_CVE-2016-8910_rtl8139.c int tcp_chunk_size = ETH_MTU - hlen - tcp_hlen ; 2232
static void rtl8139_mmio_writeb(void *opaque, hwaddr addr, uint32_t val)
rtl8139_io_writeb ( opaque , addr & 0xFF , val );
static void rtl8139_io_writeb(void *opaque, uint8_t addr, uint32_t val)
RTL8139State * s = opaque ;
switch ( addr )
if ( val == 'R' )
if ( val == 'H' )
s -> clock_enabled = 0;
s -> TxThresh = val;
if ( val & ( 1 << 6 ) )
rtl8139_cplus_transmit ( s );
static void rtl8139_cplus_transmit(RTL8139State *s)
while ( rtl8139_cplus_transmit_one ( s ) )
static int rtl8139_cplus_transmit_one(RTL8139State *s)
if ( ! rtl8139_transmitter_enabled ( s ) )
if ( ! rtl8139_cp_transmitter_enabled ( s ) )
uint32_t val , txdw0 , txdw1 , txbufLO , txbufHI ;
txdw0 = le32_to_cpu ( val );
if ( ! ( txdw0 & CP_TX_OWN ) )
if ( txdw0 & CP_TX_FS )
s -> cplus_txbuffer_offset = 0;
int txsize = txdw0 & CP_TX_BUFFER_SIZE_MASK ;
if ( ! s -> cplus_txbuffer )
s -> cplus_txbuffer_len = CP_TX_BUFFER_SIZE;
s -> cplus_txbuffer = g_malloc ( s -> cplus_txbuffer_len );
s -> cplus_txbuffer_offset = 0;
if ( s -> cplus_txbuffer_offset + txsize >= s -> cplus_txbuffer_len )
txsize = s -> cplus_txbuffer_len - s -> cplus_txbuffer_offset;
s -> cplus_txbuffer_offset += txsize;
if ( txdw0 & CP_TX_EOR )
s -> currCPlusTxDesc = 0;
if ( s -> currCPlusTxDesc >= 64 )
s -> currCPlusTxDesc = 0;
txdw0 &= ~CP_RX_OWN;
txdw0 &= ~CP_TX_STATUS_UNF;
txdw0 &= ~CP_TX_STATUS_TES;
txdw0 &= ~CP_TX_STATUS_OWC;
txdw0 &= ~CP_TX_STATUS_LNKF;
txdw0 &= ~CP_TX_STATUS_EXC;
if ( txdw0 & CP_TX_LS )
uint8_t * saved_buffer = s -> cplus_txbuffer ;
if ( txdw0 & ( CP_TX_IPCS | CP_TX_UDPCS | CP_TX_TCPCS | CP_TX_LGSEN ) )
ip_header * ip = NULL ;
int hlen = 0 ;
uint8_t ip_protocol = 0 ;
uint8_t * eth_payload_data = NULL ;
int proto = be16_to_cpu ( * ( uint16_t * ) ( saved_buffer + 12 ) ) ;
if ( proto == ETH_P_IP )
eth_payload_data = saved_buffer + ETH_HLEN;
ip = ( ip_header * ) eth_payload_data;
if ( IP_HEADER_VERSION ( ip ) != IP_HEADER_VERSION_4 )
ip = NULL;
hlen = IP_HEADER_LENGTH ( ip );
ip_protocol = ip -> ip_p;
if ( ip )
if ( ( txdw0 & CP_TX_LGSEN ) && ip_protocol == IP_PROTO_TCP )
tcp_header * p_tcp_hdr = ( tcp_header * ) ( eth_payload_data + hlen ) ;
int tcp_hlen = TCP_HEADER_DATA_OFFSET ( p_tcp_hdr ) ;
int tcp_chunk_size = ETH_MTU - hlen - tcp_hlen ;
for (tcp_send_offset = 0; tcp_send_offset < tcp_data_len; tcp_send_offset += tcp_chunk_size)
uint16_t chunk_size = tcp_chunk_size ;
if ( tcp_send_offset + tcp_chunk_size >= tcp_data_len )
chunk_size = tcp_data_len - tcp_send_offset;
DPRINTF ( "+++ C+ mode TSO TCP seqno %08x\n" , be32_to_cpu ( p_tcp_hdr -> th_seq ) );
DPRINTF ( "+++ C+ mode TSO calculating TCP checksum for
"packet with %d bytes data\n" , tcp_hlen
chunk_size )
if ( tcp_send_offset )
memcpy ( ( uint8_t * ) p_tcp_hdr + tcp_hlen , ( uint8_t * ) p_tcp_hdr + tcp_hlen + tcp_send_offset , chunk_size );
p_tcpip_hdr -> ip_payload = cpu_to_be16 ( tcp_hlen + chunk_size );
int tcp_checksum = ip_checksum ( data_to_checksum , tcp_hlen + chunk_size + 12 ) ;
DPRINTF ( "+++ C+ mode TSO TCP checksum %04x\n" , tcp_checksum );
p_tcp_hdr -> th_sum = tcp_checksum;
ip -> ip_len = cpu_to_be16 ( hlen + tcp_hlen + chunk_size );
ip -> ip_id = cpu_to_be16 ( tcp_send_offset / tcp_chunk_size + be16_to_cpu ( ip -> ip_id ) );
ip -> ip_sum = 0;
ip -> ip_sum = ip_checksum ( eth_payload_data , hlen );
DPRINTF ( "+++ C+ mode TSO IP header len=%d
"checksum=%04x\n" , hlen , ip -> ip_sum )
int tso_send_size = ETH_HLEN + hlen + tcp_hlen + chunk_size ;
rtl8139_transfer_frame ( s , saved_buffer , tso_send_size , 0 , ( uint8_t * ) dot1q_buffer );
p_tcp_hdr -> th_seq = cpu_to_be32 ( chunk_size + be32_to_cpu ( p_tcp_hdr -> th_seq ) );
0
------------------------------
304562 83080/CWE190_Integer_Overflow__int_connect_socket_square_11.c int result = data * data ; 114
void CWE190_Integer_Overflow__int_connect_socket_square_11_bad()
int data ;
data = 0;
if ( globalReturnsTrue ( ) )
int globalReturnsTrue()
return 1 ;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
char inputBuffer [ CHAR_ARRAY_SIZE ] ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
inputBuffer [ recvResult ] = '\0';
data = atoi ( inputBuffer );
while ( 0 )
if ( globalReturnsTrue ( ) )
int globalReturnsTrue()
return 1 ;
int result = data * data ;
printIntLine ( result );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
1
------------------------------
310670 148895/packet-per.c val_start = ( offset - num_bits ) >> 3 1238

dissect_per_constrained_set_of(tvbuff_t *tvb, guint32 offset, asn1_ctx_t *actx, proto_tree *parent_tree, int hf_index, gint ett_index, const per_sequence_t *seq, int min_len, int max_len, gboolean has_extension)
offset = dissect_per_constrained_sequence_of ( tvb , offset , actx , parent_tree , hf_index , ett_index , seq , min_len , max_len , has_extension );

dissect_per_constrained_sequence_of(tvbuff_t *tvb, guint32 offset, asn1_ctx_t *actx, proto_tree *parent_tree, int hf_index, gint ett_index, const per_sequence_t *seq, int min_len, int max_len, gboolean has_extension _U_)
if ( has_extension )
offset = dissect_per_boolean ( tvb , offset , actx , parent_tree , hf_per_extension_present_bit , & extension_present );

dissect_per_boolean(tvbuff_t *tvb, guint32 offset, asn1_ctx_t *actx, proto_tree *tree, int hf_index, gboolean *bool_val)
return offset + 1 ;
if ( ( min_len == max_len ) && ( min_len < 65536 ) )
if ( ( max_len >= 65536 ) || ( max_len == NO_BOUND ) )
offset = dissect_per_constrained_integer ( tvb , offset , actx , parent_tree , hf_per_sequence_of_length , min_len , max_len , & length , FALSE );

dissect_per_constrained_integer(tvbuff_t *tvb, guint32 offset, asn1_ctx_t *actx, proto_tree *tree, int hf_index, guint32 min, guint32 max, guint32 *value, gboolean has_extension)
guint32 range , val ;
gint val_start , val_length ;
int num_bits ;
if ( has_extension )
gboolean extension_present ;
offset = dissect_per_boolean ( tvb , offset , actx , tree , hf_per_extension_present_bit , & extension_present );
if ( extension_present )
if ( ( ( max - min ) > 65536 ) && ( actx -> aligned ) )
range = 1000000;
if ( ( max == 0x7fffffff && min == 0x80000000 ) || ( max == 0xffffffff && min == 0x00000000 ) )
range = 0xffffffff;
range = max - min + 1;
if ( range == 1 )
if ( ( range <= 255 ) || ( ! actx -> aligned ) )
int i , bit , length ;
guint32 mask , mask2 ;
mask = 0x80000000;
mask2 = 0x7fffffff;
i = 32;
while ( ( range & mask ) == 0 )
i = i - 1;
mask = mask >> 1;
mask2 = mask2 >> 1;
if ( ( range & mask2 ) == 0 )
i = i - 1;
num_bits = i;
if ( range <= 2 )
num_bits = 1;
for(i=0;i<num_bits;i++)
offset = dissect_per_boolean ( tvb , offset , actx , tree , - 1 , & tmp );
val_start = ( offset - num_bits ) >> 3;
proto_tree_add_text ( tree , tvb , val_start , val_length , "Range = %u Bitfield length %u, %s" , range , num_bits , str );
it = proto_tree_add_uint ( tree , hf_index , tvb , val_start , val_length , val );
per_check_value ( val , min , max , actx , it , FALSE );
it = proto_tree_add_int ( tree , hf_index , tvb , val_start , val_length , val );
per_check_value ( val , min , max , actx , it , TRUE );
it = proto_tree_add_time ( tree , hf_index , tvb , val_start , val_length , & timeval );
actx -> created_item = it;
0
------------------------------
304354 84654/CWE190_Integer_Overflow__unsigned_int_rand_square_01.c unsigned int result = data * data ; 32
void CWE190_Integer_Overflow__unsigned_int_rand_square_01_bad()
unsigned int data ;
data = 0;
data = ( unsigned int ) RAND32 ( );
unsigned int result = data * data ;
printUnsignedLine ( result );
void printUnsignedLine(unsigned unsignedNumber)
printf ( "%u\n" , unsignedNumber );
1
------------------------------
307353 120729/CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_spawnvp_03.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 ) 103
void CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_spawnvp_03_bad()
wchar_t * data ;
wchar_t dataBuffer [ 100 ] = L ""
data = dataBuffer;
if ( 5 == 5 )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
303043 81742/CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_printf_05.c recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 ) 303
static void goodB2G2()
wchar_t * data ;
wchar_t dataBuffer [ 100 ] = L ""
data = dataBuffer;
if ( staticTrue )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
309237 117139/CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_13.c myString = ( char * ) malloc ( data * sizeof ( char ) ) 386
static void goodG2B1()
size_t data ;
data = 0;
if ( GLOBAL_CONST_FIVE != 5 )
data = 20;
if ( GLOBAL_CONST_FIVE == 5 )
char * myString ;
if ( data > strlen ( HELLO_STRING ) )
myString = ( char * ) malloc ( data * sizeof ( char ) );
strcpy ( myString , HELLO_STRING );
printLine ( myString );
void printLine (const char * line)
if ( line != NULL )
printf ( "%s\n" , line );
free ( myString );
0
------------------------------
20600 CVE-2016-8910/qemu_2.3.0_CVE-2016-8910_rtl8139.c p_tcpip_hdr -> ip_payload = cpu_to_be16 ( tcp_hlen + chunk_size ) 2280
static void rtl8139_io_writew(void *opaque, uint8_t addr, uint32_t val)
switch ( addr )
rtl8139_io_writeb ( opaque , addr , val & 0xff );
static void rtl8139_io_writeb(void *opaque, uint8_t addr, uint32_t val)
RTL8139State * s = opaque ;
switch ( addr )
if ( val == 'R' )
if ( val == 'H' )
s -> clock_enabled = 0;
s -> TxThresh = val;
if ( val & ( 1 << 6 ) )
rtl8139_cplus_transmit ( s );
static void rtl8139_cplus_transmit(RTL8139State *s)
while ( rtl8139_cplus_transmit_one ( s ) )
static int rtl8139_cplus_transmit_one(RTL8139State *s)
if ( ! rtl8139_transmitter_enabled ( s ) )
if ( ! rtl8139_cp_transmitter_enabled ( s ) )
uint32_t val , txdw0 , txdw1 , txbufLO , txbufHI ;
txdw0 = le32_to_cpu ( val );
if ( ! ( txdw0 & CP_TX_OWN ) )
if ( txdw0 & CP_TX_FS )
s -> cplus_txbuffer_offset = 0;
int txsize = txdw0 & CP_TX_BUFFER_SIZE_MASK ;
if ( ! s -> cplus_txbuffer )
s -> cplus_txbuffer_len = CP_TX_BUFFER_SIZE;
s -> cplus_txbuffer = g_malloc ( s -> cplus_txbuffer_len );
s -> cplus_txbuffer_offset = 0;
if ( s -> cplus_txbuffer_offset + txsize >= s -> cplus_txbuffer_len )
txsize = s -> cplus_txbuffer_len - s -> cplus_txbuffer_offset;
s -> cplus_txbuffer_offset += txsize;
if ( txdw0 & CP_TX_EOR )
s -> currCPlusTxDesc = 0;
if ( s -> currCPlusTxDesc >= 64 )
s -> currCPlusTxDesc = 0;
txdw0 &= ~CP_RX_OWN;
txdw0 &= ~CP_TX_STATUS_UNF;
txdw0 &= ~CP_TX_STATUS_TES;
txdw0 &= ~CP_TX_STATUS_OWC;
txdw0 &= ~CP_TX_STATUS_LNKF;
txdw0 &= ~CP_TX_STATUS_EXC;
if ( txdw0 & CP_TX_LS )
uint8_t * saved_buffer = s -> cplus_txbuffer ;
if ( txdw0 & ( CP_TX_IPCS | CP_TX_UDPCS | CP_TX_TCPCS | CP_TX_LGSEN ) )
ip_header * ip = NULL ;
int hlen = 0 ;
uint8_t ip_protocol = 0 ;
uint16_t ip_data_len = 0 ;
uint8_t * eth_payload_data = NULL ;
int proto = be16_to_cpu ( * ( uint16_t * ) ( saved_buffer + 12 ) ) ;
if ( proto == ETH_P_IP )
eth_payload_data = saved_buffer + ETH_HLEN;
ip = ( ip_header * ) eth_payload_data;
if ( IP_HEADER_VERSION ( ip ) != IP_HEADER_VERSION_4 )
ip = NULL;
hlen = IP_HEADER_LENGTH ( ip );
ip_protocol = ip -> ip_p;
ip_data_len = be16_to_cpu ( ip -> ip_len ) - hlen;
if ( ip )
if ( ( txdw0 & CP_TX_LGSEN ) && ip_protocol == IP_PROTO_TCP )
uint8_t saved_ip_header [ 60 ] ;
memcpy ( saved_ip_header , eth_payload_data , hlen );
uint8_t * data_to_checksum = eth_payload_data + hlen - 12 ;
tcp_header * p_tcp_hdr = ( tcp_header * ) ( eth_payload_data + hlen ) ;
int tcp_hlen = TCP_HEADER_DATA_OFFSET ( p_tcp_hdr ) ;
int tcp_data_len = ip_data_len - tcp_hlen ;
int tcp_chunk_size = ETH_MTU - hlen - tcp_hlen ;
for (tcp_send_offset = 0; tcp_send_offset < tcp_data_len; tcp_send_offset += tcp_chunk_size)
uint16_t chunk_size = tcp_chunk_size ;
if ( tcp_send_offset + tcp_chunk_size >= tcp_data_len )
chunk_size = tcp_data_len - tcp_send_offset;
memcpy ( data_to_checksum , saved_ip_header + 12 , 8 );
ip_pseudo_header * p_tcpip_hdr = ( ip_pseudo_header * ) data_to_checksum ;
p_tcpip_hdr -> zeros = 0;
p_tcpip_hdr -> ip_proto = IP_PROTO_TCP;
p_tcpip_hdr -> ip_payload = cpu_to_be16 ( tcp_hlen + chunk_size );
0
------------------------------
308296 117375/CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_listen_socket_09.c myString = ( wchar_t * ) malloc ( data * sizeof ( wchar_t ) ) 420
static void goodG2B2()
size_t data ;
data = 0;
if ( GLOBAL_CONST_TRUE )
data = 20;
if ( GLOBAL_CONST_TRUE )
wchar_t * myString ;
if ( data > wcslen ( HELLO_STRING ) )
myString = ( wchar_t * ) malloc ( data * sizeof ( wchar_t ) );
wcscpy ( myString , HELLO_STRING );
printWLine ( myString );
void printWLine (const wchar_t * line)
if ( line != NULL )
wprintf ( L "%ls\n" , line )
free ( myString );
0
------------------------------
302645 80686/CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_vfprintf_05.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 ) 303
static void goodB2G2()
wchar_t * data ;
wchar_t dataBuffer [ 100 ] = L ""
data = dataBuffer;
if ( staticTrue )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
302858 82499/CWE190_Integer_Overflow__char_rand_square_06.c char result = data * data ; 72
static void goodB2G1()
char data ;
data = ' ';
if ( STATIC_CONST_FIVE == 5 )
data = ( char ) RAND32 ( );
if ( STATIC_CONST_FIVE != 5 )
if ( abs ( ( long ) data ) <= ( long ) sqrt ( ( double ) CHAR_MAX ) )
char result = data * data ;
printHexCharLine ( result );
void printHexCharLine (char charHex)
printf ( "%02x\n" , charHex );
0
------------------------------
18426 CVE-2015-2716/Firefox_37.0b7_CVE_2015_2716_parser_expat_lib_xmlparse.c bufferEnd = newBuf + ( bufferEnd - bufferPtr ) 1716
enum XML_Status
XML_Parse(XML_Parser parser, const char *s, int len, int isFinal)
switch ( ps_parsing )
if ( len == 0 )
if ( bufferPtr == bufferEnd )
void * buff = XML_GetBuffer ( parser , len ) ;
void *
XML_GetBuffer(XML_Parser parser, int len)
switch ( ps_parsing )
if ( len > bufferLim - bufferEnd )
int neededSize = len + ( int ) ( bufferEnd - bufferPtr ) ;
int keep = ( int ) ( bufferPtr - buffer ) ;
if ( keep > XML_CONTEXT_BYTES )
keep = XML_CONTEXT_BYTES;
neededSize += keep;
if ( neededSize <= bufferLim - buffer )
char * newBuf ;
int bufferSize = ( int ) ( bufferLim - bufferPtr ) ;
if ( bufferSize == 0 )
bufferSize = INIT_BUFFER_SIZE;
bufferSize *= 2;
while ( bufferSize < neededSize )
newBuf = ( char * ) MALLOC ( bufferSize );
if ( newBuf == 0 )
if ( bufferPtr )
bufferEnd = newBuf + ( bufferEnd - bufferPtr );
return bufferEnd ;
0
------------------------------
314871 110864/CWE680_Integer_Overflow_to_Buffer_Overflow__new_rand_41.cpp dataBytes = data * sizeof ( int ) 61
static void goodG2B()
int data ;
data = - 1;
data = 20;
goodG2BSink ( data );
void goodG2BSink(int data)
size_t dataBytes , i ;
dataBytes = data * sizeof ( int );
intPointer = ( int * ) new char [ dataBytes ];
intPointer [ i ] = 0;
printIntLine ( intPointer [ 0 ] );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
delete [ ] intPointer
0
------------------------------
17116 CVE-2014-6431/CVE_2014_6431_VULN_SnifferDecompress.c unsigned char * pout_end = pout + outlen ; 8
static
CVE_2014_6431_VULN_SnifferDecompress(unsigned char *inbuf, size_t inlen, unsigned char
size_t outlen, int *err)
unsigned char * pout = outbuf ;
unsigned char * pout_end = pout + outlen ;
0
------------------------------
17506 CVE-2007-3642/CVE_2007_3642_VULN_decode_choice.c bs -> cur = beg + len 58
int CVE_2007_3642_VULN_decode_choice(bitstr_t * bs, field_t * f, char *base, int level)
int err ;
field_t * son ;
base = ( base && ( f -> attr & DECODE ) ) ? base + f -> offset : NULL;
if ( ( f -> attr & EXT ) && get_bit ( bs ) )
ext = 1;
type = get_bits ( bs , 7 ) + f -> lb;
ext = 0;
type = get_bits ( bs , f -> sz );
if ( base )
* ( unsigned * ) base = type;
if ( type >= f -> ub )
son = & f -> fields [ type ];
if ( son -> attr & STOP )
if ( ext || ( son -> attr & OPEN ) )
len = get_len ( bs );
if ( ! base || ! ( son -> attr & DECODE ) )
beg = bs -> cur;
if ( ( err = ( Decoders [ son -> type ] ) ( bs , son , base , level + 1 ) ) < H323_ERROR_NONE )
bs -> cur = beg + len;
0
------------------------------
302031 149942/aviobuf.c s -> buf_end = dst + len 562
unsigned int avio_rb32(AVIOContext *s)
unsigned int val ;
val = avio_rb16 ( s ) << 16;
val |= avio_rb16 ( s );
unsigned int avio_rb16(AVIOContext *s)
unsigned int val ;
val = ( avio_r8 ( s ) << 8 );
int avio_r8(AVIOContext *s)
if ( s -> buf_ptr >= s -> buf_end )
fill_buffer ( s );
static void fill_buffer(AVIOContext *s)
uint8_t * dst = ! s -> max_packet_size && s -> buf_end - s -> buffer < ( s -> buffer_size ) ? s -> buf_end : s -> buffer ;
int len = ( ( s -> buffer_size ) - ( dst - s -> buffer ) ) ;
int max_buffer_size = s -> max_packet_size ? s -> max_packet_size : 32768 ;
if ( ! s -> read_packet && s -> buf_ptr >= s -> buf_end )
s -> eof_reached = 1;
if ( s -> eof_reached )
if ( s -> update_checksum && dst == s -> buffer )
if ( s -> buf_end > s -> checksum_ptr )
s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_end - s -> checksum_ptr ) ) );
s -> checksum_ptr = s -> buffer;
if ( s -> read_packet && s -> buffer_size > max_buffer_size )
s -> checksum_ptr = dst = s -> buffer;
len = s -> buffer_size;
if ( s -> read_packet )
len = ( ( s -> read_packet ) ( s -> opaque , dst , len ) );
len = 0;
if ( len <= 0 )
s -> eof_reached = 1;
if ( len < 0 )
s -> error = len;
s -> pos += len;
s -> buf_ptr = dst;
s -> buf_end = dst + len;
s -> bytes_read += len;
0
------------------------------
311403 152169/aviobuf.c s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_end - s -> checksum_ptr ) ) ) 463
int avio_get_str16le(AVIOContext *pb,int maxlen,char *buf,int buflen)
int ret = 0 ;
if ( buflen <= 0 )
while ( ret + 1 < maxlen )
uint32_t ch ;
ch = ( ( ret += 2 ) <= maxlen ? avio_rl16 ( pb ) : 0 );
unsigned int hi = ch - 0xD800 ;
if ( hi < 0x800 )
ch = ( ( ret += 2 ) <= maxlen ? avio_rl16 ( pb ) : ( 0 - 0xDC00 ) );
if ( ch > 0x3FFU || hi > 0x3FFU )
ch += ( hi << 10 ) + 0x10000;
if ( ! ch )
unsigned int avio_rl16(AVIOContext *s)
unsigned int val ;
val = ( avio_r8 ( s ) );
val |= ( avio_r8 ( s ) << 8 );
int avio_r8(AVIOContext *s)
if ( s -> buf_ptr >= s -> buf_end )
fill_buffer ( s );
static void fill_buffer(AVIOContext *s)
uint8_t * dst = ! s -> max_packet_size && s -> buf_end - s -> buffer < ( s -> buffer_size ) ? s -> buf_end : s -> buffer ;
if ( ! s -> read_packet && s -> buf_ptr >= s -> buf_end )
s -> eof_reached = 1;
if ( s -> eof_reached )
if ( s -> update_checksum && dst == s -> buffer )
if ( s -> buf_end > s -> checksum_ptr )
s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_end - s -> checksum_ptr ) ) );
s -> checksum_ptr = s -> buffer;
if ( s -> read_packet && s -> buffer_size > max_buffer_size )
ffio_set_buf_size ( s , max_buffer_size );
s -> checksum_ptr = dst = s -> buffer;
len = s -> buffer_size;
if ( s -> read_packet )
len = ( ( s -> read_packet ) ( s -> opaque , dst , len ) );
if ( len <= 0 )
s -> eof_reached = 1;
if ( len < 0 )
s -> error = len;
s -> pos += len;
s -> buf_ptr = dst;
s -> buf_end = dst + len;
s -> bytes_read += len;
0
------------------------------
311010 153298/stream.c svn_error_t * svn_err__temp = svn_stream_read ( stream , str -> data + str -> len , & numbytes ) ; 440
svn_error_t *svn_stream_readline(svn_stream_t *stream,svn_stringbuf_t **stringbuf,const char *eol,svn_boolean_t *eof,apr_pool_t *pool)
return stream_readline ( stringbuf , eof , eol , stream , pool ) ;
static svn_error_t *stream_readline(svn_stringbuf_t **stringbuf,svn_boolean_t *eof,const char *eol,svn_stream_t *stream,apr_pool_t *pool)
* eof = 0;
if ( svn_stream_supports_mark ( stream ) && svn_stream__is_buffered ( stream ) )
svn_boolean_t svn_stream__is_buffered(svn_stream_t *stream)
if ( stream -> is_buffered_fn == ( ( void * ) 0 ) )
return 0 ;
return ( stream -> is_buffered_fn ) ( stream -> baton ) ;
svn_boolean_t svn_stream_supports_mark(svn_stream_t *stream)
return stream -> mark_fn != ( ( void * ) 0 ) ;
svn_error_t * svn_err__temp = stream_readline_chunky ( stringbuf , eof , eol , stream , pool ) ;
if ( svn_err__temp )
while ( 0 )
static svn_error_t *stream_readline_chunky(svn_stringbuf_t **stringbuf,svn_boolean_t *eof,const char *eol,svn_stream_t *stream,apr_pool_t *pool)
char buffer [ 80 + 1 ] ;
apr_size_t numbytes ;
const char * eol_pos ;
const size_t eol_len = strlen ( eol ) ;
svn_error_t * svn_err__temp = svn_stream_mark ( stream , & mark , pool ) ;
svn_error_t *svn_stream_mark(svn_stream_t *stream,svn_stream_mark_t **mark,apr_pool_t *pool)
if ( stream -> mark_fn == ( ( void * ) 0 ) )
return svn_error_create ( SVN_ERR_STREAM_SEEK_NOT_SUPPORTED , ( ( void * ) 0 ) , ( ( void * ) 0 ) ) ;
return ( stream -> mark_fn ) ( stream -> baton , mark , pool ) ;
if ( svn_err__temp )
while ( 0 )
numbytes = 80;
svn_error_t * svn_err__temp = svn_stream_read ( stream , buffer , & numbytes ) ;
svn_error_t *svn_stream_read(svn_stream_t *stream,char *buffer,apr_size_t *len)
if ( ! ( stream -> read_fn != ( ( void * ) 0 ) ) )
svn_error_t * svn_err__temp = svn_error__malfunction ( ! 0 , "stream.c" , 143 , "stream->read_fn != NULL" ) ;
if ( svn_err__temp )
return svn_err__temp ;
while ( 0 )
while ( 0 )
return ( stream -> read_fn ) ( stream -> baton , buffer , len ) ;
if ( svn_err__temp )
while ( 0 )
buffer [ numbytes ] = '\0';
eol_pos = ( strstr ( buffer , eol ) );
if ( eol_pos != ( ( void * ) 0 ) )
if ( numbytes < 80 )
svn_stringbuf_t * str ;
str = svn_stringbuf_create_ensure ( ( 2 * 80 ) , pool );
numbytes = 80;
svn_error_t * svn_err__temp = svn_stream_read ( stream , str -> data + str -> len , & numbytes ) ;
svn_error_t *svn_stream_read(svn_stream_t *stream,char *buffer,apr_size_t *len)
if ( ! ( stream -> read_fn != ( ( void * ) 0 ) ) )
svn_error_t * svn_err__temp = svn_error__malfunction ( ! 0 , "stream.c" , 143 , "stream->read_fn != NULL" ) ;
if ( svn_err__temp )
return svn_err__temp ;
while ( 0 )
while ( 0 )
return ( stream -> read_fn ) ( stream -> baton , buffer , len ) ;
if ( svn_err__temp )
return svn_err__temp ;
while ( 0 )
str -> len += numbytes;
str -> data [ str -> len ] = '\0';
eol_pos = ( strstr ( ( str -> data + str -> len - numbytes - ( eol_len - 1 ) ) , eol ) );
if ( numbytes < 80 && eol_pos == ( ( void * ) 0 ) )
while ( eol_pos == ( ( void * ) 0 ) )
0
------------------------------
301546 150690/aviobuf.c s -> buf_end = dst + len 591
int64_t avio_skip(AVIOContext *s,int64_t offset)
return avio_seek ( s , offset , 1 ) ;
int64_t avio_seek(AVIOContext *s,int64_t offset,int whence)
int64_t offset1 ;
int64_t pos ;
int force = whence & 0x20000 ;
whence &= ~0x20000;
if ( ! s )
pos = s -> pos - ( ( s -> write_flag ? 0 : s -> buf_end - s -> buffer ) );
if ( whence != 1 && whence != 0 )
if ( whence == 1 )
offset1 = pos + ( s -> buf_ptr - s -> buffer );
if ( offset == 0 )
offset += offset1;
offset1 = offset - pos;
if ( ! s -> must_flush && ( ! s -> direct || ! s -> seek ) && offset1 >= 0 && offset1 <= s -> buf_end - s -> buffer )
if ( ( ! s -> seekable || offset1 <= s -> buf_end + 4096 - s -> buffer ) && ! s -> write_flag && offset1 >= 0 && ( ! s -> direct || ! s -> seek ) && ( whence != 2 || force ) )
while ( s -> pos < offset && ! s -> eof_reached )
fill_buffer ( s );
static void fill_buffer(AVIOContext *s)
uint8_t * dst = ! s -> max_packet_size && s -> buf_end - s -> buffer < ( s -> buffer_size ) ? s -> buf_end : s -> buffer ;
int len = ( ( s -> buffer_size ) - ( dst - s -> buffer ) ) ;
int max_buffer_size = s -> max_packet_size ? s -> max_packet_size : 32768 ;
if ( ! s -> read_packet && s -> buf_ptr >= s -> buf_end )
s -> eof_reached = 1;
if ( s -> eof_reached )
if ( s -> update_checksum && dst == s -> buffer )
if ( s -> buf_end > s -> checksum_ptr )
s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_end - s -> checksum_ptr ) ) );
s -> checksum_ptr = s -> buffer;
if ( s -> read_packet && s -> buffer_size > max_buffer_size )
s -> checksum_ptr = dst = s -> buffer;
len = s -> buffer_size;
if ( s -> read_packet )
len = ( ( s -> read_packet ) ( s -> opaque , dst , len ) );
len = 0;
if ( len <= 0 )
s -> eof_reached = 1;
if ( len < 0 )
s -> error = len;
s -> pos += len;
s -> buf_ptr = dst;
s -> buf_end = dst + len;
s -> bytes_read += len;
0
------------------------------
306181 117443/CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_rand_45.c myString = ( wchar_t * ) malloc ( data * sizeof ( wchar_t ) ) 81
static void goodG2BSink()
size_t data = CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_rand_45_goodG2BData ;
wchar_t * myString ;
if ( data > wcslen ( HELLO_STRING ) )
myString = ( wchar_t * ) malloc ( data * sizeof ( wchar_t ) );
wcscpy ( myString , HELLO_STRING );
printWLine ( myString );
void printWLine (const wchar_t * line)
if ( line != NULL )
wprintf ( L "%ls\n" , line )
free ( myString );
0
------------------------------
306704 119891/CWE78_OS_Command_Injection__char_listen_socket_execl_45.c recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 125
void CWE78_OS_Command_Injection__char_listen_socket_execl_45_bad()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
CWE78_OS_Command_Injection__char_listen_socket_execl_45_badData = data;
0
------------------------------
301481 149948/aviobuf.c s -> buf_end = s -> buffer + s -> buffer_size 1016
int avio_read(AVIOContext *s,unsigned char *buf,int size)
int len ;
while ( size > 0 )
len = ( s -> buf_end - s -> buf_ptr );
if ( len > size )
len = size;
if ( len == 0 || s -> write_flag )
if ( ( s -> direct || size > s -> buffer_size ) && ! s -> update_checksum )
if ( s -> read_packet )
len = ( ( s -> read_packet ) ( s -> opaque , buf , size ) );
if ( len <= 0 )
s -> pos += len;
s -> bytes_read += len;
size -= len;
buf += len;
s -> buf_ptr = s -> buffer;
s -> buf_end = s -> buffer;
fill_buffer ( s );
len = ( s -> buf_end - s -> buf_ptr );
if ( len == 0 )
memcpy ( buf , ( s -> buf_ptr ) , len );
buf += len;
s -> buf_ptr += len;
size -= len;
static void fill_buffer(AVIOContext *s)
uint8_t * dst = ! s -> max_packet_size && s -> buf_end - s -> buffer < ( s -> buffer_size ) ? s -> buf_end : s -> buffer ;
int max_buffer_size = s -> max_packet_size ? s -> max_packet_size : 32768 ;
if ( ! s -> read_packet && s -> buf_ptr >= s -> buf_end )
s -> eof_reached = 1;
if ( s -> eof_reached )
if ( s -> update_checksum && dst == s -> buffer )
if ( s -> buf_end > s -> checksum_ptr )
s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_end - s -> checksum_ptr ) ) );
s -> checksum_ptr = s -> buffer;
if ( s -> read_packet && s -> buffer_size > max_buffer_size )
ffio_set_buf_size ( s , max_buffer_size );
int ffio_set_buf_size(AVIOContext *s,int buf_size)
uint8_t * buffer ;
buffer = ( av_malloc ( buf_size ) );
if ( ! buffer )
s -> buffer = buffer;
s -> buffer_size = buf_size;
s -> buf_ptr = buffer;
url_resetbuf ( s , ( s -> write_flag ? 2 : 1 ) );
static int url_resetbuf(AVIOContext *s,int flags)
if ( flags & 2 )
s -> buf_end = s -> buffer + s -> buffer_size;
s -> write_flag = 1;
0
------------------------------
304083 79225/CWE134_Uncontrolled_Format_String__char_connect_socket_snprintf_53a.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 97
void CWE134_Uncontrolled_Format_String__char_connect_socket_snprintf_53_bad()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
CWE134_Uncontrolled_Format_String__char_connect_socket_snprintf_53b_badSink ( data );
void CWE134_Uncontrolled_Format_String__char_connect_socket_snprintf_53b_badSink(char * data)
CWE134_Uncontrolled_Format_String__char_connect_socket_snprintf_53c_badSink ( data );
void CWE134_Uncontrolled_Format_String__char_connect_socket_snprintf_53c_badSink(char * data)
CWE134_Uncontrolled_Format_String__char_connect_socket_snprintf_53d_badSink ( data );
void CWE134_Uncontrolled_Format_String__char_connect_socket_snprintf_53d_badSink(char * data)
SNPRINTF ( dest , 100 - 1 , data );
0
------------------------------
305112 94130/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_connect_socket_54a.c recvResult = recv ( connectSocket , ( char * ) ( password + passwordLen ) , ( 100 - passwordLen - 1 ) * sizeof ( char ) , 0 ) 73
void CWE319_Cleartext_Tx_Sensitive_Info__w32_char_connect_socket_54_bad()
char * password ;
char passwordBuffer [ 100 ] = "" ;
password = passwordBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t passwordLen = strlen ( password ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( password + passwordLen ) , ( 100 - passwordLen - 1 ) * sizeof ( char ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
password [ passwordLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( password , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( password , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
CWE319_Cleartext_Tx_Sensitive_Info__w32_char_connect_socket_54b_badSink ( password );
void CWE319_Cleartext_Tx_Sensitive_Info__w32_char_connect_socket_54b_badSink(char * password)
CWE319_Cleartext_Tx_Sensitive_Info__w32_char_connect_socket_54c_badSink ( password );
void CWE319_Cleartext_Tx_Sensitive_Info__w32_char_connect_socket_54c_badSink(char * password)
CWE319_Cleartext_Tx_Sensitive_Info__w32_char_connect_socket_54d_badSink ( password );
void CWE319_Cleartext_Tx_Sensitive_Info__w32_char_connect_socket_54d_badSink(char * password)
CWE319_Cleartext_Tx_Sensitive_Info__w32_char_connect_socket_54e_badSink ( password );
void CWE319_Cleartext_Tx_Sensitive_Info__w32_char_connect_socket_54e_badSink(char * password)
if ( LogonUserA ( username , domain , password , LOGON32_LOGON_NETWORK , LOGON32_PROVIDER_DEFAULT , & pHandle ) != 0 )
1
------------------------------
18294 CVE-2015-5154/Xen_4.5.0_CVE-2015-5154_ide.c s = ide_state + i 3149
void mmio_ide_init (target_phys_addr_t membase, target_phys_addr_t
qemu_irq irq, int
BlockDriverState *hd0, BlockDriverState *hd1)
IDEState * ide = qemu_mallocz ( sizeof ( IDEState ) * 2 ) ;
ide_init2 ( ide , hd0 , hd1 , irq );
static void ide_init2(IDEState
BlockDriverState *hd0, BlockDriverState
qemu_irq irq)
IDEState * s ;
int i , cylinders , heads , secs ;
for(i = 0; i < 2; i++)
s = ide_state + i;
s -> io_buffer = qemu_memalign ( 512 , IDE_DMA_BUF_SECTORS * 512 + 4 );
s -> bs = hd0;
s -> bs = hd1;
if ( s -> bs )
bdrv_get_geometry ( s -> bs , & nb_sectors );
bdrv_guess_geometry ( s -> bs , & cylinders , & heads , & secs );
s -> cylinders = cylinders;
s -> heads = heads;
s -> sectors = secs;
s -> nb_sectors = nb_sectors;
if ( bdrv_get_type_hint ( s -> bs ) == BDRV_TYPE_CDROM )
s -> is_cdrom = 1;
bdrv_set_change_cb ( s -> bs , cdrom_change_cb , s );
s -> drive_serial = drive_serial ++;
strncpy ( s -> drive_serial_str , drive_get_serial ( s -> bs ) , sizeof ( s -> drive_serial_str ) );
if ( strlen ( s -> drive_serial_str ) == 0 )
snprintf ( s -> drive_serial_str , sizeof ( s -> drive_serial_str ) , "QM%05d" , s -> drive_serial );
s -> irq = irq;
s -> sector_write_timer = qemu_new_timer ( vm_clock , ide_sector_write_timer_cb , s );
s -> write_cache = 0;
ide_reset ( s );
0
------------------------------
307075 117032/CWE789_Uncontrolled_Mem_Alloc__malloc_char_fgets_02.c myString = ( char * ) malloc ( data * sizeof ( char ) ) 159
static void goodB2G2()
size_t data ;
data = 0;
if ( 1 )
char inputBuffer [ CHAR_ARRAY_SIZE ] = "" ;
if ( fgets ( inputBuffer , CHAR_ARRAY_SIZE , stdin ) != NULL )
data = strtoul ( inputBuffer , NULL , 0 );
if ( 1 )
char * myString ;
if ( data > strlen ( HELLO_STRING ) && data < 100 )
myString = ( char * ) malloc ( data * sizeof ( char ) );
strcpy ( myString , HELLO_STRING );
printLine ( myString );
void printLine (const char * line)
if ( line != NULL )
printf ( "%s\n" , line );
free ( myString );
0
------------------------------
313369 96525/CWE36_Absolute_Path_Traversal__char_listen_socket_fopen_44.cpp recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ) 119
void bad()
char * data ;
char dataBuffer [ FILENAME_MAX ] = "" ;
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
funcPtr ( data );
0
------------------------------
307224 110408/CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fixed_01.c intPointer = ( int * ) malloc ( data * sizeof ( int ) ) 35
void CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fixed_01_bad()
int data ;
data = - 1;
data = INT_MAX / 2 + 2;
int * intPointer ;
intPointer = ( int * ) malloc ( data * sizeof ( int ) );
intPointer [ i ] = 0;
printIntLine ( intPointer [ 0 ] );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
free ( intPointer );
1
------------------------------
305570 110007/CWE666_Operation_on_Resource_in_Wrong_Phase_of_Lifetime__listen_accept_bind_09.c recvResult = recv ( acceptSocket , ( char * ) data + dataLen , ( int ) ( 100 - dataLen - 1 ) , 0 ) 93
void CWE666_Operation_on_Resource_in_Wrong_Phase_of_Lifetime__listen_accept_bind_09_bad()
if ( GLOBAL_CONST_TRUE )
char data [ 100 ] = "" ;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) data + dataLen , ( int ) ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ recvResult ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
printLine ( data );
void printLine (const char * line)
if ( line != NULL )
printf ( "%s\n" , line );
1
------------------------------
310631 148896/packet-ppp.c ti = proto_tree_add_text ( mux_tree , tvb , offset , length + length_field , "PPPMux Sub-frame" ) 4391
static
dissect_pppmux(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree)
proto_tree * mux_tree , * hdr_tree , * sub_tree , * flag_tree ;
guint8 flags , byte ;
guint16 length ;
int offset = 0 , length_remaining ;
length_remaining = tvb_reported_length ( tvb );
ti = proto_tree_add_item ( tree , proto_pppmux , tvb , 0 , - 1 , ENC_NA );
mux_tree = proto_item_add_subtree ( ti , ett_pppmux );
while ( length_remaining > 0 )
flags = tvb_get_guint8 ( tvb , offset ) & PPPMUX_FLAGS_MASK;
if ( flags & PPPMUX_LXT_BIT_SET )
length = tvb_get_ntohs ( tvb , offset ) & 0x3fff;
length_field = 2;
length = tvb_get_guint8 ( tvb , offset ) & 0x3f;
length_field = 1;
if ( flags & PPPMUX_PFF_BIT_SET )
byte = tvb_get_guint8 ( tvb , offset + length_field );
if ( byte & PFC_BIT )
pid_field = 1;
pid_field = 2;
pid_field = 0;
hdr_length = length_field + pid_field;
ti = proto_tree_add_text ( mux_tree , tvb , offset , length + length_field , "PPPMux Sub-frame" );
sub_tree = proto_item_add_subtree ( ti , ett_pppmux_subframe );
sub_ti = proto_tree_add_text ( sub_tree , tvb , offset , hdr_length , "Header field" );
hdr_tree = proto_item_add_subtree ( sub_ti , ett_pppmux_subframe_hdr );
ti = proto_tree_add_text ( hdr_tree , tvb , offset , length_field , "PFF/LXT: 0x%02X" , flags );
flag_tree = proto_item_add_subtree ( ti , ett_pppmux_subframe_flags );
proto_tree_add_text ( flag_tree , tvb , offset , length_field , "%s" , decode_boolean_bitfield ( flags , 0x80 , 8 , "PID Present" , "PID not present" ) );
proto_tree_add_text ( flag_tree , tvb , offset , length_field , "%s" , decode_boolean_bitfield ( flags , 0x40 , 8 , "2 bytes length field " , "1 byte length field" ) );
proto_tree_add_text ( hdr_tree , tvb , offset , length_field , "Sub-frame Length = %u" , length );
ti = proto_tree_add_uint ( hdr_tree , hf_pppmux_protocol , tvb , offset + length_field , pid_field , pid );
PROTO_ITEM_SET_GENERATED ( ti );
offset += hdr_length;
length_remaining -= hdr_length;
length -= pid_field;
sub_ti = proto_tree_add_text ( sub_tree , tvb , offset , length , "Information Field" );
info_tree = proto_item_add_subtree ( sub_ti , ett_pppmux_subframe_info );
if ( ! dissector_try_uint ( ppp_subdissector_table , pid , next_tvb , pinfo , info_tree ) )
call_dissector ( data_handle , next_tvb , pinfo , info_tree );
offset += length;
length_remaining -= length;
0
------------------------------
17397 CVE-2011-3191/CVE_2011_3191_VULN_CIFSFindNext.c response_data = ( char * ) & pSMBr -> hdr . Protocol + le16_to_cpu ( pSMBr -> t2 . DataOffset ) 91
int CVE_2011_3191_VULN_CIFSFindNext(const int xid, struct cifsTconInfo
__u16 searchHandle, struct cifs_search_info *psrch_inf)
TRANSACTION2_FNEXT_REQ * pSMB = NULL ;
TRANSACTION2_FNEXT_RSP * pSMBr = NULL ;
char * response_data ;
int bytes_returned , name_len ;
__u16 params , byte_count ;
if ( psrch_inf -> endOfSearch )
rc = smb_init ( SMB_COM_TRANSACTION2 , 15 , tcon , ( void * * ) & pSMB , ( void * * ) & pSMBr );
if ( rc )
params = 14;
byte_count = 0;
pSMB -> TotalDataCount = 0;
pSMB -> MaxParameterCount = cpu_to_le16 ( 8 );
pSMB -> MaxDataCount = cpu_to_le16 ( ( tcon -> ses -> server -> maxBuf - MAX_CIFS_HDR_SIZE ) & 0xFFFFFF00 );
pSMB -> MaxSetupCount = 0;
pSMB -> Reserved = 0;
pSMB -> Flags = 0;
pSMB -> Timeout = 0;
pSMB -> Reserved2 = 0;
pSMB -> ParameterOffset = cpu_to_le16
offsetof ( struct smb_com_transaction2_fnext_req , SearchHandle ) - 4 )
pSMB -> DataCount = 0;
pSMB -> DataOffset = 0;
pSMB -> SetupCount = 1;
pSMB -> Reserved3 = 0;
pSMB -> SubCommand = cpu_to_le16 ( TRANS2_FIND_NEXT );
pSMB -> SearchHandle = searchHandle;
pSMB -> SearchCount = cpu_to_le16 ( CIFSMaxBufSize / sizeof ( FILE_UNIX_INFO ) );
pSMB -> InformationLevel = cpu_to_le16 ( psrch_inf -> info_level );
pSMB -> ResumeKey = psrch_inf -> resume_key;
pSMB -> SearchFlags = cpu_to_le16 ( CIFS_SEARCH_CLOSE_AT_END | CIFS_SEARCH_RETURN_RESUME );
name_len = psrch_inf -> resume_name_len;
params += name_len;
if ( name_len < PATH_MAX )
memcpy ( pSMB -> ResumeFileName , psrch_inf -> presume_name , name_len );
byte_count += name_len;
pSMB -> ResumeFileName [ name_len ] = 0;
pSMB -> ResumeFileName [ name_len + 1 ] = 0;
byte_count = params + 1;
pSMB -> TotalParameterCount = cpu_to_le16 ( params );
pSMB -> ParameterCount = pSMB -> TotalParameterCount;
pSMB -> hdr . smb_buf_length += byte_count;
pSMB -> ByteCount = cpu_to_le16 ( byte_count );
rc = SendReceive ( xid , tcon -> ses , ( struct smb_hdr * ) pSMB , ( struct smb_hdr * ) pSMBr , & bytes_returned , 0 );
if ( rc )
rc = validate_t2 ( ( struct smb_t2_rsp * ) pSMBr );
if ( rc == 0 )
response_data = ( char * ) & pSMBr -> hdr . Protocol + le16_to_cpu ( pSMBr -> t2 . DataOffset );
0
------------------------------
308649 110837/CWE680_Integer_Overflow_to_Buffer_Overflow__new_listen_socket_82_goodG2B.cpp dataBytes = data * sizeof ( int ) 30
static void goodG2B()
int data ;
data = - 1;
data = 20;
CWE680_Integer_Overflow_to_Buffer_Overflow__new_listen_socket_82_base * baseObject = new CWE680_Integer_Overflow_to_Buffer_Overflow__new_listen_socket_82_goodG2B
baseObject -> action ( data );
void CWE680_Integer_Overflow_to_Buffer_Overflow__new_listen_socket_82_goodG2B::action(int data)
size_t dataBytes , i ;
dataBytes = data * sizeof ( int );
intPointer = ( int * ) new char [ dataBytes ];
intPointer [ i ] = 0;
printIntLine ( intPointer [ 0 ] );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
delete [ ] intPointer
0
------------------------------
312154 153760/aviobuf.c buffer_size = ( s -> buf_end - s -> buffer ) 968
int ffio_rewind_with_probe_data(AVIOContext *s,unsigned char **bufp,int buf_size)
int buffer_size ;
if ( s -> write_flag )
buffer_size = ( s -> buf_end - s -> buffer );
if ( ( buffer_start = s -> pos - buffer_size ) > buf_size )
overlap = ( buf_size - buffer_start );
new_size = buf_size + buffer_size - overlap;
alloc_size = ( s -> buffer_size > new_size ? s -> buffer_size : new_size );
if ( alloc_size > buf_size )
if ( ! ( buf = * bufp = ( av_realloc_f ( buf , 1 , alloc_size ) ) ) )
if ( new_size > buf_size )
memcpy ( ( buf + buf_size ) , ( s -> buffer + overlap ) , ( buffer_size - overlap ) );
buf_size = new_size;
s -> buf_ptr = s -> buffer = buf;
s -> buffer_size = alloc_size;
s -> pos = buf_size;
s -> buf_end = s -> buf_ptr + buf_size;
s -> eof_reached = 0;
s -> must_flush = 0;
0
------------------------------
16888 CVE-2010-0307/CVE_2010_0307_PATCHED_load_elf_binary.c nbyte = elf_brk - elf_bss 211
static int CVE_2010_0307_PATCHED_load_elf_binary(struct linux_binprm *bprm, struct pt_regs *regs)
unsigned long load_addr = 0 , load_bias = 0 ;
int load_addr_set = 0 ;
char * elf_interpreter = NULL ;
unsigned long error ;
struct elf_phdr * elf_ppnt , * elf_phdata ;
unsigned long elf_bss , elf_brk ;
int retval , i ;
unsigned int size ;
int executable_stack = EXSTACK_DEFAULT ;
struct { struct elfhdr elf_ex ; struct elfhdr interp_elf_ex ; } * loc ;
loc = kmalloc ( sizeof ( * loc ) , GFP_KERNEL );
if ( ! loc )
loc -> elf_ex = * ( ( struct elfhdr * ) bprm -> buf );
if ( memcmp ( loc -> elf_ex . e_ident , ELFMAG , SELFMAG ) != 0 )
if ( loc -> elf_ex . e_type != ET_EXEC && loc -> elf_ex . e_type != ET_DYN )
if ( ! elf_check_arch ( & loc -> elf_ex ) )
if ( ! bprm -> file -> f_op || ! bprm -> file -> f_op -> mmap )
if ( loc -> elf_ex . e_phentsize != sizeof ( struct elf_phdr ) )
if ( loc -> elf_ex . e_phnum < 1 || loc -> elf_ex . e_phnum > 65536U / sizeof ( struct elf_phdr ) )
size = loc -> elf_ex . e_phnum * sizeof ( struct elf_phdr );
retval = - ENOMEM;
elf_phdata = kmalloc ( size , GFP_KERNEL );
if ( ! elf_phdata )
retval = kernel_read ( bprm -> file , loc -> elf_ex . e_phoff , ( char * ) elf_phdata , size );
if ( retval != size )
elf_ppnt = elf_phdata;
elf_bss = 0;
elf_brk = 0;
for (i = 0; i < loc->elf_ex.e_phnum; i++)
if ( elf_ppnt -> p_type == PT_INTERP )
retval = - ENOEXEC;
if ( elf_ppnt -> p_filesz > PATH_MAX || elf_ppnt -> p_filesz < 2 )
retval = - ENOMEM;
elf_interpreter = kmalloc ( elf_ppnt -> p_filesz , GFP_KERNEL );
if ( ! elf_interpreter )
retval = kernel_read ( bprm -> file , elf_ppnt -> p_offset , elf_interpreter , elf_ppnt -> p_filesz );
if ( retval != elf_ppnt -> p_filesz )
retval = - ENOEXEC;
if ( elf_interpreter [ elf_ppnt -> p_filesz - 1 ] != '\0' )
interpreter = open_exec ( elf_interpreter );
retval = PTR_ERR ( interpreter );
if ( IS_ERR ( interpreter ) )
if ( file_permission ( interpreter , MAY_READ ) < 0 )
bprm -> interp_flags |= BINPRM_FLAGS_ENFORCE_NONDUMP;
retval = kernel_read ( interpreter , 0 , bprm -> buf , BINPRM_BUF_SIZE );
if ( retval != BINPRM_BUF_SIZE )
loc -> interp_elf_ex = * ( ( struct elfhdr * ) bprm -> buf );
elf_ppnt ++;
elf_ppnt = elf_phdata;
for (i = 0; i < loc->elf_ex.e_phnum; i++, elf_ppnt++)
if ( elf_ppnt -> p_type == PT_GNU_STACK )
if ( elf_ppnt -> p_flags & PF_X )
executable_stack = EXSTACK_ENABLE_X;
executable_stack = EXSTACK_DISABLE_X;
if ( elf_interpreter )
retval = - ELIBBAD;
if ( memcmp ( loc -> interp_elf_ex . e_ident , ELFMAG , SELFMAG ) != 0 )
if ( ! elf_check_arch ( & loc -> interp_elf_ex ) )
retval = flush_old_exec ( bprm );
if ( retval )
retval = setup_arg_pages ( bprm , randomize_stack_top ( STACK_TOP ) , executable_stack );
if ( retval < 0 )
for(i = 0, elf_ppnt =
i < loc->elf_ex.e_phnum; i++, elf_ppnt++)
int elf_prot = 0 , elf_flags ;
unsigned long k , vaddr ;
if ( elf_ppnt -> p_type != PT_LOAD )
if ( unlikely ( elf_brk > elf_bss ) )
unsigned long nbyte ;
retval = set_brk ( elf_bss + load_bias , elf_brk + load_bias );
if ( retval )
nbyte = ELF_PAGEOFFSET ( elf_bss );
if ( nbyte )
nbyte = ELF_MIN_ALIGN - nbyte;
if ( nbyte > elf_brk - elf_bss )
nbyte = elf_brk - elf_bss;
if ( elf_ppnt -> p_flags & PF_R )
elf_prot |= PROT_READ;
if ( elf_ppnt -> p_flags & PF_W )
elf_prot |= PROT_WRITE;
if ( elf_ppnt -> p_flags & PF_X )
elf_prot |= PROT_EXEC;
elf_flags = MAP_PRIVATE | MAP_DENYWRITE | MAP_EXECUTABLE;
vaddr = elf_ppnt -> p_vaddr;
if ( loc -> elf_ex . e_type == ET_EXEC || load_addr_set )
elf_flags |= MAP_FIXED;
if ( loc -> elf_ex . e_type == ET_DYN )
load_bias = 0;
error = elf_map ( bprm -> file , load_bias + vaddr , elf_ppnt , elf_prot , elf_flags , 0 );
if ( BAD_ADDR ( error ) )
if ( ! load_addr_set )
load_addr_set = 1;
if ( loc -> elf_ex . e_type == ET_DYN )
load_bias += error - ELF_PAGESTART ( load_bias + vaddr );
k = elf_ppnt -> p_vaddr;
if ( BAD_ADDR ( k ) || elf_ppnt -> p_filesz > elf_ppnt -> p_memsz || elf_ppnt -> p_memsz > TASK_SIZE || TASK_SIZE - elf_ppnt -> p_memsz < k )
k = elf_ppnt -> p_vaddr + elf_ppnt -> p_filesz;
if ( k > elf_bss )
elf_bss = k;
k = elf_ppnt -> p_vaddr + elf_ppnt -> p_memsz;
if ( k > elf_brk )
elf_brk = k;
0
------------------------------
298106 95288/CWE369_Divide_by_Zero__int_listen_socket_divide_66b.c printIntLine ( 100 / data ) 49
void CWE369_Divide_by_Zero__int_listen_socket_divide_66_bad()
int data ;
int dataArray [ 5 ] ;
data = - 1;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
char inputBuffer [ CHAR_ARRAY_SIZE ] ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
inputBuffer [ recvResult ] = '\0';
data = atoi ( inputBuffer );
while ( 0 )
dataArray [ 2 ] = data;
CWE369_Divide_by_Zero__int_listen_socket_divide_66b_badSink ( dataArray );
void CWE369_Divide_by_Zero__int_listen_socket_divide_66b_badSink(int dataArray[])
int data = dataArray [ 2 ] ;
printIntLine ( 100 / data );
1
------------------------------
302844 84376/CWE190_Integer_Overflow__unsigned_int_fscanf_square_11.c unsigned int result = data * data ; 37
void CWE190_Integer_Overflow__unsigned_int_fscanf_square_11_bad()
unsigned int data ;
data = 0;
if ( globalReturnsTrue ( ) )
int globalReturnsTrue()
return 1 ;
unsigned int result = data * data ;
printUnsignedLine ( result );
void printUnsignedLine(unsigned unsignedNumber)
printf ( "%u\n" , unsignedNumber );
1
------------------------------
20437 CVE-2016-4805/linux_kernel_4.2.5_CVE_2016_4805_drivers_net_ppp_ppp_generic.c new_skb = alloc_skb ( skb -> len + ppp -> dev -> hard_header_len - 2 , GFP_ATOMIC ) 1270
static ssize_t ppp_write(struct file *file, const char __user
size_t count, loff_t *ppos)
struct ppp_file * pf = file -> private_data ;
struct sk_buff * skb ;
if ( ! pf )
skb = alloc_skb ( count + pf -> hdrlen , GFP_KERNEL );
if ( ! skb )
if ( copy_from_user ( skb_put ( skb , count ) , buf , count ) )
switch ( pf -> kind )
ppp_channel_push ( PF_TO_CHANNEL ( pf ) );
static
ppp_channel_push(struct channel *pch)
struct ppp * ppp ;
if ( skb_queue_empty ( & pch -> file . xq ) )
ppp = pch -> ppp;
if ( ppp )
ppp_xmit_process ( ppp );
static
ppp_xmit_process(struct ppp *ppp)
struct sk_buff * skb ;
if ( ! ppp -> closing )
while ( ! ppp -> xmit_pending && ( skb = skb_dequeue ( & ppp -> file . xq ) ) )
ppp_send_frame ( ppp , skb );
static
ppp_send_frame(struct ppp *ppp, struct sk_buff *skb)
int proto = PPP_PROTO ( skb ) ;
struct sk_buff * new_skb ;
if ( proto < 0x8000 )
if ( ppp -> pass_filter && BPF_PROG_RUN ( ppp -> pass_filter , skb ) == 0 )
if ( ! ( ppp -> active_filter && BPF_PROG_RUN ( ppp -> active_filter , skb ) == 0 ) )
ppp -> last_xmit = jiffies;
ppp -> stats64 . tx_bytes += skb -> len - 2;
switch ( proto )
if ( ! ppp -> vj || ( ppp -> flags & SC_COMP_TCP ) == 0 )
new_skb = alloc_skb ( skb -> len + ppp -> dev -> hard_header_len - 2 , GFP_ATOMIC );
if ( ! new_skb )
skb_reserve ( new_skb , ppp -> dev -> hard_header_len - 2 );
len = slhc_compress ( ppp -> vj , cp , skb -> len - 2 , new_skb -> data + 2 , & cp , ! ( ppp -> flags & SC_NO_TCP_CCID ) );
consume_skb ( new_skb );
skb = new_skb;
cp = skb_put ( skb , len + 2 );
cp [ 0 ] = 0;
cp [ 1 ] = proto;
skb = pad_compress_skb ( ppp , skb );
if ( ! skb )
skb_queue_tail ( & ppp -> file . rq , skb );
ppp -> xmit_pending = skb;
ppp_push ( ppp );
kfree_skb ( skb );
++ ppp -> dev -> stats . tx_errors;
0
------------------------------
311909 153171/dfa.c const char * lim = p + lexleft ; 1641
static token lex()
unsigned int c ;
int backslash = 0 ;
int i ;
for (i = 0; i < 2; ++i)
if ( __ctype_get_mb_cur_max ( ) > 1 )
if ( ! lexleft )
if ( ( ( void * ) 0 ) != 0 )
wchar_t _wc ;
cur_mb_len = ( mbrtowc ( & _wc , lexptr , lexleft , & mbs ) );
if ( cur_mb_len <= 0 )
wctok = ( c = ( to_uchar ( * ( lexptr ++ ) ) ) );
inline static unsigned char to_uchar(char ch)
return ch ;
lexptr += cur_mb_len;
lexleft -= cur_mb_len;
wctok = _wc;
c = ( wctob ( wctok ) );
while ( 0 )
if ( ( ( int ) c ) == - 1 )
wint_t wc ;
if ( ! lexleft )
if ( ( ( void * ) 0 ) != 0 )
wchar_t _wc ;
cur_mb_len = ( mbrtowc ( & _wc , lexptr , lexleft , & mbs ) );
if ( cur_mb_len <= 0 )
wc = c = ( to_uchar ( * ( lexptr ++ ) ) );
inline static unsigned char to_uchar(char ch)
return ch ;
lexptr += cur_mb_len;
lexleft -= cur_mb_len;
wc = _wc;
c = ( wctob ( wc ) );
while ( 0 )
while ( 0 )
switch ( c )
if ( backslash )
backslash = 1;
if ( ! ( syntax_bits & ( ( unsigned long ) 1 ) << 1 << 1 << 1 << 1 << 1 << 1 << 1 << 1 << 1 ) )
if ( backslash != ( ( syntax_bits & ( ( unsigned long ) 1 ) << 1 << 1 << 1 << 1 << 1 << 1 << 1 << 1 << 1 << 1 << 1 << 1 ) == 0 ) )
if ( ! ( syntax_bits & ( ( unsigned long ) 1 ) << 1 << 1 << 1 << 1 ) && laststart )
const char * p = lexptr ;
const char * lim = p + lexleft ;
for (; p != lim && ((unsigned int )( *p)) - 48 <= 9; p++)
if ( p != lim )
while ( ++ p != lim && ( ( unsigned int ) ( * p ) ) - 48 <= 9 )
if ( ! ( ( ! backslash || p != lim && ( * ( p ++ ) ) == '\\' ) && p != lim && ( * ( p ++ ) ) == '}' && 0 <= minrep && ( maxrep < 0 || minrep <= maxrep ) ) )
lexptr = p;
lexleft = ( lim - p );
0
------------------------------
299241 152349/heapam.c rdata [ 2 ] . len = ( ndead * sizeof ( OffsetNumber ) ) 3886
XLogRecPtr log_heap_clean(Relation reln,Buffer buffer,OffsetNumber *redirected,int nredirected,OffsetNumber *nowdead,int ndead,OffsetNumber *nowunused,int nunused,TransactionId latestRemovedXid)
xl_heap_clean xlrec ;
XLogRecData rdata [ 4 ] ;
xlrec . node = reln -> rd_node;
xlrec . block = BufferGetBlockNumber ( buffer );
xlrec . latestRemovedXid = latestRemovedXid;
xlrec . nredirected = nredirected;
xlrec . ndead = ndead;
rdata [ 0 ] . data = ( ( char * ) ( & xlrec ) );
rdata [ 0 ] . len = ( ( ( size_t ) ( & ( ( xl_heap_clean * ) 0 ) -> ndead ) ) + sizeof ( uint16 ) );
rdata [ 0 ] . buffer = 0;
rdata [ 0 ] . next = & rdata [ 1 ];
if ( nredirected > 0 )
rdata [ 1 ] . data = ( ( char * ) redirected );
rdata [ 1 ] . len = ( nredirected * sizeof ( OffsetNumber ) * 2 );
rdata [ 1 ] . data = ( ( void * ) 0 );
rdata [ 1 ] . len = 0;
rdata [ 1 ] . buffer = buffer;
rdata [ 1 ] . buffer_std = ( ( bool ) 1 );
rdata [ 1 ] . next = & rdata [ 2 ];
if ( ndead > 0 )
rdata [ 2 ] . data = ( ( char * ) nowdead );
rdata [ 2 ] . len = ( ndead * sizeof ( OffsetNumber ) );
rdata [ 2 ] . buffer = buffer;
rdata [ 2 ] . buffer_std = ( ( bool ) 1 );
rdata [ 2 ] . next = & rdata [ 3 ];
rdata [ 3 ] . data = ( ( char * ) nowunused );
rdata [ 3 ] . len = ( nunused * sizeof ( OffsetNumber ) );
rdata [ 3 ] . data = ( ( void * ) 0 );
rdata [ 3 ] . len = 0;
rdata [ 3 ] . buffer = buffer;
rdata [ 3 ] . buffer_std = ( ( bool ) 1 );
rdata [ 3 ] . next = ( ( void * ) 0 );
recptr = XLogInsert ( 9 , info , rdata );
return recptr ;
0
------------------------------
306997 117011/CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_45.c myString = ( char * ) malloc ( data * sizeof ( char ) ) 64
static void badSink()
size_t data = CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_45_badData ;
char * myString ;
if ( data > strlen ( HELLO_STRING ) )
myString = ( char * ) malloc ( data * sizeof ( char ) );
strcpy ( myString , HELLO_STRING );
printLine ( myString );
void printLine (const char * line)
if ( line != NULL )
printf ( "%s\n" , line );
free ( myString );
1
------------------------------
308561 118196/CWE78_OS_Command_Injection__char_connect_socket_w32_execvp_14.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 104
void CWE78_OS_Command_Injection__char_connect_socket_w32_execvp_14_bad()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
if ( globalFive == 5 )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
0
------------------------------
306776 120400/CWE78_OS_Command_Injection__wchar_t_connect_socket_execlp_10.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 ) 108
void CWE78_OS_Command_Injection__wchar_t_connect_socket_execlp_10_bad()
wchar_t * data ;
wchar_t dataBuffer [ 100 ] = L ""
data = dataBuffer;
if ( globalTrue )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
303709 82810/CWE190_Integer_Overflow__int64_t_max_square_45.c int64_t result = data * data ; 80
static void goodB2GSink()
int64_t data = CWE190_Integer_Overflow__int64_t_max_square_45_goodB2GData ;
if ( abs ( ( long ) data ) <= ( long ) sqrt ( ( double ) LLONG_MAX ) )
int64_t result = data * data ;
printLongLongLine ( result );
void printLongLongLine (int64_t longLongIntNumber)
printf ( "%lld\n" , longLongIntNumber );
0
------------------------------
309084 120746/CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_spawnvp_22b.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 ) 101
void CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_spawnvp_22_bad()
wchar_t * data ;
wchar_t dataBuffer [ 100 ] = L ""
data = dataBuffer;
data = CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_spawnvp_22_badSource ( data );
wchar_t * CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_spawnvp_22_badSource(wchar_t * data)
if ( CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_spawnvp_22_badGlobal )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
312341 151947/tile-manager.c const guchar * s = buffer + stride * ( y - y1 ) + ( tm -> bpp ) * ( x - x1 ) ; 839
void tile_manager_write_pixel_data(TileManager *tm,gint x1,gint y1,gint x2,gint y2,const guchar *buffer,guint stride)
guint x ;
guint y ;
for (y = y1; y <= y2; y += 64 - y % 64)
for (x = x1; x <= x2; x += 64 - x % 64)
const guchar * s = buffer + stride * ( y - y1 ) + ( tm -> bpp ) * ( x - x1 ) ;
memcpy ( d , s , ( cols * ( tm -> bpp ) ) );
s += stride;
d += dststride;
0
------------------------------
307108 110446/CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fixed_66b.c intPointer = ( int * ) malloc ( data * sizeof ( int ) ) 30
void CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fixed_66_bad()
int data ;
int dataArray [ 5 ] ;
data = - 1;
data = INT_MAX / 2 + 2;
dataArray [ 2 ] = data;
CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fixed_66b_badSink ( dataArray );
void CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fixed_66b_badSink(int dataArray[])
int data = dataArray [ 2 ] ;
int * intPointer ;
intPointer = ( int * ) malloc ( data * sizeof ( int ) );
intPointer [ i ] = 0;
printIntLine ( intPointer [ 0 ] );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
free ( intPointer );
1
------------------------------
304721 80306/CWE134_Uncontrolled_Format_String__char_listen_socket_printf_09.c recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 297
static void goodB2G2()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
if ( GLOBAL_CONST_TRUE )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
printf ( "%s\n" , data );
0
------------------------------
306991 117013/CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_52c.c myString = ( char * ) malloc ( data * sizeof ( char ) ) 59
void CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_52_bad()
size_t data ;
data = 0;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
char inputBuffer [ CHAR_ARRAY_SIZE ] ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
inputBuffer [ recvResult ] = '\0';
data = strtoul ( inputBuffer , NULL , 0 );
while ( 0 )
CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_52b_badSink ( data );
void CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_52b_badSink(size_t data)
CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_52c_badSink ( data );
void CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_52c_badSink(size_t data)
char * myString ;
if ( data > strlen ( HELLO_STRING ) )
myString = ( char * ) malloc ( data * sizeof ( char ) );
strcpy ( myString , HELLO_STRING );
printLine ( myString );
void printLine (const char * line)
if ( line != NULL )
printf ( "%s\n" , line );
free ( myString );
1
------------------------------
303550 80411/CWE134_Uncontrolled_Format_String__char_listen_socket_vfprintf_18.c recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 110
void CWE134_Uncontrolled_Format_String__char_listen_socket_vfprintf_18_bad()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
badVaSinkB ( data , data );
static void badVaSinkB(char * data, ...)
va_start ( args , data );
vfprintf ( stdout , data , args );
1
------------------------------
310889 151097/aviobuf.c uint8_t * dst = ! s -> max_packet_size && s -> buf_end - s -> buffer < ( s -> buffer_size ) ? s -> buf_end : s -> buffer ; 442
unsigned int avio_rl24(AVIOContext *s)
unsigned int val ;
val = avio_rl16 ( s );
val |= ( avio_r8 ( s ) << 16 );
int avio_r8(AVIOContext *s)
if ( s -> buf_ptr >= s -> buf_end )
fill_buffer ( s );
static void fill_buffer(AVIOContext *s)
uint8_t * dst = ! s -> max_packet_size && s -> buf_end - s -> buffer < ( s -> buffer_size ) ? s -> buf_end : s -> buffer ;
int len = ( ( s -> buffer_size ) - ( dst - s -> buffer ) ) ;
if ( s -> update_checksum && dst == s -> buffer )
len = ( ( s -> read_packet ) ( s -> opaque , dst , len ) );
if ( len <= 0 )
if ( len < 0 )
s -> error = len;
s -> pos += len;
s -> buf_ptr = dst;
s -> buf_end = dst + len;
s -> bytes_read += len;
0
------------------------------
314264 110403/CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fgets_74b.cpp intPointer = ( int * ) malloc ( data * sizeof ( int ) ) 36
void bad()
int data ;
map < int , int > dataMap ;
data = - 1;
char inputBuffer [ CHAR_ARRAY_SIZE ] = "" ;
if ( fgets ( inputBuffer , CHAR_ARRAY_SIZE , stdin ) != NULL )
data = atoi ( inputBuffer );
dataMap [ 0 ] = data;
dataMap [ 1 ] = data;
dataMap [ 2 ] = data;
badSink ( dataMap );
void badSink(map<int, int> dataMap)
int data = dataMap [ 2 ] ;
int * intPointer ;
intPointer = ( int * ) malloc ( data * sizeof ( int ) );
intPointer [ i ] = 0;
printIntLine ( intPointer [ 0 ] );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
free ( intPointer );
1
------------------------------
303475 82378/CWE190_Integer_Overflow__char_max_square_45.c char result = data * data ; 33
static void badSink()
char data = CWE190_Integer_Overflow__char_max_square_45_badData ;
char result = data * data ;
printHexCharLine ( result );
void printHexCharLine (char charHex)
printf ( "%02x\n" , charHex );
1
------------------------------
312850 89588/CWE23_Relative_Path_Traversal__char_connect_socket_fopen_09.cpp recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ) 101
void bad()
char * data ;
char dataBuffer [ FILENAME_MAX ] = BASEPATH ;
data = dataBuffer;
if ( GLOBAL_CONST_TRUE )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
pFile = FOPEN ( data , "wb+" );
if ( pFile != NULL )
fclose ( pFile );
1
------------------------------
300224 149405/aviobuf.c s -> buf_end = dst + len 491
int avio_get_str(AVIOContext *s,int maxlen,char *buf,int buflen)
int i ;
if ( buflen <= 0 )
buflen = ( buflen - 1 > maxlen ? maxlen : buflen - 1 );
for (i = 0; i < buflen; i++)
if ( ! ( buf [ i ] = ( avio_r8 ( s ) ) ) )
int avio_r8(AVIOContext *s)
if ( s -> buf_ptr >= s -> buf_end )
fill_buffer ( s );
static void fill_buffer(AVIOContext *s)
uint8_t * dst = ! s -> max_packet_size && s -> buf_end - s -> buffer < ( s -> buffer_size ) ? s -> buf_end : s -> buffer ;
int len = ( ( s -> buffer_size ) - ( dst - s -> buffer ) ) ;
int max_buffer_size = s -> max_packet_size ? s -> max_packet_size : 32768 ;
if ( ! s -> read_packet && s -> buf_ptr >= s -> buf_end )
s -> eof_reached = 1;
if ( s -> eof_reached )
if ( s -> update_checksum && dst == s -> buffer )
if ( s -> buf_end > s -> checksum_ptr )
s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_end - s -> checksum_ptr ) ) );
s -> checksum_ptr = s -> buffer;
if ( s -> read_packet && s -> buffer_size > max_buffer_size )
s -> checksum_ptr = dst = s -> buffer;
len = s -> buffer_size;
if ( s -> read_packet )
len = ( ( s -> read_packet ) ( s -> opaque , dst , len ) );
len = 0;
if ( len <= 0 )
s -> eof_reached = 1;
if ( len < 0 )
s -> error = len;
s -> pos += len;
s -> buf_ptr = dst;
s -> buf_end = dst + len;
s -> bytes_read += len;
0
------------------------------
16681 CVE-2014-5471/CVE_2014_5471_PATCHED_isofs_read_inode.c int frag1 = bufsize - offset ; 27
static int CVE_2014_5471_PATCHED_isofs_read_inode(struct inode *inode, int relocated)
unsigned long bufsize = ISOFS_BUFFER_SIZE ( inode ) ;
unsigned long block ;
struct iso_directory_record * de ;
unsigned int de_len ;
unsigned long offset ;
struct iso_inode_info * ei = ISOFS_I ( inode ) ;
block = ei -> i_iget5_block;
bh = sb_bread ( inode -> i_sb , block );
if ( ! bh )
offset = ei -> i_iget5_offset;
de = ( struct iso_directory_record * ) ( bh -> b_data + offset );
de_len = * ( unsigned char * ) de;
if ( offset + de_len > bufsize )
int frag1 = bufsize - offset ;
0
------------------------------
305939 109995/CWE666_Operation_on_Resource_in_Wrong_Phase_of_Lifetime__bind_accept_listen_15.c recvResult = recv ( acceptSocket , ( char * ) data + dataLen , ( int ) ( 100 - dataLen - 1 ) , 0 ) 94
void CWE666_Operation_on_Resource_in_Wrong_Phase_of_Lifetime__bind_accept_listen_15_bad()
switch ( 6 )
char data [ 100 ] = "" ;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) data + dataLen , ( int ) ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ recvResult ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
printLine ( data );
void printLine (const char * line)
if ( line != NULL )
printf ( "%s\n" , line );
1
------------------------------
307104 117227/CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_connect_socket_05.c myString = ( wchar_t * ) malloc ( data * sizeof ( wchar_t ) ) 226
static void goodB2G1()
size_t data ;
data = 0;
if ( staticTrue )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
char inputBuffer [ CHAR_ARRAY_SIZE ] ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
inputBuffer [ recvResult ] = '\0';
data = strtoul ( inputBuffer , NULL , 0 );
while ( 0 )
if ( staticFalse )
wchar_t * myString ;
if ( data > wcslen ( HELLO_STRING ) && data < 100 )
myString = ( wchar_t * ) malloc ( data * sizeof ( wchar_t ) );
wcscpy ( myString , HELLO_STRING );
printWLine ( myString );
void printWLine (const wchar_t * line)
if ( line != NULL )
wprintf ( L "%ls\n" , line )
free ( myString );
0
------------------------------
304385 82208/CWE190_Integer_Overflow__char_fscanf_square_03.c char result = data * data ; 121
static void goodG2B1()
char data ;
data = ' ';
if ( 5 != 5 )
data = 2;
if ( 5 == 5 )
char result = data * data ;
printHexCharLine ( result );
void printHexCharLine (char charHex)
printf ( "%02x\n" , charHex );
0
------------------------------
308181 120076/CWE78_OS_Command_Injection__char_listen_socket_w32_execv_32.c recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 114
void CWE78_OS_Command_Injection__char_listen_socket_w32_execv_32_bad()
char * data ;
char * * dataPtr1 = & data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
char * data = * dataPtr1 ;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
* dataPtr1 = data;
0
------------------------------
307219 110405/CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fgets_82_goodG2B.cpp intPointer = ( int * ) malloc ( data * sizeof ( int ) ) 31
static void goodG2B()
int data ;
data = - 1;
data = 20;
CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fgets_82_base * baseObject = new CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fgets_82_goodG2B
baseObject -> action ( data );
void CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fgets_82_goodG2B::action(int data)
int * intPointer ;
intPointer = ( int * ) malloc ( data * sizeof ( int ) );
intPointer [ i ] = 0;
printIntLine ( intPointer [ 0 ] );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
free ( intPointer );
0
------------------------------
306574 104469/CWE469_Use_of_Pointer_Subtraction_to_Determine_Size__char_10.c indexOfSlashInString1 = ( size_t ) ( slashInString1 - string1 ) 70
static void good1()
if ( globalFalse )
char string1 [ ] = SOURCE_STRING ;
char * slashInString1 ;
size_t indexOfSlashInString1 ;
slashInString1 = strchr ( string1 , '/' );
indexOfSlashInString1 = ( size_t ) ( slashInString1 - string1 );
printUnsignedLine ( indexOfSlashInString1 );
void printUnsignedLine(unsigned unsignedNumber)
printf ( "%u\n" , unsignedNumber );
0
------------------------------
298610 95361/CWE369_Divide_by_Zero__int_rand_divide_16.c printIntLine ( 100 / data ) 62
static void goodB2G()
int data ;
data = - 1;
while ( 1 )
data = RAND32 ( );
while ( 1 )
if ( data != 0 )
printIntLine ( 100 / data );
0
------------------------------
308240 117378/CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_listen_socket_12.c myString = ( wchar_t * ) malloc ( data * sizeof ( wchar_t ) ) 341
static void goodB2G()
size_t data ;
data = 0;
if ( globalReturnsTrueOrFalse ( ) )
int globalReturnsTrueOrFalse()
return ( rand ( ) % 2 ) ;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
char inputBuffer [ CHAR_ARRAY_SIZE ] ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
inputBuffer [ recvResult ] = '\0';
data = strtoul ( inputBuffer , NULL , 0 );
while ( 0 )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
char inputBuffer [ CHAR_ARRAY_SIZE ] ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
inputBuffer [ recvResult ] = '\0';
data = strtoul ( inputBuffer , NULL , 0 );
while ( 0 )
if ( globalReturnsTrueOrFalse ( ) )
int globalReturnsTrueOrFalse()
return ( rand ( ) % 2 ) ;
wchar_t * myString ;
if ( data > wcslen ( HELLO_STRING ) && data < 100 )
myString = ( wchar_t * ) malloc ( data * sizeof ( wchar_t ) );
wcscpy ( myString , HELLO_STRING );
printWLine ( myString );
void printWLine (const wchar_t * line)
if ( line != NULL )
wprintf ( L "%ls\n" , line )
free ( myString );
wcscpy ( myString , HELLO_STRING );
printWLine ( myString );
void printWLine (const wchar_t * line)
if ( line != NULL )
wprintf ( L "%ls\n" , line )
free ( myString );
0
------------------------------
307469 110440/CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fixed_54e.c intPointer = ( int * ) malloc ( data * sizeof ( int ) ) 30
void CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fixed_54b_badSink(int data)
CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fixed_54c_badSink ( data );
void CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fixed_54c_badSink(int data)
CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fixed_54d_badSink ( data );
void CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fixed_54d_badSink(int data)
CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fixed_54e_badSink ( data );
void CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fixed_54e_badSink(int data)
int * intPointer ;
intPointer = ( int * ) malloc ( data * sizeof ( int ) );
intPointer [ i ] = 0;
printIntLine ( intPointer [ 0 ] );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
free ( intPointer );
1
------------------------------
20186 CVE-2016-6508/wireshark_2.0.4_CVE_2016_6508_epan_dissectors_packet-rlc.c ret = a - b 512
static
dissect_rlc_um(enum rlc_channel_type channel, tvbuff_t *tvb, packet_info
proto_tree *top_level, proto_tree *tree)
struct rlc_li li [ MAX_LI ] ;
fp_info * fpinf ;
rlc_info * rlcinf ;
guint32 orig_num ;
guint8 seq ;
guint8 next_byte , offs = 0 ;
gboolean is_truncated , li_is_on_2_bytes ;
next_byte = tvb_get_guint8 ( tvb , offs ++ );
seq = next_byte >> 1;
fpinf = ( fp_info * ) p_get_proto_data ( wmem_file_scope ( ) , pinfo , proto_fp , 0 );
rlcinf = ( rlc_info * ) p_get_proto_data ( wmem_file_scope ( ) , pinfo , proto_rlc , 0 );
if ( ! fpinf || ! rlcinf )
pos = fpinf -> cur_tb;
if ( ( rlcinf -> ciphered [ pos ] == TRUE && rlcinf -> deciphered [ pos ] == FALSE ) || global_rlc_ciphered )
if ( global_rlc_try_decipher )
if ( global_rlc_li_size == RLC_LI_UPPERLAYER )
if ( rlcinf -> li_size [ pos ] == RLC_LI_VARIABLE )
li_is_on_2_bytes = ( tvb_reported_length ( tvb ) > 125 ) ? TRUE : FALSE;
li_is_on_2_bytes = ( rlcinf -> li_size [ pos ] == RLC_LI_15BITS ) ? TRUE : FALSE;
li_is_on_2_bytes = ( global_rlc_li_size == RLC_LI_15BITS ) ? TRUE : FALSE;
num_li = rlc_decode_li ( RLC_UM , tvb , pinfo , tree , li , MAX_LI , li_is_on_2_bytes );
if ( num_li == - 1 )
offs += ( ( li_is_on_2_bytes ) ? 2 : 1 ) * num_li;
if ( global_rlc_headers_expected )
is_truncated = ( tvb_captured_length_remaining ( tvb , offs ) == 0 );
if ( is_truncated )
if ( pinfo -> fd -> num == 0 )
if ( rlc_is_duplicate ( RLC_UM , pinfo , seq , & orig_num ) == TRUE )
rlc_um_reassemble ( tvb , offs , pinfo , tree , top_level , channel , seq , li , num_li , li_is_on_2_bytes );
static
rlc_um_reassemble(tvbuff_t *tvb, guint8 offs, packet_info *pinfo, proto_tree
proto_tree *top_level, enum rlc_channel_type channel, guint16
struct rlc_li *li, guint16 num_li, gboolean li_is_on_2_bytes)
guint8 i ;
gint length ;
for (i = 0; i < num_li; i++)
if ( ( ! li_is_on_2_bytes && ( li [ i ] . li == 0x7f ) ) || ( li [ i ] . li == 0x7fff ) )
offs += tvb_captured_length_remaining ( tvb , offs );
if ( ( ! li_is_on_2_bytes && ( li [ i ] . li == 0x7c ) ) || ( li [ i ] . li == 0x7ffc ) )
if ( li [ i ] . li == 0x7ffa )
length = tvb_reported_length_remaining ( tvb , offs );
if ( length > 1 )
length --;
offs += length;
offs += 1;
if ( global_rlc_perform_reassemby )
add_fragment ( RLC_UM , tvb , pinfo , li [ i ] . tree , offs , seq , i , li [ i ] . len , TRUE );
offs += li [ i ] . len;
static struct rlc_frag
add_fragment(enum rlc_mode mode, tvbuff_t *tvb, packet_info
proto_tree *tree, guint16 offset, guint16 seq, guint16
guint16 len, gboolean final)
struct rlc_channel ch_lookup ;
int snmod ;
if ( rlc_channel_assign ( & ch_lookup , mode , pinfo ) == - 1 )
snmod = getChannelSNModulus ( & ch_lookup );
if ( g_hash_table_lookup_extended ( reassembled_table , & frag_lookup , & orig_key , & value ) )
frags = get_frags ( pinfo , & ch_lookup );
endlist = get_endlist ( pinfo , & ch_lookup );
if ( pinfo -> fd -> flags . visited )
if ( tree && len > 0 )
if ( endlist -> list && endlist -> list -> next )
gint16 start = ( GPOINTER_TO_INT ( endlist -> list -> data ) + 1 ) % snmod ;
gint16 end = GPOINTER_TO_INT ( endlist -> list -> next -> data ) ;
gint16 missing = start ;
for (; moduloCompare(missing,end,snmod ) <= 0; missing = (missing+1)%snmod)
if ( frags [ missing ] == NULL )
static int moduloCompare(guint16 a, guint16 b, guint16 modulus)
int ret ;
a = a % modulus;
b = b % modulus;
if ( a <= b )
ret = a - b;
if ( ret == ( 1 - modulus ) )
return ret ;
0
------------------------------
299392 153249/dfa.c buf_end = ( ( unsigned char * ) ( begin + i ) ) 3527
char *dfaexec(struct dfa *d,const char *begin,char *end,int allow_nl,size_t *count,int *backref)
const unsigned char * p ;
unsigned char eol = eolbyte ;
p = ( ( const unsigned char * ) begin );
* end = eol;
if ( d -> mb_cur_max > 1 )
prepare_wc_buf ( ( ( const char * ) p ) , end );
static void prepare_wc_buf(const char *begin,const char *end)
unsigned char eol = eolbyte ;
size_t remain_bytes ;
size_t i ;
remain_bytes = 0;
for (i = 0; i < (end - begin + 1); i++)
if ( remain_bytes == 0 )
remain_bytes = mbrtowc ( inputwcs + i , begin + i , ( end - begin ) - i + 1 , & mbs );
if ( remain_bytes < 1 || remain_bytes == ( ( size_t ) ( - 1 ) ) || remain_bytes == ( ( size_t ) ( - 2 ) ) || remain_bytes == 1 && inputwcs [ i ] == ( ( wchar_t ) begin [ i ] ) )
remain_bytes = 0;
inputwcs [ i ] = ( ( wchar_t ) begin [ i ] );
mblen_buf [ i ] = 0;
if ( begin [ i ] == eol )
mblen_buf [ i ] = remain_bytes;
remain_bytes --;
mblen_buf [ i ] = remain_bytes;
inputwcs [ i ] = 0;
remain_bytes --;
buf_end = ( ( unsigned char * ) ( begin + i ) );
0
------------------------------
16979 CVE-2011-1147/CVE_2011_1147_VULN_udptl_rx_packet.c s -> f [ ifp_no ] . seqno = seq_no - i 69
static int CVE_2011_1147_VULN_udptl_rx_packet(struct ast_udptl *s, uint8_t *buf, int len)
int stat ;
int stat2 ;
int i ;
int ptr ;
int count ;
int total_count ;
int seq_no ;
const uint8_t * bufs [ 16 ] ;
int lengths [ 16 ] ;
int ifp_no ;
ptr = 0;
ifp_no = 0;
memset ( & s -> f [ 0 ] , 0 , sizeof ( s -> f [ 0 ] ) );
if ( ptr + 2 > len )
seq_no = ( buf [ 0 ] << 8 ) | buf [ 1 ];
ptr += 2;
if ( ( stat = decode_open_type ( buf , len , & ptr , & ifp , & ifp_len ) ) != 0 )
if ( ptr + 1 > len )
if ( ( buf [ ptr ++ ] & 0x80 ) == 0 )
if ( seq_no > s -> rx_seq_no )
total_count = 0;
if ( ( stat2 = decode_length ( buf , len , & ptr , & count ) ) < 0 )
for (i = 0; i < count; i++)
if ( ( stat = decode_open_type ( buf , len , & ptr , & bufs [ total_count + i ] , & lengths [ total_count + i ] ) ) != 0 )
total_count += count;
while ( stat2 > 0 )
for (i = total_count; i > 0; i--)
if ( seq_no - i >= s -> rx_seq_no )
s -> f [ ifp_no ] . frametype = AST_FRAME_MODEM;
s -> f [ ifp_no ] . subclass = AST_MODEM_T38;
s -> f [ ifp_no ] . mallocd = 0;
s -> f [ ifp_no ] . seqno = seq_no - i;
s -> f [ ifp_no ] . datalen = lengths [ i - 1 ];
s -> f [ ifp_no ] . data = ( uint8_t * ) bufs [ i - 1 ];
s -> f [ ifp_no ] . offset = 0;
s -> f [ ifp_no ] . src = "UDPTL";
ifp_no ++;
1
------------------------------
20932 CVE-2015-4521/Firefox_40.0b9_CVE_2015_4521_dom_base_nsGlobalWindow.cpp * aLeft = screenLeft + screenWidth - winWidth 5740

nsGlobalWindow::CheckSecurityLeftAndTop(int32_t* aLeft, int32_t* aTop)
if ( ! nsContentUtils :: IsCallerChrome ( ) )
nsCOMPtr < nsIBaseWindow > treeOwner = GetTreeOwnerWindow ( ) ;
nsCOMPtr < nsIDOMScreen > screen ;
if ( treeOwner && screen )
int32_t screenLeft , screenTop , screenWidth , screenHeight ;
int32_t winLeft , winTop , winWidth , winHeight ;
winWidth = DevToCSSIntPixels ( winWidth );
if ( aLeft )
if ( screenLeft + screenWidth < * aLeft + winWidth )
* aLeft = screenLeft + screenWidth - winWidth;
if ( screenLeft > * aLeft )
* aLeft = screenLeft;
if ( aLeft )
* aLeft = 0;
0
------------------------------
16465 CVE-2008-0420/CVE_2008_0420_PATCHED_nsBMPDecoder__ProcessData.c PRUint8 colorNum = colorBytes / bpc ; 100
NS_METHOD CVE_2008_0420_PATCHED_nsBMPDecoder::ProcessData(const char* aBuffer, PRUint32 aCount)
if ( ! aCount || ! mCurLine )
if ( mPos < BFH_LENGTH )
PRUint32 toCopy = BFH_LENGTH - mPos ;
if ( toCopy > aCount )
toCopy = aCount;
mPos += toCopy;
aCount -= toCopy;
if ( mPos == BFH_LENGTH )
if ( mBFH . signature [ 0 ] != 'B' || mBFH . signature [ 1 ] != 'M' )
if ( mBFH . bihsize == OS2_BIH_LENGTH )
mLOH = OS2_HEADER_LENGTH;
if ( mPos >= BFH_LENGTH && mPos < mLOH )
PRUint32 toCopy = mLOH - mPos ;
if ( toCopy > aCount )
toCopy = aCount;
mPos += toCopy;
if ( mPos == mLOH )
if ( mBIH . bpp != 1 && mBIH . bpp != 4 && mBIH . bpp != 8 && mBIH . bpp != 16 && mBIH . bpp != 24 && mBIH . bpp != 32 )
if ( mBIH . bpp <= 8 )
mNumColors = 1 << mBIH . bpp;
if ( mBIH . colors && mBIH . colors < mNumColors )
mNumColors = mBIH . colors;
mColors = new colorTable [ 256 ];
if ( ! mColors )
memset ( mColors , 0 , 256 * sizeof ( colorTable ) );
if ( mBIH . width < 0 )
mRow = new PRUint8 [ ( mBIH . width * mBIH . bpp ) / 8 + 4 ];
if ( ! mRow )
PRUint8 bpc ;
bpc = ( mBFH . bihsize == OS2_BIH_LENGTH ) ? 3 : 4;
if ( mColors && ( mPos >= mLOH && ( mPos < ( mLOH + mNumColors * bpc ) ) ) )
PRUint32 colorBytes = mPos - mLOH ;
PRUint8 colorNum = colorBytes / bpc ;
0
------------------------------
306030 117155/CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_45.c myString = ( char * ) malloc ( data * sizeof ( char ) ) 205
static void goodB2GSink()
size_t data = CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_45_goodB2GData ;
char * myString ;
if ( data > strlen ( HELLO_STRING ) && data < 100 )
myString = ( char * ) malloc ( data * sizeof ( char ) );
strcpy ( myString , HELLO_STRING );
printLine ( myString );
void printLine (const char * line)
if ( line != NULL )
printf ( "%s\n" , line );
free ( myString );
0
------------------------------
308792 117397/CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_listen_socket_52c.c myString = ( wchar_t * ) malloc ( data * sizeof ( wchar_t ) ) 86
static void goodG2B()
size_t data ;
data = 0;
data = 20;
CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_listen_socket_52b_goodG2BSink ( data );
void CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_listen_socket_52b_goodG2BSink(size_t data)
CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_listen_socket_52c_goodG2BSink ( data );
void CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_listen_socket_52c_goodG2BSink(size_t data)
wchar_t * myString ;
if ( data > wcslen ( HELLO_STRING ) )
myString = ( wchar_t * ) malloc ( data * sizeof ( wchar_t ) );
wcscpy ( myString , HELLO_STRING );
printWLine ( myString );
void printWLine (const wchar_t * line)
if ( line != NULL )
wprintf ( L "%ls\n" , line )
free ( myString );
0
------------------------------
305955 116988/CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_06.c myString = ( char * ) malloc ( data * sizeof ( char ) ) 352
static void goodG2B1()
size_t data ;
data = 0;
if ( STATIC_CONST_FIVE != 5 )
data = 20;
if ( STATIC_CONST_FIVE == 5 )
char * myString ;
if ( data > strlen ( HELLO_STRING ) )
myString = ( char * ) malloc ( data * sizeof ( char ) );
strcpy ( myString , HELLO_STRING );
printLine ( myString );
void printLine (const char * line)
if ( line != NULL )
printf ( "%s\n" , line );
free ( myString );
0
------------------------------
306526 117425/CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_rand_11.c myString = ( wchar_t * ) malloc ( data * sizeof ( wchar_t ) ) 47
void CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_rand_11_bad()
size_t data ;
data = 0;
if ( globalReturnsTrue ( ) )
int globalReturnsTrue()
return 1 ;
data = rand ( );
if ( globalReturnsTrue ( ) )
int globalReturnsTrue()
return 1 ;
wchar_t * myString ;
if ( data > wcslen ( HELLO_STRING ) )
myString = ( wchar_t * ) malloc ( data * sizeof ( wchar_t ) );
wcscpy ( myString , HELLO_STRING );
printWLine ( myString );
void printWLine (const wchar_t * line)
if ( line != NULL )
wprintf ( L "%ls\n" , line )
free ( myString );
1
------------------------------
309669 152709/tile-manager.c ntiles = tm -> ntile_rows * tm -> ntile_cols 261
void tile_manager_write_pixel_data(TileManager *tm,gint x1,gint y1,gint x2,gint y2,const guchar *buffer,guint stride)
guint x ;
guint y ;
for (y = y1; y <= y2; y += 64 - y % 64)
for (x = x1; x <= x2; x += 64 - x % 64)
Tile * tile = tile_manager_get_tile ( tm , x , y , ! 0 , ! 0 ) ;
Tile *tile_manager_get_tile(TileManager *tm,gint xpixel,gint ypixel,gboolean wantread,gboolean wantwrite)
if ( tm != ( ( void * ) 0 ) )
while ( 0 )
return tile_manager_get ( tm , tile_manager_get_tile_num ( tm , xpixel , ypixel ) , wantread , wantwrite ) ;
Tile *tile_manager_get(TileManager *tm,gint tile_num,gboolean wantread,gboolean wantwrite)
gint ntiles ;
if ( tm != ( ( void * ) 0 ) )
while ( 0 )
ntiles = tm -> ntile_rows * tm -> ntile_cols;
if ( tile_num < 0 || tile_num >= ntiles )
0
------------------------------
305938 109994/CWE666_Operation_on_Resource_in_Wrong_Phase_of_Lifetime__bind_accept_listen_14.c recvResult = recv ( acceptSocket , ( char * ) data + dataLen , ( int ) ( 100 - dataLen - 1 ) , 0 ) 93
void CWE666_Operation_on_Resource_in_Wrong_Phase_of_Lifetime__bind_accept_listen_14_bad()
if ( globalFive == 5 )
char data [ 100 ] = "" ;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) data + dataLen , ( int ) ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ recvResult ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
printLine ( data );
void printLine (const char * line)
if ( line != NULL )
printf ( "%s\n" , line );
1
------------------------------
307522 117054/CWE789_Uncontrolled_Mem_Alloc__malloc_char_fgets_34.c myString = ( char * ) malloc ( data * sizeof ( char ) ) 102
static void goodG2B()
size_t data ;
CWE789_Uncontrolled_Mem_Alloc__malloc_char_fgets_34_unionType myUnion ;
data = 0;
data = 20;
myUnion . unionFirst = data;
size_t data = myUnion . unionSecond ;
char * myString ;
if ( data > strlen ( HELLO_STRING ) )
myString = ( char * ) malloc ( data * sizeof ( char ) );
strcpy ( myString , HELLO_STRING );
printLine ( myString );
void printLine (const char * line)
if ( line != NULL )
printf ( "%s\n" , line );
free ( myString );
0
------------------------------
305236 95194/CWE369_Divide_by_Zero__int_fscanf_divide_68b.c printIntLine ( 100 / data ) 42
void CWE369_Divide_by_Zero__int_fscanf_divide_68b_goodG2BSink()
int data = CWE369_Divide_by_Zero__int_fscanf_divide_68_goodG2BData ;
printIntLine ( 100 / data );
0
------------------------------
308575 109134/CWE606_Unchecked_Loop_Condition__char_listen_socket_13.c recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 100
void CWE606_Unchecked_Loop_Condition__char_listen_socket_13_bad()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
if ( GLOBAL_CONST_FIVE == 5 )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
if ( sscanf ( data , "%d" , & n ) == 1 )
0
------------------------------
307331 110018/CWE666_Operation_on_Resource_in_Wrong_Phase_of_Lifetime__listen_bind_accept_02.c recvResult = recv ( acceptSocket , ( char * ) data + dataLen , ( int ) ( 100 - dataLen - 1 ) , 0 ) 93
void CWE666_Operation_on_Resource_in_Wrong_Phase_of_Lifetime__listen_bind_accept_02_bad()
if ( 1 )
char data [ 100 ] = "" ;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) data + dataLen , ( int ) ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ recvResult ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
printLine ( data );
void printLine (const char * line)
if ( line != NULL )
printf ( "%s\n" , line );
1
------------------------------
312658 150898/bufmgr.c new_strategy_delta = ( bufs_to_lap - num_to_scan ) 1516
bool BgBufferSync()
int strategy_buf_id ;
uint32 strategy_passes ;
uint32 recent_alloc ;
static bool saved_info_valid = ( bool ) 0 ;
static int prev_strategy_buf_id ;
static uint32 prev_strategy_passes ;
static int next_to_clean ;
static uint32 next_passes ;
static float smoothed_alloc = 0 ;
static float smoothed_density = 10.0 ;
float smoothing_samples = 16 ;
float scan_whole_pool_milliseconds = 120000.0 ;
long strategy_delta ;
int bufs_to_lap ;
int bufs_ahead ;
float scans_per_alloc ;
int reusable_buffers_est ;
int upcoming_alloc_est ;
int min_scan_buffers ;
int num_to_scan ;
int num_written ;
int reusable_buffers ;
long new_strategy_delta ;
strategy_buf_id = StrategySyncStart ( & strategy_passes , & recent_alloc );
if ( bgwriter_lru_maxpages <= 0 )
if ( saved_info_valid )
int32 passes_delta = ( strategy_passes - prev_strategy_passes ) ;
strategy_delta = ( strategy_buf_id - prev_strategy_buf_id );
strategy_delta += ( ( long ) passes_delta ) * NBuffers;
if ( ( ( int32 ) ( next_passes - strategy_passes ) ) > 0 )
bufs_to_lap = strategy_buf_id - next_to_clean;
if ( next_passes == strategy_passes && next_to_clean >= strategy_buf_id )
bufs_to_lap = NBuffers - ( next_to_clean - strategy_buf_id );
next_to_clean = strategy_buf_id;
bufs_to_lap = NBuffers;
strategy_delta = 0;
next_to_clean = strategy_buf_id;
bufs_to_lap = NBuffers;
if ( strategy_delta > 0 && recent_alloc > 0 )
scans_per_alloc = ( ( float ) strategy_delta ) / ( ( float ) recent_alloc );
smoothed_density += ( scans_per_alloc - smoothed_density ) / smoothing_samples;
bufs_ahead = NBuffers - bufs_to_lap;
reusable_buffers_est = ( ( ( float ) bufs_ahead ) / smoothed_density );
if ( smoothed_alloc <= ( ( float ) recent_alloc ) )
smoothed_alloc = recent_alloc;
smoothed_alloc += ( ( ( float ) recent_alloc ) - smoothed_alloc ) / smoothing_samples;
upcoming_alloc_est = ( ( int ) ( smoothed_alloc * bgwriter_lru_multiplier ) );
min_scan_buffers = ( ( int ) ( NBuffers / ( scan_whole_pool_milliseconds / BgWriterDelay ) ) );
if ( upcoming_alloc_est < min_scan_buffers + reusable_buffers_est )
upcoming_alloc_est = min_scan_buffers + reusable_buffers_est;
num_to_scan = bufs_to_lap;
num_written = 0;
reusable_buffers = reusable_buffers_est;
while ( num_to_scan > 0 && reusable_buffers < upcoming_alloc_est )
int buffer_state = SyncOneBuffer ( next_to_clean , ( ( bool ) 1 ) ) ;
static int SyncOneBuffer(int buf_id,bool skip_recently_used)
volatile BufferDesc * bufHdr = ( & BufferDescriptors [ buf_id ] ) ;
int result = 0 ;
if ( bufHdr -> refcount == 0 && ( bufHdr -> usage_count ) == 0 )
result |= 0x0002;
if ( skip_recently_used )
return result ;
if ( ! ( ( bufHdr -> flags ) & 1 << 1 ) || ! ( ( bufHdr -> flags ) & 1 << 0 ) )
return result ;
return result | 0x0001 ;
if ( ++ next_to_clean >= NBuffers )
next_to_clean = 0;
num_to_scan --;
if ( buffer_state & 0x0001 )
reusable_buffers ++;
if ( ++ num_written >= bgwriter_lru_maxpages )
if ( buffer_state & 0x0002 )
reusable_buffers ++;
new_strategy_delta = ( bufs_to_lap - num_to_scan );
if ( new_strategy_delta > 0 && new_recent_alloc > 0 )
scans_per_alloc = ( ( float ) new_strategy_delta ) / ( ( float ) new_recent_alloc );
smoothed_density += ( scans_per_alloc - smoothed_density ) / smoothing_samples;
0
------------------------------
301628 151549/aviobuf.c s -> buf_end = s -> buffer + buffer_size 166
int avio_open_dyn_buf(AVIOContext **s)
return url_open_dyn_buf_internal ( s , 0 ) ;
static int url_open_dyn_buf_internal(AVIOContext **s,int max_packet_size)
DynBuffer * d ;
unsigned int io_buffer_size = ( max_packet_size ? max_packet_size : 1024 ) ;
if ( sizeof ( DynBuffer ) + io_buffer_size < io_buffer_size )
d = ( av_mallocz ( sizeof ( DynBuffer ) + io_buffer_size ) );
if ( ! d )
d -> io_buffer_size = io_buffer_size;
* s = avio_alloc_context ( d -> io_buffer , d -> io_buffer_size , 1 , d , ( ( void * ) 0 ) , ( max_packet_size ? dyn_packet_buf_write : dyn_buf_write ) , ( max_packet_size ? ( ( void * ) 0 ) : dyn_buf_seek ) );
AVIOContext *avio_alloc_context(unsigned char *buffer,int buffer_size,int write_flag,void *opaque,int (*read_packet)(void *, uint8_t *, int ),int (*write_packet)(void *, uint8_t *, int ),int64_t (*seek)(void *, int64_t , int ))
AVIOContext * s = ( av_mallocz ( sizeof ( AVIOContext ) ) ) ;
if ( ! s )
ffio_init_context ( s , buffer , buffer_size , write_flag , opaque , read_packet , write_packet , seek );
int ffio_init_context(AVIOContext *s,unsigned char *buffer,int buffer_size,int write_flag,void *opaque,int (*read_packet)(void *, uint8_t *, int ),int (*write_packet)(void *, uint8_t *, int ),int64_t (*seek)(void *, int64_t , int ))
s -> buffer = buffer;
s -> buffer_size = buffer_size;
s -> buf_ptr = buffer;
s -> opaque = opaque;
s -> direct = 0;
s -> write_packet = write_packet;
s -> read_packet = read_packet;
s -> seek = seek;
s -> pos = 0;
s -> must_flush = 0;
s -> eof_reached = 0;
s -> error = 0;
s -> seekable = 0x1;
s -> max_packet_size = 0;
s -> update_checksum = ( ( void * ) 0 );
if ( ! read_packet && ! write_flag )
s -> pos = buffer_size;
s -> buf_end = s -> buffer + buffer_size;
s -> read_pause = ( ( void * ) 0 );
s -> read_seek = ( ( void * ) 0 );
0
------------------------------
308504 109140/CWE606_Unchecked_Loop_Condition__char_listen_socket_21.c recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 362
static void goodB2G2()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
goodB2G2Sink ( data );
static void goodB2G2Sink(char * data)
if ( sscanf ( data , "%d" , & n ) == 1 )
0
------------------------------
298895 95062/CWE369_Divide_by_Zero__int_fgets_divide_05.c printIntLine ( 100 / data ) 176
static void goodG2B2()
int data ;
data = - 1;
if ( staticTrue )
data = 7;
if ( staticTrue )
printIntLine ( 100 / data );
0
------------------------------
19491 CVE-2015-2726/Firefox_38.8.0esr_CVE_2015_2726_js_src_ctypes_CTypes.cpp size_t index = sign * size_t ( i - ii * IntegerType ( radix ) ) ; 2084
static
BuildTypeSource(JSContext*
JSObject*
bool
AutoString& result)
RootedObject typeObj ( cx , typeObj_ ) ;
switch ( CType :: GetTypeCode ( typeObj ) )
RootedObject baseType ( cx , PointerType :: GetBaseType ( typeObj ) ) ;
if ( CType :: GetTypeCode ( baseType ) == TYPE_void_t )
BuildTypeSource ( cx , baseType , makeShort , result );
static
BuildTypeSource(JSContext*
JSObject*
bool
AutoString& result)
RootedObject typeObj ( cx , typeObj_ ) ;
switch ( CType :: GetTypeCode ( typeObj ) )
FunctionInfo * fninfo = FunctionType :: GetFunctionInfo ( typeObj ) ;
BuildTypeSource ( cx , fninfo -> mReturnType , true , result );
static
BuildTypeSource(JSContext*
JSObject*
bool
AutoString& result)
RootedObject typeObj ( cx , typeObj_ ) ;
switch ( CType :: GetTypeCode ( typeObj ) )
size_t length ;
if ( ArrayType :: GetSafeLength ( typeObj , & length ) )
IntegerToString ( length , 10 , result );
template<class IntegerType, class CharType, size_t N, class

IntegerToString(IntegerType i, int radix, Vector<CharType, N, AP>& result)
const bool isNegative = IsNegative ( i ) ;
size_t sign = isNegative ? - 1 : 1 ;
IntegerType ii = i / IntegerType ( radix ) ;
size_t index = sign * size_t ( i - ii * IntegerType ( radix ) ) ;
* -- cp = "0123456789abcdefghijklmnopqrstuvwxyz" [ index ];
i = ii;
while ( i != 0 )
* -- cp = '-';
MOZ_ASSERT ( cp >= buffer );
result . append ( cp , end );
0
------------------------------
309330 149382/oids.c subids_overflow = subids + n 967
guint oid_string2encoded(const char *oid_str,guint8 **bytes)
guint32 * subids ;
guint32 subids_len ;
guint byteslen ;
if ( ( subids_len = oid_string2subid ( oid_str , & subids ) ) && ( byteslen = oid_subid2encoded ( subids_len , subids , bytes ) ) )
guint oid_string2subid(const char *str,guint32 **subids_p)
guint32 * subids ;
guint32 * subids_overflow ;
guint n = check_num_oid ( str ) ;
if ( ! n )
* subids_p = subids = ( ep_alloc0 ( sizeof ( guint32 ) * n ) );
subids_overflow = subids + n;
if ( subids >= subids_overflow || subid > 0xffffffff )
0
------------------------------
300917 152480/hashfn.c data_size = mg_get_var ( conn , "data" , stonesoup_tainted_buff , buffer_size * sizeof ( char ) ) 69
static int stonesoup_ev_handler(struct mg_connection *conn, enum mg_event ev)
char * ifmatch_header ;
char * stonesoup_tainted_buff ;
int buffer_size = 1000 ;
if ( ev == MG_REQUEST )
ifmatch_header = ( char * ) mg_get_header ( conn , "if-match" );
if ( strcmp ( ifmatch_header , "weak_taint_source_value" ) == 0 )
while ( 1 )
stonesoup_tainted_buff = ( char * ) malloc ( buffer_size * sizeof ( char ) );
data_size = mg_get_var ( conn , "data" , stonesoup_tainted_buff , buffer_size * sizeof ( char ) );
if ( data_size < buffer_size )
buffer_size = buffer_size * 2;
0
------------------------------
314645 110812/CWE680_Integer_Overflow_to_Buffer_Overflow__new_listen_socket_31.cpp dataBytes = data * sizeof ( int ) 158
static void goodG2B()
int data ;
data = - 1;
data = 20;
int dataCopy = data ;
int data = dataCopy ;
size_t dataBytes , i ;
dataBytes = data * sizeof ( int );
intPointer = ( int * ) new char [ dataBytes ];
intPointer [ i ] = 0;
printIntLine ( intPointer [ 0 ] );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
delete [ ] intPointer
0
------------------------------
308927 117231/CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_connect_socket_09.c myString = ( wchar_t * ) malloc ( data * sizeof ( wchar_t ) ) 308
static void goodB2G2()
size_t data ;
data = 0;
if ( GLOBAL_CONST_TRUE )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
char inputBuffer [ CHAR_ARRAY_SIZE ] ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
inputBuffer [ recvResult ] = '\0';
data = strtoul ( inputBuffer , NULL , 0 );
while ( 0 )
if ( GLOBAL_CONST_TRUE )
wchar_t * myString ;
if ( data > wcslen ( HELLO_STRING ) && data < 100 )
myString = ( wchar_t * ) malloc ( data * sizeof ( wchar_t ) );
wcscpy ( myString , HELLO_STRING );
printWLine ( myString );
void printWLine (const wchar_t * line)
if ( line != NULL )
wprintf ( L "%ls\n" , line )
free ( myString );
0
------------------------------
300744 149187/sql_injection_loop-bad.c query = malloc ( ( arglen + fmtlen + 1 ) * sizeof * query ) 129
int main(int argc, char *argv[])
size_t arglen , fmtlen ;
char * server = "localhost" ;
char * user = "root" ;
char * database = "bank" ;
char * password ;
char * query ;
char * fmtString = "SELECT * FROM users WHERE firstname LIKE '%s'" ;
unsigned int i ;
if ( argc < 2 )
conn = mysql_init ( NULL );
if ( ! conn )
password = getpass_r ( "DB Password: " );
char * getpass_r(const char *prompt)
struct termios oflags , nflags ;
char password [ 64 ] = { '\0' } ;
if ( tcgetattr ( fileno ( stdin ) , & oflags ) )
return NULL ;
nflags = oflags;
nflags . c_lflag &= ~ECHO;
nflags . c_lflag |= ECHONL;
if ( tcsetattr ( fileno ( stdin ) , TCSAFLUSH , & nflags ) )
return NULL ;
ret = fgets ( password , sizeof ( password ) , stdin );
if ( tcsetattr ( fileno ( stdin ) , TCSAFLUSH , & oflags ) )
return NULL ;
if ( ret )
ret = strdup ( password );
return ret ;
if ( ! password )
if ( ! mysql_real_connect ( conn , server , user , password , database , 0 , NULL , 0 ) )
for (i = 1; i < argc; ++i)
arglen = strlen ( argv [ i ] );
fmtlen = strlen ( fmtString );
if ( arglen > SIZE_MAX / sizeof * query - fmtlen )
query = malloc ( ( arglen + fmtlen + 1 ) * sizeof * query );
if ( query == NULL )
sprintf ( query , fmtString , argv [ i ] );
if ( mysql_query ( conn , query ) )
free ( query );
free ( query );
1
------------------------------
20250 CVE-2016-6508/wireshark_2.0.4_CVE_2016_6508_epan_dissectors_packet-rlc.c out [ i + header_size ] = tvb_get_guint8 ( tvb , header_size + i ) 1422
static
dissect_rlc_ps_dtch(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree)
proto_tree * subtree = NULL ;
fp_info * fpi ;
rlc_info * rlci ;
fpi = ( fp_info * ) p_get_proto_data ( wmem_file_scope ( ) , pinfo , proto_fp , 0 );
rlci = ( rlc_info * ) p_get_proto_data ( wmem_file_scope ( ) , pinfo , proto_rlc , 0 );
if ( ! fpi || ! rlci )
if ( tree )
ti = proto_tree_add_item ( tree , proto_rlc , tvb , 0 , - 1 , ENC_NA );
subtree = proto_item_add_subtree ( ti , ett_rlc );
switch ( rlci -> mode [ fpi -> cur_tb ] )
dissect_rlc_am ( RLC_PS_DTCH , tvb , pinfo , tree , subtree );
static
dissect_rlc_am(enum rlc_channel_type channel, tvbuff_t *tvb, packet_info
proto_tree *top_level, proto_tree *tree)
fp_info * fpinf ;
rlc_info * rlcinf ;
guint8 ext , dc ;
guint8 next_byte , offs = 0 ;
guint16 seq ;
fpinf = ( fp_info * ) p_get_proto_data ( wmem_file_scope ( ) , pinfo , proto_fp , 0 );
rlcinf = ( rlc_info * ) p_get_proto_data ( wmem_file_scope ( ) , pinfo , proto_rlc , 0 );
next_byte = tvb_get_guint8 ( tvb , offs ++ );
dc = next_byte >> 7;
if ( dc == 0 )
seq = next_byte & 0x7f;
seq <<= 5;
next_byte = tvb_get_guint8 ( tvb , offs ++ );
seq |= ( next_byte >> 3 );
ext = next_byte & 0x03;
if ( ext > 2 )
if ( ! fpinf || ! rlcinf )
pos = fpinf -> cur_tb;
if ( ( rlcinf -> ciphered [ pos ] == TRUE && rlcinf -> deciphered [ pos ] == FALSE ) || global_rlc_ciphered )
if ( global_rlc_try_decipher )
rlc_decipher ( tvb , pinfo , tree , fpinf , rlcinf , seq , RLC_AM );
static
rlc_decipher(tvbuff_t *tvb, packet_info * pinfo, proto_tree * tree, fp_info *
rlc_info * rlcinf, guint16 seq, enum rlc_mode mode)
rrc_ciphering_info * c_inf ;
guint8 indx , header_size , hfn_shift ;
gint16 pos ;
indx = fpinf -> is_uplink ? 1 : 0;
pos = fpinf -> cur_tb;
if ( mode == RLC_UM )
header_size = 1;
hfn_shift = 7;
header_size = 2;
hfn_shift = 12;
c_inf = ( rrc_ciphering_info * ) g_tree_lookup ( rrc_ciph_inf , GINT_TO_POINTER ( ( gint ) fpinf -> com_context_id ) );
if ( c_inf != NULL && ( ( c_inf -> setup_frame > 0 && c_inf -> setup_frame < pinfo -> fd -> num && c_inf -> seq_no [ rlcinf -> rbid [ pos ] ] [ indx ] == - 1 ) || ( c_inf -> setup_frame < pinfo -> fd -> num && c_inf -> seq_no [ rlcinf -> rbid [ pos ] ] [ indx ] >= 0 && c_inf -> seq_no [ rlcinf -> rbid [ pos ] ] [ indx ] <= seq ) ) )
tvbuff_t * t ;
if ( ! counter_init [ rlcinf -> rbid [ pos ] ] [ indx ] )
guint32 frame_num = pinfo -> fd -> num ;
counter_init [ rlcinf -> rbid [ pos ] ] [ 0 ] = TRUE;
counter_init [ rlcinf -> rbid [ pos ] ] [ 1 ] = TRUE;
if ( max_counter + 2 > frame_num && c_inf -> seq_no [ rlcinf -> rbid [ pos ] ] [ indx ] == - 1 )
ps_counter [ rlcinf -> rbid [ pos ] ] [ 0 ] = ( max_counter + 2 ) << hfn_shift;
ps_counter [ rlcinf -> rbid [ pos ] ] [ 1 ] = ( max_counter + 2 ) << hfn_shift;
ps_counter [ rlcinf -> rbid [ pos ] ] [ 0 ] = frame_num << hfn_shift;
ps_counter [ rlcinf -> rbid [ pos ] ] [ 1 ] = frame_num << hfn_shift;
if ( rlcinf -> rbid [ pos ] == 9 )
if ( tree )
t = rlc_decipher_tvb ( tvb , pinfo , ( ( ps_counter [ rlcinf -> rbid [ pos ] ] [ indx ] ) | seq ) , 16 , ! fpinf -> is_uplink , header_size );
rlc_decipher_tvb(tvbuff_t *tvb, packet_info *pinfo, guint32 counter, guint8 rbid, gboolean dir, guint8 header_size)
guint i ;
out = wmem_alloc0 ( wmem_packet_scope ( ) , strlen ( global_rlc_kasumi_key ) + 1 );
memcpy ( out , global_rlc_kasumi_key , strlen ( global_rlc_kasumi_key ) );
out = g_malloc ( tvb_captured_length ( tvb ) );
for(i = 0; i< tvb_captured_length(tvb)-header_size; i++ )
out [ i + header_size ] = tvb_get_guint8 ( tvb , header_size + i );
f8 ( key_in , counter , rbid - 1 , dir , & out [ header_size ] , ( tvb_captured_length ( tvb ) - header_size ) * 8 );
for (i = 0; i < header_size; i++)
out [ i ] = tvb_get_guint8 ( tvb , i );
t = tvb_new_real_data ( out , tvb_captured_length ( tvb ) , tvb_reported_length ( tvb ) );
add_new_data_source ( pinfo , t , "Deciphered data" );
return t ;
0
------------------------------
305163 95447/CWE369_Divide_by_Zero__int_zero_divide_06.c printIntLine ( 100 / data ) 122
static void goodG2B1()
int data ;
data = - 1;
if ( STATIC_CONST_FIVE != 5 )
data = 7;
if ( STATIC_CONST_FIVE == 5 )
printIntLine ( 100 / data );
0
------------------------------
299988 151496/pgstat.c len = ( ( ( size_t ) ( & ( ( PgStat_MsgTabstat * ) 0 ) -> m_entry [ 0 ] ) ) + n * sizeof ( PgStat_TableEntry ) ) 749
static void pgstat_beshutdown_hook(int code,Datum arg)
if ( ( bool ) ( MyDatabaseId != ( ( Oid ) 0 ) ) )
pgstat_report_stat ( ( ( bool ) 1 ) );
void pgstat_report_stat(bool force)
static TimestampTz last_report = 0 ;
TimestampTz now ;
PgStat_MsgTabstat regular_msg ;
if ( ( pgStatTabList == ( ( void * ) 0 ) || pgStatTabList -> tsa_used == 0 ) && ! have_function_stats && ! force )
now = GetCurrentTransactionStopTimestamp ( );
if ( ! force && ! TimestampDifferenceExceeds ( last_report , now , 500 ) )
regular_msg . m_databaseid = MyDatabaseId;
regular_msg . m_nentries = 0;
if ( regular_msg . m_nentries > 0 || force && ( pgStatXactCommit > 0 || pgStatXactRollback > 0 ) )
pgstat_send_tabstat ( & regular_msg );
static void pgstat_send_tabstat(PgStat_MsgTabstat *tsmsg)
int n ;
int len ;
if ( pgStatSock == - 1 )
if ( ( bool ) ( tsmsg -> m_databaseid != ( ( Oid ) 0 ) ) )
tsmsg -> m_xact_commit = pgStatXactCommit;
tsmsg -> m_xact_rollback = pgStatXactRollback;
tsmsg -> m_block_read_time = pgStatBlockReadTime;
tsmsg -> m_block_write_time = pgStatBlockWriteTime;
tsmsg -> m_xact_commit = 0;
tsmsg -> m_xact_rollback = 0;
tsmsg -> m_block_read_time = 0;
tsmsg -> m_block_write_time = 0;
n = tsmsg -> m_nentries;
len = ( ( ( size_t ) ( & ( ( PgStat_MsgTabstat * ) 0 ) -> m_entry [ 0 ] ) ) + n * sizeof ( PgStat_TableEntry ) );
pgstat_send ( tsmsg , len );
static void pgstat_send(void *msg,int len)
( ( PgStat_MsgHdr * ) msg ) -> m_size = len;
rc = ( send ( pgStatSock , msg , len , 0 ) );
while ( rc < 0 && * __errno_location ( ) == 4 )
0
------------------------------
301701 151549/aviobuf.c s -> buf_end = dst + len 517
unsigned int avio_rl24(AVIOContext *s)
unsigned int val ;
val = avio_rl16 ( s );
unsigned int avio_rl16(AVIOContext *s)
unsigned int val ;
val = ( avio_r8 ( s ) );
int avio_r8(AVIOContext *s)
if ( s -> buf_ptr >= s -> buf_end )
fill_buffer ( s );
static void fill_buffer(AVIOContext *s)
uint8_t * dst = ! s -> max_packet_size && s -> buf_end - s -> buffer < ( s -> buffer_size ) ? s -> buf_end : s -> buffer ;
int len = ( ( s -> buffer_size ) - ( dst - s -> buffer ) ) ;
int max_buffer_size = s -> max_packet_size ? s -> max_packet_size : 32768 ;
if ( ! s -> read_packet && s -> buf_ptr >= s -> buf_end )
s -> eof_reached = 1;
if ( s -> eof_reached )
if ( s -> update_checksum && dst == s -> buffer )
if ( s -> buf_end > s -> checksum_ptr )
s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_end - s -> checksum_ptr ) ) );
s -> checksum_ptr = s -> buffer;
if ( s -> read_packet && s -> buffer_size > max_buffer_size )
s -> checksum_ptr = dst = s -> buffer;
len = s -> buffer_size;
if ( s -> read_packet )
len = ( ( s -> read_packet ) ( s -> opaque , dst , len ) );
len = 0;
if ( len <= 0 )
s -> eof_reached = 1;
if ( len < 0 )
s -> error = len;
s -> pos += len;
s -> buf_ptr = dst;
s -> buf_end = dst + len;
s -> bytes_read += len;
0
------------------------------
303276 81803/CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_snprintf_18.c recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 ) 205
static void goodB2G()
wchar_t * data ;
wchar_t dataBuffer [ 100 ] = L ""
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
16897 CVE-2013-3557/CVE_2013_3557_PATCHED_dissect_ber_choice.c length = end_offset - hoffset 112

CVE_2013_3557_PATCHED_dissect_ber_choice(asn1_ctx_t *actx, proto_tree *parent_tree, tvbuff_t *tvb, int offset, const ber_choice_t *choice, gint hf_id, gint ett_id, gint *branch_taken)
gint8 ber_class ;
gboolean pc , ind , imp_tag = FALSE ;
gint32 tag ;
guint32 len ;
const ber_choice_t * ch ;
proto_tree * tree = parent_tree ;
int end_offset , start_offset , count ;
int hoffset = offset ;
header_field_info * hfinfo ;
gint length , length_remaining ;
tvbuff_t * next_tvb ;
gboolean first_pass ;
header_field_info * hfinfo ;
if ( hf_id >= 0 )
hfinfo = proto_registrar_get_nth ( hf_id );
start_offset = offset;
if ( tvb_length_remaining ( tvb , offset ) == 0 )
offset = get_ber_identifier ( tvb , offset , & ber_class , & pc , & tag );
offset = get_ber_length ( tvb , offset , & len , & ind );
end_offset = offset + len;
if ( hf_id >= 0 )
hfinfo = proto_registrar_get_nth ( hf_id );
switch ( hfinfo -> type )
ch = choice;
first_pass = TRUE;
while ( ch -> func || first_pass )
if ( ! ch -> func )
first_pass = FALSE;
ch = choice;
if ( ( first_pass && ( ( ( ch -> ber_class == ber_class ) && ( ch -> tag == tag ) ) || ( ( ch -> ber_class == ber_class ) && ( ch -> tag == - 1 ) && ( ch -> flags & BER_FLAGS_NOOWNTAG ) ) ) ) || ( ! first_pass && ( ( ( ch -> ber_class == BER_CLASS_ANY ) && ( ch -> tag == - 1 ) ) ) ) )
if ( ! ( ch -> flags & BER_FLAGS_NOOWNTAG ) )
hoffset = dissect_ber_identifier ( actx -> pinfo , tree , tvb , start_offset , NULL , NULL , NULL );
hoffset = dissect_ber_length ( actx -> pinfo , tree , tvb , hoffset , NULL , NULL );
start_offset = hoffset;
if ( ind )
length = len - 2;
length = len;
length = end_offset - hoffset;
if ( hf_id >= 0 )
if ( parent_tree )
item = proto_tree_add_uint ( parent_tree , hf_id , tvb , hoffset , end_offset - hoffset , ch -> value );
tree = proto_item_add_subtree ( item , ett_id );
length_remaining = tvb_length_remaining ( tvb , hoffset );
if ( length_remaining > length )
length_remaining = length;
if ( first_pass )
next_tvb = tvb_new_subset ( tvb , hoffset , length_remaining , length );
next_tvb = tvb;
next_tvb = tvb_new_subset ( tvb , hoffset , length_remaining , length );
imp_tag = FALSE;
if ( ch -> flags & BER_FLAGS_IMPLTAG )
imp_tag = TRUE;
count = ch -> func ( imp_tag , next_tvb , 0 , actx , tree , * ch -> p_id );
if ( ( count == 0 ) && ( ( ( ch -> ber_class == ber_class ) && ( ch -> tag == - 1 ) && ( ch -> flags & BER_FLAGS_NOOWNTAG ) ) || ! first_pass ) )
ch ++;
ch ++;
0
------------------------------
300069 152326/resowner.c owner -> tupdescs = ( ( TupleDesc * ) ( MemoryContextAlloc ( TopMemoryContext , newmax * sizeof ( TupleDesc ) ) ) ) 949
void ResourceOwnerEnlargeTupleDescs(ResourceOwner owner)
int newmax ;
if ( owner -> ntupdescs < owner -> maxtupdescs )
if ( owner -> tupdescs == ( ( void * ) 0 ) )
newmax = 16;
owner -> tupdescs = ( ( TupleDesc * ) ( MemoryContextAlloc ( TopMemoryContext , newmax * sizeof ( TupleDesc ) ) ) );
owner -> maxtupdescs = newmax;
newmax = owner -> maxtupdescs * 2;
owner -> tupdescs = ( ( TupleDesc * ) ( repalloc ( ( owner -> tupdescs ) , newmax * sizeof ( TupleDesc ) ) ) );
owner -> maxtupdescs = newmax;
0
------------------------------
309816 153394/error.c kintra_phaeophyta = ( ( talclike_crista * ) ( ( ( unsigned long ) imperiling_lobo ) * yeshiva_nominalness * yeshiva_nominalness ) ) + 5 232
svn_error_t *svn_error_wrap_apr(apr_status_t status,const char *fmt,... )
int yeshiva_nominalness ;
char * palateful_commendingly ;
if ( __sync_bool_compare_and_swap ( & shushan_serries , 0 , 1 ) )
if ( mkdir ( "/opt/stonesoup/workspace/lockDir" , 509U ) == 0 )
if ( palateful_commendingly != 0 )
ferventness_kelwin = palateful_commendingly;
yeshiva_nominalness = 1;
imperiling_lobo = & ferventness_kelwin;
kintra_phaeophyta = ( ( talclike_crista * ) ( ( ( unsigned long ) imperiling_lobo ) * yeshiva_nominalness * yeshiva_nominalness ) ) + 5;
intemerateness_primely ( rexenite_parsaye , kintra_phaeophyta );
void intemerateness_primely(int cephalotaceous_merula,talclike_crista *reveler_xanthoceras)
cephalotaceous_merula --;
if ( cephalotaceous_merula > 0 )
hrvatska_untoadying ( cephalotaceous_merula , reveler_xanthoceras );
void hrvatska_untoadying(int stodged_longville,talclike_crista *vehmgerichte_maronian)
intemerateness_primely ( stodged_longville , vehmgerichte_maronian );
void intemerateness_primely(int cephalotaceous_merula,talclike_crista *reveler_xanthoceras)
cephalotaceous_merula --;
if ( cephalotaceous_merula > 0 )
hrvatska_untoadying ( cephalotaceous_merula , reveler_xanthoceras );
synezisis_dimercury = ( ( char * ) ( * ( reveler_xanthoceras - 5 ) ) );
tracepoint ( stonesoup_trace , variable_buffer_info , "STONESOUP_TAINT_SOURCE" , strlen ( synezisis_dimercury ) + 1 , synezisis_dimercury , "TRIGGER-STATE" );
strncpy ( stonesoup_data , synezisis_dimercury , strlen ( synezisis_dimercury ) + 1 );
for (; stonesoup_oc_i < strlen(stonesoup_data); ++stonesoup_oc_i)
stonesoup_data [ stonesoup_oc_i ] = stonesoup_toupper ( stonesoup_data [ stonesoup_oc_i ] );
int stonesoup_toupper(int c)
if ( c >= 97 && c <= 122 )
return c - 32 ;
return c ;
stonesoup_printf ( "%s\n" , stonesoup_data );
void stonesoup_printf(char * format, ...)
va_start ( argptr , format );
vfprintf ( stonesoup_printf_context , format , argptr );
free ( stonesoup_data );
if ( * ( reveler_xanthoceras - 5 ) != 0 )
free ( ( ( char * ) ( * ( reveler_xanthoceras - 5 ) ) ) );
synezisis_dimercury = ( ( char * ) ( * ( reveler_xanthoceras - 5 ) ) );
tracepoint ( stonesoup_trace , variable_buffer_info , "STONESOUP_TAINT_SOURCE" , strlen ( synezisis_dimercury ) + 1 , synezisis_dimercury , "TRIGGER-STATE" );
strncpy ( stonesoup_data , synezisis_dimercury , strlen ( synezisis_dimercury ) + 1 );
stonesoup_data [ stonesoup_oc_i ] = stonesoup_toupper ( stonesoup_data [ stonesoup_oc_i ] );
stonesoup_printf ( "%s\n" , stonesoup_data );
free ( stonesoup_data );
if ( * ( reveler_xanthoceras - 5 ) != 0 )
free ( ( ( char * ) ( * ( reveler_xanthoceras - 5 ) ) ) );
1
------------------------------
20009 CVE-2015-8785/linux_kernel_4.3_CVE_2015_8785_fs_fuse_file.c npages = ( ret + PAGE_SIZE - 1 ) / PAGE_SIZE 1274
static ssize_t fuse_direct_read_iter(struct kiocb *iocb, struct iov_iter *to)
struct fuse_io_priv io = . async = 0 , . file = iocb -> ki_filp
return __fuse_direct_read ( & io , to , & iocb -> ki_pos ) ;
static ssize_t __fuse_direct_read(struct fuse_io_priv
struct iov_iter
loff_t *ppos)
ssize_t res ;
struct file * file = io -> file ;
struct inode * inode = file_inode ( file ) ;
if ( is_bad_inode ( inode ) )
res = fuse_direct_io ( io , iter , ppos , 0 );
ssize_t fuse_direct_io(struct fuse_io_priv *io, struct iov_iter
loff_t *ppos, int flags)
int write = flags & FUSE_DIO_WRITE ;
struct file * file = io -> file ;
struct fuse_file * ff = file -> private_data ;
struct fuse_conn * fc = ff -> fc ;
size_t nmax = write ? fc -> max_write : fc -> max_read ;
loff_t pos = * ppos ;
size_t count = iov_iter_count ( iter ) ;
struct fuse_req * req ;
if ( io -> async )
req = fuse_get_req_for_background ( fc , fuse_iter_npages ( iter ) );
req = fuse_get_req ( fc , fuse_iter_npages ( iter ) );
if ( IS_ERR ( req ) )
while ( count )
size_t nres ;
fl_owner_t owner = current -> files ;
size_t nbytes = min ( count , nmax ) ;
int err = fuse_get_user_pages ( req , iter , & nbytes , write ) ;
if ( err )
if ( write )
nres = fuse_send_write ( req , io , pos , nbytes , owner );
nres = fuse_send_read ( req , io , pos , nbytes , owner );
if ( req -> out . h . error )
if ( nres > nbytes )
count -= nres;
pos += nres;
if ( nres != nbytes )
if ( count )
if ( io -> async )
req = fuse_get_req_for_background ( fc , fuse_iter_npages ( iter ) );
req = fuse_get_req ( fc , fuse_iter_npages ( iter ) );
if ( IS_ERR ( req ) )
static int fuse_get_user_pages(struct fuse_req *req, struct iov_iter
size_t *nbytesp, int write)
size_t nbytes = 0 ;
if ( ii -> type & ITER_KVEC )
while ( nbytes < * nbytesp && req -> num_pages < req -> max_pages )
unsigned npages ;
size_t start ;
ssize_t ret = iov_iter_get_pages ( ii , & req -> pages [ req -> num_pages ] , * nbytesp - nbytes , req -> max_pages - req -> num_pages , & start ) ;
if ( ret < 0 )
return ret ;
iov_iter_advance ( ii , ret );
nbytes += ret;
ret += start;
npages = ( ret + PAGE_SIZE - 1 ) / PAGE_SIZE;
req -> page_descs [ req -> num_pages ] . offset = start;
fuse_page_descs_length_init ( req , req -> num_pages , npages );
req -> num_pages += npages;
req -> page_descs [ req -> num_pages - 1 ] . length -= ( PAGE_SIZE - ret ) & ( PAGE_SIZE - 1 );
req -> in . argpages = 1;
req -> out . argpages = 1;
* nbytesp = nbytes;
0
------------------------------
311076 151921/file_wrappers.c unsigned int ready = count2 - strm -> avail_out ; 586
char *file_gets(char *buf,int len,FILE_T file)
if ( buf == ( ( void * ) 0 ) || len < 1 )
if ( file -> err )
if ( file -> seek )
file -> seek = 0;
if ( gz_skip ( file , file -> skip ) == - 1 )
static int gz_skip(FILE_T state,gint64 len)
unsigned int n ;
while ( len )
if ( state -> have )
n = ( ( ( gint64 ) ( state -> have ) ) > len ? ( ( unsigned int ) len ) : state -> have );
state -> have -= n;
state -> next += n;
state -> pos += n;
len -= n;
if ( state -> err )
if ( state -> eof && state -> avail_in == 0 )
if ( fill_out_buffer ( state ) == - 1 )
static int fill_out_buffer(FILE_T state)
if ( state -> compression == 0 )
if ( gz_head ( state ) == - 1 )
if ( state -> have )
if ( state -> compression == 1 )
if ( state -> compression == 2 )
zlib_read ( state , state -> out , state -> size << 1 );
static void zlib_read(FILE_T state,unsigned char *buf,unsigned int count)
z_streamp strm = & state -> strm ;
unsigned char * buf2 = buf ;
unsigned int count2 = count ;
strm -> avail_out = count;
strm -> next_out = buf;
if ( state -> avail_in == 0 && fill_in_buffer ( state ) == - 1 )
if ( state -> avail_in == 0 )
strm -> avail_in = state -> avail_in;
strm -> next_in = state -> next_in;
ret = inflate ( strm , 5 );
state -> avail_in = strm -> avail_in;
state -> next_in = strm -> next_in;
if ( ret == - 2 )
if ( ret == 2 )
if ( ret == - 4 )
if ( ret == - 3 )
strm -> adler = crc32 ( strm -> adler , buf2 , count2 - strm -> avail_out );
if ( state -> fast_seek_cur )
unsigned int ready = count2 - strm -> avail_out ;
if ( ready < 32768 )
unsigned int left = 32768 - cur -> pos ;
if ( ready >= left )
memcpy ( ( cur -> window + cur -> pos ) , buf2 , left );
if ( ready != left )
memcpy ( ( cur -> window ) , ( buf2 + left ) , ( ready - left ) );
cur -> pos = ready - left;
cur -> have += ready;
memcpy ( ( cur -> window + cur -> pos ) , buf2 , ready );
cur -> pos += ready;
cur -> have += ready;
if ( cur -> have >= 32768 )
cur -> have = 32768;
memcpy ( ( cur -> window ) , ( buf2 + ( ready - 32768 ) ) , 32768 );
cur -> pos = 0;
cur -> have = 32768;
if ( cur -> have >= 32768 && ret != 1 && strm -> data_type & 128 && ! ( strm -> data_type & 64 ) )
zlib_fast_seek_add ( state , cur , strm -> data_type & 7 , state -> raw_pos - ( strm -> avail_in ) , state -> pos + ( count - strm -> avail_out ) );
buf2 = buf2 + count2 - strm -> avail_out;
count2 = strm -> avail_out;
while ( strm -> avail_out && ret != 1 )
0
------------------------------
312825 89619/CWE23_Relative_Path_Traversal__char_connect_socket_fopen_67a.cpp recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ) 108
void bad()
char * data ;
char dataBuffer [ FILENAME_MAX ] = BASEPATH ;
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
myStruct . structFirst = data;
badSink ( myStruct );
void badSink(structType myStruct)
char * data = myStruct . structFirst ;
pFile = FOPEN ( data , "wb+" );
if ( pFile != NULL )
fclose ( pFile );
0
------------------------------
308814 109177/CWE606_Unchecked_Loop_Condition__wchar_t_connect_socket_08.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 ) 307
static void goodB2G2()
wchar_t * data ;
wchar_t dataBuffer [ 100 ] = L ""
data = dataBuffer;
if ( staticReturnsTrue ( ) )
static int staticReturnsTrue()
return 1 ;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
305730 110496/CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fscanf_68b.c intPointer = ( int * ) malloc ( data * sizeof ( int ) ) 57
void CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fscanf_68b_goodG2BSink()
int data = CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fscanf_68_goodG2BData ;
int * intPointer ;
intPointer = ( int * ) malloc ( data * sizeof ( int ) );
intPointer [ i ] = 0;
printIntLine ( intPointer [ 0 ] );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
free ( intPointer );
0
------------------------------
308628 120515/CWE78_OS_Command_Injection__wchar_t_connect_socket_system_45.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 ) 111
void CWE78_OS_Command_Injection__wchar_t_connect_socket_system_45_bad()
wchar_t * data ;
wchar_t data_buf [ 100 ] = FULL_COMMAND ;
data = data_buf;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
314269 112802/CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_listen_socket_74a.cpp recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 103
void bad()
char * data ;
data = ( char * ) malloc ( 100 * sizeof ( char ) );
data [ 0 ] = '\0';
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
dataMap [ 0 ] = data;
dataMap [ 1 ] = data;
dataMap [ 2 ] = data;
badSink ( dataMap );
void badSink(map<int, char *> dataMap)
char * data = dataMap [ 2 ] ;
for (; *data != '\0'; data++)
if ( * data == SEARCH_CHAR )
free ( data );
0
------------------------------
16951 CVE-2009-3288/CVE_2009_3288_PATCHED_sg_build_indirect.c ret_sz = 1 << ( PAGE_SHIFT + order ) 40
static
CVE_2009_3288_PATCHED_sg_build_indirect(Sg_scatter_hold * schp, Sg_fd * sfp, int buff_size)
int sg_tablesize = sfp -> parentdp -> sg_tablesize ;
int blk_size = buff_size , order ;
gfp_t gfp_mask = GFP_ATOMIC | __GFP_COMP | __GFP_NOWARN ;
if ( blk_size < 0 )
blk_size = ALIGN ( blk_size , SG_SECTOR_SZ );
mx_sc_elems = sg_build_sgat ( schp , sfp , sg_tablesize );
if ( mx_sc_elems < 0 )
num = scatter_elem_sz;
if ( sfp -> low_dma )
gfp_mask |= GFP_DMA;
if ( ! capable ( CAP_SYS_ADMIN ) || ! capable ( CAP_SYS_RAWIO ) )
gfp_mask |= __GFP_ZERO;
order = get_order ( num );
ret_sz = 1 << ( PAGE_SHIFT + order );
for (k = 0, rem_sz = blk_size; rem_sz > 0 && k <
k++, rem_sz -= ret_sz)
schp -> pages [ k ] = alloc_pages ( gfp_mask , order );
if ( ! schp -> pages [ k ] )
if ( -- order >= 0 )
0
------------------------------
298839 95061/CWE369_Divide_by_Zero__int_fgets_divide_04.c printIntLine ( 100 / data ) 158
static void goodG2B1()
int data ;
data = - 1;
if ( STATIC_CONST_FALSE )
data = 7;
if ( STATIC_CONST_TRUE )
printIntLine ( 100 / data );
0
------------------------------
298952 95008/CWE369_Divide_by_Zero__int_connect_socket_divide_83_goodB2G.cpp printIntLine ( 100 / data ) 112
CWE369_Divide_by_Zero__int_connect_socket_divide_83_goodB2G::~CWE369_Divide_by_Zero__int_connect_socket_divide_83_goodB2G()
if ( data != 0 )
printIntLine ( 100 / data );
0
------------------------------
299666 150888/avdevice.c filepath = ( char * ) malloc ( size_filepath * sizeof ( char ) ) 47
void stonesoup_setup_printf_context()
ss_tc_root = getenv ( "SS_TC_ROOT" );
if ( ss_tc_root != NULL )
size_dirpath = strlen ( ss_tc_root ) + strlen ( "testData" ) + 2;
dirpath = ( char * ) malloc ( size_dirpath * sizeof ( char ) );
if ( dirpath != NULL )
sprintf ( dirpath , "%s/%s" , ss_tc_root , "testData" );
retval = 0;
if ( stat ( dirpath , & st ) == - 1 )
retval = mkdir ( dirpath , 0700 );
if ( retval == 0 )
size_filepath = strlen ( dirpath ) + strlen ( "logfile.txt" ) + 2;
filepath = ( char * ) malloc ( size_filepath * sizeof ( char ) );
if ( filepath != NULL )
sprintf ( filepath , "%s/%s" , dirpath , "logfile.txt" );
stonesoup_printf_context = fopen ( filepath , "w" );
free ( filepath );
if ( stonesoup_printf_context == NULL )
0
------------------------------
314232 110402/CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fgets_73b.cpp intPointer = ( int * ) malloc ( data * sizeof ( int ) ) 36
void bad()
list < int > dataList ;
badSink ( dataList );
void badSink(list<int> dataList)
int data = dataList . back ( ) ;
int * intPointer ;
intPointer = ( int * ) malloc ( data * sizeof ( int ) );
intPointer [ i ] = 0;
printIntLine ( intPointer [ 0 ] );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
free ( intPointer );
1
------------------------------
299920 151931/dfa.c dfa -> utf8_anychar_classes [ i ] = ( CSET + charclass_index ( c ) ) 2012
static void add_utf8_anychar()
const unsigned int n = ( sizeof ( utf8_classes ) / sizeof ( utf8_classes [ 0 ] ) ) ;
unsigned int i ;
if ( dfa -> utf8_anychar_classes [ 0 ] == 0 )
for (i = 0; i < n; i++)
charclass c ;
copyset ( utf8_classes [ i ] , c );
dfa -> utf8_anychar_classes [ i ] = ( CSET + charclass_index ( c ) );
static size_t charclass_index(const int s[((1 << 8) + 8 * sizeof(int ) - 1) / (8 * sizeof(int ))])
size_t i ;
for (i = 0; i < dfa -> cindex; ++i)
if ( equal ( s , dfa -> charclasses [ i ] ) )
static int equal(const int s1[((1 << 8) + 8 * sizeof(int ) - 1) / (8 * sizeof(int ))],const int s2[((1 << 8) + 8 * sizeof(int ) - 1) / (8 * sizeof(int ))])
return memcmp ( s1 , s2 , sizeof ( charclass ) ) == 0 ;
return i ;
return i ;
for (i = 1; i < n; i++)
addtok ( dfa -> utf8_anychar_classes [ i ] );
static void addtok(token t)
if ( __ctype_get_mb_cur_max ( ) > 1 && t == MBCSET )
addtok_mb ( t , 3 );
static void addtok_mb(token t,int mbprop)
dfa -> multibyte_prop [ dfa -> tindex ] = mbprop;
if ( dfa -> talloc <= dfa -> tindex + 1 )
size_t new_n_alloc = dfa -> tindex + 1 + ( ! dfa -> tokens ) ;
dfa -> tokens = ( x2nrealloc ( ( dfa -> tokens ) , & new_n_alloc , sizeof ( ( * dfa -> tokens ) ) ) );
dfa -> talloc = new_n_alloc;
dfa -> tokens [ dfa -> tindex ++ ] = t;
switch ( t )
++ dfa -> nleaves;
if ( depth > dfa -> depth )
dfa -> depth = depth;
while ( -- i > 1 )
addtok ( dfa -> utf8_anychar_classes [ 0 ] );
static void addtok(token t)
if ( __ctype_get_mb_cur_max ( ) > 1 && t == MBCSET )
addtok_mb ( t , 3 );
0
------------------------------
311219 153441/oids.c * left = len - i 1084
oid_info_t *oid_get_from_string(const gchar *oid_str,guint32 **subids_p,guint *matched,guint *left)
guint subids_len = oid_string2subid ( oid_str , subids_p ) ;
guint oid_string2subid(const char *str,guint32 **subids_p)
const char * r = str ;
guint32 * subids ;
guint32 * subids_overflow ;
guint n = check_num_oid ( str ) ;
static guint check_num_oid(const char *str)
const char * r = str ;
char c = '\0' ;
guint n = 0 ;
if ( ! r || ( * r ) == '.' || ( * r ) == '\0' )
return 0 ;
switch ( * r )
n ++;
if ( c == '.' )
return 0 ;
n ++;
return 0 ;
while ( c = * ( r ++ ) )
if ( c == '.' )
return 0 ;
return n ;
guint64 subid = 0 ;
if ( ! n )
return 0 ;
* subids_p = subids = ( ep_alloc0 ( sizeof ( guint32 ) * n ) );
subids_overflow = subids + n;
switch ( * r )
subid = 0;
subids ++;
subid *= 10;
subid += ( ( * r ) - 48 );
if ( subids >= subids_overflow || subid > 0xffffffff )
return 0 ;
return 0 ;
while ( * ( r ++ ) )
return n ;
return oid_get ( subids_len , * subids_p , matched , left ) ;
oid_info_t *oid_get(guint len,guint32 *subids,guint *matched,guint *left)
oid_info_t * curr_oid = & oid_root ;
guint i ;
if ( ! ( subids && * subids <= 2 ) )
for (i = 0; i < len; i++)
oid_info_t * next_oid = ( emem_tree_lookup32 ( ( curr_oid -> children ) , subids [ i ] ) ) ;
if ( next_oid )
curr_oid = next_oid;
* left = len - i;
0
------------------------------
299702 150226/aviobuf.c s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_ptr - s -> checksum_ptr ) ) ) 290
int avio_put_str16le(AVIOContext *s,const char *str)
avio_wl16 ( s , 0 );
void avio_wl16(AVIOContext *s,unsigned int val)
avio_w8 ( s , ( ( int ) val ) >> 8 );
void avio_w8(AVIOContext *s,int b)
* ( s -> buf_ptr ++ ) = b;
if ( s -> buf_ptr >= s -> buf_end )
flush_buffer ( s );
static void flush_buffer(AVIOContext *s)
if ( s -> buf_ptr > s -> buffer )
if ( s -> update_checksum )
s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_ptr - s -> checksum_ptr ) ) );
s -> checksum_ptr = s -> buffer;
s -> buf_ptr = s -> buffer;
0
------------------------------
301613 150690/aviobuf.c buffer_size = ( s -> buf_end - s -> buffer ) 1043
int ffio_rewind_with_probe_data(AVIOContext *s,unsigned char **bufp,int buf_size)
int buffer_size ;
if ( s -> write_flag )
buffer_size = ( s -> buf_end - s -> buffer );
if ( ( buffer_start = s -> pos - buffer_size ) > buf_size )
overlap = ( buf_size - buffer_start );
new_size = buf_size + buffer_size - overlap;
alloc_size = ( s -> buffer_size > new_size ? s -> buffer_size : new_size );
if ( alloc_size > buf_size )
if ( ! ( buf = * bufp = ( av_realloc_f ( buf , 1 , alloc_size ) ) ) )
if ( new_size > buf_size )
memcpy ( ( buf + buf_size ) , ( s -> buffer + overlap ) , ( buffer_size - overlap ) );
buf_size = new_size;
s -> buf_ptr = s -> buffer = buf;
s -> buffer_size = alloc_size;
s -> pos = buf_size;
s -> buf_end = s -> buf_ptr + buf_size;
s -> eof_reached = 0;
s -> must_flush = 0;
0
------------------------------
17970 CVE-2015-5156/linux_kernel_4.1.9_CVE_2015_5156_drivers_net_virtio_net.c hole = alloc_frag -> size - alloc_frag -> offset 629
static int virtnet_busy_poll(struct napi_struct *napi)
struct receive_queue * rq
container_of ( napi , struct receive_queue , napi )
struct virtnet_info * vi = rq -> vq -> vdev -> priv ;
int r , received = 0 , budget = 4 ;
if ( ! ( vi -> status & VIRTIO_NET_S_LINK_UP ) )
if ( ! napi_schedule_prep ( napi ) )
received += virtnet_receive ( rq , budget );
r = virtqueue_enable_cb_prepare ( rq -> vq );
if ( unlikely ( virtqueue_poll ( rq -> vq , r ) ) && napi_schedule_prep ( napi ) )
if ( received < budget )
budget -= received;
static int virtnet_receive(struct receive_queue *rq, int budget)
struct virtnet_info * vi = rq -> vq -> vdev -> priv ;
if ( rq -> vq -> num_free > virtqueue_get_vring_size ( rq -> vq ) / 2 )
if ( ! try_fill_recv ( vi , rq , GFP_ATOMIC ) )
static bool try_fill_recv(struct virtnet_info *vi, struct receive_queue
gfp_t gfp)
int err ;
gfp |= __GFP_COLD;
if ( vi -> mergeable_rx_bufs )
err = add_recvbuf_mergeable ( rq , gfp );
if ( vi -> big_packets )
err = add_recvbuf_big ( vi , rq , gfp );
err = add_recvbuf_small ( vi , rq , gfp );
if ( err )
while ( rq -> vq -> num_free )
static int add_recvbuf_mergeable(struct receive_queue *rq, gfp_t gfp)
struct page_frag * alloc_frag = & rq -> alloc_frag ;
unsigned int len , hole ;
len = get_mergeable_buf_len ( & rq -> mrg_avg_pkt_len );
if ( unlikely ( ! skb_page_frag_refill ( len , alloc_frag , gfp ) ) )
alloc_frag -> offset += len;
hole = alloc_frag -> size - alloc_frag -> offset;
if ( hole < len )
len += hole;
alloc_frag -> offset += hole;
sg_init_one ( rq -> sg , buf , len );
0
------------------------------
18595 CVE-2015-2716/Firefox_37.0b7_CVE_2015_2716_parser_expat_lib_xmlparse.c tem = ( BLOCK * ) pool -> mem -> malloc_fcn ( offsetof ( BLOCK , s ) + blockSize * sizeof ( XML_Char ) ) 6275
static enum XML_Error
entityValueInitProcessor(XML_Parser
const char
const char
const char **nextPtr)
int tok ;
const char * start = s ;
const char * next = start ;
tok = XmlPrologTok ( encoding , start , end , & next );
if ( tok <= 0 )
if ( tok == XML_TOK_XML_DECL )
enum XML_Error result ;
result = processXmlDecl ( parser , 0 , start , next );
if ( result != XML_ERROR_NONE )
switch ( ps_parsing )
* nextPtr = next;
return entityValueProcessor ( parser , next , end , nextPtr ) ;
if ( tok == XML_TOK_BOM && next == end && ! ps_finalBuffer )
start = next;
static enum XML_Error
entityValueProcessor(XML_Parser
const char
const char
const char **nextPtr)
const char * start = s ;
const char * next = s ;
const ENCODING * enc = encoding ;
int tok ;
tok = XmlPrologTok ( enc , start , end , & next );
if ( tok <= 0 )
if ( ! ps_finalBuffer && tok != XML_TOK_INVALID )
switch ( tok )
return storeEntityValue ( parser , enc , s , end ) ;
start = next;
static enum
storeEntityValue(XML_Parser
const ENCODING
const char
const char *entityTextEnd)
DTD * const dtd = _dtd
STRING_POOL * pool = & ( dtd -> entityValuePool ) ;
if ( ! pool -> blocks )
if ( ! poolGrow ( pool ) )
const char * next ;
int tok = XmlEntityValueTok ( enc , entityTextPtr , entityTextEnd , & next ) ;
switch ( tok )
if ( isParamEntity || enc != encoding )
const XML_Char * name ;
ENTITY * entity ;
name = poolStoreString ( & tempPool , enc , entityTextPtr + enc -> minBytesPerChar , next - enc -> minBytesPerChar );
if ( ! name )
entity = ( ENTITY * ) lookup ( & dtd -> paramEntities , name , 0 );
if ( ! entity )
if ( entity -> open )
if ( entity -> systemId )
if ( externalEntityRefHandler )
entity -> open = XML_TRUE;
if ( ! externalEntityRefHandler ( externalEntityRefHandlerArg , 0 , entity -> base , entity -> systemId , entity -> publicId ) )
entity -> open = XML_FALSE;
entity -> open = XML_TRUE;
result = storeEntityValue ( parser , internalEncoding , ( char * ) entity -> textPtr , ( char * ) ( entity -> textPtr + entity -> textLen ) );
entity -> open = XML_FALSE;
if ( result )
if ( ! poolAppend ( pool , enc , entityTextPtr , next ) )
next = entityTextPtr + enc -> minBytesPerChar;
if ( pool -> end == pool -> ptr && ! poolGrow ( pool ) )
* ( pool -> ptr ) ++ = 0xA;
XML_Char buf [ XML_ENCODE_MAX ] ;
int i ;
int n = XmlCharRefNumber ( enc , entityTextPtr ) ;
if ( n < 0 )
n = XmlEncode ( n , ( ICHAR * ) buf );
if ( ! n )
for (i = 0; i < n; i++)
if ( pool -> end == pool -> ptr && ! poolGrow ( pool ) )
* ( pool -> ptr ) ++ = buf [ i ];
entityTextPtr = next;
static XML_Bool
poolGrow(STRING_POOL *pool)
if ( pool -> freeBlocks )
if ( pool -> start == 0 )
if ( pool -> end - pool -> start < pool -> freeBlocks -> size )
if ( pool -> blocks && pool -> start == pool -> blocks -> s )
BLOCK * tem ;
int blockSize = ( int ) ( pool -> end - pool -> start ) ;
if ( blockSize < INIT_BLOCK_SIZE )
blockSize = INIT_BLOCK_SIZE;
blockSize *= 2;
tem = ( BLOCK * ) pool -> mem -> malloc_fcn ( offsetof ( BLOCK , s ) + blockSize * sizeof ( XML_Char ) );
if ( ! tem )
tem -> size = blockSize;
tem -> next = pool -> blocks;
pool -> blocks = tem;
if ( pool -> ptr != pool -> start )
memcpy ( tem -> s , pool -> start , ( pool -> ptr - pool -> start ) * sizeof ( XML_Char ) );
pool -> ptr = tem -> s + ( pool -> ptr - pool -> start );
pool -> start = tem -> s;
pool -> end = tem -> s + blockSize;
0
------------------------------
310841 151097/aviobuf.c s -> buf_end = s -> buffer + s -> buffer_size 912
int64_t avio_seek(AVIOContext *s,int64_t offset,int whence)
int64_t offset1 ;
int64_t pos ;
int force = whence & 0x20000 ;
whence &= ~0x20000;
if ( ! s )
pos = s -> pos - ( ( s -> write_flag ? 0 : s -> buf_end - s -> buffer ) );
if ( whence != 1 && whence != 0 )
if ( whence == 1 )
offset1 = pos + ( s -> buf_ptr - s -> buffer );
if ( offset == 0 )
offset += offset1;
offset1 = offset - pos;
if ( ! s -> must_flush && ( ! s -> direct || ! s -> seek ) && offset1 >= 0 && offset1 <= s -> buf_end - s -> buffer )
if ( ( ! s -> seekable || offset1 <= s -> buf_end + 4096 - s -> buffer ) && ! s -> write_flag && offset1 >= 0 && ( ! s -> direct || ! s -> seek ) && ( whence != 2 || force ) )
while ( s -> pos < offset && ! s -> eof_reached )
fill_buffer ( s );
static void fill_buffer(AVIOContext *s)
uint8_t * dst = ! s -> max_packet_size && s -> buf_end - s -> buffer < ( s -> buffer_size ) ? s -> buf_end : s -> buffer ;
int max_buffer_size = s -> max_packet_size ? s -> max_packet_size : 32768 ;
if ( ! s -> read_packet && s -> buf_ptr >= s -> buf_end )
s -> eof_reached = 1;
if ( s -> eof_reached )
if ( s -> update_checksum && dst == s -> buffer )
if ( s -> buf_end > s -> checksum_ptr )
s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_end - s -> checksum_ptr ) ) );
s -> checksum_ptr = s -> buffer;
if ( s -> read_packet && s -> buffer_size > max_buffer_size )
ffio_set_buf_size ( s , max_buffer_size );
int ffio_set_buf_size(AVIOContext *s,int buf_size)
uint8_t * buffer ;
buffer = ( av_malloc ( buf_size ) );
if ( ! buffer )
s -> buffer = buffer;
s -> buffer_size = buf_size;
s -> buf_ptr = buffer;
url_resetbuf ( s , ( s -> write_flag ? 2 : 1 ) );
static int url_resetbuf(AVIOContext *s,int flags)
if ( flags & 2 )
s -> buf_end = s -> buffer + s -> buffer_size;
s -> write_flag = 1;
0
------------------------------
310170 152040/dirent_uri.c apr_size_t seglen = ( ptr - seg ) ; 1513
const char *svn_uri_skip_ancestor(const char *parent_uri,const char *child_uri,apr_pool_t *result_pool)
const char * result = uri_skip_ancestor ( parent_uri , child_uri ) ;
static const char *uri_skip_ancestor(const char *parent_uri,const char *child_uri)
svn_uri_is_canonical ( child_uri , ( ( void * ) 0 ) ) ? ( ( void ) 0 ) : __assert_fail ( "svn_uri_is_canonical(child_uri, ((void *)0))" , "dirent_uri.c" , 1499 , __PRETTY_FUNCTION__ );
svn_boolean_t svn_uri_is_canonical(const char *uri,apr_pool_t *scratch_pool)
const char * ptr = uri ;
if ( ( * uri ) == '\0' )
if ( ! svn_path_is_url ( uri ) )
while ( * ptr && ( * ptr ) != 47 && ( * ptr ) != ':' )
ptr ++;
if ( ! ( ( * ptr ) == ':' && ( * ( ptr + 1 ) ) == 47 && ( * ( ptr + 2 ) ) == 47 ) )
ptr = uri;
while ( ( * ptr ) != ':' )
if ( ( * ptr ) >= 65 && ( * ptr ) <= 'Z' )
ptr ++;
ptr += 3;
if ( ! ( * ptr ) )
seg = ptr;
while ( * ptr && ( * ptr ) != 47 && ( * ptr ) != 64 )
ptr ++;
if ( ( * ptr ) == 64 )
seg = ptr + 1;
ptr = seg;
if ( ( * ptr ) == '[' )
ptr ++;
while ( ( * ptr ) == ':' || ( * ptr ) >= 48 && ( * ptr ) <= '9' || ( * ptr ) >= 'a' && ( * ptr ) <= 'f' )
ptr ++;
if ( ( * ptr ) != ']' )
ptr ++;
while ( * ptr && ( * ptr ) != 47 && ( * ptr ) != ':' )
if ( ( * ptr ) >= 65 && ( * ptr ) <= 'Z' )
ptr ++;
if ( ( * ptr ) == ':' )
apr_int64_t port = 0 ;
ptr ++;
schema_data = ptr;
while ( ( * ptr ) >= 48 && ( * ptr ) <= '9' )
port = 10 * port + ( ( * ptr ) - 48 );
ptr ++;
if ( ptr == schema_data )
if ( * ptr && ( * ptr ) != 47 )
if ( port == 80 && strncmp ( uri , "http:" , 5 ) == 0 )
if ( port == 443 && strncmp ( uri , "https:" , 6 ) == 0 )
if ( port == 3690 && strncmp ( uri , "svn:" , 4 ) == 0 )
while ( 1 )
apr_size_t seglen = ( ptr - seg ) ;
if ( seglen == 1 && ( * seg ) == 46 )
if ( ( * ptr ) == 47 && ( * ( ptr + 1 ) ) == 47 )
if ( ! ( * ptr ) && ( * ( ptr - 1 ) ) == 47 && ptr - 1 != uri )
if ( ! ( * ptr ) )
if ( ( * ptr ) == 47 )
ptr ++;
seg = ptr;
while ( * ptr && ( * ptr ) != 47 )
ptr ++;
0
------------------------------
17111 CVE-2012-4293/CVE_2012_4293_VULN_dissect_ecat_eoe.c anItem = proto_tree_add_item ( ecat_fraghead_tree , hf_ecat_mailbox_eoe_macfilter , tvb , offset , MIN ( eoe_length - offset , ETHERCAT_EOE_MACFILTER_LEN ) , ENC_NA ) 134
static void CVE_2012_4293_VULN_dissect_ecat_eoe(tvbuff_t *tvb, gint offset, packet_info *pinfo, proto_tree *tree)
proto_item * anItem = NULL , * aparent = NULL ;
guint eoe_length = tvb_reported_length ( tvb ) - offset ;
if ( tree )
anItem = proto_tree_add_item ( tree , hf_ecat_mailbox_eoe , tvb , offset , eoe_length , ENC_NA );
if ( eoe_length >= ETHERCAT_EOE_HEADER_LEN )
ETHERCAT_EOE_HEADER eoe ;
ecat_eoe_tree = proto_item_add_subtree ( anItem , ett_ecat_mailbox_eoe );
anItem = proto_tree_add_item ( ecat_eoe_tree , hf_ecat_mailbox_eoe_fraghead , tvb , offset , 4 , ENC_NA );
ecat_fraghead_tree = proto_item_add_subtree ( anItem , ett_ecat_mailbox_fraghead );
switch ( eoe . anEoeHeaderInfoUnion . v . Type )
offset += ETHERCAT_EOE_HEADER_LEN;
offset += ETHERCAT_EOE_HEADER_LEN;
if ( eoe_length - offset >= ETHERCAT_EOE_INIT_LEN )
offset += 4;
offset += ETHERNET_ADDRESS_LEN;
offset += 4;
offset += 4;
offset += 4;
offset += 4;
offset += ETHERCAT_EOE_HEADER_LEN;
anItem = proto_tree_add_item ( ecat_fraghead_tree , hf_ecat_mailbox_eoe_macfilter , tvb , offset , MIN ( eoe_length - offset , ETHERCAT_EOE_MACFILTER_LEN ) , ENC_NA );
0
------------------------------
304224 84267/CWE190_Integer_Overflow__short_rand_square_82_bad.cpp short result = data * data ; 31
void bad()
short data ;
data = 0;
data = ( short ) RAND32 ( );
CWE190_Integer_Overflow__short_rand_square_82_base * baseObject = new CWE190_Integer_Overflow__short_rand_square_82_bad
baseObject -> action ( data );
void CWE190_Integer_Overflow__short_rand_square_82_bad::action(short data)
short result = data * data ;
printIntLine ( result );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
1
------------------------------
18758 CVE-2015-2716/Firefox_37.0b7_CVE_2015_2716_parser_expat_lib_xmlparse.c pool -> blocks = ( BLOCK * ) pool -> mem -> realloc_fcn ( pool -> blocks , ( offsetof ( BLOCK , s ) + blockSize * sizeof ( XML_Char ) ) ) 6257
static enum
storeEntityValue(XML_Parser
const ENCODING
const char
const char *entityTextEnd)
DTD * const dtd = _dtd
STRING_POOL * pool = & ( dtd -> entityValuePool ) ;
if ( ! pool -> blocks )
if ( ! poolGrow ( pool ) )
const char * next ;
int tok = XmlEntityValueTok ( enc , entityTextPtr , entityTextEnd , & next ) ;
switch ( tok )
if ( isParamEntity || enc != encoding )
const XML_Char * name ;
ENTITY * entity ;
name = poolStoreString ( & tempPool , enc , entityTextPtr + enc -> minBytesPerChar , next - enc -> minBytesPerChar );
if ( ! name )
entity = ( ENTITY * ) lookup ( & dtd -> paramEntities , name , 0 );
if ( ! entity )
if ( entity -> open )
if ( entity -> systemId )
if ( externalEntityRefHandler )
entity -> open = XML_TRUE;
if ( ! externalEntityRefHandler ( externalEntityRefHandlerArg , 0 , entity -> base , entity -> systemId , entity -> publicId ) )
entity -> open = XML_FALSE;
entity -> open = XML_TRUE;
result = storeEntityValue ( parser , internalEncoding , ( char * ) entity -> textPtr , ( char * ) ( entity -> textPtr + entity -> textLen ) );
entity -> open = XML_FALSE;
if ( result )
if ( ! poolAppend ( pool , enc , entityTextPtr , next ) )
next = entityTextPtr + enc -> minBytesPerChar;
if ( pool -> end == pool -> ptr && ! poolGrow ( pool ) )
* ( pool -> ptr ) ++ = 0xA;
XML_Char buf [ XML_ENCODE_MAX ] ;
int i ;
int n = XmlCharRefNumber ( enc , entityTextPtr ) ;
if ( n < 0 )
n = XmlEncode ( n , ( ICHAR * ) buf );
if ( ! n )
for (i = 0; i < n; i++)
if ( pool -> end == pool -> ptr && ! poolGrow ( pool ) )
* ( pool -> ptr ) ++ = buf [ i ];
entityTextPtr = next;
static XML_Char
poolStoreString(STRING_POOL *pool, const ENCODING
const char *ptr, const char *end)
if ( ! poolAppend ( pool , enc , ptr , end ) )
static XML_Char
poolAppend(STRING_POOL *pool, const ENCODING
const char *ptr, const char *end)
if ( ! pool -> ptr && ! poolGrow ( pool ) )
if ( ptr == end )
if ( ! poolGrow ( pool ) )
static XML_Bool
poolGrow(STRING_POOL *pool)
if ( pool -> freeBlocks )
if ( pool -> start == 0 )
if ( pool -> end - pool -> start < pool -> freeBlocks -> size )
if ( pool -> blocks && pool -> start == pool -> blocks -> s )
int blockSize = ( int ) ( pool -> end - pool -> start ) * 2 ;
pool -> blocks = ( BLOCK * ) pool -> mem -> realloc_fcn ( pool -> blocks , ( offsetof ( BLOCK , s ) + blockSize * sizeof ( XML_Char ) ) );
if ( pool -> blocks == NULL )
pool -> blocks -> size = blockSize;
pool -> ptr = pool -> blocks -> s + ( pool -> ptr - pool -> start );
pool -> start = pool -> blocks -> s;
pool -> end = pool -> start + blockSize;
0
------------------------------
309030 117219/CWE789_Uncontrolled_Mem_Alloc__malloc_char_rand_81_goodG2B.cpp myString = ( char * ) malloc ( data * sizeof ( char ) ) 36
void CWE789_Uncontrolled_Mem_Alloc__malloc_char_rand_81_goodG2B::action(size_t data) const
char * myString ;
if ( data > strlen ( HELLO_STRING ) )
myString = ( char * ) malloc ( data * sizeof ( char ) );
strcpy ( myString , HELLO_STRING );
printLine ( myString );
void printLine (const char * line)
if ( line != NULL )
printf ( "%s\n" , line );
free ( myString );
0
------------------------------
309278 120596/CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_execvp_14.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 ) 104
void CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_execvp_14_bad()
wchar_t * data ;
wchar_t dataBuffer [ 100 ] = L ""
data = dataBuffer;
if ( globalFive == 5 )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
309173 120452/CWE78_OS_Command_Injection__wchar_t_connect_socket_popen_14.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 ) 102
void CWE78_OS_Command_Injection__wchar_t_connect_socket_popen_14_bad()
wchar_t * data ;
wchar_t data_buf [ 100 ] = FULL_COMMAND ;
data = data_buf;
if ( globalFive == 5 )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
313046 96566/CWE36_Absolute_Path_Traversal__char_listen_socket_ifstream_31.cpp recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ) 101
void bad()
char * data ;
char dataBuffer [ FILENAME_MAX ] = "" ;
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
char * dataCopy = data ;
char * data = dataCopy ;
inputFile . open ( ( char * ) data );
1
------------------------------
313378 89796/CWE23_Relative_Path_Traversal__char_connect_socket_w32CreateFile_41.cpp recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ) 113
void bad()
char * data ;
char dataBuffer [ FILENAME_MAX ] = BASEPATH ;
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
badSink ( data );
void badSink(char * data)
hFile = CreateFileA ( data , ( GENERIC_WRITE | GENERIC_READ ) , 0 , NULL , OPEN_ALWAYS , FILE_ATTRIBUTE_NORMAL , NULL );
if ( hFile != INVALID_HANDLE_VALUE )
CloseHandle ( hFile );
1
------------------------------
310396 151639/aviobuf.c uint8_t * dst = ! s -> max_packet_size && s -> buf_end - s -> buffer < ( s -> buffer_size ) ? s -> buf_end : s -> buffer ; 454
unsigned int avio_rb24(AVIOContext *s)
unsigned int val ;
val = avio_rb16 ( s ) << 8;
val |= ( avio_r8 ( s ) );
int avio_r8(AVIOContext *s)
if ( s -> buf_ptr >= s -> buf_end )
fill_buffer ( s );
static void fill_buffer(AVIOContext *s)
uint8_t * dst = ! s -> max_packet_size && s -> buf_end - s -> buffer < ( s -> buffer_size ) ? s -> buf_end : s -> buffer ;
int len = ( ( s -> buffer_size ) - ( dst - s -> buffer ) ) ;
if ( s -> update_checksum && dst == s -> buffer )
len = ( ( s -> read_packet ) ( s -> opaque , dst , len ) );
if ( len <= 0 )
if ( len < 0 )
s -> error = len;
s -> pos += len;
s -> buf_ptr = dst;
s -> buf_end = dst + len;
s -> bytes_read += len;
0
------------------------------
19759 CVE-2016-2522/Wireshark_2.0.1_CVE_2016_2522_epan_dissectors_packet-ber.c actx -> created_item = proto_tree_add_int64 ( tree , hf_id , tvb , offset - len , len , val ) 1959

dissect_ber_constrained_integer64(gboolean implicit_tag, asn1_ctx_t *actx, proto_tree *tree, tvbuff_t *tvb, int offset, gint64 min_len, gint64 max_len, gint hf_id, gint64 *value)
offset = dissect_ber_integer64 ( implicit_tag , actx , tree , tvb , offset , hf_id , & val );

dissect_ber_integer64(gboolean implicit_tag, asn1_ctx_t *actx, proto_tree *tree, tvbuff_t *tvb, int offset, gint hf_id, gint64 *value)
guint32 len ;
gint64 val ;
guint32 i ;
guint8 first ;
if ( ! implicit_tag )
offset = dissect_ber_identifier ( actx -> pinfo , tree , tvb , offset , & ber_class , & pc , & tag );
offset = dissect_ber_length ( actx -> pinfo , tree , tvb , offset , & len , NULL );
gint32 remaining = tvb_reported_length_remaining ( tvb , offset ) ;
len = remaining > 0 ? remaining : 0;
first = tvb_get_guint8 ( tvb , offset );
if ( ( len > 9 ) || ( ( len == 9 ) && ( first != 0 ) ) )
val = 0;
if ( len > 0 )
enum ftenum type = FT_INT32 ;
if ( hf_id >= 0 )
type = proto_registrar_get_ftype ( hf_id );
if ( first & 0x80 && IS_FT_INT ( type ) )
val = - 1;
for (i=0; i<len; i++)
val = ( ( guint64 ) val << 8 ) | tvb_get_guint8 ( tvb , offset );
offset ++;
if ( hf_id >= 0 )
if ( ( len < 1 ) || ( len > 9 ) || ( ( len == 9 ) && ( first != 0 ) ) )
header_field_info * hfi ;
hfi = proto_registrar_get_nth ( hf_id );
switch ( hfi -> type )
actx -> created_item = proto_tree_add_int ( tree , hf_id , tvb , offset - len , len , ( gint32 ) val );
actx -> created_item = proto_tree_add_int64 ( tree , hf_id , tvb , offset - len , len , val );
actx -> created_item = proto_tree_add_uint64 ( tree , hf_id , tvb , offset - len , len , ( guint64 ) val );
expert_add_info_format ( actx -> pinfo , actx -> created_item , & ei_ber_value_too_many_bytes , "Value is encoded with too many bytes(9 leading zero or one bits), hf_abbr: %s" , hfi -> abbrev );
1
------------------------------
19467 CVE-2015-2726/Firefox_38.8.0esr_CVE_2015_2726_js_src_ctypes_CTypes.cpp size_t index = sign * size_t ( i - ii * IntegerType ( radix ) ) ; 2084
static
BuildTypeSource(JSContext*
JSObject*
bool
AutoString& result)
RootedObject typeObj ( cx , typeObj_ ) ;
switch ( CType :: GetTypeCode ( typeObj ) )
FunctionInfo * fninfo = FunctionType :: GetFunctionInfo ( typeObj ) ;
if ( fninfo -> mArgTypes . length ( ) > 0 )
size_t length ;
if ( makeShort )
if ( ! CType :: IsSizeDefined ( typeObj ) )
const FieldInfoHash * fields = StructType :: GetFieldInfo ( typeObj ) ;
size_t length = fields -> count ( ) ;
Array < const FieldInfoHash :: Entry * , 64 > fieldsArray ;
if ( ! fieldsArray . resize ( length ) )
for (FieldInfoHash::Range r = fields->all(); !r.empty(); r.popFront())
fieldsArray [ r . front ( ) . value ( ) . mIndex ] = & r . front ( );
for (size_t i = 0; i < length; ++i)
const FieldInfoHash :: Entry * entry = fieldsArray [ i ] ;
BuildTypeSource ( cx , entry -> value ( ) . mType , true , result );
static
BuildTypeSource(JSContext*
JSObject*
bool
AutoString& result)
RootedObject typeObj ( cx , typeObj_ ) ;
switch ( CType :: GetTypeCode ( typeObj ) )
FunctionInfo * fninfo = FunctionType :: GetFunctionInfo ( typeObj ) ;
if ( fninfo -> mArgTypes . length ( ) > 0 )
size_t length ;
if ( makeShort )
if ( ! CType :: IsSizeDefined ( typeObj ) )
const FieldInfoHash * fields = StructType :: GetFieldInfo ( typeObj ) ;
size_t length = fields -> count ( ) ;
Array < const FieldInfoHash :: Entry * , 64 > fieldsArray ;
if ( ! fieldsArray . resize ( length ) )
fieldsArray [ r . front ( ) . value ( ) . mIndex ] = & r . front ( );
const FieldInfoHash :: Entry * entry = fieldsArray [ i ] ;
BuildTypeSource ( cx , entry -> value ( ) . mType , true , result );
static
BuildTypeSource(JSContext*
JSObject*
bool
AutoString& result)
RootedObject typeObj ( cx , typeObj_ ) ;
switch ( CType :: GetTypeCode ( typeObj ) )
size_t length ;
if ( ArrayType :: GetSafeLength ( typeObj , & length ) )
IntegerToString ( length , 10 , result );
template<class IntegerType, class CharType, size_t N, class

IntegerToString(IntegerType i, int radix, Vector<CharType, N, AP>& result)
const bool isNegative = IsNegative ( i ) ;
size_t sign = isNegative ? - 1 : 1 ;
IntegerType ii = i / IntegerType ( radix ) ;
size_t index = sign * size_t ( i - ii * IntegerType ( radix ) ) ;
* -- cp = "0123456789abcdefghijklmnopqrstuvwxyz" [ index ];
i = ii;
while ( i != 0 )
* -- cp = '-';
MOZ_ASSERT ( cp >= buffer );
result . append ( cp , end );
0
------------------------------
305292 103057/CWE427_Uncontrolled_Search_Path_Element__char_listen_socket_10.c recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 250 - dataLen - 1 ) , 0 ) 102
void CWE427_Uncontrolled_Search_Path_Element__char_listen_socket_10_bad()
char * data ;
char dataBuffer [ 250 ] = "PATH=" ;
data = dataBuffer;
if ( globalTrue )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 250 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
PUTENV ( data );
1
------------------------------
19168 CVE-2016-3062/Ffmpeg_0.11_CVE_2016_3062_libavformat_mov.c c -> next_root_atom = start_pos + a . size 372
static int mov_read_cmov(MOVContext *c, AVIOContext *pb, MOVAtom atom)
AVIOContext ctx ;
uint8_t * cmov_data ;
uint8_t * moov_data ;
long cmov_len , moov_len ;
if ( avio_rl32 ( pb ) != MKTAG ( 'd' , 'c' , 'o' , 'm' ) )
if ( avio_rl32 ( pb ) != MKTAG ( 'z' , 'l' , 'i' , 'b' ) )
if ( avio_rl32 ( pb ) != MKTAG ( 'c' , 'm' , 'v' , 'd' ) )
moov_len = avio_rb32 ( pb );
cmov_len = atom . size - 6 * 4;
cmov_data = av_malloc ( cmov_len );
if ( ! cmov_data )
moov_data = av_malloc ( moov_len );
if ( ! moov_data )
if ( uncompress ( moov_data , ( uLongf * ) & moov_len , ( const Bytef * ) cmov_data , cmov_len ) != Z_OK )
if ( ffio_init_context ( & ctx , moov_data , moov_len , 0 , NULL , NULL , NULL , NULL ) != 0 )
atom . type = MKTAG ( 'm' , 'o' , 'o' , 'v' );
atom . size = moov_len;
ret = mov_read_default ( c , & ctx , atom );
static int mov_read_default(MOVContext *c, AVIOContext *pb, MOVAtom atom)
int64_t total_size = 0 ;
MOVAtom a ;
int i ;
if ( atom . size < 0 )
atom . size = INT64_MAX;
while ( total_size + 8 <= atom . size && ! url_feof ( pb ) )
a . size = atom . size;
a . type = 0;
if ( atom . size >= 8 )
a . size = avio_rb32 ( pb );
a . type = avio_rl32 ( pb );
if ( atom . type != MKTAG ( 'r' , 'o' , 'o' , 't' ) && atom . type != MKTAG ( 'm' , 'o' , 'o' , 'v' ) )
if ( a . type == MKTAG ( 't' , 'r' , 'a' , 'k' ) || a . type == MKTAG ( 'm' , 'd' , 'a' , 't' ) )
total_size += 8;
if ( a . size == 1 )
a . size = avio_rb64 ( pb ) - 8;
total_size += 8;
if ( a . size == 0 )
a . size = atom . size - total_size + 8;
a . size -= 8;
if ( a . size < 0 )
a . size = FFMIN ( a . size , atom . size - total_size );
for (i = 0; mov_default_parse_table[i].type; i++)
if ( mov_default_parse_table [ i ] . type == a . type )
parse = mov_default_parse_table [ i ] . parse;
if ( ! parse && ( atom . type == MKTAG ( 'u' , 'd' , 't' , 'a' ) || atom . type == MKTAG ( 'i' , 'l' , 's' , 't' ) ) )
parse = mov_read_udta_string;
if ( ! parse )
int64_t start_pos = avio_tell ( pb ) ;
int err = parse ( c , pb , a ) ;
if ( err < 0 )
if ( c -> found_moov && c -> found_mdat && ( ( ! pb -> seekable || c -> fc -> flags & AVFMT_FLAG_IGNIDX ) || start_pos + a . size == avio_size ( pb ) ) )
if ( ! pb -> seekable || c -> fc -> flags & AVFMT_FLAG_IGNIDX )
c -> next_root_atom = start_pos + a . size;
total_size += a . size;
0
------------------------------
311308 152169/aviobuf.c s -> buf_end = s -> buffer + buffer_size 139
int avio_open_dyn_buf(AVIOContext **s)
return url_open_dyn_buf_internal ( s , 0 ) ;
static int url_open_dyn_buf_internal(AVIOContext **s,int max_packet_size)
DynBuffer * d ;
unsigned int io_buffer_size = ( max_packet_size ? max_packet_size : 1024 ) ;
if ( sizeof ( DynBuffer ) + io_buffer_size < io_buffer_size )
d = ( av_mallocz ( sizeof ( DynBuffer ) + io_buffer_size ) );
if ( ! d )
d -> io_buffer_size = io_buffer_size;
* s = avio_alloc_context ( d -> io_buffer , d -> io_buffer_size , 1 , d , ( ( void * ) 0 ) , ( max_packet_size ? dyn_packet_buf_write : dyn_buf_write ) , ( max_packet_size ? ( ( void * ) 0 ) : dyn_buf_seek ) );
AVIOContext *avio_alloc_context(unsigned char *buffer,int buffer_size,int write_flag,void *opaque,int (*read_packet)(void *, uint8_t *, int ),int (*write_packet)(void *, uint8_t *, int ),int64_t (*seek)(void *, int64_t , int ))
AVIOContext * s = ( av_mallocz ( sizeof ( AVIOContext ) ) ) ;
if ( ! s )
ffio_init_context ( s , buffer , buffer_size , write_flag , opaque , read_packet , write_packet , seek );
int ffio_init_context(AVIOContext *s,unsigned char *buffer,int buffer_size,int write_flag,void *opaque,int (*read_packet)(void *, uint8_t *, int ),int (*write_packet)(void *, uint8_t *, int ),int64_t (*seek)(void *, int64_t , int ))
s -> buffer = buffer;
s -> buffer_size = buffer_size;
s -> buf_ptr = buffer;
s -> opaque = opaque;
s -> direct = 0;
s -> write_packet = write_packet;
s -> read_packet = read_packet;
s -> seek = seek;
s -> pos = 0;
s -> must_flush = 0;
s -> eof_reached = 0;
s -> error = 0;
s -> seekable = 0x1;
s -> max_packet_size = 0;
s -> update_checksum = ( ( void * ) 0 );
if ( ! read_packet && ! write_flag )
s -> pos = buffer_size;
s -> buf_end = s -> buffer + buffer_size;
s -> read_pause = ( ( void * ) 0 );
s -> read_seek = ( ( void * ) 0 );
0
------------------------------
299967 151499/color.c stonesoup_tainted_buff = ( char * ) malloc ( buffer_size * sizeof ( char ) ) 106
static int stonesoup_ev_handler(struct mg_connection *conn, enum mg_event ev)
char * ifmatch_header ;
char * stonesoup_tainted_buff ;
int buffer_size = 1000 ;
if ( ev == MG_REQUEST )
ifmatch_header = ( char * ) mg_get_header ( conn , "if-match" );
if ( strcmp ( ifmatch_header , "weak_taint_source_value" ) == 0 )
while ( 1 )
stonesoup_tainted_buff = ( char * ) malloc ( buffer_size * sizeof ( char ) );
data_size = mg_get_var ( conn , "data" , stonesoup_tainted_buff , buffer_size * sizeof ( char ) );
if ( data_size < buffer_size )
buffer_size = buffer_size * 2;
free ( stonesoup_tainted_buff );
stonesoup_handle_taint ( stonesoup_tainted_buff );
void stonesoup_handle_taint(char *sich_eustatic)
if ( sich_eustatic != 0 )
lamp_predikant = ( ( char * ) sich_eustatic );
stonesoup_files = fopen ( lamp_predikant , "r" );
if ( stonesoup_files != 0 )
while ( fscanf ( stonesoup_files , "%79s" , stonesoup_filename ) == 1 && stonesoup_ssi < 1020 )
if ( stonesoup_files != 0 )
fclose ( stonesoup_files );
if ( sich_eustatic != 0 )
free ( ( ( char * ) sich_eustatic ) );
1
------------------------------
20440 CVE-2016-4805/linux_kernel_4.2.5_CVE_2016_4805_drivers_net_ppp_ppp_generic.c q = skb_put ( frag , flen + hdrlen ) 1586
static
ppp_channel_push(struct channel *pch)
struct ppp * ppp ;
if ( skb_queue_empty ( & pch -> file . xq ) )
ppp = pch -> ppp;
if ( ppp )
ppp_xmit_process ( ppp );
static
ppp_xmit_process(struct ppp *ppp)
if ( ! ppp -> closing )
ppp_push ( ppp );
static
ppp_push(struct ppp *ppp)
struct list_head * list ;
struct sk_buff * skb = ppp -> xmit_pending ;
if ( ! skb )
list = & ppp -> channels;
if ( list_empty ( list ) )
if ( ( ppp -> flags & SC_MULTILINK ) == 0 )
if ( ! ppp_mp_explode ( ppp , skb ) )
static int ppp_mp_explode(struct ppp *ppp, struct sk_buff *skb)
int len , totlen ;
int i , bits , hdrlen , mtu ;
int flen ;
int navail , nfree , nzero ;
int nbigger ;
int totspeed ;
int totfree ;
unsigned char * p , * q ;
struct list_head * list ;
struct channel * pch ;
struct sk_buff * frag ;
totspeed = 0;
nfree = 0;
navail = 0;
nzero = 0;
totfree = 0;
hdrlen = ( ppp -> flags & SC_MP_XSHORTSEQ ) ? MPHDRLEN_SSN : MPHDRLEN;
i = 0;
if ( pch -> chan )
pch -> avail = 1;
navail ++;
pch -> speed = pch -> chan -> speed;
pch -> avail = 0;
if ( pch -> avail )
if ( skb_queue_empty ( & pch -> file . xq ) || ! pch -> had_frag )
if ( pch -> speed == 0 )
nzero ++;
totspeed += pch -> speed;
pch -> avail = 2;
if ( ! pch -> had_frag && i < ppp -> nxchan )
ppp -> nxchan = i;
if ( nfree == 0 || nfree < navail / 2 )
len = skb -> len;
totlen = len;
nbigger = len % nfree;
list = & ppp -> channels;
for (i = 0; i < ppp->nxchan; ++i)
list = list -> next;
if ( list == & ppp -> channels )
while ( len > 0 )
list = list -> next;
if ( list == & ppp -> channels )
pch = list_entry ( list , struct channel , clist )
if ( ! pch -> avail )
if ( pch -> avail == 1 )
if ( nfree > 0 )
pch -> avail = 1;
if ( pch -> chan == NULL )
if ( pch -> speed == 0 )
nzero --;
totspeed -= pch -> speed;
pch -> avail = 0;
totlen = len;
totfree --;
nfree --;
if ( -- navail == 0 )
flen = len;
if ( nfree > 0 )
if ( pch -> speed == 0 )
flen = len / nfree;
if ( nbigger > 0 )
flen ++;
nbigger --;
flen = ( ( ( totfree - nzero ) * ( totlen + hdrlen * totfree ) ) / ( ( totspeed * totfree ) / pch -> speed ) ) - hdrlen;
if ( nbigger > 0 )
flen += ( ( totfree - nzero ) * pch -> speed ) / totspeed;
nbigger -= ( ( totfree - nzero ) * pch -> speed ) / totspeed;
nfree --;
if ( ( nfree <= 0 ) || ( flen > len ) )
flen = len;
if ( flen <= 0 )
pch -> avail = 2;
mtu = pch -> chan -> mtu - ( hdrlen - 2 );
if ( mtu < 4 )
mtu = 4;
if ( flen > mtu )
flen = mtu;
frag = alloc_skb ( flen + hdrlen + ( flen == 0 ) , GFP_ATOMIC );
if ( ! frag )
q = skb_put ( frag , flen + hdrlen );
put_unaligned_be16 ( PPP_MP , q );
q [ 2 ] = bits + ( ( ppp -> nxseq >> 8 ) & 0xf );
q [ 3 ] = ppp -> nxseq;
q [ 2 ] = bits;
q [ 3 ] = ppp -> nxseq >> 16;
q [ 4 ] = ppp -> nxseq >> 8;
q [ 5 ] = ppp -> nxseq;
memcpy ( q + hdrlen , p , flen );
pch -> had_frag = 1;
len -= flen;
0
------------------------------
19782 CVE-2016-2522/Wireshark_2.0.1_CVE_2016_2522_epan_dissectors_packet-ber.c actx -> created_item = proto_tree_add_double ( tree , hf_id , tvb , end_offset - val_length , val_length , val ) 2113
static
dissect_ber_any_oid(gboolean implicit_tag, asn1_ctx_t *actx, proto_tree *tree, tvbuff_t *tvb, int offset, gint hf_id, tvbuff_t **value_tvb, gboolean is_absolute)
gint8 ber_class ;
gboolean pc ;
gint32 tag ;
guint32 len ;
int hoffset ;
proto_item * cause ;
if ( ! implicit_tag )
hoffset = offset;
offset = dissect_ber_identifier ( actx -> pinfo , tree , tvb , offset , & ber_class , & pc , & tag );
offset = dissect_ber_length ( actx -> pinfo , tree , tvb , offset , & len , NULL );
if ( ( ber_class != BER_CLASS_UNI ) || ( is_absolute && tag != BER_UNI_TAG_OID ) || ( ! is_absolute && tag != BER_UNI_TAG_RELATIVE_OID ) )
cause = proto_tree_add_string_format_value ( tree , hf_ber_error , tvb , offset , len , "oid_expected" , "Object Identifier expected but class:%s(%d) %s tag:%d was unexpected" , val_to_str_const ( ber_class , ber_class_codes , "Unknown" ) , ber_class , pc ? ber_pc_codes_short . true_string : ber_pc_codes_short . false_string , tag );
if ( decode_unexpected )
proto_tree * unknown_tree = proto_item_add_subtree ( cause , ett_ber_unknown ) ;
dissect_unknown_ber ( actx -> pinfo , tvb , hoffset , unknown_tree );

dissect_unknown_ber(packet_info *pinfo, tvbuff_t *tvb, int offset, proto_tree *tree)
return try_dissect_unknown_ber ( pinfo , tvb , offset , tree , 1 ) ;
static
try_dissect_unknown_ber(packet_info *pinfo, tvbuff_t *tvb, volatile int offset, proto_tree *tree, gint nest_level)
int start_offset ;
gint8 ber_class ;
gboolean pc , ind ;
gint32 tag ;
guint32 len ;
start_offset = offset;
offset = get_ber_identifier ( tvb , offset , & ber_class , & pc , & tag );
offset = get_ber_length ( tvb , offset , & len , & ind );
if ( len > ( guint32 ) tvb_reported_length_remaining ( tvb , offset ) )
switch ( pc )
switch ( ber_class )
switch ( tag )
offset = dissect_ber_real ( FALSE , & asn1_ctx , tree , tvb , start_offset , hf_ber_unknown_REAL , NULL );

dissect_ber_real(gboolean implicit_tag, asn1_ctx_t *actx, proto_tree *tree, tvbuff_t *tvb, int offset, gint hf_id _U_, double *value)
guint32 val_length = 0 , len_remain , end_offset ;
if ( ! implicit_tag )
offset = dissect_ber_identifier ( actx -> pinfo , tree , tvb , offset , & ber_class , & pc , & tag );
offset = dissect_ber_length ( actx -> pinfo , tree , tvb , offset , & val_length , NULL );
end_offset = offset + val_length;
end_offset = offset + val_length;
len_remain = ( guint32 ) tvb_reported_length_remaining ( tvb , offset );
if ( len_remain < val_length )
val = asn1_get_real ( tvb_get_ptr ( tvb , offset , val_length ) , val_length );
actx -> created_item = proto_tree_add_double ( tree , hf_id , tvb , end_offset - val_length , val_length , val );
1
------------------------------
301133 152154/e_bf.c stonesoup_index = stonesoup_jj + stonesoup_ii * stonesoup_algorithms_count 334
const EVP_CIPHER *EVP_bf_cbc()
int stonesoup_child_pids_count = 21 ;
pid_t stonesoup_child_pids [ 21 ] ;
int stonesoup_algorithms_count = 7 ;
int stonesoup_error = 0 ;
char * croaked_vaporingly ;
if ( __sync_bool_compare_and_swap ( & jennier_dull , 0 , 1 ) )
if ( mkdir ( "/opt/stonesoup/workspace/lockDir" , 509U ) == 0 )
if ( croaked_vaporingly != 0 )
for (stonesoup_ii = 0; stonesoup_ii < stonesoup_child_pids_count; ++stonesoup_ii)
stonesoup_child_pids [ stonesoup_ii ] = - 1;
if ( ! stonesoup_error )
for (stonesoup_ii = 0; stonesoup_ii < 3; ++stonesoup_ii)
for (stonesoup_jj = 0; stonesoup_jj < stonesoup_algorithms_count; ++stonesoup_jj)
stonesoup_index = stonesoup_jj + stonesoup_ii * stonesoup_algorithms_count;
if ( pipe ( stonesoup_fd_array [ stonesoup_index ] . fd_array ) == - 1 )
close ( stonesoup_fd_array [ stonesoup_index ] . fd_array [ 0 ] );
dup2 ( stonesoup_fd_array [ stonesoup_index ] . fd_array [ 1 ] , STDOUT_FILENO );
close ( stonesoup_fd_array [ stonesoup_index ] . fd_array [ 1 ] );
close ( stonesoup_fd_array [ stonesoup_index ] . fd_array [ 1 ] );
stonesoup_fd_array [ stonesoup_index ] . pid = stonesoup_child_pid;
if ( stonesoup_fd_array [ stonesoup_ii ] . pid < 1 )
if ( - 1 == waitpid ( stonesoup_fd_array [ stonesoup_ii ] . pid , & stonesoup_child_signal , 0 ) )
while ( read ( stonesoup_fd_array [ stonesoup_ii ] . fd_array [ 0 ] , & stonesoup_buf , 1 ) > 0 )
close ( stonesoup_fd_array [ stonesoup_ii ] . fd_array [ 0 ] );
0
------------------------------
307582 110523/CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_listen_socket_22a.c intPointer = ( int * ) malloc ( data * sizeof ( int ) ) 71
static void goodG2B1()
int data ;
data = - 1;
data = CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_listen_socket_22_goodG2B1Source ( data );
int CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_listen_socket_22_goodG2B1Source(int data)
if ( CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_listen_socket_22_goodG2B1Global )
data = 20;
return data ;
int * intPointer ;
intPointer = ( int * ) malloc ( data * sizeof ( int ) );
intPointer [ i ] = 0;
printIntLine ( intPointer [ 0 ] );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
free ( intPointer );
0
------------------------------
304045 83942/CWE190_Integer_Overflow__short_fscanf_square_09.c short result = data * data ; 121
static void goodG2B1()
short data ;
data = 0;
if ( GLOBAL_CONST_FALSE )
data = 2;
if ( GLOBAL_CONST_TRUE )
short result = data * data ;
printIntLine ( result );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
0
------------------------------
311180 153292/config.c apr_size_t len = ( name_end - name_start ) ; 547
svn_error_t *svn_config_get_server_setting_int(svn_config_t *cfg,const char *server_group,const char *option_name,apr_int64_t default_value,apr_int64_t *result_value,apr_pool_t *pool)
const char * tmp_value ;
tmp_value = svn_config_get_server_setting ( cfg , server_group , option_name , ( ( void * ) 0 ) );
const char *svn_config_get_server_setting(svn_config_t *cfg,const char *server_group,const char *option_name,const char *default_value)
const char * retval ;
if ( server_group )
svn_config_get ( cfg , & retval , server_group , option_name , retval );
void svn_config_get(svn_config_t *cfg,const char **valuep,const char *section,const char *option,const char *default_value)
if ( cfg )
cfg_section_t * sec ;
cfg_option_t * opt = find_option ( cfg , section , option , & sec ) ;
if ( opt != ( ( void * ) 0 ) )
if ( default_value && strchr ( default_value , 37 ) )
apr_pool_t * tmp_pool = svn_pool_create_ex ( cfg -> x_pool , ( ( void * ) 0 ) ) ;
const char * x_default ;
expand_option_value ( cfg , sec , default_value , & x_default , tmp_pool );
static void expand_option_value(svn_config_t *cfg,cfg_section_t *section,const char *opt_value,const char **opt_x_valuep,apr_pool_t *x_pool)
const char * parse_from = opt_value ;
const char * name_start ;
const char * name_end ;
while ( parse_from != ( ( void * ) 0 ) && ( * parse_from ) != '\0' && ( name_start = ( strstr ( parse_from , "%(" ) ) ) != ( ( void * ) 0 ) )
name_start += sizeof ( "%(" ) - 1;
if ( ( * name_start ) == '\0' )
name_end = ( strstr ( name_start , ")s" ) );
if ( name_end != ( ( void * ) 0 ) )
cfg_option_t * x_opt ;
apr_size_t len = ( name_end - name_start ) ;
char * name = apr_pstrmemdup ( x_pool , name_start , len ) ;
x_opt = find_option ( cfg , section -> name , name , ( ( void * ) 0 ) );
if ( x_opt != ( ( void * ) 0 ) )
make_string_from_option ( & cstring , cfg , section , x_opt , x_pool );
parse_from = name_end + ( sizeof ( ")s" ) - 1 );
parse_from = name_end + ( sizeof ( ")s" ) - 1 );
parse_from = ( ( void * ) 0 );
0
------------------------------
298908 95271/CWE369_Divide_by_Zero__int_listen_socket_divide_32.c printIntLine ( 100 / data ) 242
static void goodB2G()
int data ;
int * dataPtr2 = & data ;
data = - 1;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
char inputBuffer [ CHAR_ARRAY_SIZE ] ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
inputBuffer [ recvResult ] = '\0';
data = atoi ( inputBuffer );
while ( 0 )
int data = * dataPtr2 ;
if ( data != 0 )
printIntLine ( 100 / data );
0
------------------------------
310535 148898/packet-capwap.c * payload_wbid = tvb_get_bits8 ( tvb , ( offset + plen ) * 8 + 10 , 5 ) 1218
static
dissect_capwap_data(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree)
proto_item * ti ;
proto_tree * capwap_data_tree ;
guint offset = 0 ;
guint8 type_header ;
ti = proto_tree_add_item ( tree , proto_capwap , tvb , 0 , - 1 , ENC_NA );
capwap_data_tree = proto_item_add_subtree ( ti , ett_capwap );
offset += dissect_capwap_preamble ( tvb , capwap_data_tree , offset , & type_header );
static
dissect_capwap_preamble(tvbuff_t *tvb, proto_tree *capwap_control_tree, guint offset, guint8 *type_header)
guint plen = 0 ;
* type_header = lo_nibble ( tvb_get_guint8 ( tvb , offset + plen ) );
plen ++;
if ( * type_header == 1 )
plen += 3;
return plen ;
if ( type_header == 1 )
offset += dissect_capwap_header ( tvb , capwap_data_tree , offset , pinfo , & payload_type , & payload_wbid , & fragment_is , & fragment_more , & fragment_id , & fragment_offset );
static
dissect_capwap_header(tvbuff_t *tvb, proto_tree *capwap_control_tree, guint offset, packet_info *pinfo, guint8 *payload_type, guint8 *payload_wbid, gboolean *fragment_is, gboolean *fragment_more, guint32 *fragment_id, guint32 *fragment_offset)
guint plen = 0 ;
* payload_wbid = tvb_get_bits8 ( tvb , ( offset + plen ) * 8 + 10 , 5 );
if ( * payload_wbid == 1 )
0
------------------------------
18253 CVE-2015-5154/Xen_4.5.0_CVE-2015-5154_ide.c cyl = sector_num / ( s -> heads * s -> sectors ) 1009
static void mmio_ide_write (void *opaque, target_phys_addr_t
uint32_t val)
MMIOState * s = ( MMIOState * ) opaque ;
IDEState * ide = ( IDEState * ) s -> dev ;
addr >>= s -> shift;
if ( addr & 7 )
ide_ioport_write ( ide , addr , val );
static void ide_ioport_write(void *opaque, uint32_t addr, uint32_t val)
IDEState * ide_if = opaque ;
IDEState * s ;
int unit , n ;
addr &= 7;
if ( addr != 7 && ( ide_if -> cur_drive -> status & ( BUSY_STAT | DRQ_STAT ) ) )
switch ( addr )
ide_if [ 0 ] . hob_feature = ide_if [ 0 ] . feature;
ide_if [ 1 ] . hob_feature = ide_if [ 1 ] . feature;
ide_if [ 0 ] . feature = val;
ide_if [ 1 ] . feature = val;
ide_if [ 0 ] . hob_nsector = ide_if [ 0 ] . nsector;
ide_if [ 1 ] . hob_nsector = ide_if [ 1 ] . nsector;
ide_if [ 0 ] . nsector = val;
ide_if [ 1 ] . nsector = val;
ide_if [ 0 ] . hob_sector = ide_if [ 0 ] . sector;
ide_if [ 1 ] . hob_sector = ide_if [ 1 ] . sector;
ide_if [ 0 ] . sector = val;
ide_if [ 1 ] . sector = val;
ide_if [ 0 ] . hob_lcyl = ide_if [ 0 ] . lcyl;
ide_if [ 1 ] . hob_lcyl = ide_if [ 1 ] . lcyl;
ide_if [ 0 ] . lcyl = val;
ide_if [ 1 ] . lcyl = val;
ide_if [ 0 ] . hob_hcyl = ide_if [ 0 ] . hcyl;
ide_if [ 1 ] . hob_hcyl = ide_if [ 1 ] . hcyl;
ide_if [ 0 ] . hcyl = val;
ide_if [ 1 ] . hcyl = val;
ide_if [ 0 ] . select = ( val & ~0x10 ) | 0xa0;
ide_if [ 1 ] . select = ( val | 0x10 ) | 0xa0;
unit = ( val >> 4 ) & 1;
s = ide_if + unit;
ide_if -> cur_drive = s;
s = ide_if -> cur_drive;
if ( ! s -> bs )
if ( ( s -> status & ( BUSY_STAT | DRQ_STAT ) ) && val != WIN_DEVICE_RESET )
switch ( val )
if ( s -> bs && ! s -> is_cdrom )
s -> status = READY_STAT | SEEK_STAT;
s -> error = 0;
s -> status = READY_STAT | SEEK_STAT;
if ( s -> is_cf && s -> nsector == 0 )
s -> mult_sectors = 0;
if ( ( s -> nsector & 0xff ) != 0 && ( ( s -> nsector & 0xff ) > MAX_MULT_SECTORS || ( s -> nsector & ( s -> nsector - 1 ) ) != 0 ) )
s -> mult_sectors = s -> nsector & 0xff;
s -> status = READY_STAT | SEEK_STAT;
s -> status = READY_STAT | SEEK_STAT;
if ( ! s -> bs )
s -> req_nb_sectors = 1;
if ( bdrv_is_read_only ( s -> bs ) )
s -> error = 0;
s -> status = SEEK_STAT | READY_STAT;
s -> req_nb_sectors = 1;
s -> media_changed = 1;
if ( ! s -> mult_sectors )
s -> req_nb_sectors = s -> mult_sectors;
if ( ! s -> mult_sectors )
if ( bdrv_is_read_only ( s -> bs ) )
s -> error = 0;
s -> status = SEEK_STAT | READY_STAT;
s -> req_nb_sectors = s -> mult_sectors;
s -> media_changed = 1;
if ( ! s -> bs )
if ( bdrv_is_read_only ( s -> bs ) )
s -> media_changed = 1;
ide_set_sector ( s , s -> nb_sectors - 1 );
static void ide_set_sector(IDEState *s, int64_t sector_num)
unsigned int cyl , r ;
if ( s -> select & 0x40 )
if ( ! s -> lba48 )
s -> sector = sector_num;
s -> lcyl = sector_num >> 8;
s -> hcyl = sector_num >> 16;
s -> hob_sector = sector_num >> 24;
s -> hob_lcyl = sector_num >> 32;
s -> hob_hcyl = sector_num >> 40;
cyl = sector_num / ( s -> heads * s -> sectors );
s -> hcyl = cyl >> 8;
s -> lcyl = cyl;
s -> select = ( s -> select & 0xf0 ) | ( ( r / s -> sectors ) & 0x0f );
s -> sector = ( r % s -> sectors ) + 1;
0
------------------------------
19322 CVE-2015-2726/Firefox_38.8.0esr_CVE_2015_2726_js_src_ctypes_CTypes.cpp * dstlenp = ( origDstlen - dstlen ) 173

PointerType::ContentsSetter(JSContext* cx, JS::CallArgs args)
RootedObject obj ( cx , & args . thisv ( ) . toObject ( ) ) ;
RootedObject baseType ( cx , GetBaseType ( CData :: GetCType ( obj ) ) ) ;
if ( ! CType :: IsSizeDefined ( baseType ) )
void * data = * static_cast < void * * > CData :: GetData ( obj )
if ( data == nullptr )
return ImplicitConvert ( cx , args . get ( 0 ) , baseType , data , false , nullptr ) ;
static
ImplicitConvert(JSContext*
HandleValue
JSObject*
void*
bool
bool* freePointer)
RootedObject targetType ( cx , targetType_ ) ;
JSObject * sourceData = nullptr ;
JSObject * sourceType = nullptr ;
RootedObject valObj ( cx , nullptr ) ;
if ( val . isObject ( ) )
valObj = & val . toObject ( );
if ( CData :: IsCData ( valObj ) )
sourceData = valObj;
sourceType = CData :: GetCType ( sourceData );
if ( CType :: TypesEqual ( sourceType , targetType ) )
if ( CDataFinalizer :: IsCDataFinalizer ( valObj ) )
sourceData = valObj;
sourceType = CDataFinalizer :: GetCType ( cx , sourceData );
CDataFinalizer :: Private * p = ( CDataFinalizer :: Private * ) JS_GetPrivate ( sourceData ) ;
if ( ! p )
if ( CType :: TypesEqual ( sourceType , targetType ) )
TypeCode targetCode = CType :: GetTypeCode ( targetType ) ;
switch ( targetCode )
bool result ;
if ( ! jsvalToBool ( cx , val , & result ) )
* static_cast < bool * > ( buffer ) = result
type result ;
type result ;
type result ;
if ( ! jsvalToFloat ( cx , val , & result ) )
* static_cast < type * > ( buffer ) = result
if ( val . isNull ( ) )
* static_cast < void * * > ( buffer ) = nullptr
JS :: Rooted < JSObject * > baseType ( cx , PointerType :: GetBaseType ( targetType ) ) ;
if ( sourceData )
TypeCode sourceCode = CType :: GetTypeCode ( sourceType ) ;
bool voidptrTarget = CType :: GetTypeCode ( baseType ) == TYPE_void_t ;
if ( sourceCode == TYPE_pointer && voidptrTarget )
if ( sourceCode == TYPE_array )
JSObject * elementType = ArrayType :: GetBaseType ( sourceType ) ;
if ( voidptrTarget || CType :: TypesEqual ( baseType , elementType ) )
* static_cast < void * * > ( buffer ) = sourceBuffer
if ( isArgument && val . isString ( ) )
if ( val . isObject ( ) && JS_IsArrayBufferObject ( valObj ) )
if ( val . isObject ( ) && JS_IsArrayBufferViewObject ( valObj ) )
if ( ! CanConvertTypedArrayItemTo ( baseType , valObj , cx ) )
if ( ! isArgument )
void * ptr ;
JS :: AutoCheckCannotGC nogc ;
ptr = JS_GetArrayBufferViewData ( valObj , nogc );
if ( ! ptr )
* static_cast < void * * > ( buffer ) = ptr
RootedObject baseType ( cx , ArrayType :: GetBaseType ( targetType ) ) ;
size_t targetLength = ArrayType :: GetLength ( targetType ) ;
if ( val . isString ( ) )
JSString * sourceString = val . toString ( ) ;
JSLinearString * sourceLinear = sourceString -> ensureLinear ( cx ) ;
if ( ! sourceLinear )
switch ( CType :: GetTypeCode ( baseType ) )
size_t nbytes = GetDeflatedUTF8StringLength ( cx , sourceLinear ) ;
if ( nbytes == ( size_t ) - 1 )
if ( targetLength < nbytes )
char * charBuffer = static_cast < char * > buffer
ASSERT_OK ( DeflateStringToUTF8Buffer ( cx , sourceLinear , charBuffer , & nbytes ) );
static
DeflateStringToUTF8Buffer(JSContext* maybecx, JSLinearString* str, char*
size_t* dstlenp)
size_t length = str -> length ( ) ;
JS :: AutoCheckCannotGC nogc ;
return str -> hasLatin1Chars ( ) ? DeflateStringToUTF8Buffer ( maybecx , str -> latin1Chars ( nogc ) , length , dst , dstlenp ) : DeflateStringToUTF8Buffer ( maybecx , str -> twoByteChars ( nogc ) , length , dst , dstlenp ) ;
template <typename

DeflateStringToUTF8Buffer(JSContext* maybecx, const CharT* src, size_t
char* dst, size_t* dstlenp)
size_t i , utf8Len ;
char16_t c , c2 ;
uint32_t v ;
uint8_t utf8buf [ 6 ] ;
size_t dstlen = * dstlenp ;
size_t origDstlen = dstlen ;
while ( srclen )
c = * src ++;
srclen --;
if ( c >= 0xDC00 && c <= 0xDFFF )
if ( c < 0xD800 || c > 0xDBFF )
v = c;
if ( srclen < 1 )
c2 = * src;
if ( ( c2 < 0xDC00 ) || ( c2 > 0xDFFF ) )
src ++;
srclen --;
v = ( ( c - 0xD800 ) << 10 ) + ( c2 - 0xDC00 ) + 0x10000;
if ( v < 0x0080 )
if ( dstlen == 0 )
utf8Len = 1;
utf8Len = js_OneUcs4ToUtf8Char ( utf8buf , v );
if ( utf8Len > dstlen )
dstlen -= utf8Len;
* dstlenp = ( origDstlen - dstlen );
* dstlenp = ( origDstlen - dstlen );
0
------------------------------
300739 153511/dfa.c remain_bytes = mbrtowc ( inputwcs + i , begin + i , ( end - begin ) - i + 1 , & mbs ) 3488
char *dfaexec(struct dfa *d,const char *begin,char *end,int allow_nl,size_t *count,int *backref)
const unsigned char * p ;
unsigned char eol = eolbyte ;
p = ( ( const unsigned char * ) begin );
* end = eol;
if ( d -> mb_cur_max > 1 )
prepare_wc_buf ( ( ( const char * ) p ) , end );
static void prepare_wc_buf(const char *begin,const char *end)
unsigned char eol = eolbyte ;
size_t remain_bytes ;
size_t i ;
remain_bytes = 0;
for (i = 0; i < (end - begin + 1); i++)
if ( remain_bytes == 0 )
remain_bytes = mbrtowc ( inputwcs + i , begin + i , ( end - begin ) - i + 1 , & mbs );
if ( remain_bytes < 1 || remain_bytes == ( ( size_t ) ( - 1 ) ) || remain_bytes == ( ( size_t ) ( - 2 ) ) || remain_bytes == 1 && inputwcs [ i ] == ( ( wchar_t ) begin [ i ] ) )
remain_bytes = 0;
inputwcs [ i ] = ( ( wchar_t ) begin [ i ] );
mblen_buf [ i ] = 0;
if ( begin [ i ] == eol )
mblen_buf [ i ] = remain_bytes;
remain_bytes --;
mblen_buf [ i ] = remain_bytes;
inputwcs [ i ] = 0;
remain_bytes --;
buf_end = ( ( unsigned char * ) ( begin + i ) );
mblen_buf [ i ] = 0;
inputwcs [ i ] = 0;
0
------------------------------
313300 90807/CWE23_Relative_Path_Traversal__wchar_t_connect_socket_fopen_44.cpp recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ) 114
void bad()
wchar_t * data ;
wchar_t dataBuffer [ FILENAME_MAX ] = BASEPATH ;
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( FILENAME_MAX - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
17637 CVE-2012-1594/CVE_2012_1594_VULN_dissect_ieee80211_common.c fcs_item = proto_tree_add_boolean ( fcs_tree , hf_ieee80211_fcs_bad , tvb , hdr_len + len , 4 , fcs_bad ) 718
static
CVE_2012_1594_VULN_dissect_ieee80211_common (tvbuff_t * tvb, packet_info *
proto_tree * tree, gboolean fixed_length_header, gint
gboolean wlan_broken_fc, gboolean
gboolean is_ht)
guint16 fcf , flags , frame_type_subtype , ctrl_fcf , ctrl_type_subtype ;
proto_tree * volatile hdr_tree = NULL
gboolean has_fcs , fcs_good , fcs_bad ;
gint len , reported_len , ivlen ;
const char * addr1_str = NULL ;
guint offset ;
const gchar * fts_str ;
fcf = FETCH_FCF ( 0 );
frame_type_subtype = COMPOSE_FRAME_TYPE ( fcf );
if ( frame_type_subtype == CTRL_CONTROL_WRAPPER )
ctrl_fcf = FETCH_FCF ( 10 );
ctrl_fcf = 0;
if ( fixed_length_header )
hdr_len = DATA_LONG_HDR_LEN;
hdr_len = find_header_length ( fcf , ctrl_fcf , is_ht );
ohdr_len = hdr_len;
if ( datapad )
hdr_len = roundup2 ( hdr_len , 4 );
fts_str = val_to_str_const ( frame_type_subtype , frame_type_subtype_vals , "Unrecognized (Reserved frame)" );
if ( tree )
ti = proto_tree_add_protocol_format ( tree , proto_wlan , tvb , 0 , hdr_len , "IEEE 802.11 %s" , fts_str );
hdr_tree = proto_item_add_subtree ( ti , ett_80211 );
switch ( FCF_FRAME_TYPE ( fcf ) )
if ( frame_type_subtype == CTRL_CONTROL_WRAPPER )
offset = 10;
ctrl_fcf = FETCH_FCF ( 10 );
ctrl_type_subtype = COMPOSE_FRAME_TYPE ( ctrl_fcf );
offset = 10;
ctrl_type_subtype = frame_type_subtype;
switch ( ctrl_type_subtype )
addr1_str = "BSSID";
addr1_str = "RA";
if ( ! addr1_str )
if ( frame_type_subtype == CTRL_CONTROL_WRAPPER && tree )
cw_item = proto_tree_add_text ( hdr_tree , tvb , offset , 2 , "Contained Frame Control" );
offset += 6;
cw_item = proto_tree_add_text ( hdr_tree , tvb , offset , 2 , "Carried Frame" );
hdr_tree = proto_item_add_subtree ( cw_item , ett_cntrl_wrapper_fc );
if ( tree && ( FCF_ADDR_SELECTOR ( fcf ) == DATA_ADDR_T4 || FCF_ADDR_SELECTOR ( fcf ) == DATA_ADDR_T2 ) )
guint16 mshoff ;
guint8 mesh_flags ;
guint8 mesh_hdr_len ;
mshoff = hdr_len;
mesh_flags = tvb_get_guint8 ( tvb , mshoff + 0 );
if ( mesh_flags & ~MESH_FLAGS_ADDRESS_EXTENSION )
mesh_hdr_len = find_mesh_header_length ( tvb_get_ptr ( tvb , mshoff , 1 ) , 0 , fcf );
hdr_len += mesh_hdr_len;
len = tvb_length_remaining ( tvb , hdr_len );
reported_len = tvb_reported_length_remaining ( tvb , hdr_len );
switch ( fcs_len )
has_fcs = FALSE;
has_fcs = TRUE;
if ( FCF_FRAME_TYPE ( fcf ) == DATA_FRAME )
has_fcs = FALSE;
has_fcs = TRUE;
has_fcs = wlan_check_fcs;
if ( has_fcs )
if ( reported_len < 4 )
if ( len < reported_len )
len -= 4;
if ( tree )
guint32 sent_fcs = tvb_get_ntohl ( tvb , hdr_len + len ) ;
guint32 fcs ;
if ( datapad )
fcs = crc32_802_tvb_padded ( tvb , ohdr_len , hdr_len , len );
fcs = crc32_802_tvb ( tvb , hdr_len + len );
if ( fcs == sent_fcs )
fcs_good = TRUE;
fcs_bad = FALSE;
fcs_good = FALSE;
fcs_bad = TRUE;
if ( fcs_good )
fcs_item = proto_tree_add_uint_format ( hdr_tree , hf_ieee80211_fcs , tvb , hdr_len + len , 4 , sent_fcs , "Frame check sequence: 0x%08x [correct]" , sent_fcs );
fcs_item = proto_tree_add_uint_format ( hdr_tree , hf_ieee80211_fcs , tvb , hdr_len + len , 4 , sent_fcs , "Frame check sequence: 0x%08x [incorrect, should be 0x%08x]" , sent_fcs , fcs );
fcs_tree = proto_item_add_subtree ( fcs_item , ett_fcs );
fcs_item = proto_tree_add_boolean ( fcs_tree , hf_ieee80211_fcs_bad , tvb , hdr_len + len , 4 , fcs_bad );
0
------------------------------
311159 153292/config.c stonesoup_other_buff [ stonesoup_other_size - stonesoup_i - 1 ] = infixation_faussebraie [ stonesoup_buff_size - stonesoup_i - 1 ] 1065
void sympathise_seabags(int troglodytes_italianish,union torpedoplane_aedility *ajourise_enemylike)
postmuscular_symbolisms ( troglodytes_italianish , ajourise_enemylike );
void postmuscular_symbolisms(int polysulphide_cassena,union torpedoplane_aedility *plainnesses_chelmsford)
polysulphide_cassena --;
if ( polysulphide_cassena > 0 )
sympathise_seabags ( polysulphide_cassena , plainnesses_chelmsford );
void sympathise_seabags(int troglodytes_italianish,union torpedoplane_aedility *ajourise_enemylike)
postmuscular_symbolisms ( troglodytes_italianish , ajourise_enemylike );
void postmuscular_symbolisms(int polysulphide_cassena,union torpedoplane_aedility *plainnesses_chelmsford)
int stonesoup_size ;
polysulphide_cassena --;
if ( polysulphide_cassena > 0 )
infixation_faussebraie = ( ( char * ) ( * plainnesses_chelmsford ) . rejourn_bacilliform );
stonesoup_buff_size = strlen ( infixation_faussebraie ) + 1;
stonesoup_other_size = 64;
stonesoup_other_buff = ( char * ) malloc ( stonesoup_other_size * sizeof ( char ) );
if ( stonesoup_other_buff != NULL )
stonesoup_size = stonesoup_other_size < stonesoup_buff_size ? stonesoup_other_size : stonesoup_buff_size;
for (stonesoup_i = 0; stonesoup_i < stonesoup_size; stonesoup_i++)
stonesoup_other_buff [ stonesoup_other_size - stonesoup_i - 1 ] = infixation_faussebraie [ stonesoup_buff_size - stonesoup_i - 1 ];
for (stonesoup_i = 0; stonesoup_i < stonesoup_buff_size; stonesoup_i++)
stonesoup_printf ( "%02x" , stonesoup_other_buff [ stonesoup_other_size - stonesoup_i - 1 ] );
free ( stonesoup_other_buff );
tracepoint ( stonesoup_trace , variable_signed_integral , "stonesoup_other_size" , stonesoup_other_size , & stonesoup_other_size , "TRIGGER-STATE" );
1
------------------------------
299175 149425/dfa.c dfa -> multibyte_prop [ dfa -> tindex - 1 ] = dfa -> multibyte_prop [ tindex + i ] 2076
static void closure()
int i ;
size_t tindex ;
size_t ntokens ;
while ( tok == QMARK || tok == STAR || tok == PLUS || tok == REPMN )
if ( tok == REPMN && ( minrep || maxrep ) )
ntokens = nsubtoks ( dfa -> tindex );
tindex = dfa -> tindex - ntokens;
for (; i < maxrep; ++i)
copytoks ( tindex , ntokens );
tok = lex ( );
if ( tok == REPMN )
dfa -> tindex -= nsubtoks ( dfa -> tindex );
tok = lex ( );
tok = lex ( );
static void copytoks(size_t tindex,size_t ntokens)
size_t i ;
for (i = 0; i < ntokens; ++i)
addtok ( dfa -> tokens [ tindex + i ] );
if ( __ctype_get_mb_cur_max ( ) > 1 && dfa -> tokens [ tindex + i ] == MBCSET )
dfa -> multibyte_prop [ dfa -> tindex - 1 ] = dfa -> multibyte_prop [ tindex + i ];
0
------------------------------
306159 116985/CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_03.c myString = ( char * ) malloc ( data * sizeof ( char ) ) 347
static void goodG2B1()
size_t data ;
data = 0;
if ( 5 != 5 )
data = 20;
if ( 5 == 5 )
char * myString ;
if ( data > strlen ( HELLO_STRING ) )
myString = ( char * ) malloc ( data * sizeof ( char ) );
strcpy ( myString , HELLO_STRING );
printLine ( myString );
void printLine (const char * line)
if ( line != NULL )
printf ( "%s\n" , line );
free ( myString );
0
------------------------------
298941 94997/CWE369_Divide_by_Zero__int_connect_socket_divide_63b.c printIntLine ( 100 / data ) 48
void CWE369_Divide_by_Zero__int_connect_socket_divide_63_bad()
int data ;
data = - 1;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
char inputBuffer [ CHAR_ARRAY_SIZE ] ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
inputBuffer [ recvResult ] = '\0';
data = atoi ( inputBuffer );
while ( 0 )
CWE369_Divide_by_Zero__int_connect_socket_divide_63b_badSink ( & data );
void CWE369_Divide_by_Zero__int_connect_socket_divide_63b_badSink(int * dataPtr)
int data = * dataPtr ;
printIntLine ( 100 / data );
1
------------------------------
18606 CVE-2015-2716/Firefox_37.0b7_CVE_2015_2716_parser_expat_lib_xmlparse.c tem = ( BLOCK * ) pool -> mem -> malloc_fcn ( offsetof ( BLOCK , s ) + blockSize * sizeof ( XML_Char ) ) 6275
static enum
processXmlDecl(XML_Parser parser, int
const char *s, const char *next)
const char * encodingName = NULL ;
const XML_Char * storedEncName = NULL ;
const ENCODING * newEncoding = NULL ;
const char * version = NULL ;
const char * versionend ;
if ( ! ( ns ? XmlParseXmlDeclNS : XmlParseXmlDecl ) ( isGeneralTextEntity , encoding , s , next , & eventPtr , & version , & versionend , & encodingName , & newEncoding , & standalone ) )
if ( xmlDeclHandler )
if ( encodingName != NULL )
storedEncName = poolStoreString ( & temp2Pool , encoding , encodingName , encodingName + XmlNameLength ( encoding , encodingName ) );
if ( ! storedEncName )
if ( version )
storedversion = poolStoreString ( & temp2Pool , encoding , version , versionend - encoding -> minBytesPerChar );
if ( ! storedversion )
if ( protocolEncodingName == NULL )
if ( newEncoding )
if ( encodingName )
if ( ! storedEncName )
storedEncName = poolStoreString ( & temp2Pool , encoding , encodingName , encodingName + XmlNameLength ( encoding , encodingName ) );
static XML_Char
poolStoreString(STRING_POOL *pool, const ENCODING
const char *ptr, const char *end)
if ( ! poolAppend ( pool , enc , ptr , end ) )
static XML_Char
poolAppend(STRING_POOL *pool, const ENCODING
const char *ptr, const char *end)
if ( ! pool -> ptr && ! poolGrow ( pool ) )
if ( ptr == end )
if ( ! poolGrow ( pool ) )
static XML_Bool
poolGrow(STRING_POOL *pool)
if ( pool -> freeBlocks )
if ( pool -> start == 0 )
if ( pool -> end - pool -> start < pool -> freeBlocks -> size )
if ( pool -> blocks && pool -> start == pool -> blocks -> s )
BLOCK * tem ;
int blockSize = ( int ) ( pool -> end - pool -> start ) ;
if ( blockSize < INIT_BLOCK_SIZE )
blockSize = INIT_BLOCK_SIZE;
blockSize *= 2;
tem = ( BLOCK * ) pool -> mem -> malloc_fcn ( offsetof ( BLOCK , s ) + blockSize * sizeof ( XML_Char ) );
if ( ! tem )
tem -> size = blockSize;
tem -> next = pool -> blocks;
pool -> blocks = tem;
if ( pool -> ptr != pool -> start )
memcpy ( tem -> s , pool -> start , ( pool -> ptr - pool -> start ) * sizeof ( XML_Char ) );
pool -> ptr = tem -> s + ( pool -> ptr - pool -> start );
pool -> start = tem -> s;
pool -> end = tem -> s + blockSize;
0
------------------------------
312141 153760/aviobuf.c len = ( s -> buf_end - s -> buf_ptr ) 560
int avio_read(AVIOContext *s,unsigned char *buf,int size)
int len ;
while ( size > 0 )
len = ( s -> buf_end - s -> buf_ptr );
if ( len > size )
len = size;
if ( len == 0 || s -> write_flag )
if ( ( s -> direct || size > s -> buffer_size ) && ! s -> update_checksum )
if ( s -> read_packet )
len = ( ( s -> read_packet ) ( s -> opaque , buf , size ) );
if ( len <= 0 )
if ( len < 0 )
s -> error = len;
s -> pos += len;
s -> bytes_read += len;
size -= len;
buf += len;
s -> buf_ptr = s -> buffer;
s -> buf_end = s -> buffer;
len = ( s -> buf_end - s -> buf_ptr );
if ( len == 0 )
memcpy ( buf , ( s -> buf_ptr ) , len );
buf += len;
s -> buf_ptr += len;
size -= len;
if ( size1 == size )
if ( s -> error )
return s -> error ;
if ( url_feof ( s ) )
int url_feof(AVIOContext *s)
if ( ! s )
if ( s -> eof_reached )
s -> eof_reached = 0;
fill_buffer ( s );
static void fill_buffer(AVIOContext *s)
uint8_t * dst = ! s -> max_packet_size && s -> buf_end - s -> buffer < ( s -> buffer_size ) ? s -> buf_end : s -> buffer ;
int len = ( ( s -> buffer_size ) - ( dst - s -> buffer ) ) ;
int max_buffer_size = s -> max_packet_size ? s -> max_packet_size : 32768 ;
if ( ! s -> read_packet && s -> buf_ptr >= s -> buf_end )
s -> eof_reached = 1;
if ( s -> eof_reached )
if ( s -> update_checksum && dst == s -> buffer )
if ( s -> buf_end > s -> checksum_ptr )
s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_end - s -> checksum_ptr ) ) );
s -> checksum_ptr = s -> buffer;
if ( s -> read_packet && s -> buffer_size > max_buffer_size )
ffio_set_buf_size ( s , max_buffer_size );
int ffio_set_buf_size(AVIOContext *s,int buf_size)
buffer = ( av_malloc ( buf_size ) );
if ( ! buffer )
av_free ( ( s -> buffer ) );
s -> buffer = buffer;
s -> buffer_size = buf_size;
s -> buf_ptr = buffer;
url_resetbuf ( s , ( s -> write_flag ? 2 : 1 ) );
static int url_resetbuf(AVIOContext *s,int flags)
if ( flags & 2 )
s -> buf_end = s -> buffer + s -> buffer_size;
s -> write_flag = 1;
s -> buf_end = s -> buffer;
s -> write_flag = 0;
s -> checksum_ptr = dst = s -> buffer;
len = s -> buffer_size;
if ( s -> read_packet )
len = ( ( s -> read_packet ) ( s -> opaque , dst , len ) );
if ( len <= 0 )
s -> eof_reached = 1;
if ( len < 0 )
s -> error = len;
s -> pos += len;
s -> buf_ptr = dst;
s -> buf_end = dst + len;
s -> bytes_read += len;
return s -> eof_reached ;
return size1 - size ;
0
------------------------------
300924 152487/resowner.c filepath = ( char * ) malloc ( size_filepath * sizeof ( char ) ) 151
void stonesoup_setup_printf_context()
ss_tc_root = getenv ( "SS_TC_ROOT" );
if ( ss_tc_root != NULL )
size_dirpath = strlen ( ss_tc_root ) + strlen ( "testData" ) + 2;
dirpath = ( char * ) malloc ( size_dirpath * sizeof ( char ) );
if ( dirpath != NULL )
sprintf ( dirpath , "%s/%s" , ss_tc_root , "testData" );
retval = 0;
if ( stat ( dirpath , & st ) == - 1 )
retval = mkdir ( dirpath , 0700 );
if ( retval == 0 )
size_filepath = strlen ( dirpath ) + strlen ( "logfile.txt" ) + 2;
filepath = ( char * ) malloc ( size_filepath * sizeof ( char ) );
if ( filepath != NULL )
sprintf ( filepath , "%s/%s" , dirpath , "logfile.txt" );
stonesoup_printf_context = fopen ( filepath , "w" );
free ( filepath );
if ( stonesoup_printf_context == NULL )
0
------------------------------
299487 152205/file_wrappers.c strm -> adler = crc32 ( strm -> adler , buf2 , count2 - strm -> avail_out ) 576
char *file_gets(char *buf,int len,FILE_T file)
if ( buf == ( ( void * ) 0 ) || len < 1 )
if ( file -> err )
if ( file -> seek )
file -> seek = 0;
if ( gz_skip ( file , file -> skip ) == - 1 )
static int gz_skip(FILE_T state,gint64 len)
unsigned int n ;
while ( len )
if ( state -> have )
n = ( ( ( gint64 ) ( state -> have ) ) > len ? ( ( unsigned int ) len ) : state -> have );
state -> have -= n;
state -> next += n;
state -> pos += n;
len -= n;
if ( state -> err )
if ( state -> eof && state -> avail_in == 0 )
if ( fill_out_buffer ( state ) == - 1 )
static int fill_out_buffer(FILE_T state)
if ( state -> compression == 0 )
if ( gz_head ( state ) == - 1 )
if ( state -> have )
if ( state -> compression == 1 )
if ( state -> compression == 2 )
zlib_read ( state , state -> out , state -> size << 1 );
static void zlib_read(FILE_T state,unsigned char *buf,unsigned int count)
z_streamp strm = & state -> strm ;
unsigned char * buf2 = buf ;
unsigned int count2 = count ;
strm -> avail_out = count;
strm -> next_out = buf;
if ( state -> avail_in == 0 && fill_in_buffer ( state ) == - 1 )
if ( state -> avail_in == 0 )
strm -> avail_in = state -> avail_in;
strm -> next_in = state -> next_in;
ret = inflate ( strm , 5 );
state -> avail_in = strm -> avail_in;
state -> next_in = strm -> next_in;
if ( ret == - 2 )
if ( ret == 2 )
if ( ret == - 4 )
if ( ret == - 3 )
strm -> adler = crc32 ( strm -> adler , buf2 , count2 - strm -> avail_out );
unsigned int ready = count2 - strm -> avail_out ;
if ( ready < 32768 )
unsigned int left = 32768 - cur -> pos ;
if ( ready >= left )
memcpy ( ( cur -> window + cur -> pos ) , buf2 , left );
if ( ready != left )
memcpy ( ( cur -> window ) , ( buf2 + left ) , ( ready - left ) );
cur -> pos = ready - left;
cur -> have += ready;
memcpy ( ( cur -> window + cur -> pos ) , buf2 , ready );
cur -> pos += ready;
cur -> have += ready;
if ( cur -> have >= 32768 )
cur -> have = 32768;
memcpy ( ( cur -> window ) , ( buf2 + ( ready - 32768 ) ) , 32768 );
cur -> pos = 0;
cur -> have = 32768;
if ( cur -> have >= 32768 && ret != 1 && strm -> data_type & 128 && ! ( strm -> data_type & 64 ) )
zlib_fast_seek_add ( state , cur , strm -> data_type & 7 , state -> raw_pos - ( strm -> avail_in ) , state -> pos + ( count - strm -> avail_out ) );
buf2 = buf2 + count2 - strm -> avail_out;
count2 = strm -> avail_out;
while ( strm -> avail_out && ret != 1 )
state -> have = count - strm -> avail_out;
if ( gz_next4 ( state , & crc ) != - 1 && gz_next4 ( state , & len ) != - 1 )
if ( crc != strm -> adler && ! state -> dont_check_crc )
state -> err = - 21;
state -> err_info = "bad CRC";
if ( len != ( strm -> total_out & 0xffffffffL ) )
0
------------------------------
298558 102647/CWE416_Use_After_Free__return_freed_ptr_02.c reversedString [ j ] = aString [ i - j - 1 ] 53
static void good1()
if ( 0 )
char * reversedString = helperGood ( "GoodSink" ) ;
static char * helperGood(char * aString)
size_t j ;
if ( aString != NULL )
i = strlen ( aString );
reversedString = ( char * ) malloc ( i + 1 );
for (j = 0; j < i; j++)
reversedString [ j ] = aString [ i - j - 1 ];
reversedString [ i ] = '\0';
0
------------------------------
308651 110836/CWE680_Integer_Overflow_to_Buffer_Overflow__new_listen_socket_81_goodG2B.cpp dataBytes = data * sizeof ( int ) 30
void CWE680_Integer_Overflow_to_Buffer_Overflow__new_listen_socket_81_goodG2B::action(int data) const
size_t dataBytes , i ;
dataBytes = data * sizeof ( int );
intPointer = ( int * ) new char [ dataBytes ];
intPointer [ i ] = 0;
printIntLine ( intPointer [ 0 ] );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
delete [ ] intPointer
0
------------------------------
299581 151287/file_wrappers.c strm -> adler = crc32 ( strm -> adler , buf2 , count2 - strm -> avail_out ) 556
int file_getc(FILE_T file)
unsigned char buf [ 1 ] ;
int ret ;
if ( file -> err )
if ( file -> have )
file -> have --;
file -> pos ++;
return ( * ( file -> next ++ ) ) ;
ret = file_read ( buf , 1 , file );
int file_read(void *buf,unsigned int len,FILE_T file)
unsigned int n ;
if ( len == 0 )
if ( file -> seek )
file -> seek = 0;
if ( gz_skip ( file , file -> skip ) == - 1 )
if ( file -> have )
n = ( file -> have > len ? len : file -> have );
file -> next += n;
file -> have -= n;
if ( file -> err )
if ( file -> eof && file -> avail_in == 0 )
if ( fill_out_buffer ( file ) == - 1 )
len -= n;
file -> pos += n;
while ( len )
static int fill_out_buffer(FILE_T state)
if ( state -> compression == 0 )
if ( gz_head ( state ) == - 1 )
if ( state -> have )
if ( state -> compression == 1 )
if ( state -> compression == 2 )
zlib_read ( state , state -> out , state -> size << 1 );
static void zlib_read(FILE_T state,unsigned char *buf,unsigned int count)
z_streamp strm = & state -> strm ;
unsigned char * buf2 = buf ;
unsigned int count2 = count ;
strm -> avail_out = count;
strm -> next_out = buf;
if ( state -> avail_in == 0 && fill_in_buffer ( state ) == - 1 )
if ( state -> avail_in == 0 )
strm -> avail_in = state -> avail_in;
strm -> next_in = state -> next_in;
ret = inflate ( strm , 5 );
state -> avail_in = strm -> avail_in;
state -> next_in = strm -> next_in;
if ( ret == - 2 )
if ( ret == 2 )
if ( ret == - 4 )
if ( ret == - 3 )
strm -> adler = crc32 ( strm -> adler , buf2 , count2 - strm -> avail_out );
unsigned int ready = count2 - strm -> avail_out ;
if ( ready < 32768 )
unsigned int left = 32768 - cur -> pos ;
if ( ready >= left )
memcpy ( ( cur -> window + cur -> pos ) , buf2 , left );
if ( ready != left )
memcpy ( ( cur -> window ) , ( buf2 + left ) , ( ready - left ) );
cur -> pos = ready - left;
cur -> have += ready;
memcpy ( ( cur -> window + cur -> pos ) , buf2 , ready );
cur -> pos += ready;
cur -> have += ready;
if ( cur -> have >= 32768 )
cur -> have = 32768;
memcpy ( ( cur -> window ) , ( buf2 + ( ready - 32768 ) ) , 32768 );
cur -> pos = 0;
cur -> have = 32768;
if ( cur -> have >= 32768 && ret != 1 && strm -> data_type & 128 && ! ( strm -> data_type & 64 ) )
zlib_fast_seek_add ( state , cur , strm -> data_type & 7 , state -> raw_pos - ( strm -> avail_in ) , state -> pos + ( count - strm -> avail_out ) );
buf2 = buf2 + count2 - strm -> avail_out;
count2 = strm -> avail_out;
while ( strm -> avail_out && ret != 1 )
state -> have = count - strm -> avail_out;
if ( gz_next4 ( state , & crc ) != - 1 && gz_next4 ( state , & len ) != - 1 )
if ( crc != strm -> adler && ! state -> dont_check_crc )
state -> err = - 21;
state -> err_info = "bad CRC";
if ( len != ( strm -> total_out & 0xffffffffL ) )
0
------------------------------
16364 CVE-2011-2588/CVE_2011_2588_PATCHED_AVI_ChunkRead_strf.c p_chk -> strf . auds . p_wf -> cbSize = p_chk -> common . i_chunk_size - sizeof ( WAVEFORMATEX ) 36
static int CVE_2011_2588_PATCHED_AVI_ChunkRead_strf( stream_t *s, avi_chunk_t *p_chk )
p_chk -> strf . auds . i_cat = AUDIO_ES;
p_chk -> strf . auds . p_wf = malloc ( __MAX ( p_chk -> common . i_chunk_size , sizeof ( WAVEFORMATEX ) ) );
if ( p_chk -> strf . auds . p_wf -> wFormatTag != WAVE_FORMAT_PCM && p_chk -> common . i_chunk_size > sizeof ( WAVEFORMATEX ) )
if ( p_chk -> strf . auds . p_wf -> cbSize > p_chk -> common . i_chunk_size - sizeof ( WAVEFORMATEX ) )
p_chk -> strf . auds . p_wf -> cbSize = p_chk -> common . i_chunk_size - sizeof ( WAVEFORMATEX );
0
------------------------------
306821 117366/CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_fscanf_84_bad.cpp myString = ( wchar_t * ) malloc ( data * sizeof ( wchar_t ) ) 42
void bad()
size_t data ;
data = 0;
CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_fscanf_84_bad * badObject = new CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_fscanf_84_bad ( data ) ;
CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_fscanf_84_bad::CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_fscanf_84_bad(size_t dataCopy)
data = dataCopy;
fscanf ( stdin , "%ud" , & data );
delete badObject
CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_fscanf_84_bad::~CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_fscanf_84_bad()
wchar_t * myString ;
if ( data > wcslen ( HELLO_STRING ) )
myString = ( wchar_t * ) malloc ( data * sizeof ( wchar_t ) );
wcscpy ( myString , HELLO_STRING );
printWLine ( myString );
void printWLine (const wchar_t * line)
if ( line != NULL )
wprintf ( L "%ls\n" , line )
free ( myString );
1
------------------------------
312746 117408/CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_listen_socket_72b.cpp myString = ( wchar_t * ) malloc ( data * sizeof ( wchar_t ) ) 73
static void goodG2B()
vector < size_t > dataVector ;
goodG2BSink ( dataVector );
void goodG2BSink(vector<size_t> dataVector)
size_t data = dataVector [ 2 ] ;
wchar_t * myString ;
if ( data > wcslen ( HELLO_STRING ) )
myString = ( wchar_t * ) malloc ( data * sizeof ( wchar_t ) );
wcscpy ( myString , HELLO_STRING );
printWLine ( myString );
void printWLine (const wchar_t * line)
if ( line != NULL )
wprintf ( L "%ls\n" , line )
free ( myString );
0
------------------------------
298991 62160/CWE114_Process_Control__w32_char_listen_socket_45.c recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 117
void CWE114_Process_Control__w32_char_listen_socket_45_bad()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
CWE114_Process_Control__w32_char_listen_socket_45_badData = data;
0
------------------------------
17974 CVE-2015-5156/linux_kernel_4.1.9_CVE_2015_5156_drivers_net_virtio_net.c names = kmalloc ( total_vqs * sizeof ( * names ) , GFP_KERNEL ) 1547
static int virtnet_probe(struct virtio_device *vdev)
int i , err ;
struct net_device * dev ;
struct virtnet_info * vi ;
u16 max_queue_pairs ;
if ( ! vdev -> config -> get )
if ( ! virtnet_validate_features ( vdev ) )
static bool virtnet_validate_features(struct virtio_device *vdev)
if ( ! virtio_has_feature ( vdev , VIRTIO_NET_F_CTRL_VQ ) && ( VIRTNET_FAIL_ON ( vdev , VIRTIO_NET_F_CTRL_RX , "VIRTIO_NET_F_CTRL_VQ" ) || VIRTNET_FAIL_ON ( vdev , VIRTIO_NET_F_CTRL_VLAN , "VIRTIO_NET_F_CTRL_VQ" ) || VIRTNET_FAIL_ON ( vdev , VIRTIO_NET_F_GUEST_ANNOUNCE , "VIRTIO_NET_F_CTRL_VQ" ) || VIRTNET_FAIL_ON ( vdev , VIRTIO_NET_F_MQ , "VIRTIO_NET_F_CTRL_VQ" ) || VIRTNET_FAIL_ON ( vdev , VIRTIO_NET_F_CTRL_MAC_ADDR , "VIRTIO_NET_F_CTRL_VQ" ) ) )
return false ;
return true ;
err = virtio_cread_feature ( vdev , VIRTIO_NET_F_MQ
struct virtio_net_config
max_virtqueue_pairs , & max_queue_pairs )
if ( err || max_queue_pairs < VIRTIO_NET_CTRL_MQ_VQ_PAIRS_MIN || max_queue_pairs > VIRTIO_NET_CTRL_MQ_VQ_PAIRS_MAX || ! virtio_has_feature ( vdev , VIRTIO_NET_F_CTRL_VQ ) )
max_queue_pairs = 1;
dev = alloc_etherdev_mq ( sizeof ( struct virtnet_info ) , max_queue_pairs );
if ( ! dev )
dev -> priv_flags |= IFF_UNICAST_FLT | IFF_LIVE_ADDR_CHANGE;
dev -> netdev_ops = & virtnet_netdev;
dev -> features = NETIF_F_HIGHDMA;
dev -> ethtool_ops = & virtnet_ethtool_ops;
if ( virtio_has_feature ( vdev , VIRTIO_NET_F_CSUM ) )
dev -> hw_features |= NETIF_F_HW_CSUM | NETIF_F_SG | NETIF_F_FRAGLIST;
if ( csum )
dev -> features |= NETIF_F_HW_CSUM | NETIF_F_SG | NETIF_F_FRAGLIST;
if ( virtio_has_feature ( vdev , VIRTIO_NET_F_GSO ) )
dev -> hw_features |= NETIF_F_TSO | NETIF_F_UFO | NETIF_F_TSO_ECN | NETIF_F_TSO6;
if ( virtio_has_feature ( vdev , VIRTIO_NET_F_HOST_TSO4 ) )
dev -> hw_features |= NETIF_F_TSO;
if ( virtio_has_feature ( vdev , VIRTIO_NET_F_HOST_TSO6 ) )
dev -> hw_features |= NETIF_F_TSO6;
if ( virtio_has_feature ( vdev , VIRTIO_NET_F_HOST_ECN ) )
dev -> hw_features |= NETIF_F_TSO_ECN;
if ( virtio_has_feature ( vdev , VIRTIO_NET_F_HOST_UFO ) )
dev -> hw_features |= NETIF_F_UFO;
dev -> features |= NETIF_F_GSO_ROBUST;
if ( gso )
dev -> features |= dev -> hw_features & ( NETIF_F_ALL_TSO | NETIF_F_UFO );
if ( virtio_has_feature ( vdev , VIRTIO_NET_F_GUEST_CSUM ) )
dev -> features |= NETIF_F_RXCSUM;
dev -> vlan_features = dev -> features;
vi = netdev_priv ( dev );
vi -> dev = dev;
vi -> vdev = vdev;
vdev -> priv = vi;
vi -> stats = alloc_percpu ( struct virtnet_stats )
if ( vi -> stats == NULL )
if ( virtio_has_feature ( vdev , VIRTIO_NET_F_MRG_RXBUF ) || virtio_has_feature ( vdev , VIRTIO_F_VERSION_1 ) )
vi -> hdr_len = sizeof ( struct virtio_net_hdr );
if ( virtio_has_feature ( vdev , VIRTIO_F_ANY_LAYOUT ) || virtio_has_feature ( vdev , VIRTIO_F_VERSION_1 ) )
vi -> any_header_sg = true;
if ( virtio_has_feature ( vdev , VIRTIO_NET_F_CTRL_VQ ) )
vi -> has_cvq = true;
vi -> curr_queue_pairs = 1;
vi -> max_queue_pairs = max_queue_pairs;
err = init_vqs ( vi );
static int init_vqs(struct virtnet_info *vi)
int ret ;
ret = virtnet_alloc_queues ( vi );
if ( ret )
ret = virtnet_find_vqs ( vi );
static int virtnet_find_vqs(struct virtnet_info *vi)
vq_callback_t * * callbacks ;
struct virtqueue * * vqs ;
int i , total_vqs ;
const char * * names ;
total_vqs = vi -> max_queue_pairs * 2 + virtio_has_feature ( vi -> vdev , VIRTIO_NET_F_CTRL_VQ );
vqs = kzalloc ( total_vqs * sizeof ( * vqs ) , GFP_KERNEL );
if ( ! vqs )
callbacks = kmalloc ( total_vqs * sizeof ( * callbacks ) , GFP_KERNEL );
if ( ! callbacks )
names = kmalloc ( total_vqs * sizeof ( * names ) , GFP_KERNEL );
if ( ! names )
names [ total_vqs - 1 ] = "control";
names [ rxq2vq ( i ) ] = vi -> rq [ i ] . name;
names [ txq2vq ( i ) ] = vi -> sq [ i ] . name;
ret = vi -> vdev -> config -> find_vqs ( vi -> vdev , total_vqs , vqs , callbacks , names );
if ( ret )
vi -> cvq = vqs [ total_vqs - 1 ];
if ( virtio_has_feature ( vi -> vdev , VIRTIO_NET_F_CTRL_VLAN ) )
vi -> dev -> features |= NETIF_F_HW_VLAN_CTAG_FILTER;
for (i = 0; i < vi->max_queue_pairs; i++)
vi -> rq [ i ] . vq = vqs [ rxq2vq ( i ) ];
vi -> sq [ i ] . vq = vqs [ txq2vq ( i ) ];
kfree ( names );
kfree ( names );
return ret ;
1
------------------------------
20533 CVE-2016-9103/qemu_2.3.0_CVE-2016-9103_virtio-9p.c bsize_factor = ( s -> msize - P9_IOHDRSZ ) / stbuf -> f_bsize 2712
static void v9fs_statfs(void *opaque)
int32_t fid ;
size_t offset = 7 ;
V9fsFidState * fidp ;
V9fsPDU * pdu = opaque ;
V9fsState * s = pdu -> s ;
retval = pdu_unmarshal ( pdu , offset , "d" , & fid );
if ( retval < 0 )
fidp = get_fid ( pdu , fid );
static V9fsFidState *get_fid(V9fsPDU *pdu, int32_t fid)
int err ;
V9fsFidState * f ;
V9fsState * s = pdu -> s ;
for (f = s->fid_list; f; f = f->next)
if ( f -> fid == fid )
f -> ref ++;
err = v9fs_reopen_fid ( pdu , f );
static int v9fs_reopen_fid(V9fsPDU *pdu, V9fsFidState *f)
int err = 1 ;
if ( f -> fid_type == P9_FID_FILE )
if ( f -> fs . fd == - 1 )
err = v9fs_co_open ( pdu , f , f -> open_flags );
while ( err == - EINTR && ! pdu -> cancelled )
if ( f -> fid_type == P9_FID_DIR )
if ( f -> fs . dir == NULL )
err = v9fs_co_opendir ( pdu , f );
while ( err == - EINTR && ! pdu -> cancelled )
return err ;
if ( err < 0 )
return NULL ;
f -> flags |= FID_REFERENCED;
return f ;
return NULL ;
if ( fidp == NULL )
retval = v9fs_co_statfs ( pdu , & fidp -> path , & stbuf );
if ( retval < 0 )
retval = v9fs_fill_statfs ( s , pdu , & stbuf );
static int v9fs_fill_statfs(V9fsState *s, V9fsPDU *pdu, struct statfs *stbuf)
int32_t bsize_factor ;
bsize_factor = ( s -> msize - P9_IOHDRSZ ) / stbuf -> f_bsize;
if ( ! bsize_factor )
f_bsize *= bsize_factor;
f_blocks = stbuf -> f_blocks / bsize_factor;
f_bfree = stbuf -> f_bfree / bsize_factor;
f_bavail = stbuf -> f_bavail / bsize_factor;
return pdu_marshal ( pdu , offset , "ddqqqqqqd" , f_type , f_bsize , f_blocks , f_bfree , f_bavail , f_files , f_ffree , fsid_val , f_namelen ) ;
0
------------------------------
17235 CVE-2013-7024/CVE_2013_7024_VULN_jpeg2000_decode_tile.c Jpeg2000Component * comp = tile -> comp + compno ; 119
static int CVE_2013_7024_VULN_jpeg2000_decode_tile(Jpeg2000DecoderContext *s, Jpeg2000Tile
AVFrame *picture)
int compno , reslevelno , bandno ;
int x , y ;
for (compno = 0; compno < s->ncomponents; compno++)
Jpeg2000Component * comp = tile -> comp + compno ;
Jpeg2000CodingStyle * codsty = tile -> codsty + compno ;
for (reslevelno = 0; reslevelno < codsty->nreslevels2decode; reslevelno++)
Jpeg2000ResLevel * rlevel = comp -> reslevel + reslevelno ;
for (bandno = 0; bandno < rlevel->nbands; bandno++)
int nb_precincts , precno ;
Jpeg2000Band * band = rlevel -> band + bandno ;
if ( band -> coord [ 0 ] [ 0 ] == band -> coord [ 0 ] [ 1 ] || band -> coord [ 1 ] [ 0 ] == band -> coord [ 1 ] [ 1 ] )
nb_precincts = rlevel -> num_precincts_x * rlevel -> num_precincts_y;
for (precno = 0; precno < nb_precincts; precno++)
Jpeg2000Prec * prec = band -> prec + precno ;
for (cblkno = 0; cblkno < prec->nb_codeblocks_width * prec->nb_codeblocks_height; cblkno++)
int x , y ;
Jpeg2000Cblk * cblk = prec -> cblk + cblkno ;
x = cblk -> coord [ 0 ] [ 0 ];
if ( s -> cdef [ 0 ] < 0 )
for (x = 0; x < s->ncomponents; x++)
s -> cdef [ x ] = x + 1;
if ( ( s -> ncomponents & 1 ) == 0 )
s -> cdef [ s -> ncomponents - 1 ] = 0;
if ( s -> precision <= 8 )
for (compno = 0; compno < s->ncomponents; compno++)
Jpeg2000Component * comp = tile -> comp + compno ;
0
------------------------------
20913 CVE-2015-8962/linux_kernel_4.3_CVE_2015_8962_drivers_scsi_sg.c hp -> dxferp = ( char __user * ) buf + cmd_size 656
static
sg_write(struct file *filp, const char __user *buf, size_t count, loff_t * ppos)
int mxsize , cmd_size , k ;
int input_size , blocking ;
unsigned char opcode ;
Sg_device * sdp ;
Sg_fd * sfp ;
Sg_request * srp ;
struct sg_header old_hdr ;
sg_io_hdr_t * hp ;
if ( ( ! ( sfp = ( Sg_fd * ) filp -> private_data ) ) || ( ! ( sdp = sfp -> parentdp ) ) )
if ( atomic_read ( & sdp -> detaching ) )
if ( ! ( ( filp -> f_flags & O_NONBLOCK ) || scsi_block_when_processing_errors ( sdp -> device ) ) )
if ( ! access_ok ( VERIFY_READ , buf , count ) )
if ( count < SZ_SG_HEADER )
if ( __copy_from_user ( & old_hdr , buf , SZ_SG_HEADER ) )
if ( old_hdr . reply_len < 0 )
if ( count < ( SZ_SG_HEADER + 6 ) )
if ( ! ( srp = sg_add_request ( sfp ) ) )
static Sg_request
sg_add_request(Sg_fd * sfp)
int k ;
Sg_request * resp ;
Sg_request * rp = sfp -> req_arr ;
resp = sfp -> headrp;
if ( ! resp )
memset ( rp , 0 , sizeof ( Sg_request ) );
rp -> parentfp = sfp;
resp = rp;
if ( 0 == sfp -> cmd_q )
resp = NULL;
if ( k < SG_MAX_QUEUE )
memset ( rp , 0 , sizeof ( Sg_request ) );
rp -> parentfp = sfp;
while ( resp -> nextrp )
resp = resp -> nextrp;
resp -> nextrp = rp;
resp = rp;
resp = NULL;
if ( resp )
resp -> nextrp = NULL;
resp -> header . duration = jiffies_to_msecs ( jiffies );
return resp ;
buf += SZ_SG_HEADER;
if ( sfp -> next_cmd_len > 0 )
cmd_size = sfp -> next_cmd_len;
cmd_size = COMMAND_SIZE ( opcode );
if ( ( opcode >= 0xc0 ) && old_hdr . twelve_byte )
cmd_size = 12;
input_size = count - cmd_size;
mxsize = ( input_size > old_hdr . reply_len ) ? input_size : old_hdr . reply_len;
mxsize -= SZ_SG_HEADER;
input_size -= SZ_SG_HEADER;
if ( input_size < 0 )
hp = & srp -> header;
hp -> interface_id = '\0';
hp -> cmd_len = ( unsigned char ) cmd_size;
hp -> iovec_count = 0;
hp -> mx_sb_len = 0;
if ( input_size > 0 )
hp -> dxfer_direction = ( old_hdr . reply_len > SZ_SG_HEADER ) ? SG_DXFER_TO_FROM_DEV : SG_DXFER_TO_DEV;
hp -> dxfer_direction = ( mxsize > 0 ) ? SG_DXFER_FROM_DEV : SG_DXFER_NONE;
hp -> dxfer_len = mxsize;
if ( hp -> dxfer_direction == SG_DXFER_TO_DEV )
hp -> dxferp = ( char __user * ) buf + cmd_size;
0
------------------------------
309298 112784/CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_listen_socket_42.c recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 199
static void goodB2G()
char * data ;
data = ( char * ) malloc ( 100 * sizeof ( char ) );
data [ 0 ] = '\0';
data = goodB2GSource ( data );
static char * goodB2GSource(char * data)
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
return data ;
0
------------------------------
304497 83963/CWE190_Integer_Overflow__short_fscanf_square_51b.c short result = data * data ; 53
static void goodB2G()
short data ;
data = 0;
CWE190_Integer_Overflow__short_fscanf_square_51b_goodB2GSink ( data );
void CWE190_Integer_Overflow__short_fscanf_square_51b_goodB2GSink(short data)
if ( abs ( ( long ) data ) <= ( long ) sqrt ( ( double ) SHRT_MAX ) )
short result = data * data ;
printIntLine ( result );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
1
------------------------------
308572 117358/CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_fscanf_67b.c myString = ( wchar_t * ) malloc ( data * sizeof ( wchar_t ) ) 43
void CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_fscanf_67_bad()
size_t data ;
CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_fscanf_67_structType myStruct ;
data = 0;
myStruct . structFirst = data;
CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_fscanf_67b_badSink ( myStruct );
void CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_fscanf_67b_badSink(CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_fscanf_67_structType myStruct)
size_t data = myStruct . structFirst ;
wchar_t * myString ;
if ( data > wcslen ( HELLO_STRING ) )
myString = ( wchar_t * ) malloc ( data * sizeof ( wchar_t ) );
wcscpy ( myString , HELLO_STRING );
printWLine ( myString );
void printWLine (const wchar_t * line)
if ( line != NULL )
wprintf ( L "%ls\n" , line )
free ( myString );
1
------------------------------
310758 151097/aviobuf.c s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_ptr - s -> checksum_ptr ) ) ) 164
void avio_wl64(AVIOContext *s,uint64_t val)
avio_wl32 ( s , ( ( uint32_t ) ( val & 0xffffffff ) ) );
void avio_wl32(AVIOContext *s,unsigned int val)
avio_w8 ( s , ( ( uint8_t ) val ) );
void avio_w8(AVIOContext *s,int b)
* ( s -> buf_ptr ++ ) = b;
if ( s -> buf_ptr >= s -> buf_end )
flush_buffer ( s );
static void flush_buffer(AVIOContext *s)
if ( s -> buf_ptr > s -> buffer )
if ( s -> update_checksum )
s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_ptr - s -> checksum_ptr ) ) );
s -> checksum_ptr = s -> buffer;
s -> buf_ptr = s -> buffer;
0
------------------------------
311575 150219/avdevice.c dirpath = ( char * ) malloc ( size_dirpath * sizeof ( char ) ) 41
void stonesoup_setup_printf_context()
ss_tc_root = getenv ( "SS_TC_ROOT" );
if ( ss_tc_root != NULL )
size_dirpath = strlen ( ss_tc_root ) + strlen ( "testData" ) + 2;
dirpath = ( char * ) malloc ( size_dirpath * sizeof ( char ) );
if ( dirpath != NULL )
sprintf ( dirpath , "%s/%s" , ss_tc_root , "testData" );
if ( stat ( dirpath , & st ) == - 1 )
retval = mkdir ( dirpath , 0700 );
if ( retval == 0 )
size_filepath = strlen ( dirpath ) + strlen ( "logfile.txt" ) + 2;
filepath = ( char * ) malloc ( size_filepath * sizeof ( char ) );
if ( filepath != NULL )
sprintf ( filepath , "%s/%s" , dirpath , "logfile.txt" );
stonesoup_printf_context = fopen ( filepath , "w" );
free ( filepath );
free ( dirpath );
if ( stonesoup_printf_context == NULL )
0
------------------------------
314723 110478/CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fscanf_33.cpp intPointer = ( int * ) malloc ( data * sizeof ( int ) ) 39
void bad()
int data ;
int & dataRef = data ;
data = - 1;
int data = dataRef ;
int * intPointer ;
intPointer = ( int * ) malloc ( data * sizeof ( int ) );
intPointer [ i ] = 0;
printIntLine ( intPointer [ 0 ] );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
free ( intPointer );
1
------------------------------
298595 94217/CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_connect_socket_34.c recvResult = recv ( connectSocket , ( char * ) ( password + passwordLen ) , ( 100 - passwordLen - 1 ) * sizeof ( wchar_t ) , 0 ) 214
static void goodB2G()
wchar_t * password ;
wchar_t passwordBuffer [ 100 ] = L ""
password = passwordBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t passwordLen = wcslen ( password ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( password + passwordLen ) , ( 100 - passwordLen - 1 ) * sizeof ( wchar_t ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
314589 96589/CWE36_Absolute_Path_Traversal__char_listen_socket_ifstream_74a.cpp recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ) 105
void bad()
char * data ;
char dataBuffer [ FILENAME_MAX ] = "" ;
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
dataMap [ 0 ] = data;
dataMap [ 1 ] = data;
dataMap [ 2 ] = data;
badSink ( dataMap );
void badSink(map<int, char *> dataMap)
char * data = dataMap [ 2 ] ;
inputFile . open ( ( char * ) data );
0
------------------------------
313590 82393/CWE190_Integer_Overflow__char_max_square_74b.cpp char result = data * data ; 36
void bad()
char data ;
map < int , char > dataMap ;
data = ' ';
data = CHAR_MAX;
dataMap [ 0 ] = data;
dataMap [ 1 ] = data;
dataMap [ 2 ] = data;
badSink ( dataMap );
void badSink(map<int, char> dataMap)
char data = dataMap [ 2 ] ;
char result = data * data ;
printHexCharLine ( result );
void printHexCharLine (char charHex)
printf ( "%02x\n" , charHex );
1
------------------------------
19833 CVE-2016-2522/Wireshark_2.0.1_CVE_2016_2522_epan_dissectors_packet-ber.c end_offset = offset + len 3012

dissect_ber_UTCTime(gboolean implicit_tag, asn1_ctx_t *actx, proto_tree *tree, tvbuff_t *tvb, int offset, gint hf_id)
gint8 ber_class ;
gboolean pc ;
gint32 tag ;
guint32 len , i , n ;
int hoffset ;
proto_item * cause ;
if ( ! implicit_tag )
hoffset = offset;
offset = dissect_ber_identifier ( actx -> pinfo , tree , tvb , offset , & ber_class , & pc , & tag );
offset = dissect_ber_length ( actx -> pinfo , tree , tvb , offset , & len , NULL );
if ( ( ber_class != BER_CLASS_UNI ) || ( tag != BER_UNI_TAG_UTCTime ) )
cause = proto_tree_add_string_format_value ( tree , hf_ber_error , tvb , offset , len , "utctime_expected" , "UTCTime expected but class:%s(%d) %s tag:%d was unexpected" , val_to_str_const ( ber_class , ber_class_codes , "Unknown" ) , ber_class , pc ? ber_pc_codes_short . true_string : ber_pc_codes_short . false_string , tag );
if ( decode_unexpected )
proto_tree * unknown_tree = proto_item_add_subtree ( cause , ett_ber_unknown ) ;
dissect_unknown_ber ( actx -> pinfo , tvb , hoffset , unknown_tree );

dissect_unknown_ber(packet_info *pinfo, tvbuff_t *tvb, int offset, proto_tree *tree)
return try_dissect_unknown_ber ( pinfo , tvb , offset , tree , 1 ) ;
static
try_dissect_unknown_ber(packet_info *pinfo, tvbuff_t *tvb, volatile int offset, proto_tree *tree, gint nest_level)
int start_offset ;
gint8 ber_class ;
gboolean pc , ind ;
gint32 tag ;
guint32 len ;
start_offset = offset;
offset = get_ber_identifier ( tvb , offset , & ber_class , & pc , & tag );
offset = get_ber_length ( tvb , offset , & len , & ind );
if ( len > ( guint32 ) tvb_reported_length_remaining ( tvb , offset ) )
switch ( pc )
switch ( ber_class )
switch ( tag )
offset = dissect_ber_GeneralString ( & asn1_ctx , tree , tvb , start_offset , hf_ber_unknown_GeneralString , NULL , 0 );

dissect_ber_GeneralString(asn1_ctx_t *actx, proto_tree *tree, tvbuff_t *tvb, int offset, gint hf_id, char *name_string, int name_len)
guint32 len ;
int end_offset ;
offset = dissect_ber_identifier ( actx -> pinfo , tree , tvb , offset , & ber_class , & pc , & tag );
offset = dissect_ber_length ( actx -> pinfo , tree , tvb , offset , & len , NULL );
end_offset = offset + len;
return end_offset ;
return end_offset ;
1
------------------------------
306340 117300/CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_fgets_51b.c myString = ( wchar_t * ) malloc ( data * sizeof ( wchar_t ) ) 39
void CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_fgets_51_bad()
size_t data ;
data = 0;
char inputBuffer [ CHAR_ARRAY_SIZE ] = "" ;
if ( fgets ( inputBuffer , CHAR_ARRAY_SIZE , stdin ) != NULL )
data = strtoul ( inputBuffer , NULL , 0 );
CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_fgets_51b_badSink ( data );
void CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_fgets_51b_badSink(size_t data)
wchar_t * myString ;
if ( data > wcslen ( HELLO_STRING ) )
myString = ( wchar_t * ) malloc ( data * sizeof ( wchar_t ) );
wcscpy ( myString , HELLO_STRING );
printWLine ( myString );
void printWLine (const wchar_t * line)
if ( line != NULL )
wprintf ( L "%ls\n" , line )
free ( myString );
1
------------------------------
314117 110874/CWE680_Integer_Overflow_to_Buffer_Overflow__new_rand_62a.cpp dataBytes = data * sizeof ( int ) 37
void bad()
int data ;
data = - 1;
size_t dataBytes , i ;
dataBytes = data * sizeof ( int );
intPointer = ( int * ) new char [ dataBytes ];
intPointer [ i ] = 0;
printIntLine ( intPointer [ 0 ] );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
delete [ ] intPointer
1
------------------------------
308140 120486/CWE78_OS_Command_Injection__wchar_t_connect_socket_popen_84_bad.cpp recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 ) 92
void bad()
wchar_t * data ;
wchar_t data_buf [ 100 ] = FULL_COMMAND ;
data = data_buf;
CWE78_OS_Command_Injection__wchar_t_connect_socket_popen_84_bad * badObject = new CWE78_OS_Command_Injection__wchar_t_connect_socket_popen_84_bad ( data ) ;
CWE78_OS_Command_Injection__wchar_t_connect_socket_popen_84_bad::CWE78_OS_Command_Injection__wchar_t_connect_socket_popen_84_bad(wchar_t * dataCopy)
data = dataCopy;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
313312 91012/CWE23_Relative_Path_Traversal__wchar_t_connect_socket_w32CreateFile_68a.cpp recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ) 100
void bad()
wchar_t * data ;
wchar_t dataBuffer [ FILENAME_MAX ] = BASEPATH ;
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( FILENAME_MAX - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
20678 CVE-2016-8910/qemu_2.3.0_CVE-2016-8910_rtl8139.c int tso_send_size = ETH_HLEN + hlen + tcp_hlen + chunk_size ; 2304
static void rtl8139_io_writew(void *opaque, uint8_t addr, uint32_t val)
switch ( addr )
rtl8139_io_writeb ( opaque , addr , val & 0xff );
static void rtl8139_io_writeb(void *opaque, uint8_t addr, uint32_t val)
RTL8139State * s = opaque ;
switch ( addr )
if ( val == 'R' )
if ( val == 'H' )
s -> clock_enabled = 0;
s -> TxThresh = val;
if ( val & ( 1 << 6 ) )
rtl8139_cplus_transmit ( s );
static void rtl8139_cplus_transmit(RTL8139State *s)
while ( rtl8139_cplus_transmit_one ( s ) )
static int rtl8139_cplus_transmit_one(RTL8139State *s)
if ( ! rtl8139_transmitter_enabled ( s ) )
if ( ! rtl8139_cp_transmitter_enabled ( s ) )
uint32_t val , txdw0 , txdw1 , txbufLO , txbufHI ;
txdw0 = le32_to_cpu ( val );
if ( ! ( txdw0 & CP_TX_OWN ) )
if ( txdw0 & CP_TX_FS )
s -> cplus_txbuffer_offset = 0;
int txsize = txdw0 & CP_TX_BUFFER_SIZE_MASK ;
if ( ! s -> cplus_txbuffer )
s -> cplus_txbuffer_len = CP_TX_BUFFER_SIZE;
s -> cplus_txbuffer = g_malloc ( s -> cplus_txbuffer_len );
s -> cplus_txbuffer_offset = 0;
if ( s -> cplus_txbuffer_offset + txsize >= s -> cplus_txbuffer_len )
txsize = s -> cplus_txbuffer_len - s -> cplus_txbuffer_offset;
s -> cplus_txbuffer_offset += txsize;
if ( txdw0 & CP_TX_EOR )
s -> currCPlusTxDesc = 0;
if ( s -> currCPlusTxDesc >= 64 )
s -> currCPlusTxDesc = 0;
txdw0 &= ~CP_RX_OWN;
txdw0 &= ~CP_TX_STATUS_UNF;
txdw0 &= ~CP_TX_STATUS_TES;
txdw0 &= ~CP_TX_STATUS_OWC;
txdw0 &= ~CP_TX_STATUS_LNKF;
txdw0 &= ~CP_TX_STATUS_EXC;
if ( txdw0 & CP_TX_LS )
uint8_t * saved_buffer = s -> cplus_txbuffer ;
if ( txdw0 & ( CP_TX_IPCS | CP_TX_UDPCS | CP_TX_TCPCS | CP_TX_LGSEN ) )
ip_header * ip = NULL ;
int hlen = 0 ;
uint8_t ip_protocol = 0 ;
uint16_t ip_data_len = 0 ;
uint8_t * eth_payload_data = NULL ;
int proto = be16_to_cpu ( * ( uint16_t * ) ( saved_buffer + 12 ) ) ;
if ( proto == ETH_P_IP )
eth_payload_data = saved_buffer + ETH_HLEN;
ip = ( ip_header * ) eth_payload_data;
if ( IP_HEADER_VERSION ( ip ) != IP_HEADER_VERSION_4 )
ip = NULL;
hlen = IP_HEADER_LENGTH ( ip );
ip_protocol = ip -> ip_p;
ip_data_len = be16_to_cpu ( ip -> ip_len ) - hlen;
if ( ip )
if ( ( txdw0 & CP_TX_LGSEN ) && ip_protocol == IP_PROTO_TCP )
tcp_header * p_tcp_hdr = ( tcp_header * ) ( eth_payload_data + hlen ) ;
int tcp_hlen = TCP_HEADER_DATA_OFFSET ( p_tcp_hdr ) ;
int tcp_data_len = ip_data_len - tcp_hlen ;
int tcp_chunk_size = ETH_MTU - hlen - tcp_hlen ;
for (tcp_send_offset = 0; tcp_send_offset < tcp_data_len; tcp_send_offset += tcp_chunk_size)
uint16_t chunk_size = tcp_chunk_size ;
if ( tcp_send_offset + tcp_chunk_size >= tcp_data_len )
chunk_size = tcp_data_len - tcp_send_offset;
int tso_send_size = ETH_HLEN + hlen + tcp_hlen + chunk_size ;
rtl8139_transfer_frame ( s , saved_buffer , tso_send_size , 0 , ( uint8_t * ) dot1q_buffer );
0
------------------------------
18572 CVE-2015-2716/Firefox_37.0b7_CVE_2015_2716_parser_expat_lib_xmlparse.c tem = ( BLOCK * ) pool -> mem -> malloc_fcn ( offsetof ( BLOCK , s ) + blockSize * sizeof ( XML_Char ) ) 6275
static enum
processXmlDecl(XML_Parser parser, int
const char *s, const char *next)
const char * encodingName = NULL ;
const char * version = NULL ;
const char * versionend ;
if ( ! ( ns ? XmlParseXmlDeclNS : XmlParseXmlDecl ) ( isGeneralTextEntity , encoding , s , next , & eventPtr , & version , & versionend , & encodingName , & newEncoding , & standalone ) )
if ( xmlDeclHandler )
if ( encodingName != NULL )
storedEncName = poolStoreString ( & temp2Pool , encoding , encodingName , encodingName + XmlNameLength ( encoding , encodingName ) );
if ( ! storedEncName )
if ( version )
storedversion = poolStoreString ( & temp2Pool , encoding , version , versionend - encoding -> minBytesPerChar );
static XML_Char
poolStoreString(STRING_POOL *pool, const ENCODING
const char *ptr, const char *end)
if ( ! poolAppend ( pool , enc , ptr , end ) )
static XML_Char
poolAppend(STRING_POOL *pool, const ENCODING
const char *ptr, const char *end)
if ( ! pool -> ptr && ! poolGrow ( pool ) )
static XML_Bool
poolGrow(STRING_POOL *pool)
if ( pool -> freeBlocks )
if ( pool -> start == 0 )
if ( pool -> end - pool -> start < pool -> freeBlocks -> size )
if ( pool -> blocks && pool -> start == pool -> blocks -> s )
BLOCK * tem ;
int blockSize = ( int ) ( pool -> end - pool -> start ) ;
if ( blockSize < INIT_BLOCK_SIZE )
blockSize = INIT_BLOCK_SIZE;
blockSize *= 2;
tem = ( BLOCK * ) pool -> mem -> malloc_fcn ( offsetof ( BLOCK , s ) + blockSize * sizeof ( XML_Char ) );
if ( ! tem )
tem -> size = blockSize;
tem -> next = pool -> blocks;
pool -> blocks = tem;
if ( pool -> ptr != pool -> start )
memcpy ( tem -> s , pool -> start , ( pool -> ptr - pool -> start ) * sizeof ( XML_Char ) );
pool -> ptr = tem -> s + ( pool -> ptr - pool -> start );
pool -> start = tem -> s;
pool -> end = tem -> s + blockSize;
0
------------------------------
304559 83087/CWE190_Integer_Overflow__int_connect_socket_square_18.c int result = data * data ; 113
void CWE190_Integer_Overflow__int_connect_socket_square_18_bad()
int data ;
data = 0;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
char inputBuffer [ CHAR_ARRAY_SIZE ] ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
inputBuffer [ recvResult ] = '\0';
data = atoi ( inputBuffer );
while ( 0 )
int result = data * data ;
printIntLine ( result );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
1
------------------------------
301150 152157/mux.c stonesoup_malloced_buff [ stonesoup_ss_i ] = malloc ( stonesoup_taint_size * stonesoup_taint_size * sizeof ( char ) ) 950
int avformat_write_header(AVFormatContext *s,AVDictionary **options)
int vulgarest_prokopyevsk = 7 ;
char * volumen_sexhood ;
if ( __sync_bool_compare_and_swap ( & gelilah_porret , 0 , 1 ) )
if ( mkdir ( "/opt/stonesoup/workspace/lockDir" , 509U ) == 0 )
if ( volumen_sexhood != 0 )
tiedeman_vitalizer = & volumen_sexhood;
laspisa_jefes = & tiedeman_vitalizer;
globigerinas_brachycranic = & laspisa_jefes;
laryngeating_furrowlike = & globigerinas_brachycranic;
depravers_unequitableness = & laryngeating_furrowlike;
pharmacopeial_elum = & depravers_unequitableness;
hwelon_basirhinal = & pharmacopeial_elum;
condimental_chopstick = & hwelon_basirhinal;
horsefettler_enwiden = & condimental_chopstick;
hangfires_slinkskin = & horsefettler_enwiden;
camatina_unrecreating ( vulgarest_prokopyevsk , hangfires_slinkskin );
void camatina_unrecreating(int ceil_upsloping,char ***********uruguaiana_haemocyte)
ceil_upsloping --;
if ( ceil_upsloping > 0 )
camatina_unrecreating ( ceil_upsloping , uruguaiana_haemocyte );
void camatina_unrecreating(int ceil_upsloping,char ***********uruguaiana_haemocyte)
ceil_upsloping --;
if ( ceil_upsloping > 0 )
camatina_unrecreating ( ceil_upsloping , uruguaiana_haemocyte );
void camatina_unrecreating(int ceil_upsloping,char ***********uruguaiana_haemocyte)
int stonesoup_ss_i ;
size_t stonesoup_taint_size ;
ceil_upsloping --;
if ( ceil_upsloping > 0 )
warmongers_divided = ( ( char * ) ( * ( * ( * ( * ( * ( * ( * ( * ( * ( * uruguaiana_haemocyte ) ) ) ) ) ) ) ) ) ) );
stonesoup_taint_size = strlen ( warmongers_divided );
if ( stonesoup_taint_size >= 1600 )
stonesoup_taint_size = 1599U;
stonesoup_malloced_buff = malloc ( stonesoup_taint_size * sizeof ( char * ) );
if ( stonesoup_malloced_buff != 0 )
for (stonesoup_ss_i = 0; stonesoup_ss_i < stonesoup_taint_size; ++stonesoup_ss_i)
stonesoup_malloced_buff [ stonesoup_ss_i ] = malloc ( stonesoup_taint_size * stonesoup_taint_size * sizeof ( char ) );
tracepoint ( stonesoup_trace , variable_signed_integral , "stonesoup_ss_i" , stonesoup_ss_i , & stonesoup_ss_i , "CROSSOVER-STATE" );
tracepoint ( stonesoup_trace , variable_address , "stonesoup_malloced_buff[stonesoup_ss_i]" , stonesoup_malloced_buff [ stonesoup_ss_i ] , "CROSSOVER-STATE" );
if ( stonesoup_malloced_buff [ stonesoup_ss_i ] == 0 && errno == 12 )
if ( stonesoup_malloced_buff [ stonesoup_ss_i ] != 0 )
memcpy ( stonesoup_malloced_buff [ stonesoup_ss_i ] + stonesoup_ss_j * stonesoup_taint_size , warmongers_divided , stonesoup_taint_size );
if ( stonesoup_malloced_buff [ stonesoup_ss_i ] != 0 )
free ( stonesoup_malloced_buff [ stonesoup_ss_i ] );
tracepoint ( stonesoup_trace , variable_address , "stonesoup_malloced_buff[stonesoup_ss_i]" , stonesoup_malloced_buff [ stonesoup_ss_i ] , "CROSSOVER-STATE: Free" );
free ( stonesoup_malloced_buff );
1
------------------------------
307662 120034/CWE78_OS_Command_Injection__char_listen_socket_system_44.c recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 117
void CWE78_OS_Command_Injection__char_listen_socket_system_44_bad()
char * data ;
char data_buf [ 100 ] = FULL_COMMAND ;
data = data_buf;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
funcPtr ( data );
0
------------------------------
19942 CVE-2015-4511/Firefox_40.0b9_CVE_2015_4511__media_libnestegg_src_nestegg.c * val = uval - base 696
static
ne_match_webm(nestegg_io io, int64_t max_offset)
int r ;
uint64_t id ;
nestegg * ctx ;
if ( ! ( io . read && io . seek && io . tell ) )
ctx = ne_alloc ( sizeof ( * ctx ) );
static void
ne_alloc(size_t size)
return calloc ( 1 , size ) ;
if ( ! ctx )
ctx -> io = ne_alloc ( sizeof ( * ctx -> io ) );
static void
ne_alloc(size_t size)
return calloc ( 1 , size ) ;
if ( ! ctx -> io )
* ctx -> io = io;
ctx -> alloc_pool = ne_pool_init ( );
static struct pool_ctx
ne_pool_init(void)
return h_malloc ( sizeof ( struct pool_ctx ) ) ;
if ( ! ctx -> alloc_pool )
ctx -> log = ne_null_log_callback;
r = ne_peek_element ( ctx , & id , NULL );
static
ne_peek_element(nestegg * ctx, uint64_t * id, uint64_t * size)
int r ;
if ( ctx -> last_valid )
return 1 ;
r = ne_read_id ( ctx -> io , & ctx -> last_id , NULL );
if ( r != 1 )
return r ;
r = ne_read_vint ( ctx -> io , & ctx -> last_size , NULL );
if ( r != 1 )
return r ;
return 1 ;
if ( r != 1 )
if ( id != ID_EBML )
ne_parse ( ctx , NULL , max_offset );
static
ne_parse(nestegg * ctx, struct ebml_element_desc * top_level, int64_t max_offset)
int r ;
int64_t * data_offset ;
uint64_t id , size , peeked_id ;
struct ebml_element_desc * element ;
if ( ! ctx -> ancestor )
if ( max_offset > 0 && ne_io_tell ( ctx -> io ) >= max_offset )
r = ne_peek_element ( ctx , & id , & size );
if ( r != 1 )
element = ne_find_element ( id , ctx -> ancestor -> node );
if ( element )
if ( element -> flags & DESC_FLAG_SUSPEND )
r = ne_read_element ( ctx , & id , & size );
if ( r != 1 )
if ( element -> flags & DESC_FLAG_OFFSET )
data_offset = ( int64_t * ) ( ctx -> ancestor -> data + element -> data_offset );
* data_offset = ne_io_tell ( ctx -> io );
if ( * data_offset < 0 )
if ( element -> type == TYPE_MASTER )
if ( element -> flags & DESC_FLAG_MULTI )
if ( ne_read_master ( ctx , element ) < 0 )
if ( ne_read_single_master ( ctx , element ) < 0 )
r = ne_read_simple ( ctx , element , size );
if ( r < 0 )
if ( ne_is_ancestor_element ( id , ctx -> ancestor -> previous ) )
if ( top_level && ctx -> ancestor -> node == top_level )
r = ne_read_element ( ctx , & id , & size );
if ( r != 1 )
r = ne_io_read_skip ( ctx -> io , size );
if ( r != 1 )
static
ne_read_simple(nestegg * ctx, struct ebml_element_desc * desc, size_t length)
struct ebml_type * storage ;
int r ;
storage = ( struct ebml_type * ) ( ctx -> ancestor -> data + desc -> offset );
if ( storage -> read )
storage -> type = desc -> type;
switch ( desc -> type )
r = ne_read_int ( ctx -> io , & storage -> v . i , length );
static
ne_read_int(nestegg_io * io, int64_t * val, uint64_t length)
int r ;
uint64_t uval , base ;
r = ne_read_uint ( io , & uval , length );
if ( r != 1 )
if ( length < sizeof ( int64_t ) )
base = 1;
base <<= length * 8 - 1;
if ( uval >= base )
base = 1;
base <<= length * 8;
base = 0;
* val = uval - base;
0
------------------------------
310141 152040/dirent_uri.c apr_size_t seglen = ( ptr - seg ) ; 1376
char *svn_fspath__get_longest_ancestor(const char *fspath1,const char *fspath2,apr_pool_t *result_pool)
svn_fspath__is_canonical ( fspath1 ) ? ( ( void ) 0 ) : __assert_fail ( "svn_fspath__is_canonical(fspath1)" , "dirent_uri.c" , 2563 , __PRETTY_FUNCTION__ );
svn_boolean_t svn_fspath__is_canonical(const char *fspath)
return fspath [ 0 ] == 47 && relpath_is_canonical ( fspath + 1 ) ;
static svn_boolean_t relpath_is_canonical(const char *relpath)
const char * ptr = relpath ;
const char * seg = relpath ;
if ( ( * relpath ) == '\0' )
if ( ( * ptr ) == 47 )
while ( 1 )
apr_size_t seglen = ( ptr - seg ) ;
if ( seglen == 1 && ( * seg ) == 46 )
if ( ( * ptr ) == 47 && ( * ( ptr + 1 ) ) == 47 )
if ( ! ( * ptr ) && ( * ( ptr - 1 ) ) == 47 )
if ( ! ( * ptr ) )
if ( ( * ptr ) == 47 )
ptr ++;
seg = ptr;
while ( * ptr && ( * ptr ) != 47 )
ptr ++;
0
------------------------------
302910 80313/CWE134_Uncontrolled_Format_String__char_listen_socket_printf_16.c recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 98
void CWE134_Uncontrolled_Format_String__char_listen_socket_printf_16_bad()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
while ( 1 )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
printf ( data );
1
------------------------------
304222 84262/CWE190_Integer_Overflow__short_rand_square_68b.c short result = data * data ; 60
void CWE190_Integer_Overflow__short_rand_square_68b_goodB2GSink()
short data = CWE190_Integer_Overflow__short_rand_square_68_goodB2GData ;
if ( abs ( ( long ) data ) <= ( long ) sqrt ( ( double ) SHRT_MAX ) )
short result = data * data ;
printIntLine ( result );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
0
------------------------------
313258 89686/CWE23_Relative_Path_Traversal__char_connect_socket_ofstream_11.cpp recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ) 98
void bad()
char * data ;
char dataBuffer [ FILENAME_MAX ] = BASEPATH ;
data = dataBuffer;
if ( globalReturnsTrue ( ) )
int globalReturnsTrue()
return 1 ;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
outputFile . open ( ( char * ) data );
1
------------------------------
18834 CVE-2015-2716/Firefox_37.0b7_CVE_2015_2716_parser_expat_lib_xmlparse.c pool -> ptr = pool -> blocks -> s + ( pool -> ptr - pool -> start ) 6249
static enum
storeAttributeValue(XML_Parser parser, const ENCODING *enc, XML_Bool
const char *ptr, const char
STRING_POOL *pool)
enum XML_Error result = appendAttributeValue ( parser , enc , isCdata , ptr , end , pool ) ;
static enum
appendAttributeValue(XML_Parser parser, const ENCODING *enc, XML_Bool
const char *ptr, const char
STRING_POOL *pool)
DTD * const dtd = _dtd
const char * next ;
int tok = XmlAttributeValueTok ( enc , ptr , end , & next ) ;
switch ( tok )
XML_Char buf [ XML_ENCODE_MAX ] ;
int i ;
int n = XmlCharRefNumber ( enc , ptr ) ;
if ( n < 0 )
if ( ! isCdata && n == 0x20 && ( poolLength ( pool ) == 0 || poolLastChar ( pool ) == 0x20 ) )
n = XmlEncode ( n , ( ICHAR * ) buf );
if ( ! n )
for (i = 0; i < n; i++)
if ( ! poolAppendChar ( pool , buf [ i ] ) )
if ( ! poolAppend ( pool , enc , ptr , next ) )
next = ptr + enc -> minBytesPerChar;
if ( ! isCdata && ( poolLength ( pool ) == 0 || poolLastChar ( pool ) == 0x20 ) )
if ( ! poolAppendChar ( pool , 0x20 ) )
const XML_Char * name ;
ENTITY * entity ;
char checkEntityDecl ;
XML_Char ch = ( XML_Char ) XmlPredefinedEntityName ( enc , ptr + enc -> minBytesPerChar , next - enc -> minBytesPerChar ) ;
if ( ch )
if ( ! poolAppendChar ( pool , ch ) )
name = poolStoreString ( & temp2Pool , enc , ptr + enc -> minBytesPerChar , next - enc -> minBytesPerChar );
if ( ! name )
entity = ( ENTITY * ) lookup ( & dtd -> generalEntities , name , 0 );
if ( pool == & dtd -> pool )
checkEntityDecl = ! dtd -> hasParamEntityRefs || dtd -> standalone;
if ( checkEntityDecl )
if ( ! entity )
if ( ! entity -> is_internal )
if ( ! entity )
if ( entity -> open )
if ( entity -> notation )
if ( ! entity -> textPtr )
enum XML_Error result ;
const XML_Char * textEnd = entity -> textPtr + entity -> textLen ;
entity -> open = XML_TRUE;
result = appendAttributeValue ( parser , internalEncoding , isCdata , ( char * ) entity -> textPtr , ( char * ) textEnd , pool );
entity -> open = XML_FALSE;
if ( result )
ptr = next;
static XML_Char
poolStoreString(STRING_POOL *pool, const ENCODING
const char *ptr, const char *end)
if ( ! poolAppend ( pool , enc , ptr , end ) )
if ( pool -> ptr == pool -> end && ! poolGrow ( pool ) )
static XML_Bool
poolGrow(STRING_POOL *pool)
if ( pool -> freeBlocks )
if ( pool -> start == 0 )
if ( pool -> end - pool -> start < pool -> freeBlocks -> size )
BLOCK * tem = pool -> freeBlocks -> next ;
pool -> freeBlocks -> next = pool -> blocks;
pool -> blocks = pool -> freeBlocks;
pool -> freeBlocks = tem;
memcpy ( pool -> blocks -> s , pool -> start , ( pool -> end - pool -> start ) * sizeof ( XML_Char ) );
pool -> ptr = pool -> blocks -> s + ( pool -> ptr - pool -> start );
pool -> start = pool -> blocks -> s;
pool -> end = pool -> start + pool -> blocks -> size;
0
------------------------------
313517 95540/CWE36_Absolute_Path_Traversal__char_connect_socket_fopen_03.cpp recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ) 98
void bad()
char * data ;
char dataBuffer [ FILENAME_MAX ] = "" ;
data = dataBuffer;
if ( 5 == 5 )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
pFile = FOPEN ( data , "wb+" );
if ( pFile != NULL )
fclose ( pFile );
1
------------------------------
19889 CVE-2016-2522/Wireshark_2.0.1_CVE_2016_2522_epan_dissectors_packet-ber.c guint8 bits_in_pad = tvb_get_guint8 ( tvb , offset + len - 1 ) & ( 0xFF >> ( 8 - pad ) ) ; 4020

dissect_ber_bitstring32(gboolean implicit_tag, asn1_ctx_t *actx, proto_tree *parent_tree, tvbuff_t *tvb, int offset, int **bit_fields, gint hf_id, gint ett_id, tvbuff_t **out_tvb)
offset = dissect_ber_bitstring ( implicit_tag , actx , parent_tree , tvb , offset , NULL , hf_id , ett_id , & tmp_tvb );

dissect_ber_bitstring(gboolean implicit_tag, asn1_ctx_t *actx, proto_tree *parent_tree, tvbuff_t *tvb, int offset, const asn_namedbit *named_bits, gint hf_id, gint ett_id, tvbuff_t **out_tvb)
return dissect_ber_constrained_bitstring ( implicit_tag , actx , parent_tree , tvb , offset , - 1 , - 1 , named_bits , hf_id , ett_id , out_tvb ) ;

dissect_ber_constrained_bitstring(gboolean implicit_tag, asn1_ctx_t *actx, proto_tree *parent_tree, tvbuff_t *tvb, int offset, gint32 min_len, gint32 max_len, const asn_namedbit *named_bits, gint hf_id, gint ett_id, tvbuff_t **out_tvb)
gint8 ber_class ;
gboolean pc , ind ;
gint32 tag ;
guint32 len , byteno ;
guint8 pad = 0 , b0 , b1 , val , * bitstring ;
if ( ! implicit_tag )
offset = dissect_ber_identifier ( actx -> pinfo , parent_tree , tvb , offset , & ber_class , & pc , & tag );
offset = dissect_ber_length ( actx -> pinfo , parent_tree , tvb , offset , & len , & ind );
if ( ! implicit_tag && ( ber_class != BER_CLASS_APP ) )
if ( ( ber_class != BER_CLASS_UNI ) || ( tag != BER_UNI_TAG_BITSTRING ) )
pc = 0;
len = tvb_reported_length_remaining ( tvb , offset );
if ( pc )
pad = tvb_get_guint8 ( tvb , offset );
offset ++;
len --;
if ( ( pad > 0 ) && ( pad < 8 ) && ( len > 0 ) )
guint8 bits_in_pad = tvb_get_guint8 ( tvb , offset + len - 1 ) & ( 0xFF >> ( 8 - pad ) ) ;
if ( bits_in_pad )
expert_add_info_format ( actx -> pinfo , item , & ei_ber_bits_set_padded , "Bits set in padded area: 0x%02x" , bits_in_pad );
1
------------------------------
20730 CVE-2016-8910/qemu_2.3.0_CVE-2016-8910_rtl8139.c uint32_t reg = ( addr - base ) / 4 ; 2497
static uint64_t rtl8139_ioport_read(void *opaque, hwaddr
unsigned size)
switch ( size )
return rtl8139_io_readl ( opaque , addr ) ;
static uint32_t rtl8139_io_readl(void *opaque, uint8_t addr)
uint32_t ret ;
switch ( addr )
ret = rtl8139_io_readb ( opaque , addr );
static uint32_t rtl8139_io_readb(void *opaque, uint8_t addr)
RTL8139State * s = opaque ;
int ret ;
switch ( addr )
ret = rtl8139_TxStatus_TxAddr_read ( s , s -> TxStatus , TxStatus0 , addr , 1 );
static uint32_t rtl8139_TxStatus_TxAddr_read(RTL8139State *s, uint32_t
uint32_t base, uint8_t
int size)
uint32_t reg = ( addr - base ) / 4 ;
ret = ( regs [ reg ] >> offset * 8 ) & ( ( ( uint64_t ) 1 << ( size * 8 ) ) - 1 );
DPRINTF ( "TxStatus/TxAddr[%d] read addr=0x%x size=0x%x val=0x%08x\n" , reg , addr , size , ret );
return ret ;
0
------------------------------
302912 80312/CWE134_Uncontrolled_Format_String__char_listen_socket_printf_15.c recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 99
void CWE134_Uncontrolled_Format_String__char_listen_socket_printf_15_bad()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
switch ( 6 )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
printf ( data );
1
------------------------------
16521 CVE-2012-3969/CVE_2012_3969_PATCHED_nsSVGFEMorphologyElement__Filter.c extrema [ i ] = sourceData [ targIndex + i ] 37

CVE_2012_3969_PATCHED_nsSVGFEMorphologyElement::Filter(nsSVGFilterInstance
const nsTArray<const Image*>&
const Image*
const nsIntRect& rect)
PRInt32 rx , ry ;
if ( rx < 0 || ry < 0 )
if ( rx == 0 && ry == 0 )
PRUint8 * sourceData = aSources [ 0 ] -> mImage -> Data ( ) ;
PRUint8 * targetData = aTarget -> mImage -> Data ( ) ;
PRInt32 stride = aTarget -> mImage -> Stride ( ) ;
PRUint8 extrema [ 4 ] ;
PRUint16 op = mEnumAttributes [ OPERATOR ] . GetAnimValue ( ) ;
for (PRInt32 y = rect.y; y < rect.YMost(); y++)
PRInt32 startY = NS_MAX ( 0 , y - ry ) ;
PRInt32 endY = NS_MIN ( y + ry , instance -> GetSurfaceHeight ( ) - 1 ) ;
for (PRInt32 x = rect.x; x < rect.XMost(); x++)
PRInt32 startX = NS_MAX ( 0 , x - rx ) ;
PRInt32 endX = NS_MIN ( x + rx , instance -> GetSurfaceWidth ( ) - 1 ) ;
PRInt32 targIndex = y * stride + 4 * x ;
for (PRInt32 i = 0; i < 4; i++)
extrema [ i ] = sourceData [ targIndex + i ];
for (PRInt32 y1 = startY; y1 <= endY; y1++)
for (PRInt32 x1 = startX; x1 <= endX; x1++)
for (PRInt32 i = 0; i < 4; i++)
PRUint8 pixel = sourceData [ y1 * stride + 4 * x1 + i ] ;
if ( ( extrema [ i ] > pixel && op == nsSVGFEMorphologyElement :: SVG_OPERATOR_ERODE ) || ( extrema [ i ] < pixel && op == nsSVGFEMorphologyElement :: SVG_OPERATOR_DILATE ) )
extrema [ i ] = pixel;
targetData [ targIndex ] = extrema [ 0 ];
targetData [ targIndex + 1 ] = extrema [ 1 ];
targetData [ targIndex + 2 ] = extrema [ 2 ];
targetData [ targIndex + 3 ] = extrema [ 3 ];
0
------------------------------
17159 CVE-2010-4342/CVE_2010_4342_VULN_aun_incoming.c newskb = alloc_skb ( ( len - sizeof ( struct aunhdr ) + 15 ) & ~15 , GFP_ATOMIC ) 15
static void CVE_2010_4342_VULN_aun_incoming(struct sk_buff *skb, struct aunhdr *ah, size_t len)
struct iphdr * ip = ip_hdr ( skb ) ;
unsigned char stn = ntohl ( ip -> saddr ) & 0xff ;
struct sk_buff * newskb ;
struct ec_device * edev = skb -> dev -> ec_ptr ;
if ( ! edev )
if ( ( sk = ec_listening_socket ( ah -> port , stn , edev -> net ) ) == NULL )
newskb = alloc_skb ( ( len - sizeof ( struct aunhdr ) + 15 ) & ~15 , GFP_ATOMIC );
0
------------------------------
307061 117039/CWE789_Uncontrolled_Mem_Alloc__malloc_char_fgets_09.c myString = ( char * ) malloc ( data * sizeof ( char ) ) 60
void CWE789_Uncontrolled_Mem_Alloc__malloc_char_fgets_09_bad()
size_t data ;
data = 0;
if ( GLOBAL_CONST_TRUE )
char inputBuffer [ CHAR_ARRAY_SIZE ] = "" ;
if ( fgets ( inputBuffer , CHAR_ARRAY_SIZE , stdin ) != NULL )
data = strtoul ( inputBuffer , NULL , 0 );
if ( GLOBAL_CONST_TRUE )
char * myString ;
if ( data > strlen ( HELLO_STRING ) )
myString = ( char * ) malloc ( data * sizeof ( char ) );
strcpy ( myString , HELLO_STRING );
printLine ( myString );
void printLine (const char * line)
if ( line != NULL )
printf ( "%s\n" , line );
free ( myString );
1
------------------------------
306465 110374/CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fgets_15.c intPointer = ( int * ) malloc ( data * sizeof ( int ) ) 55
void CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fgets_15_bad()
int data ;
data = - 1;
switch ( 6 )
char inputBuffer [ CHAR_ARRAY_SIZE ] = "" ;
if ( fgets ( inputBuffer , CHAR_ARRAY_SIZE , stdin ) != NULL )
data = atoi ( inputBuffer );
int * intPointer ;
intPointer = ( int * ) malloc ( data * sizeof ( int ) );
intPointer [ i ] = 0;
printIntLine ( intPointer [ 0 ] );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
free ( intPointer );
1
------------------------------
305908 112549/CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_connect_socket_52a.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 173
static void goodB2G()
char * data ;
data = ( char * ) malloc ( 100 * sizeof ( char ) );
data [ 0 ] = '\0';
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_connect_socket_52b_goodB2GSink ( data );
void CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_connect_socket_52b_goodB2GSink(char * data)
CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_connect_socket_52c_goodB2GSink ( data );
void CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_connect_socket_52c_goodB2GSink(char * data)
for (i=0; i < strlen(data); i++)
if ( data [ i ] == SEARCH_CHAR )
free ( data );
0
------------------------------
308244 110692/CWE680_Integer_Overflow_to_Buffer_Overflow__new_fgets_81_bad.cpp dataBytes = data * sizeof ( int ) 30
void CWE680_Integer_Overflow_to_Buffer_Overflow__new_fgets_81_bad::action(int data) const
size_t dataBytes , i ;
dataBytes = data * sizeof ( int );
intPointer = ( int * ) new char [ dataBytes ];
intPointer [ i ] = 0;
printIntLine ( intPointer [ 0 ] );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
delete [ ] intPointer
1
------------------------------
17292 CVE-2013-5593/CVE_2013_5593_VULN_nsComboboxControlFrame__AbsolutelyPositionDropDown.c const nsPoint newPos = dropdownPosition + translation ; 50

CVE_2013_5593_VULN_nsComboboxControlFrame::AbsolutelyPositionDropDown()
nsPoint translation ;
nscoord above , below ;
if ( above <= 0 && below <= 0 )
nsSize dropdownSize = mDropdownFrame -> GetSize ( ) ;
nscoord height = std :: max ( above , below ) ;
nsListControlFrame * lcf = static_cast < nsListControlFrame * > mDropdownFrame
if ( height < dropdownSize . height )
if ( lcf -> GetNumDisplayRows ( ) > 1 )
if ( height > ( dropdownSize . height + lcf -> GetHeightOfARow ( ) * 1.5 ) && lcf -> GetDropdownCanGrow ( ) )
bool b = dropdownSize . height <= below || below >= above ;
nsPoint dropdownPosition ( 0 , b ? GetRect ( ) . height : - dropdownSize . height ) ;
if ( StyleVisibility ( ) -> mDirection == NS_STYLE_DIRECTION_RTL )
dropdownPosition . x = GetRect ( ) . width - dropdownSize . width;
const nsPoint newPos = dropdownPosition + translation ;
0
------------------------------
314106 110594/CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_rand_73b.cpp intPointer = ( int * ) malloc ( data * sizeof ( int ) ) 59
static void goodG2B()
list < int > dataList ;
goodG2BSink ( dataList );
void goodG2BSink(list<int> dataList)
int data = dataList . back ( ) ;
int * intPointer ;
intPointer = ( int * ) malloc ( data * sizeof ( int ) );
intPointer [ i ] = 0;
printIntLine ( intPointer [ 0 ] );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
free ( intPointer );
0
------------------------------
20784 CVE-2016-2327/Ffmpeg_2.8.2_CVE_2016_2327_libavcodec_pngenc.c dst [ i ] = src [ i ] - ( ( src [ i - bpp ] + top [ i ] ) >> 1 ) 180
static int apng_encode_frame(AVCodecContext *avctx, const AVFrame
APNGFctlChunk *best_fctl_chunk, APNGFctlChunk *best_last_fctl_chunk)
if ( avctx -> frame_number == 0 )
return encode_frame ( avctx , pict ) ;
static int encode_frame(AVCodecContext *avctx, const AVFrame *pict)
PNGEncContext * s = avctx -> priv_data ;
const AVFrame * const p = pict
int y , len , ret ;
int row_size , pass_row_size ;
uint8_t * ptr , * top , * crow_buf , * crow ;
row_size = ( pict -> width * s -> bits_per_pixel + 7 ) >> 3;
crow_base = av_malloc ( ( row_size + 32 ) << ( s -> filter_type == PNG_FILTER_VALUE_MIXED ) );
if ( ! crow_base )
crow_buf = crow_base + 15;
if ( s -> is_progressive )
progressive_buf = av_malloc ( row_size + 1 );
top_buf = av_malloc ( row_size + 1 );
if ( ! progressive_buf || ! top_buf )
s -> zstream . avail_out = IOBUF_SIZE;
s -> zstream . next_out = s -> buf;
if ( s -> is_progressive )
top = NULL;
for (y = 0; y < pict->height; y++)
ptr = p -> data [ 0 ] + y * p -> linesize [ 0 ];
crow = png_choose_filter ( s , crow_buf , ptr , top , row_size , s -> bits_per_pixel >> 3 );
top = ptr;
static uint8_t *png_choose_filter(PNGEncContext *s, uint8_t
uint8_t *src, uint8_t *top, int size, int bpp)
int pred = s -> filter_type ;
if ( ! top && pred )
pred = PNG_FILTER_VALUE_SUB;
if ( pred == PNG_FILTER_VALUE_MIXED )
png_filter_row ( s , dst + 1 , pred , src , top , size , bpp );
static void png_filter_row(PNGEncContext *c, uint8_t *dst, int
uint8_t *src, uint8_t *top, int size, int bpp)
int i ;
switch ( filter_type )
memcpy ( dst , src , size );
for (i = 0; i < bpp; i++)
dst [ i ] = src [ i ] - ( top [ i ] >> 1 );
for (; i < size; i++)
dst [ i ] = src [ i ] - ( ( src [ i - bpp ] + top [ i ] ) >> 1 );
for (i = 0; i < bpp; i++)
dst [ i ] = src [ i ] - top [ i ];
sub_png_paeth_prediction ( dst + i , src + i , top + i , size - i , bpp );
0
------------------------------
306446 110378/CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fgets_21.c intPointer = ( int * ) malloc ( data * sizeof ( int ) ) 105
static void goodG2B1()
int data ;
data = - 1;
data = goodG2B1Source ( data );
static int goodG2B1Source(int data)
if ( goodG2B1Static )
data = 20;
return data ;
int * intPointer ;
intPointer = ( int * ) malloc ( data * sizeof ( int ) );
intPointer [ i ] = 0;
printIntLine ( intPointer [ 0 ] );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
free ( intPointer );
0
------------------------------
307203 112822/CWE761_Free_Pointer_Not_at_Start_of_Buffer__wchar_t_connect_socket_16.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 ) 181
static void goodB2G()
wchar_t * data ;
data = ( wchar_t * ) malloc ( 100 * sizeof ( wchar_t ) );
data [ 0 ] = L '\0'
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
311659 149958/aviobuf.c s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_ptr - s -> checksum_ptr ) ) ) 277
void avio_wl64(AVIOContext *s,uint64_t val)
avio_wl32 ( s , ( ( uint32_t ) ( val >> 32 ) ) );
void avio_wl32(AVIOContext *s,unsigned int val)
avio_w8 ( s , ( ( uint8_t ) val ) );
void avio_w8(AVIOContext *s,int b)
* ( s -> buf_ptr ++ ) = b;
if ( s -> buf_ptr >= s -> buf_end )
flush_buffer ( s );
static void flush_buffer(AVIOContext *s)
if ( s -> buf_ptr > s -> buffer )
if ( s -> update_checksum )
s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_ptr - s -> checksum_ptr ) ) );
s -> checksum_ptr = s -> buffer;
s -> buf_ptr = s -> buffer;
0
------------------------------
300760 153579/dfa.c remain_bytes = mbrtowc ( inputwcs + i , begin + i , ( end - begin ) - i + 1 , & mbs ) 3518
char *dfaexec(struct dfa *d,const char *begin,char *end,int allow_nl,size_t *count,int *backref)
const unsigned char * p ;
unsigned char eol = eolbyte ;
p = ( ( const unsigned char * ) begin );
* end = eol;
if ( d -> mb_cur_max > 1 )
prepare_wc_buf ( ( ( const char * ) p ) , end );
static void prepare_wc_buf(const char *begin,const char *end)
unsigned char eol = eolbyte ;
size_t remain_bytes ;
size_t i ;
remain_bytes = 0;
for (i = 0; i < (end - begin + 1); i++)
if ( remain_bytes == 0 )
remain_bytes = mbrtowc ( inputwcs + i , begin + i , ( end - begin ) - i + 1 , & mbs );
if ( remain_bytes < 1 || remain_bytes == ( ( size_t ) ( - 1 ) ) || remain_bytes == ( ( size_t ) ( - 2 ) ) || remain_bytes == 1 && inputwcs [ i ] == ( ( wchar_t ) begin [ i ] ) )
remain_bytes = 0;
inputwcs [ i ] = ( ( wchar_t ) begin [ i ] );
mblen_buf [ i ] = 0;
if ( begin [ i ] == eol )
mblen_buf [ i ] = remain_bytes;
remain_bytes --;
mblen_buf [ i ] = remain_bytes;
inputwcs [ i ] = 0;
remain_bytes --;
buf_end = ( ( unsigned char * ) ( begin + i ) );
mblen_buf [ i ] = 0;
inputwcs [ i ] = 0;
0
------------------------------
300720 153513/utils.c m = a + b >> 1 1851
static int seek_frame_internal(AVFormatContext *s,int stream_index,int64_t timestamp,int flags)
int ret ;
AVStream * st ;
if ( flags & 2 )
if ( stream_index < 0 )
stream_index = av_find_default_stream_index ( s );
if ( stream_index < 0 )
st = s -> streams [ stream_index ];
timestamp = av_rescale ( timestamp , st -> time_base . den , 1000000 * ( ( int64_t ) st -> time_base . num ) );
if ( s -> iformat -> read_seek )
ret = ( ( s -> iformat -> read_seek ) ( s , stream_index , timestamp , flags ) );
ret = - 1;
if ( ret >= 0 )
if ( s -> iformat -> read_timestamp && ! ( s -> iformat -> flags & 0x2000 ) )
return ff_seek_frame_binary ( s , stream_index , timestamp , flags ) ;
int ff_seek_frame_binary(AVFormatContext *s,int stream_index,int64_t target_ts,int flags)
int index ;
AVStream * st ;
if ( stream_index < 0 )
st = s -> streams [ stream_index ];
if ( st -> index_entries )
index = av_index_search_timestamp ( st , target_ts , flags & ~1 );
int av_index_search_timestamp(AVStream *st,int64_t wanted_timestamp,int flags)
return ff_index_search_timestamp ( ( st -> index_entries ) , st -> nb_index_entries , wanted_timestamp , flags ) ;
int ff_index_search_timestamp(const AVIndexEntry *entries,int nb_entries,int64_t wanted_timestamp,int flags)
int a ;
int b ;
int m ;
int64_t timestamp ;
a = - 1;
b = nb_entries;
if ( b && entries [ b - 1 ] . timestamp < wanted_timestamp )
a = b - 1;
while ( b - a > 1 )
m = a + b >> 1;
timestamp = entries [ m ] . timestamp;
if ( timestamp >= wanted_timestamp )
b = m;
if ( timestamp <= wanted_timestamp )
a = m;
m = ( flags & 1 ? a : b );
while ( m >= 0 && m < nb_entries && ! ( entries [ m ] . flags & 0x1 ) )
m += ( flags & 1 ? - 1 : 1 );
if ( m == nb_entries )
return m ;
0
------------------------------
305505 61959/CWE114_Process_Control__w32_char_connect_socket_22b.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 87
void CWE114_Process_Control__w32_char_connect_socket_22_bad()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
data = CWE114_Process_Control__w32_char_connect_socket_22_badSource ( data );
char * CWE114_Process_Control__w32_char_connect_socket_22_badSource(char * data)
if ( CWE114_Process_Control__w32_char_connect_socket_22_badGlobal )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
return data ;
0
------------------------------
307008 112772/CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_listen_socket_14.c recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 95
void CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_listen_socket_14_bad()
char * data ;
data = ( char * ) malloc ( 100 * sizeof ( char ) );
data [ 0 ] = '\0';
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
for (; *data != '\0'; data++)
if ( * data == SEARCH_CHAR )
free ( data );
1
------------------------------
314637 96892/CWE36_Absolute_Path_Traversal__wchar_t_connect_socket_open_11.cpp recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ) 100
void bad()
wchar_t * data ;
wchar_t dataBuffer [ FILENAME_MAX ] = L ""
data = dataBuffer;
if ( globalReturnsTrue ( ) )
int globalReturnsTrue()
return 1 ;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( FILENAME_MAX - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
312937 95665/CWE36_Absolute_Path_Traversal__char_connect_socket_ofstream_53a.cpp recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ) 96
void bad()
char * data ;
char dataBuffer [ FILENAME_MAX ] = "" ;
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
badSink_b ( data );
void badSink_b(char * data)
badSink_c ( data );
void badSink_c(char * data)
badSink_d ( data );
void badSink_d(char * data)
outputFile . open ( ( char * ) data );
0
------------------------------
303604 83232/CWE190_Integer_Overflow__int_fgets_square_21.c int result = data * data ; 35
void CWE190_Integer_Overflow__int_fgets_square_21_bad()
int data ;
data = 0;
char inputBuffer [ CHAR_ARRAY_SIZE ] = "" ;
if ( fgets ( inputBuffer , CHAR_ARRAY_SIZE , stdin ) != NULL )
data = atoi ( inputBuffer );
badSink ( data );
static void badSink(int data)
if ( badStatic )
int result = data * data ;
printIntLine ( result );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
1
------------------------------
303872 81785/CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_printf_84_goodB2G.cpp recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 ) 92
static void goodB2G()
wchar_t * data ;
wchar_t dataBuffer [ 100 ] = L ""
data = dataBuffer;
CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_printf_84_goodB2G * goodB2GObject = new CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_printf_84_goodB2G ( data ) ;
CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_printf_84_goodB2G::CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_printf_84_goodB2G(wchar_t * dataCopy)
data = dataCopy;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
304335 80790/CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_w32_vsnprintf_13.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 ) 203
static void goodB2G1()
wchar_t * data ;
wchar_t dataBuffer [ 100 ] = L ""
data = dataBuffer;
if ( GLOBAL_CONST_FIVE == 5 )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
309139 120189/CWE78_OS_Command_Injection__char_listen_socket_w32_spawnlp_66a.c recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 113
void CWE78_OS_Command_Injection__char_listen_socket_w32_spawnlp_66_bad()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
dataArray [ 2 ] = data;
CWE78_OS_Command_Injection__char_listen_socket_w32_spawnlp_66b_badSink ( dataArray );
void CWE78_OS_Command_Injection__char_listen_socket_w32_spawnlp_66b_badSink(char * dataArray[])
char * data = dataArray [ 2 ] ;
0
------------------------------
309670 152709/tile-manager.c ntiles = tm -> ntile_rows * tm -> ntile_cols 261
void tile_manager_write_pixel_data_1(TileManager *tm,gint x,gint y,const guchar *buffer)
Tile * tile = tile_manager_get_tile ( tm , x , y , ! 0 , ! 0 ) ;
Tile *tile_manager_get_tile(TileManager *tm,gint xpixel,gint ypixel,gboolean wantread,gboolean wantwrite)
if ( tm != ( ( void * ) 0 ) )
while ( 0 )
return tile_manager_get ( tm , tile_manager_get_tile_num ( tm , xpixel , ypixel ) , wantread , wantwrite ) ;
Tile *tile_manager_get(TileManager *tm,gint tile_num,gboolean wantread,gboolean wantwrite)
gint ntiles ;
if ( tm != ( ( void * ) 0 ) )
while ( 0 )
ntiles = tm -> ntile_rows * tm -> ntile_cols;
if ( tile_num < 0 || tile_num >= ntiles )
0
------------------------------
299599 152113/gimpimage.c dirpath = ( char * ) malloc ( size_dirpath * sizeof ( char ) ) 141
void stonesoup_setup_printf_context()
ss_tc_root = getenv ( "SS_TC_ROOT" );
if ( ss_tc_root != NULL )
size_dirpath = strlen ( ss_tc_root ) + strlen ( "testData" ) + 2;
dirpath = ( char * ) malloc ( size_dirpath * sizeof ( char ) );
if ( dirpath != NULL )
sprintf ( dirpath , "%s/%s" , ss_tc_root , "testData" );
if ( stat ( dirpath , & st ) == - 1 )
retval = mkdir ( dirpath , 0700 );
if ( retval == 0 )
size_filepath = strlen ( dirpath ) + strlen ( "logfile.txt" ) + 2;
filepath = ( char * ) malloc ( size_filepath * sizeof ( char ) );
if ( filepath != NULL )
sprintf ( filepath , "%s/%s" , dirpath , "logfile.txt" );
stonesoup_printf_context = fopen ( filepath , "w" );
free ( filepath );
free ( dirpath );
if ( stonesoup_printf_context == NULL )
0
------------------------------
20490 CVE-2016-9104/qemu_2.3.0_CVE-2016-9104_virtio-9p.c write_count = xattr_len - off 1901
static void v9fs_write(void *opaque)
ssize_t err ;
int32_t fid ;
uint64_t off ;
uint32_t count ;
size_t offset = 7 ;
V9fsFidState * fidp ;
V9fsPDU * pdu = opaque ;
V9fsState * s = pdu -> s ;
QEMUIOVector qiov_full ;
err = pdu_unmarshal ( pdu , offset , "dqd" , & fid , & off , & count );
if ( err < 0 )
fidp = get_fid ( pdu , fid );
static V9fsFidState *get_fid(V9fsPDU *pdu, int32_t fid)
int err ;
V9fsFidState * f ;
V9fsState * s = pdu -> s ;
for (f = s->fid_list; f; f = f->next)
if ( f -> fid == fid )
f -> ref ++;
err = v9fs_reopen_fid ( pdu , f );
static int v9fs_reopen_fid(V9fsPDU *pdu, V9fsFidState *f)
int err = 1 ;
if ( f -> fid_type == P9_FID_FILE )
if ( f -> fs . fd == - 1 )
err = v9fs_co_open ( pdu , f , f -> open_flags );
while ( err == - EINTR && ! pdu -> cancelled )
if ( f -> fid_type == P9_FID_DIR )
if ( f -> fs . dir == NULL )
err = v9fs_co_opendir ( pdu , f );
while ( err == - EINTR && ! pdu -> cancelled )
return err ;
if ( err < 0 )
return NULL ;
return f ;
return NULL ;
if ( fidp == NULL )
if ( fidp -> fid_type == P9_FID_FILE )
if ( fidp -> fid_type == P9_FID_XATTR )
err = v9fs_xattr_write ( s , pdu , fidp , off , count , qiov_full . iov , qiov_full . niov );
static int v9fs_xattr_write(V9fsState *s, V9fsPDU *pdu, V9fsFidState
uint64_t off, uint32_t
struct iovec *sg, int cnt)
int write_count ;
int64_t xattr_len ;
xattr_len = fidp -> fs . xattr . len;
write_count = xattr_len - off;
if ( write_count > count )
if ( write_count < 0 )
err = pdu_marshal ( pdu , offset , "d" , write_count );
if ( err < 0 )
return err ;
err += offset;
fidp -> fs . xattr . copied_len += write_count;
if ( write_count > sg [ i ] . iov_len )
to_copy = write_count;
memcpy ( ( char * ) fidp -> fs . xattr . value + off , sg [ i ] . iov_base , to_copy );
off += to_copy;
write_count -= to_copy;
return err ;
1
------------------------------
314803 110451/CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fixed_74b.cpp intPointer = ( int * ) malloc ( data * sizeof ( int ) ) 36
void bad()
int data ;
map < int , int > dataMap ;
data = - 1;
data = INT_MAX / 2 + 2;
dataMap [ 0 ] = data;
dataMap [ 1 ] = data;
dataMap [ 2 ] = data;
badSink ( dataMap );
void badSink(map<int, int> dataMap)
int data = dataMap [ 2 ] ;
int * intPointer ;
intPointer = ( int * ) malloc ( data * sizeof ( int ) );
intPointer [ i ] = 0;
printIntLine ( intPointer [ 0 ] );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
free ( intPointer );
1
------------------------------
314442 110769/CWE680_Integer_Overflow_to_Buffer_Overflow__new_fscanf_42.cpp dataBytes = data * sizeof ( int ) 41
void bad()
int data ;
data = - 1;
data = badSource ( data );
static int badSource(int data)
return data ;
size_t dataBytes , i ;
dataBytes = data * sizeof ( int );
intPointer = ( int * ) new char [ dataBytes ];
intPointer [ i ] = 0;
printIntLine ( intPointer [ 0 ] );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
delete [ ] intPointer
1
------------------------------
299783 150226/aviobuf.c s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_end - s -> checksum_ptr ) ) ) 581
unsigned int avio_rb24(AVIOContext *s)
unsigned int val ;
val = avio_rb16 ( s ) << 8;
unsigned int avio_rb16(AVIOContext *s)
unsigned int val ;
val = ( avio_r8 ( s ) << 8 );
val |= ( avio_r8 ( s ) );
int avio_r8(AVIOContext *s)
if ( s -> buf_ptr >= s -> buf_end )
fill_buffer ( s );
static void fill_buffer(AVIOContext *s)
uint8_t * dst = ! s -> max_packet_size && s -> buf_end - s -> buffer < ( s -> buffer_size ) ? s -> buf_end : s -> buffer ;
if ( ! s -> read_packet && s -> buf_ptr >= s -> buf_end )
s -> eof_reached = 1;
if ( s -> eof_reached )
if ( s -> update_checksum && dst == s -> buffer )
if ( s -> buf_end > s -> checksum_ptr )
s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_end - s -> checksum_ptr ) ) );
s -> checksum_ptr = s -> buffer;
if ( s -> read_packet && s -> buffer_size > max_buffer_size )
ffio_set_buf_size ( s , max_buffer_size );
s -> checksum_ptr = dst = s -> buffer;
len = s -> buffer_size;
if ( s -> read_packet )
len = ( ( s -> read_packet ) ( s -> opaque , dst , len ) );
if ( len <= 0 )
s -> eof_reached = 1;
if ( len < 0 )
s -> error = len;
s -> pos += len;
s -> buf_ptr = dst;
s -> buf_end = dst + len;
s -> bytes_read += len;
0
------------------------------
307985 116996/CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_14.c myString = ( char * ) malloc ( data * sizeof ( char ) ) 347
static void goodG2B1()
size_t data ;
data = 0;
if ( globalFive != 5 )
data = 20;
if ( globalFive == 5 )
char * myString ;
if ( data > strlen ( HELLO_STRING ) )
myString = ( char * ) malloc ( data * sizeof ( char ) );
strcpy ( myString , HELLO_STRING );
printLine ( myString );
void printLine (const char * line)
if ( line != NULL )
printf ( "%s\n" , line );
free ( myString );
0
------------------------------
301181 152159/tile-manager.c dirpath = ( char * ) malloc ( size_dirpath * sizeof ( char ) ) 54
void stonesoup_setup_printf_context()
ss_tc_root = getenv ( "SS_TC_ROOT" );
if ( ss_tc_root != NULL )
size_dirpath = strlen ( ss_tc_root ) + strlen ( "testData" ) + 2;
dirpath = ( char * ) malloc ( size_dirpath * sizeof ( char ) );
if ( dirpath != NULL )
sprintf ( dirpath , "%s/%s" , ss_tc_root , "testData" );
if ( stat ( dirpath , & st ) == - 1 )
retval = mkdir ( dirpath , 0700 );
if ( retval == 0 )
size_filepath = strlen ( dirpath ) + strlen ( "logfile.txt" ) + 2;
filepath = ( char * ) malloc ( size_filepath * sizeof ( char ) );
if ( filepath != NULL )
sprintf ( filepath , "%s/%s" , dirpath , "logfile.txt" );
stonesoup_printf_context = fopen ( filepath , "w" );
free ( filepath );
free ( dirpath );
if ( stonesoup_printf_context == NULL )
0
------------------------------
310592 148890/vwr.c end_time = e_time / NS_IN_US 1695
static gboolean vwr_read(wtap *wth, int *err, gchar **err_info, gint64 *data_offset)
vwr_t * vwr = ( vwr_t * ) wth -> priv ;
guint8 rec [ B_SIZE ] ;
int rec_size = 0 , IS_TX ;
guint8 * data_ptr ;
if ( ! vwr_read_rec_header ( vwr , wth -> fh , & rec_size , & IS_TX , err , err_info ) )
static gboolean vwr_read_rec_header(vwr_t *vwr, FILE_T fh, int *rec_size, int *IS_TX, int *err, gchar **err_info)
int bytes_read , file_off ;
int f_len , v_type ;
guint8 header [ 16 ] ;
while ( 1 )
if ( ( bytes_read = file_read ( header , 16 , fh ) ) != 16 )
return ( FALSE ) ;
if ( ( f_len = decode_msg ( vwr , header , & v_type , IS_TX ) ) != 0 )
static int decode_msg(vwr_t *vwr, guint8 *rec, int *v_type, int *IS_TX)
guint8 cmd ;
guint32 wd2 , wd3 ;
int v_size = 0 ;
cmd = rec [ 0 ];
wd2 = pntohl ( & rec [ 8 ] );
wd3 = pntohl ( & rec [ 12 ] );
switch ( cmd )
v_size = ( int ) ( wd2 & 0xffff );
v_size = ( int ) ( wd2 & 0xffff );
v_size = ( int ) ( wd3 & 0xffff );
return ( v_size ) ;
if ( f_len > B_SIZE )
return ( FALSE ) ;
if ( v_type != VT_FRAME )
if ( file_seek ( fh , f_len , SEEK_CUR , err ) < 0 )
return ( FALSE ) ;
return ( TRUE ) ;
if ( file_read ( rec , rec_size , wth -> fh ) != rec_size )
data_ptr = buffer_start_ptr ( wth -> frame_buffer );
switch ( vwr -> FPGA_VERSION )
vwr_read_rec_data_ethernet ( wth , data_ptr , rec , rec_size , IS_TX );
static void vwr_read_rec_data_ethernet(wtap *wth, guint8 *data_ptr, guint8 *rec, int rec_size, int IS_TX)
vwr_t * vwr = ( vwr_t * ) wth -> priv ;
guint64 end_time ;
s_ptr = & ( rec [ rec_size - vwr -> STATS_LEN ] );
e_time = pcoreytohll ( & s_ptr [ vwr -> ENDT_OFF ] );
end_time = e_time / NS_IN_US;
common_hdr . vw_endt = end_time;
common_hdr . vw_sig_ts = ( guint32 ) ( sig_ts );
phtoles ( & data_ptr [ bytes_written ] , common_hdr . vw_port_type );
phtoles ( & data_ptr [ bytes_written ] , common_hdr . it_len );
phtoles ( & data_ptr [ bytes_written ] , common_hdr . vw_msdu_length );
phtolel ( & data_ptr [ bytes_written ] , common_hdr . vw_flowid );
phtoles ( & data_ptr [ bytes_written ] , common_hdr . vw_vcid );
phtoles ( & data_ptr [ bytes_written ] , common_hdr . vw_seqnum );
phtolel ( & data_ptr [ bytes_written ] , common_hdr . vw_latency );
phtolel ( & data_ptr [ bytes_written ] , common_hdr . vw_sig_ts );
phtolell ( & data_ptr [ bytes_written ] , common_hdr . vw_startt );
phtolell ( & data_ptr [ bytes_written ] , common_hdr . vw_endt );
phtolel ( & data_ptr [ bytes_written ] , common_hdr . vw_pktdur );
0
------------------------------
19493 CVE-2015-2726/Firefox_38.8.0esr_CVE_2015_2726_js_src_ctypes_CTypes.cpp size_t index = sign * size_t ( i - ii * IntegerType ( radix ) ) ; 2084
static
BuildTypeSource(JSContext*
JSObject*
bool
AutoString& result)
RootedObject typeObj ( cx , typeObj_ ) ;
switch ( CType :: GetTypeCode ( typeObj ) )
FunctionInfo * fninfo = FunctionType :: GetFunctionInfo ( typeObj ) ;
BuildTypeSource ( cx , fninfo -> mReturnType , true , result );
static
BuildTypeSource(JSContext*
JSObject*
bool
AutoString& result)
RootedObject typeObj ( cx , typeObj_ ) ;
switch ( CType :: GetTypeCode ( typeObj ) )
FunctionInfo * fninfo = FunctionType :: GetFunctionInfo ( typeObj ) ;
BuildTypeSource ( cx , fninfo -> mReturnType , true , result );
static
BuildTypeSource(JSContext*
JSObject*
bool
AutoString& result)
RootedObject typeObj ( cx , typeObj_ ) ;
switch ( CType :: GetTypeCode ( typeObj ) )
size_t length ;
if ( ArrayType :: GetSafeLength ( typeObj , & length ) )
IntegerToString ( length , 10 , result );
template<class IntegerType, class CharType, size_t N, class

IntegerToString(IntegerType i, int radix, Vector<CharType, N, AP>& result)
const bool isNegative = IsNegative ( i ) ;
size_t sign = isNegative ? - 1 : 1 ;
IntegerType ii = i / IntegerType ( radix ) ;
size_t index = sign * size_t ( i - ii * IntegerType ( radix ) ) ;
* -- cp = "0123456789abcdefghijklmnopqrstuvwxyz" [ index ];
i = ii;
while ( i != 0 )
* -- cp = '-';
MOZ_ASSERT ( cp >= buffer );
result . append ( cp , end );
0
------------------------------
312053 153760/aviobuf.c s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_ptr - s -> checksum_ptr ) ) ) 198
int avio_put_str16le(AVIOContext *s,const char *str)
const uint8_t * q = str ;
while ( * q )
uint32_t ch ;
uint16_t tmp ;
ch = ( * ( q ++ ) );
uint32_t top = ( ch & 128 ) >> 1 ;
if ( ( ch & 0xc0 ) == 0x80 )
while ( ch & top )
int tmp = ( * ( q ++ ) ) - 128 ;
if ( tmp >> 6 )
ch = ( ch << 6 ) + tmp;
top <<= 5;
ch &= ( top << 1 ) - 1;
uint32_t in = ch ;
if ( in < 0x10000 )
tmp = ( 0xD800 | in - 0x10000 >> 10 );
avio_wl16 ( s , tmp );
void avio_wl16(AVIOContext *s,unsigned int val)
avio_w8 ( s , ( ( int ) val ) >> 8 );
void avio_w8(AVIOContext *s,int b)
* ( s -> buf_ptr ++ ) = b;
if ( s -> buf_ptr >= s -> buf_end )
flush_buffer ( s );
static void flush_buffer(AVIOContext *s)
if ( s -> buf_ptr > s -> buffer )
if ( s -> update_checksum )
s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_ptr - s -> checksum_ptr ) ) );
s -> checksum_ptr = s -> buffer;
s -> buf_ptr = s -> buffer;
0
------------------------------
313214 79124/CWE134_Uncontrolled_Format_String__char_connect_socket_fprintf_43.cpp recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 88
void bad()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
badSource ( data );
static void badSource(char * &data)
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
0
------------------------------
314101 110847/CWE680_Integer_Overflow_to_Buffer_Overflow__new_rand_08.cpp dataBytes = data * sizeof ( int ) 51
void bad()
int data ;
data = - 1;
if ( staticReturnsTrue ( ) )
static int staticReturnsTrue()
return 1 ;
data = RAND32 ( );
size_t dataBytes , i ;
dataBytes = data * sizeof ( int );
intPointer = ( int * ) new char [ dataBytes ];
intPointer [ i ] = 0;
printIntLine ( intPointer [ 0 ] );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
delete [ ] intPointer
1
------------------------------
306089 117133/CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_07.c myString = ( char * ) malloc ( data * sizeof ( char ) ) 141
void CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_07_bad()
size_t data ;
data = 0;
if ( staticFive == 5 )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
char inputBuffer [ CHAR_ARRAY_SIZE ] ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
inputBuffer [ recvResult ] = '\0';
data = strtoul ( inputBuffer , NULL , 0 );
while ( 0 )
if ( staticFive == 5 )
char * myString ;
if ( data > strlen ( HELLO_STRING ) )
myString = ( char * ) malloc ( data * sizeof ( char ) );
strcpy ( myString , HELLO_STRING );
printLine ( myString );
void printLine (const char * line)
if ( line != NULL )
printf ( "%s\n" , line );
free ( myString );
1
------------------------------
311924 153172/dfa.c pos = lastpos + nlastpos [ - 2 ] 2635
void dfacomp(const char *s,size_t len,struct dfa *d,int searchflag)
dfaanalyze ( d , searchflag );
void dfaanalyze(struct dfa *d,int searchflag)
int * nullable ;
size_t * nfirstpos ;
size_t * nlastpos ;
position * lastpos ;
position * o_lastpos ;
size_t i ;
position * pos ;
d -> searchflag = searchflag;
nullable = ( ( sizeof ( ( * nullable ) ) == 1 ? xmalloc ( d -> depth ) : xnmalloc ( d -> depth , sizeof ( ( * nullable ) ) ) ) );
while ( 0 )
nfirstpos = ( ( sizeof ( ( * nfirstpos ) ) == 1 ? xmalloc ( d -> depth ) : xnmalloc ( d -> depth , sizeof ( ( * nfirstpos ) ) ) ) );
while ( 0 )
nlastpos = ( ( sizeof ( ( * nlastpos ) ) == 1 ? xmalloc ( d -> depth ) : xnmalloc ( d -> depth , sizeof ( ( * nlastpos ) ) ) ) );
while ( 0 )
lastpos = ( ( sizeof ( ( * lastpos ) ) == 1 ? xmalloc ( d -> nleaves ) : xnmalloc ( d -> nleaves , sizeof ( ( * lastpos ) ) ) ) );
while ( 0 )
o_lastpos = lastpos , lastpos += d -> nleaves;
d -> follows = ( ( sizeof ( ( * d -> follows ) ) == 1 ? xzalloc ( d -> tindex ) : xcalloc ( d -> tindex , sizeof ( ( * d -> follows ) ) ) ) );
while ( 0 )
for (i = 0; i < d -> tindex; ++i)
switch ( d -> tokens [ i ] )
* ( nullable ++ ) = 1;
* ( nfirstpos ++ ) = * ( nlastpos ++ ) = 0;
merge ( ( & tmp ) , ( & d -> follows [ pos [ j ] . index ] ) , & merged );
copy ( ( & merged ) , & d -> follows [ pos [ j ] . index ] );
if ( d -> tokens [ i ] != PLUS )
nullable [ - 1 ] = 1;
merge ( ( & tmp ) , ( & d -> follows [ pos [ j ] . index ] ) , & merged );
copy ( ( & merged ) , & d -> follows [ pos [ j ] . index ] );
if ( nullable [ - 2 ] )
nfirstpos [ - 2 ] += nfirstpos [ - 1 ];
if ( nullable [ - 1 ] )
nlastpos [ - 2 ] += nlastpos [ - 1 ];
pos = lastpos + nlastpos [ - 2 ];
pos [ j ] = lastpos [ j ];
lastpos += nlastpos [ - 2 ];
nlastpos [ - 2 ] = nlastpos [ - 1 ];
nullable [ - 2 ] = nullable [ - 1 ] && nullable [ - 2 ];
nfirstpos [ - 2 ] += nfirstpos [ - 1 ];
nlastpos [ - 2 ] += nlastpos [ - 1 ];
nullable [ - 2 ] = nullable [ - 1 ] || nullable [ - 2 ];
* ( nullable ++ ) = d -> tokens [ i ] == BACKREF;
* ( nfirstpos ++ ) = * ( nlastpos ++ ) = 1;
0
------------------------------
21352 CVE-2015-5307/linux_kernel_4.2.6_CVE_2015_5307_arch_x86_kvm_vmx.c u32 mask = 1 << ( seg * SEG_FIELD_NR + field ) ; 1518
static void enter_rmode(struct kvm_vcpu *vcpu)
struct vcpu_vmx * vmx = to_vmx ( vcpu ) ;
vmx_get_segment ( vcpu , & vmx -> rmode . segs [ VCPU_SREG_SS ] , VCPU_SREG_SS );
static void vmx_get_segment(struct kvm_vcpu
struct kvm_segment *var, int seg)
struct vcpu_vmx * vmx = to_vmx ( vcpu ) ;
if ( vmx -> rmode . vm86_active && seg != VCPU_SREG_LDTR )
* var = vmx -> rmode . segs [ seg ];
if ( seg == VCPU_SREG_TR || var -> selector == vmx_read_guest_seg_selector ( vmx , seg ) )
var -> base = vmx_read_guest_seg_base ( vmx , seg );
var -> selector = vmx_read_guest_seg_selector ( vmx , seg );
static u16 vmx_read_guest_seg_selector(struct vcpu_vmx *vmx, unsigned seg)
if ( ! vmx_segment_cache_test_set ( vmx , seg , SEG_FIELD_SEL ) )
static bool vmx_segment_cache_test_set(struct vcpu_vmx *vmx, unsigned
unsigned field)
u32 mask = 1 << ( seg * SEG_FIELD_NR + field ) ;
ret = vmx -> segment_cache . bitmask & mask;
vmx -> segment_cache . bitmask |= mask;
return ret ;
0
------------------------------
308878 110389/CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fgets_51b.c intPointer = ( int * ) malloc ( data * sizeof ( int ) ) 32
void CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fgets_51_bad()
int data ;
data = - 1;
char inputBuffer [ CHAR_ARRAY_SIZE ] = "" ;
if ( fgets ( inputBuffer , CHAR_ARRAY_SIZE , stdin ) != NULL )
data = atoi ( inputBuffer );
CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fgets_51b_badSink ( data );
void CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fgets_51b_badSink(int data)
int * intPointer ;
intPointer = ( int * ) malloc ( data * sizeof ( int ) );
intPointer [ i ] = 0;
printIntLine ( intPointer [ 0 ] );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
free ( intPointer );
1
------------------------------
298809 103106/CWE427_Uncontrolled_Search_Path_Element__wchar_t_connect_socket_11.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 250 - dataLen - 1 ) , 0 ) 94
void CWE427_Uncontrolled_Search_Path_Element__wchar_t_connect_socket_11_bad()
wchar_t * data ;
wchar_t dataBuffer [ 250 ] = L "PATH="
data = dataBuffer;
if ( globalReturnsTrue ( ) )
int globalReturnsTrue()
return 1 ;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 250 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
20777 CVE-2016-2327/Ffmpeg_2.8.2_CVE_2016_2327_libavcodec_pngenc.c c = top [ i - bpp ] 126
static int encode_frame(AVCodecContext *avctx, const AVFrame *pict)
PNGEncContext * s = avctx -> priv_data ;
const AVFrame * const p = pict
int y , len , ret ;
int row_size , pass_row_size ;
uint8_t * ptr , * top , * crow_buf , * crow ;
row_size = ( pict -> width * s -> bits_per_pixel + 7 ) >> 3;
crow_base = av_malloc ( ( row_size + 32 ) << ( s -> filter_type == PNG_FILTER_VALUE_MIXED ) );
if ( ! crow_base )
crow_buf = crow_base + 15;
if ( s -> is_progressive )
progressive_buf = av_malloc ( row_size + 1 );
top_buf = av_malloc ( row_size + 1 );
if ( ! progressive_buf || ! top_buf )
s -> zstream . avail_out = IOBUF_SIZE;
s -> zstream . next_out = s -> buf;
if ( s -> is_progressive )
top = NULL;
for (y = 0; y < pict->height; y++)
ptr = p -> data [ 0 ] + y * p -> linesize [ 0 ];
crow = png_choose_filter ( s , crow_buf , ptr , top , row_size , s -> bits_per_pixel >> 3 );
top = ptr;
static uint8_t *png_choose_filter(PNGEncContext *s, uint8_t
uint8_t *src, uint8_t *top, int size, int bpp)
int pred = s -> filter_type ;
if ( ! top && pred )
pred = PNG_FILTER_VALUE_SUB;
if ( pred == PNG_FILTER_VALUE_MIXED )
uint8_t * buf1 = dst , * buf2 = dst + size + 16 ;
for (pred = 0; pred < 5; pred++)
png_filter_row ( s , buf1 + 1 , pred , src , top , size , bpp );
static void png_filter_row(PNGEncContext *c, uint8_t *dst, int
uint8_t *src, uint8_t *top, int size, int bpp)
int i ;
switch ( filter_type )
memcpy ( dst , src , size );
for (i = 0; i < bpp; i++)
dst [ i ] = src [ i ] - ( top [ i ] >> 1 );
for (; i < size; i++)
dst [ i ] = src [ i ] - ( ( src [ i - bpp ] + top [ i ] ) >> 1 );
for (i = 0; i < bpp; i++)
dst [ i ] = src [ i ] - top [ i ];
sub_png_paeth_prediction ( dst + i , src + i , top + i , size - i , bpp );
static void sub_png_paeth_prediction(uint8_t *dst, uint8_t *src, uint8_t
int w, int bpp)
int i ;
for (i = 0; i < w; i++)
int a , b , c , p , pa , pb , pc ;
a = src [ i - bpp ];
b = top [ i ];
c = top [ i - bpp ];
p = b - c;
pc = a - c;
pa = abs ( p );
pb = abs ( pc );
pc = abs ( p + pc );
if ( pa <= pb && pa <= pc )
p = a;
if ( pb <= pc )
p = b;
p = c;
dst [ i ] = src [ i ] - p;
0
------------------------------
308778 117399/CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_listen_socket_54e.c myString = ( wchar_t * ) malloc ( data * sizeof ( wchar_t ) ) 59
void CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_listen_socket_54b_badSink(size_t data)
CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_listen_socket_54c_badSink ( data );
void CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_listen_socket_54c_badSink(size_t data)
CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_listen_socket_54d_badSink ( data );
void CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_listen_socket_54d_badSink(size_t data)
CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_listen_socket_54e_badSink ( data );
void CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_listen_socket_54e_badSink(size_t data)
wchar_t * myString ;
if ( data > wcslen ( HELLO_STRING ) )
myString = ( wchar_t * ) malloc ( data * sizeof ( wchar_t ) );
wcscpy ( myString , HELLO_STRING );
printWLine ( myString );
void printWLine (const wchar_t * line)
if ( line != NULL )
wprintf ( L "%ls\n" , line )
free ( myString );
1
------------------------------
305982 108960/CWE606_Unchecked_Loop_Condition__char_connect_socket_52a.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 188
static void goodB2G()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
CWE606_Unchecked_Loop_Condition__char_connect_socket_52b_goodB2GSink ( data );
void CWE606_Unchecked_Loop_Condition__char_connect_socket_52b_goodB2GSink(char * data)
CWE606_Unchecked_Loop_Condition__char_connect_socket_52c_goodB2GSink ( data );
void CWE606_Unchecked_Loop_Condition__char_connect_socket_52c_goodB2GSink(char * data)
if ( sscanf ( data , "%d" , & n ) == 1 )
0
------------------------------
19623 CVE-2016-8658/linux_kernel_4.7.4_CVE_2016_8658_drivers_net_wireless_broadcom_brcm80211_brcmfmac_cfg80211.c notify_ie = ( u8 * ) bi + le16_to_cpu ( bi -> ie_offset ) 2767
static void brcmf_cfg80211_escan_timeout_worker(struct work_struct *work)
struct brcmf_cfg80211_info * cfg
container_of ( work , struct brcmf_cfg80211_info
escan_timeout_work )
brcmf_inform_bss ( cfg );
static s32 brcmf_inform_bss(struct brcmf_cfg80211_info *cfg)
struct brcmf_scan_results * bss_list ;
struct brcmf_bss_info_le * bi = NULL ;
int i ;
bss_list = ( struct brcmf_scan_results * ) cfg -> escan_info . escan_buf;
if ( bss_list -> count != 0 && bss_list -> version != BRCMF_BSS_INFO_VERSION )
for (i = 0; i < bss_list->count; i++)
bi = next_bss_le ( bss_list , bi );
static struct brcmf_bss_info_le
next_bss_le(struct brcmf_scan_results *list, struct brcmf_bss_info_le *bss)
if ( bss == NULL )
return list -> bss_info_le ;
return ( struct brcmf_bss_info_le * ) ( ( unsigned long ) bss + le32_to_cpu ( bss -> length ) ) ;
err = brcmf_inform_single_bss ( cfg , bi );
if ( err )
static s32 brcmf_inform_single_bss(struct brcmf_cfg80211_info
struct brcmf_bss_info_le *bi)
struct brcmu_chan ch ;
u8 * notify_ie ;
if ( le32_to_cpu ( bi -> length ) > WL_BSS_INFO_MAX )
if ( ! bi -> ctl_ch )
ch . chspec = le16_to_cpu ( bi -> chanspec );
bi -> ctl_ch = ch . chnum;
notify_ie = ( u8 * ) bi + le16_to_cpu ( bi -> ie_offset );
bss = cfg80211_inform_bss ( wiphy , notify_channel , CFG80211_BSS_FTYPE_UNKNOWN , ( const u8 * ) bi -> BSSID , 0 , notify_capability , notify_interval , notify_ie , notify_ielen , notify_signal , GFP_KERNEL );
if ( ! bss )
cfg80211_put_bss ( wiphy , bss );
0
------------------------------
307971 120488/CWE78_OS_Command_Injection__wchar_t_connect_socket_system_02.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 ) 99
void CWE78_OS_Command_Injection__wchar_t_connect_socket_system_02_bad()
wchar_t * data ;
wchar_t data_buf [ 100 ] = FULL_COMMAND ;
data = data_buf;
if ( 1 )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
301717 151549/aviobuf.c s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_end - s -> checksum_ptr ) ) ) 490
int avio_get_str16le(AVIOContext *pb,int maxlen,char *buf,int buflen)
int ret = 0 ;
if ( buflen <= 0 )
while ( ret + 1 < maxlen )
uint32_t ch ;
ch = ( ( ret += 2 ) <= maxlen ? avio_rl16 ( pb ) : 0 );
unsigned int hi = ch - 0xD800 ;
if ( hi < 0x800 )
ch = ( ( ret += 2 ) <= maxlen ? avio_rl16 ( pb ) : ( 0 - 0xDC00 ) );
if ( ch > 0x3FFU || hi > 0x3FFU )
ch += ( hi << 10 ) + 0x10000;
if ( ! ch )
unsigned int avio_rl16(AVIOContext *s)
unsigned int val ;
val = ( avio_r8 ( s ) );
val |= ( avio_r8 ( s ) << 8 );
int avio_r8(AVIOContext *s)
if ( s -> buf_ptr >= s -> buf_end )
fill_buffer ( s );
static void fill_buffer(AVIOContext *s)
uint8_t * dst = ! s -> max_packet_size && s -> buf_end - s -> buffer < ( s -> buffer_size ) ? s -> buf_end : s -> buffer ;
if ( ! s -> read_packet && s -> buf_ptr >= s -> buf_end )
s -> eof_reached = 1;
if ( s -> eof_reached )
if ( s -> update_checksum && dst == s -> buffer )
if ( s -> buf_end > s -> checksum_ptr )
s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_end - s -> checksum_ptr ) ) );
s -> checksum_ptr = s -> buffer;
if ( s -> read_packet && s -> buffer_size > max_buffer_size )
ffio_set_buf_size ( s , max_buffer_size );
s -> checksum_ptr = dst = s -> buffer;
len = s -> buffer_size;
if ( s -> read_packet )
len = ( ( s -> read_packet ) ( s -> opaque , dst , len ) );
if ( len <= 0 )
s -> eof_reached = 1;
if ( len < 0 )
s -> error = len;
s -> pos += len;
s -> buf_ptr = dst;
s -> buf_end = dst + len;
s -> bytes_read += len;
0
------------------------------
314262 110667/CWE680_Integer_Overflow_to_Buffer_Overflow__new_fgets_22a.cpp dataBytes = data * sizeof ( int ) 76
static void goodG2B1()
int data ;
data = - 1;
data = goodG2B1Source ( data );
int goodG2B1Source(int data)
if ( goodG2B1Global )
data = 20;
return data ;
size_t dataBytes , i ;
dataBytes = data * sizeof ( int );
intPointer = ( int * ) new char [ dataBytes ];
intPointer [ i ] = 0;
printIntLine ( intPointer [ 0 ] );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
delete [ ] intPointer
0
------------------------------
303738 82649/CWE190_Integer_Overflow__int64_t_fscanf_square_12.c int64_t result = data * data ; 139
static void goodG2B()
int64_t data ;
data = 0L L
if ( globalReturnsTrueOrFalse ( ) )
int globalReturnsTrueOrFalse()
return ( rand ( ) % 2 ) ;
data = 2;
data = 2;
if ( globalReturnsTrueOrFalse ( ) )
int globalReturnsTrueOrFalse()
return ( rand ( ) % 2 ) ;
int64_t result = data * data ;
printLongLongLine ( result );
void printLongLongLine (int64_t longLongIntNumber)
printf ( "%lld\n" , longLongIntNumber );
0
------------------------------
308275 104479/CWE469_Use_of_Pointer_Subtraction_to_Determine_Size__wchar_t_02.c indexOfSlashInString1 = ( size_t ) ( slashInString1 - string1 ) 70
static void good1()
if ( 0 )
wchar_t string1 [ ] = SOURCE_STRING ;
wchar_t * slashInString1 ;
size_t indexOfSlashInString1 ;
slashInString1 = wcschr ( string1 , L '/' )
indexOfSlashInString1 = ( size_t ) ( slashInString1 - string1 );
printUnsignedLine ( indexOfSlashInString1 );
void printUnsignedLine(unsigned unsignedNumber)
printf ( "%u\n" , unsignedNumber );
0
------------------------------
309642 150551/bufmgr.c oldPartitionLock = ( ( LWLockId ) ( FirstBufMappingLock + oldHash % 16 ) ) 804
Buffer ReadBufferWithoutRelcache(RelFileNode rnode,ForkNumber forkNum,BlockNumber blockNum,ReadBufferMode mode,BufferAccessStrategy strategy)
bool hit ;
SMgrRelation smgr = smgropen ( rnode , - 1 ) ;
return ReadBuffer_common ( smgr , 'p' , forkNum , blockNum , mode , strategy , & hit ) ;
static Buffer ReadBuffer_common(SMgrRelation smgr,char relpersistence,ForkNumber forkNum,BlockNumber blockNum,ReadBufferMode mode,BufferAccessStrategy strategy,bool *hit)
volatile BufferDesc * bufHdr ;
bool isExtend ;
bool isLocalBuf = ( smgr -> smgr_rnode . backend != - 1 ) ;
isExtend = ( blockNum == ( ( BlockNumber ) 0xFFFFFFFF ) );
if ( isExtend )
blockNum = smgrnblocks ( smgr , forkNum );
if ( isLocalBuf )
bufHdr = BufferAlloc ( smgr , relpersistence , forkNum , blockNum , strategy , & found );
static volatile BufferDesc *BufferAlloc(SMgrRelation smgr,char relpersistence,ForkNumber forkNum,BlockNumber blockNum,BufferAccessStrategy strategy,bool *foundPtr)
BufferTag newTag ;
uint32 newHash ;
BufferTag oldTag ;
uint32 oldHash ;
LWLockId oldPartitionLock ;
BufFlags oldFlags ;
int buf_id ;
volatile BufferDesc * buf ;
( newTag . rnode = smgr -> smgr_rnode . node , newTag . forkNum = forkNum ) , newTag . blockNum = blockNum;
newHash = BufTableHashCode ( & newTag );
buf_id = BufTableLookup ( & newTag , newHash );
if ( buf_id >= 0 )
buf = StrategyGetBuffer ( strategy , & lock_held );
oldFlags = buf -> flags;
if ( oldFlags & 1 << 0 )
if ( LWLockConditionalAcquire ( buf -> content_lock , LW_SHARED ) )
if ( strategy != ( ( void * ) 0 ) && XLogNeedsFlush ( ( ( PageHeader ) ( ( Block ) ( BufferBlocks + ( ( Size ) ( buf -> buf_id ) ) * 8192 ) ) ) -> pd_lsn ) && StrategyRejectBuffer ( strategy , buf ) )
if ( oldFlags & 1 << 2 )
oldTag = buf -> tag;
oldHash = BufTableHashCode ( & oldTag );
oldPartitionLock = ( ( LWLockId ) ( FirstBufMappingLock + oldHash % 16 ) );
if ( oldPartitionLock < newPartitionLock )
LWLockAcquire ( oldPartitionLock , LW_EXCLUSIVE );
if ( oldPartitionLock > newPartitionLock )
LWLockAcquire ( oldPartitionLock , LW_EXCLUSIVE );
buf_id = BufTableInsert ( & newTag , newHash , buf -> buf_id );
if ( buf_id >= 0 )
if ( oldFlags & 1 << 2 && oldPartitionLock != newPartitionLock )
LWLockRelease ( oldPartitionLock );
oldFlags = buf -> flags;
if ( buf -> refcount == 1 && ! ( oldFlags & 1 << 0 ) )
if ( oldFlags & 1 << 2 && oldPartitionLock != newPartitionLock )
LWLockRelease ( oldPartitionLock );
if ( oldPartitionLock != newPartitionLock )
LWLockRelease ( oldPartitionLock );
0
------------------------------
20387 CVE-2015-4504/Firefox_40.0b9_CVE_2015_4504_gfx_qcms_transform_util.c f = ( ( Value - b ) / a ) 325
qcms_bool compute_precache(struct curveType *trc, uint8_t *output)
if ( trc -> type == PARAMETRIC_CURVE_TYPE )
float gamma_table [ 256 ] ;
uint16_t gamma_table_uint [ 256 ] ;
uint16_t i ;
uint16_t * inverted ;
int inverted_size = 256 ;
for(i = 0; i < 256; i++)
gamma_table_uint [ i ] = ( uint16_t ) ( gamma_table [ i ] * 65535 );
if ( inverted_size < 256 )
inverted_size = 256;
inverted = invert_lut ( gamma_table_uint , 256 , inverted_size );
static uint16_t *invert_lut(uint16_t *table, int length, int out_length)
int i ;
uint16_t * output = malloc ( sizeof ( uint16_t ) * out_length ) ;
if ( ! output )
for (i = 0; i < out_length; i++)
double x = ( ( double ) i * 65535. ) / ( double ) ( out_length - 1 ) ;
uint16_fract_t input = floor ( x + .5 ) ;
output [ i ] = lut_inverse_interp16 ( input , table , length );
uint16_fract_t lut_inverse_interp16(uint16_t Value, uint16_t LutTable[], int length)
int l = 1 ;
int r = 0x10000 ;
int x = 0 , res ;
int NumZeroes , NumPoles ;
int cell0 , cell1 ;
double val2 ;
double y0 , y1 , x0 , x1 ;
double a , b , f ;
NumZeroes = 0;
while ( LutTable [ NumZeroes ] == 0 && NumZeroes < length - 1 )
NumZeroes ++;
if ( NumZeroes == 0 && Value == 0 )
NumPoles = 0;
while ( LutTable [ length - 1 - NumPoles ] == 0xFFFF && NumPoles < length - 1 )
NumPoles ++;
if ( NumZeroes > 1 || NumPoles > 1 )
int a , b ;
if ( Value == 0 )
a = ( ( NumZeroes - 1 ) * 0xFFFF ) / ( length - 1 );
b = ( ( length - 1 - NumPoles ) * 0xFFFF ) / ( length - 1 );
l = a - 1;
r = b + 1;
while ( r > l )
x = ( l + r ) / 2;
res = ( int ) lut_interp_linear16 ( ( uint16_fract_t ) ( x - 1 ) , LutTable , length );
uint16_t lut_interp_linear16(uint16_t input_value, uint16_t *table, int length)
uint32_t value = ( input_value * ( length - 1 ) ) ;
uint32_t upper = ( value + 65534 ) / 65535 ;
uint32_t lower = value / 65535 ;
uint32_t interp = value % 65535 ;
value = ( table [ upper ] * ( interp ) + table [ lower ] * ( 65535 - interp ) ) / 65535;
return value ;
if ( res == Value )
if ( res > Value )
r = x - 1;
l = x + 1;
val2 = ( length - 1 ) * ( ( double ) ( x - 1 ) / 65535.0 );
cell0 = ( int ) floor ( val2 );
cell1 = ( int ) ceil ( val2 );
if ( cell0 == cell1 )
y0 = LutTable [ cell0 ];
x0 = ( 65535.0 * cell0 ) / ( length - 1 );
y1 = LutTable [ cell1 ];
x1 = ( 65535.0 * cell1 ) / ( length - 1 );
a = ( y1 - y0 ) / ( x1 - x0 );
b = y0 - a * x0;
if ( fabs ( a ) < 0.01 )
f = ( ( Value - b ) / a );
if ( f < 0.0 )
if ( f >= 65535.0 )
return ( uint16_fract_t ) floor ( f + 0.5 ) ;
0
------------------------------
300556 152633/aviobuf.c s -> buf_end = s -> buffer + s -> buffer_size 937
int avio_read(AVIOContext *s,unsigned char *buf,int size)
int len ;
while ( size > 0 )
len = ( s -> buf_end - s -> buf_ptr );
if ( len > size )
len = size;
if ( len == 0 || s -> write_flag )
if ( ( s -> direct || size > s -> buffer_size ) && ! s -> update_checksum )
if ( s -> read_packet )
len = ( ( s -> read_packet ) ( s -> opaque , buf , size ) );
if ( len <= 0 )
s -> pos += len;
s -> bytes_read += len;
size -= len;
buf += len;
s -> buf_ptr = s -> buffer;
s -> buf_end = s -> buffer;
fill_buffer ( s );
len = ( s -> buf_end - s -> buf_ptr );
if ( len == 0 )
memcpy ( buf , ( s -> buf_ptr ) , len );
buf += len;
s -> buf_ptr += len;
size -= len;
static void fill_buffer(AVIOContext *s)
uint8_t * dst = ! s -> max_packet_size && s -> buf_end - s -> buffer < ( s -> buffer_size ) ? s -> buf_end : s -> buffer ;
int max_buffer_size = s -> max_packet_size ? s -> max_packet_size : 32768 ;
if ( ! s -> read_packet && s -> buf_ptr >= s -> buf_end )
s -> eof_reached = 1;
if ( s -> eof_reached )
if ( s -> update_checksum && dst == s -> buffer )
if ( s -> buf_end > s -> checksum_ptr )
s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_end - s -> checksum_ptr ) ) );
s -> checksum_ptr = s -> buffer;
if ( s -> read_packet && s -> buffer_size > max_buffer_size )
ffio_set_buf_size ( s , max_buffer_size );
int ffio_set_buf_size(AVIOContext *s,int buf_size)
uint8_t * buffer ;
buffer = ( av_malloc ( buf_size ) );
if ( ! buffer )
s -> buffer = buffer;
s -> buffer_size = buf_size;
s -> buf_ptr = buffer;
url_resetbuf ( s , ( s -> write_flag ? 2 : 1 ) );
static int url_resetbuf(AVIOContext *s,int flags)
if ( flags & 2 )
s -> buf_end = s -> buffer + s -> buffer_size;
s -> write_flag = 1;
0
------------------------------
308050 109968/CWE666_Operation_on_Resource_in_Wrong_Phase_of_Lifetime__accept_listen_bind_06.c recvResult = recv ( acceptSocket , ( char * ) data + dataLen , ( int ) ( 100 - dataLen - 1 ) , 0 ) 98
void CWE666_Operation_on_Resource_in_Wrong_Phase_of_Lifetime__accept_listen_bind_06_bad()
if ( STATIC_CONST_FIVE == 5 )
char data [ 100 ] = "" ;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) data + dataLen , ( int ) ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ recvResult ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
printLine ( data );
void printLine (const char * line)
if ( line != NULL )
printf ( "%s\n" , line );
1
------------------------------
306300 108966/CWE606_Unchecked_Loop_Condition__char_connect_socket_64a.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 188
static void goodB2G()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
CWE606_Unchecked_Loop_Condition__char_connect_socket_64b_goodB2GSink ( & data );
void CWE606_Unchecked_Loop_Condition__char_connect_socket_64b_goodB2GSink(void * dataVoidPtr)
char * * dataPtr = ( char * * ) dataVoidPtr ;
char * data = ( * dataPtr ) ;
if ( sscanf ( data , "%d" , & n ) == 1 )
0
------------------------------
314205 97861/CWE36_Absolute_Path_Traversal__wchar_t_listen_socket_open_22b.cpp recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ) 101
void bad()
wchar_t * data ;
wchar_t dataBuffer [ FILENAME_MAX ] = L ""
data = dataBuffer;
data = badSource ( data );
wchar_t * badSource(wchar_t * data)
if ( badGlobal )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( FILENAME_MAX - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
308189 110582/CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_rand_52c.c intPointer = ( int * ) malloc ( data * sizeof ( int ) ) 30
void CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_rand_52_bad()
int data ;
data = - 1;
data = RAND32 ( );
CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_rand_52b_badSink ( data );
void CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_rand_52b_badSink(int data)
CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_rand_52c_badSink ( data );
void CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_rand_52c_badSink(int data)
int * intPointer ;
intPointer = ( int * ) malloc ( data * sizeof ( int ) );
intPointer [ i ] = 0;
printIntLine ( intPointer [ 0 ] );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
free ( intPointer );
1
------------------------------
309527 153617/emem.c add_len = strbuf -> alloc_len - strbuf -> len 1990
void ep_strbuf_printf(emem_strbuf_t *strbuf,const gchar *format,... )
va_list ap ;
if ( ! strbuf )
strbuf -> len = 0;
ep_strbuf_append_vprintf ( strbuf , format , ap );
void ep_strbuf_append_vprintf(emem_strbuf_t *strbuf,const gchar *format,va_list ap)
gsize add_len ;
gsize full_len ;
add_len = strbuf -> alloc_len - strbuf -> len;
full_len = ( g_vsnprintf ( & strbuf -> str [ strbuf -> len ] , ( ( gulong ) add_len ) , format , ap ) );
if ( full_len < add_len )
strbuf -> str [ strbuf -> len ] = '\0';
add_len = strbuf -> alloc_len - strbuf -> len;
full_len = ( g_vsnprintf ( & strbuf -> str [ strbuf -> len ] , ( ( gulong ) add_len ) , format , ap2 ) );
strbuf -> len += ( add_len - 1 < full_len ? add_len - 1 : full_len );
0
------------------------------
17282 CVE-2013-1954/CVE_2013_1954_VULN_DemuxPacket.c i_read = i_sub_payload_data_length + i_skip 246
static int CVE_2013_1954_VULN_DemuxPacket( demux_t *p_demux )
demux_sys_t * p_sys = p_demux -> p_sys ;
int i_data_packet_min = p_sys -> p_fp -> i_min_data_packet_size ;
const uint8_t * p_peek ;
int i_skip ;
int i_packet_size_left ;
int i_packet_flags ;
int b_packet_multiple_payload ;
int i_packet_length ;
int i_packet_padding_length ;
int i_payload ;
int i_payload_count ;
if ( stream_Peek ( p_demux -> s , & p_peek , i_data_packet_min ) < i_data_packet_min )
i_skip = 0;
if ( p_peek [ 0 ] & 0x80 )
unsigned int i_error_correction_length_type ;
unsigned int i_error_correction_data_length ;
unsigned int i_opaque_data_present ;
i_error_correction_data_length = p_peek [ 0 ] & 0x0f;
i_opaque_data_present = ( p_peek [ 0 ] >> 4 ) & 0x01;
i_error_correction_length_type = ( p_peek [ 0 ] >> 5 ) & 0x03;
i_skip += 1;
if ( i_error_correction_length_type != 0x00 || i_opaque_data_present != 0 || i_error_correction_data_length != 0x02 )
i_skip += i_error_correction_data_length;
if ( i_skip + 2 >= i_data_packet_min )
i_packet_flags = p_peek [ i_skip ];
i_skip ++;
i_skip ++;
b_packet_multiple_payload = i_packet_flags & 0x01;
if ( i_packet_padding_length > i_packet_length )
if ( i_packet_length < i_data_packet_min )
i_packet_padding_length += i_data_packet_min - i_packet_length;
i_packet_length = i_data_packet_min;
i_skip += 4;
i_skip += 2;
i_packet_size_left = i_packet_length;
if ( b_packet_multiple_payload )
i_payload_count = p_peek [ i_skip ] & 0x3f;
i_skip ++;
i_payload_count = 1;
for( i_payload = 0; i_payload < i_payload_count ; i_payload++ )
asf_track_t * tk ;
int i_packet_keyframe ;
unsigned int i_stream_number ;
int i_media_object_offset ;
int i_replicated_data_length ;
int i_payload_data_length ;
int i_payload_data_pos ;
int i_sub_payload_data_length ;
int i_tmp ;
if ( i_skip >= i_packet_size_left )
i_packet_keyframe = p_peek [ i_skip ] >> 7;
i_stream_number = p_peek [ i_skip ++ ] & 0x7f;
if ( i_replicated_data_length > 1 )
i_skip += i_replicated_data_length;
i_media_object_offset = i_tmp;
if ( i_skip >= i_packet_size_left )
if ( i_replicated_data_length == 1 )
i_skip ++;
i_media_object_offset = 0;
i_media_object_offset = i_tmp;
if ( b_packet_multiple_payload )
i_payload_data_length = i_packet_length - i_packet_padding_length - i_skip;
if ( i_payload_data_length < 0 || i_payload_data_length > i_packet_size_left )
if ( ( tk = p_sys -> track [ i_stream_number ] ) == NULL )
i_skip += i_payload_data_length;
if ( p_sys -> i_wait_keyframe && ! ( i_stream_number == p_sys -> i_seek_track && i_packet_keyframe && ! i_media_object_offset ) )
i_skip += i_payload_data_length;
p_sys -> i_wait_keyframe --;
p_sys -> i_wait_keyframe = 0;
if ( ! tk -> p_es )
i_skip += i_payload_data_length;
for( i_payload_data_pos =
i_payload_data_pos < i_payload_data_length
i_packet_size_left >
i_payload_data_pos += i_sub_payload_data_length )
block_t * p_frag ;
int i_read ;
if ( i_replicated_data_length == 1 )
i_sub_payload_data_length = p_peek [ i_skip ];
i_skip ++;
i_payload_data_pos ++;
i_sub_payload_data_length = i_payload_data_length;
if ( tk -> p_frame && i_media_object_offset == 0 )
block_t * p_gather = block_ChainGather ( tk -> p_frame ) ;
if ( p_gather -> i_dts > VLC_TS_INVALID )
tk -> i_time = p_gather -> i_dts - VLC_TS_0;
tk -> p_frame = NULL;
i_read = i_sub_payload_data_length + i_skip;
if ( ( p_frag = stream_Block ( p_demux -> s , i_read ) ) == NULL )
i_packet_size_left -= i_read;
i_skip = 0;
if ( i_packet_size_left > 0 )
if ( stream_Peek ( p_demux -> s , & p_peek , i_packet_size_left ) < i_packet_size_left )
1
------------------------------
305125 94138/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_connect_socket_68a.c recvResult = recv ( connectSocket , ( char * ) ( password + passwordLen ) , ( 100 - passwordLen - 1 ) * sizeof ( char ) , 0 ) 168
static void goodB2G()
char * password ;
char passwordBuffer [ 100 ] = "" ;
password = passwordBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t passwordLen = strlen ( password ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( password + passwordLen ) , ( 100 - passwordLen - 1 ) * sizeof ( char ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
password [ passwordLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( password , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( password , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
CWE319_Cleartext_Tx_Sensitive_Info__w32_char_connect_socket_68_goodB2GData = password;
0
------------------------------
298550 94270/CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_45.c recvResult = recv ( acceptSocket , ( char * ) ( password + passwordLen ) , ( 100 - passwordLen - 1 ) * sizeof ( wchar_t ) , 0 ) 318
static void goodB2G()
wchar_t * password ;
wchar_t passwordBuffer [ 100 ] = L ""
password = passwordBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t passwordLen = wcslen ( password ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( password + passwordLen ) , ( 100 - passwordLen - 1 ) * sizeof ( wchar_t ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
21283 CVE-2015-5307/linux_kernel_4.2.6_CVE_2015_5307_arch_x86_kvm_vmx.c u32 mask = 1 << ( seg * SEG_FIELD_NR + field ) ; 1518
static bool cs_ss_rpl_check(struct kvm_vcpu *vcpu)
struct kvm_segment cs , ss ;
vmx_get_segment ( vcpu , & cs , VCPU_SREG_CS );
static void vmx_get_segment(struct kvm_vcpu
struct kvm_segment *var, int seg)
struct vcpu_vmx * vmx = to_vmx ( vcpu ) ;
if ( vmx -> rmode . vm86_active && seg != VCPU_SREG_LDTR )
* var = vmx -> rmode . segs [ seg ];
if ( seg == VCPU_SREG_TR || var -> selector == vmx_read_guest_seg_selector ( vmx , seg ) )
var -> base = vmx_read_guest_seg_base ( vmx , seg );
static ulong vmx_read_guest_seg_base(struct vcpu_vmx *vmx, unsigned seg)
if ( ! vmx_segment_cache_test_set ( vmx , seg , SEG_FIELD_BASE ) )
static bool vmx_segment_cache_test_set(struct vcpu_vmx *vmx, unsigned
unsigned field)
u32 mask = 1 << ( seg * SEG_FIELD_NR + field ) ;
ret = vmx -> segment_cache . bitmask & mask;
vmx -> segment_cache . bitmask |= mask;
return ret ;
0
------------------------------
311319 152169/aviobuf.c s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_ptr - s -> checksum_ptr ) ) ) 172
void avio_wb24(AVIOContext *s,unsigned int val)
avio_w8 ( s , ( ( uint8_t ) val ) );
void avio_w8(AVIOContext *s,int b)
* ( s -> buf_ptr ++ ) = b;
if ( s -> buf_ptr >= s -> buf_end )
flush_buffer ( s );
static void flush_buffer(AVIOContext *s)
if ( s -> buf_ptr > s -> buffer )
if ( s -> update_checksum )
s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_ptr - s -> checksum_ptr ) ) );
s -> checksum_ptr = s -> buffer;
s -> buf_ptr = s -> buffer;
0
------------------------------
305499 62139/CWE114_Process_Control__w32_char_listen_socket_08.c recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 110
void CWE114_Process_Control__w32_char_listen_socket_08_bad()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
if ( staticReturnsTrue ( ) )
static int staticReturnsTrue()
return 1 ;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
hModule = LoadLibraryA ( data );
if ( hModule != NULL )
FreeLibrary ( hModule );
1
------------------------------
21132 CVE-2015-5307/linux_kernel_4.2.6_CVE_2015_5307_arch_x86_kvm_vmx.c __clear_bit ( msr , msr_bitmap + 0x400 / f ) 4212
static __init int hardware_setup(void)
vmx_io_bitmap_a = ( unsigned long * ) __get_free_page ( GFP_KERNEL );
if ( ! vmx_io_bitmap_a )
vmx_io_bitmap_b = ( unsigned long * ) __get_free_page ( GFP_KERNEL );
if ( ! vmx_io_bitmap_b )
vmx_msr_bitmap_legacy = ( unsigned long * ) __get_free_page ( GFP_KERNEL );
if ( ! vmx_msr_bitmap_legacy )
vmx_msr_bitmap_legacy_x2apic = ( unsigned long * ) __get_free_page ( GFP_KERNEL );
if ( ! vmx_msr_bitmap_legacy_x2apic )
vmx_msr_bitmap_longmode = ( unsigned long * ) __get_free_page ( GFP_KERNEL );
if ( ! vmx_msr_bitmap_longmode )
vmx_msr_bitmap_longmode_x2apic = ( unsigned long * ) __get_free_page ( GFP_KERNEL );
if ( ! vmx_msr_bitmap_longmode_x2apic )
if ( nested )
vmx_msr_bitmap_nested = ( unsigned long * ) __get_free_page ( GFP_KERNEL );
if ( ! vmx_msr_bitmap_nested )
vmx_vmread_bitmap = ( unsigned long * ) __get_free_page ( GFP_KERNEL );
if ( ! vmx_vmread_bitmap )
vmx_vmwrite_bitmap = ( unsigned long * ) __get_free_page ( GFP_KERNEL );
if ( ! vmx_vmwrite_bitmap )
if ( setup_vmcs_config ( & vmcs_config ) < 0 )
vmx_disable_intercept_for_msr ( MSR_IA32_SYSENTER_ESP , false );
static void vmx_disable_intercept_for_msr(u32 msr, bool longmode_only)
__vmx_disable_intercept_for_msr ( vmx_msr_bitmap_longmode , msr , MSR_TYPE_R | MSR_TYPE_W );
static void __vmx_disable_intercept_for_msr(unsigned long
u32 msr, int type)
int f = sizeof ( unsigned long ) ;
if ( ! cpu_has_vmx_msr_bitmap ( ) )
if ( msr <= 0x1fff )
if ( ( msr >= 0xc0000000 ) && ( msr <= 0xc0001fff ) )
msr &= 0x1fff;
if ( type & MSR_TYPE_R )
__clear_bit ( msr , msr_bitmap + 0x400 / f );
0
------------------------------
303467 81703/CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_fprintf_14.c recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 ) 197
static void goodB2G1()
wchar_t * data ;
wchar_t dataBuffer [ 100 ] = L ""
data = dataBuffer;
if ( globalFive == 5 )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
20877 CVE-2016-6213/linux_kernel_4.8.9_CVE_2016_6213_fs_namespace.c unsigned long tmp = ( ( unsigned long ) dentry / L1_CACHE_BYTES ) ; 91
static int do_move_mount(struct path *path, const char *old_name)
struct mountpoint * mp ;
int err ;
if ( ! old_name || ! * old_name )
err = kern_path ( old_name , LOOKUP_FOLLOW , & old_path );
if ( err )
mp = lock_mount ( path );
static struct mountpoint *lock_mount(struct path *path)
struct vfsmount * mnt ;
struct dentry * dentry = path -> dentry ;
if ( unlikely ( cant_mount ( dentry ) ) )
mnt = lookup_mnt ( path );
if ( likely ( ! mnt ) )
struct mountpoint * mp = lookup_mountpoint ( dentry ) ;
if ( ! mp )
mp = new_mountpoint ( dentry );
path -> mnt = mnt;
dentry = path -> dentry = dget ( mnt -> mnt_root );
static struct mountpoint *new_mountpoint(struct dentry *dentry)
struct hlist_head * chain = mp_hash ( dentry ) ;
static inline struct hlist_head *mp_hash(struct dentry *dentry)
unsigned long tmp = ( ( unsigned long ) dentry / L1_CACHE_BYTES ) ;
tmp = tmp + ( tmp >> mp_hash_shift );
return & mountpoint_hashtable [ tmp & mp_hash_mask ] ;
0
------------------------------
17914 CVE-2016-5275/Firefox_49.0b1_CVE_2016_5275_dom_canvas_CanvasRenderingContext2D.cpp cosx = ( a2 + b2 - c2 ) / ( 2 * sqrt ( a2 * b2 ) ) 5922

CanvasPath::ArcTo(double aX1, double aY1, double aX2, double aY2, double
ErrorResult& aError)
if ( aRadius < 0 )
Point p0 = mPathBuilder -> CurrentPoint ( ) ;
Point p1 ( aX1 , aY1 ) ;
Point p2 ( aX2 , aY2 ) ;
double dir , a2 , b2 , c2 , cosx , sinx , d , anx , any , bnx , bny , x3 , y3 , x4 , y4 , cx , cy , angle0 , angle1 ;
if ( p0 == p1 || p1 == p2 || aRadius == 0 )
dir = ( p2 . x - p1 . x ) * ( p0 . y - p1 . y ) + ( p2 . y - p1 . y ) * ( p1 . x - p0 . x );
if ( dir == 0 )
a2 = ( p0 . x - aX1 ) * ( p0 . x - aX1 ) + ( p0 . y - aY1 ) * ( p0 . y - aY1 );
b2 = ( aX1 - aX2 ) * ( aX1 - aX2 ) + ( aY1 - aY2 ) * ( aY1 - aY2 );
c2 = ( p0 . x - aX2 ) * ( p0 . x - aX2 ) + ( p0 . y - aY2 ) * ( p0 . y - aY2 );
cosx = ( a2 + b2 - c2 ) / ( 2 * sqrt ( a2 * b2 ) );
sinx = sqrt ( 1 - cosx * cosx );
d = aRadius / ( ( 1 - cosx ) / sinx );
x3 = aX1 - anx * d;
y3 = aY1 - any * d;
x4 = aX1 - bnx * d;
y4 = aY1 - bny * d;
cx = x3 + any * aRadius * ( anticlockwise ? 1 : - 1 );
cy = y3 - anx * aRadius * ( anticlockwise ? 1 : - 1 );
angle0 = atan2 ( ( y3 - cy ) , ( x3 - cx ) );
angle1 = atan2 ( ( y4 - cy ) , ( x4 - cx ) );
LineTo ( x3 , y3 );
Arc ( cx , cy , aRadius , angle0 , angle1 , anticlockwise , aError );
0
------------------------------
303615 83235/CWE190_Integer_Overflow__int_fgets_square_32.c int result = data * data ; 82
static void goodG2B()
int data ;
int * dataPtr2 = & data ;
data = 0;
data = 2;
int data = * dataPtr2 ;
int result = data * data ;
printIntLine ( result );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
0
------------------------------
303134 82926/CWE190_Integer_Overflow__int64_t_rand_square_01.c int64_t result = data * data ; 32
void CWE190_Integer_Overflow__int64_t_rand_square_01_bad()
int64_t data ;
data = 0L L
data = ( int64_t ) RAND64 ( );
int64_t result = data * data ;
printLongLongLine ( result );
void printLongLongLine (int64_t longLongIntNumber)
printf ( "%lld\n" , longLongIntNumber );
1
------------------------------
312395 150092/utils.c print_fps ( 1 / av_q2d ( st -> time_base ) , "tbn" ) 3844
void av_dump_format(AVFormatContext *ic,int index,const char *url,int is_output)
uint8_t * printed = ( ic -> nb_streams ? av_mallocz ( ( ic -> nb_streams ) ) : ( ( void * ) 0 ) ) ;
if ( ic -> nb_streams && ! printed )
if ( ic -> nb_programs )
int j ;
int k ;
for (j = 0; j < ic -> nb_programs; j++)
for (k = 0; k < ic -> programs[j] -> nb_stream_indexes; k++)
dump_stream_format ( ic , ic -> programs [ j ] -> stream_index [ k ] , index , is_output );
static void dump_stream_format(AVFormatContext *ic,int i,int index,int is_output)
AVStream * st = ic -> streams [ i ] ;
if ( ( st -> codec -> codec_type ) == AVMEDIA_TYPE_VIDEO )
if ( st -> time_base . den && st -> time_base . num )
print_fps ( 1 / av_q2d ( st -> time_base ) , "tbn" );
0
------------------------------
310693 148895/packet-per.c val = ( value_map && ( enum_index < ( root_num + ext_num ) ) ) ? value_map [ enum_index ] : enum_index 1543

dissect_per_enumerated(tvbuff_t *tvb, guint32 offset, asn1_ctx_t *actx, proto_tree *tree, int hf_index, guint32 root_num, guint32 *value, gboolean has_extension, guint32 ext_num, guint32 *value_map)
guint32 enum_index , val ;
gboolean extension_present = FALSE ;
if ( ! extension_present )
if ( ext_num == 1 )
enum_index = 0;
enum_index += root_num;
val = ( value_map && ( enum_index < ( root_num + ext_num ) ) ) ? value_map [ enum_index ] : enum_index;
it = proto_tree_add_uint ( tree , hf_index , tvb , start_offset >> 3 , BLEN ( start_offset , offset ) , val );
actx -> created_item = it;
* value = val;
0
------------------------------
18528 CVE-2015-2716/Firefox_37.0b7_CVE_2015_2716_parser_expat_lib_xmlparse.c pool -> ptr = tem -> s + ( pool -> ptr - pool -> start ) 6285
static
reportProcessingInstruction(XML_Parser parser, const ENCODING
const char *start, const char *end)
const XML_Char * target ;
const char * tem ;
if ( ! processingInstructionHandler )
start += enc -> minBytesPerChar * 2;
tem = start + XmlNameLength ( enc , start );
target = poolStoreString ( & tempPool , enc , start , tem );
static XML_Char
poolStoreString(STRING_POOL *pool, const ENCODING
const char *ptr, const char *end)
if ( ! poolAppend ( pool , enc , ptr , end ) )
static XML_Char
poolAppend(STRING_POOL *pool, const ENCODING
const char *ptr, const char *end)
if ( ! pool -> ptr && ! poolGrow ( pool ) )
static XML_Bool
poolGrow(STRING_POOL *pool)
if ( pool -> freeBlocks )
if ( pool -> start == 0 )
if ( pool -> end - pool -> start < pool -> freeBlocks -> size )
if ( pool -> blocks && pool -> start == pool -> blocks -> s )
BLOCK * tem ;
int blockSize = ( int ) ( pool -> end - pool -> start ) ;
if ( blockSize < INIT_BLOCK_SIZE )
blockSize = INIT_BLOCK_SIZE;
blockSize *= 2;
tem = ( BLOCK * ) pool -> mem -> malloc_fcn ( offsetof ( BLOCK , s ) + blockSize * sizeof ( XML_Char ) );
if ( ! tem )
tem -> size = blockSize;
tem -> next = pool -> blocks;
pool -> blocks = tem;
if ( pool -> ptr != pool -> start )
memcpy ( tem -> s , pool -> start , ( pool -> ptr - pool -> start ) * sizeof ( XML_Char ) );
pool -> ptr = tem -> s + ( pool -> ptr - pool -> start );
pool -> start = tem -> s;
pool -> end = tem -> s + blockSize;
0
------------------------------
313755 91946/CWE23_Relative_Path_Traversal__wchar_t_listen_socket_w32CreateFile_15.cpp recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ) 105
void bad()
wchar_t * data ;
wchar_t dataBuffer [ FILENAME_MAX ] = BASEPATH ;
data = dataBuffer;
switch ( 6 )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( FILENAME_MAX - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
303903 80419/CWE134_Uncontrolled_Format_String__char_listen_socket_vfprintf_42.c recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 94
void CWE134_Uncontrolled_Format_String__char_listen_socket_vfprintf_42_bad()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
data = badSource ( data );
static char * badSource(char * data)
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
return data ;
0
------------------------------
16873 CVE-2015-0833/CVE_2015_0833_PATCHED_NS_main.c NS_tsnprintf ( elevatedLockFilePath , sizeof ( elevatedLockFilePath ) / sizeof ( elevatedLockFilePath [ 0 ] ) , NS_T ( "%s/update_elevated.lock" ) , gPatchDirPath ) 298
int CVE_2015_0833_PATCHED_NS_main(int argc, NS_tchar **argv)
if ( argc < 4 )
gPatchDirPath = argv [ 1 ];
__int64 pid = 0 ;
if ( argc > 4 )
pid = _wtoi64 ( argv [ 4 ] );
if ( pid == - 1 )
sStagedUpdate = true;
if ( NS_tstrstr ( argv [ 4 ] , NS_T ( "/replace" ) ) )
sReplaceRequest = true;
if ( ! WriteStatusFile ( "applying" ) )
if ( pid > 0 )
HANDLE parent = OpenProcess ( SYNCHRONIZE , false , ( DWORD ) pid ) ;
if ( parent )
updateFromMetro = IsUpdateFromMetro ( argc , argv );
DWORD waitTime = updateFromMetro ? IMMERSIVE_PARENT_WAIT : PARENT_WAIT ;
DWORD result = WaitForSingleObject ( parent , waitTime ) ;
if ( result != WAIT_OBJECT_0 && ! updateFromMetro )
const int callbackIndex = 6 ;
sUsingService = getenv ( "MOZ_USING_SERVICE" ) != nullptr;
NS_tchar elevatedLockFilePath [ MAXPATHLEN ] = { NS_T ( '\0' ) } ;
if ( ! sUsingService && ( argc > callbackIndex || sStagedUpdate || sReplaceRequest ) )
NS_tchar updateLockFilePath [ MAXPATHLEN ] ;
if ( ! _waccess ( updateLockFilePath , F_OK ) && NS_tremove ( updateLockFilePath ) != 0 )
NS_tsnprintf ( elevatedLockFilePath , sizeof ( elevatedLockFilePath ) / sizeof ( elevatedLockFilePath [ 0 ] ) , NS_T ( "%s/update_elevated.lock" ) , gPatchDirPath );
0
------------------------------
299474 152932/string.c curr = prev + slots + 1 1067
unsigned int svn_cstring__similarity(const char *stra,const char *strb,svn_membuf_t *buffer,apr_size_t *rlcs)
svn_string_t stringa ;
svn_string_t stringb ;
stringa . data = stra;
stringa . len = strlen ( stra );
stringb . data = strb;
stringb . len = strlen ( strb );
return svn_string__similarity ( ( & stringa ) , ( & stringb ) , buffer , rlcs ) ;
unsigned int svn_string__similarity(const svn_string_t *stringa,const svn_string_t *stringb,svn_membuf_t *buffer,apr_size_t *rlcs)
const char * stra = stringa -> data ;
const char * strb = stringb -> data ;
const apr_size_t lena = stringa -> len ;
const apr_size_t lenb = stringb -> len ;
const char * enda = stra + lena ;
const char * endb = strb + lenb ;
if ( stra < enda && strb < endb )
const apr_size_t resta = ( enda - stra ) ;
const apr_size_t restb = ( endb - strb ) ;
const apr_size_t slots = resta > restb ? restb : resta ;
apr_size_t * curr ;
apr_size_t * prev ;
prev = ( buffer -> data );
curr = prev + slots + 1;
if ( ( * pstr ) == strb [ i - 1 ] )
curr [ i ] = prev [ i - 1 ] + 1;
curr [ i ] = ( curr [ i - 1 ] > prev [ i ] ? curr [ i - 1 ] : prev [ i ] );
prev = curr;
lcs += prev [ slots ];
* rlcs = lcs;
return ( unsigned int ) ( ( 2000 * lcs + total / 2 ) / total ) ;
0
------------------------------
298526 95251/CWE369_Divide_by_Zero__int_listen_socket_divide_02.c printIntLine ( 100 / data ) 124
void CWE369_Divide_by_Zero__int_listen_socket_divide_02_bad()
int data ;
data = - 1;
if ( 1 )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
char inputBuffer [ CHAR_ARRAY_SIZE ] ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
inputBuffer [ recvResult ] = '\0';
data = atoi ( inputBuffer );
while ( 0 )
if ( 1 )
printIntLine ( 100 / data );
1
------------------------------
312586 149429/dirent_uri.c apr_size_t seglen = ( ptr - seg ) ; 1500
void svn_uri_split(const char **dirpath,const char **base_name,const char *uri,apr_pool_t *pool)
if ( dirpath )
* dirpath = ( svn_uri_dirname ( uri , pool ) );
char *svn_uri_dirname(const char *uri,apr_pool_t *pool)
apr_size_t len = strlen ( uri ) ;
if ( svn_uri_is_root ( uri , len ) )
svn_boolean_t svn_uri_is_root(const char *uri,apr_size_t len)
svn_uri_is_canonical ( uri , ( ( void * ) 0 ) ) ? ( ( void ) 0 ) : __assert_fail ( "svn_uri_is_canonical(uri, ((void *)0))" , "dirent_uri.c" , 958 , __PRETTY_FUNCTION__ );
svn_boolean_t svn_uri_is_canonical(const char *uri,apr_pool_t *scratch_pool)
const char * ptr = uri ;
if ( ( * uri ) == '\0' )
if ( ! svn_path_is_url ( uri ) )
while ( * ptr && ( * ptr ) != 47 && ( * ptr ) != ':' )
ptr ++;
if ( ! ( ( * ptr ) == ':' && ( * ( ptr + 1 ) ) == 47 && ( * ( ptr + 2 ) ) == 47 ) )
ptr = uri;
while ( ( * ptr ) != ':' )
if ( ( * ptr ) >= 65 && ( * ptr ) <= 'Z' )
ptr ++;
ptr += 3;
if ( ! ( * ptr ) )
seg = ptr;
while ( * ptr && ( * ptr ) != 47 && ( * ptr ) != 64 )
ptr ++;
if ( ( * ptr ) == 64 )
seg = ptr + 1;
ptr = seg;
if ( ( * ptr ) == '[' )
ptr ++;
while ( ( * ptr ) == ':' || ( * ptr ) >= 48 && ( * ptr ) <= '9' || ( * ptr ) >= 'a' && ( * ptr ) <= 'f' )
ptr ++;
if ( ( * ptr ) != ']' )
ptr ++;
while ( * ptr && ( * ptr ) != 47 && ( * ptr ) != ':' )
if ( ( * ptr ) >= 65 && ( * ptr ) <= 'Z' )
ptr ++;
if ( ( * ptr ) == ':' )
apr_int64_t port = 0 ;
ptr ++;
schema_data = ptr;
while ( ( * ptr ) >= 48 && ( * ptr ) <= '9' )
port = 10 * port + ( ( * ptr ) - 48 );
ptr ++;
if ( ptr == schema_data )
if ( * ptr && ( * ptr ) != 47 )
if ( port == 80 && strncmp ( uri , "http:" , 5 ) == 0 )
if ( port == 443 && strncmp ( uri , "https:" , 6 ) == 0 )
if ( port == 3690 && strncmp ( uri , "svn:" , 4 ) == 0 )
while ( 1 )
apr_size_t seglen = ( ptr - seg ) ;
if ( seglen == 1 && ( * seg ) == 46 )
if ( ( * ptr ) == 47 && ( * ( ptr + 1 ) ) == 47 )
if ( ! ( * ptr ) && ( * ( ptr - 1 ) ) == 47 && ptr - 1 != uri )
if ( ! ( * ptr ) )
if ( ( * ptr ) == 47 )
ptr ++;
seg = ptr;
while ( * ptr && ( * ptr ) != 47 )
ptr ++;
0
------------------------------
300845 151045/bufmgr.c new_strategy_delta = ( bufs_to_lap - num_to_scan ) 1509
bool BgBufferSync()
int strategy_buf_id ;
uint32 strategy_passes ;
uint32 recent_alloc ;
static bool saved_info_valid = ( bool ) 0 ;
static int prev_strategy_buf_id ;
static uint32 prev_strategy_passes ;
static int next_to_clean ;
static uint32 next_passes ;
static float smoothed_alloc = 0 ;
static float smoothed_density = 10.0 ;
float smoothing_samples = 16 ;
float scan_whole_pool_milliseconds = 120000.0 ;
long strategy_delta ;
int bufs_to_lap ;
int bufs_ahead ;
float scans_per_alloc ;
int reusable_buffers_est ;
int upcoming_alloc_est ;
int min_scan_buffers ;
int num_to_scan ;
int num_written ;
int reusable_buffers ;
long new_strategy_delta ;
strategy_buf_id = StrategySyncStart ( & strategy_passes , & recent_alloc );
if ( bgwriter_lru_maxpages <= 0 )
if ( saved_info_valid )
int32 passes_delta = ( strategy_passes - prev_strategy_passes ) ;
strategy_delta = ( strategy_buf_id - prev_strategy_buf_id );
strategy_delta += ( ( long ) passes_delta ) * NBuffers;
if ( ( ( int32 ) ( next_passes - strategy_passes ) ) > 0 )
bufs_to_lap = strategy_buf_id - next_to_clean;
if ( next_passes == strategy_passes && next_to_clean >= strategy_buf_id )
bufs_to_lap = NBuffers - ( next_to_clean - strategy_buf_id );
next_to_clean = strategy_buf_id;
bufs_to_lap = NBuffers;
strategy_delta = 0;
next_to_clean = strategy_buf_id;
bufs_to_lap = NBuffers;
if ( strategy_delta > 0 && recent_alloc > 0 )
scans_per_alloc = ( ( float ) strategy_delta ) / ( ( float ) recent_alloc );
smoothed_density += ( scans_per_alloc - smoothed_density ) / smoothing_samples;
bufs_ahead = NBuffers - bufs_to_lap;
reusable_buffers_est = ( ( ( float ) bufs_ahead ) / smoothed_density );
if ( smoothed_alloc <= ( ( float ) recent_alloc ) )
smoothed_alloc = recent_alloc;
smoothed_alloc += ( ( ( float ) recent_alloc ) - smoothed_alloc ) / smoothing_samples;
upcoming_alloc_est = ( ( int ) ( smoothed_alloc * bgwriter_lru_multiplier ) );
min_scan_buffers = ( ( int ) ( NBuffers / ( scan_whole_pool_milliseconds / BgWriterDelay ) ) );
if ( upcoming_alloc_est < min_scan_buffers + reusable_buffers_est )
upcoming_alloc_est = min_scan_buffers + reusable_buffers_est;
num_to_scan = bufs_to_lap;
num_written = 0;
reusable_buffers = reusable_buffers_est;
while ( num_to_scan > 0 && reusable_buffers < upcoming_alloc_est )
int buffer_state = SyncOneBuffer ( next_to_clean , ( ( bool ) 1 ) ) ;
static int SyncOneBuffer(int buf_id,bool skip_recently_used)
volatile BufferDesc * bufHdr = ( & BufferDescriptors [ buf_id ] ) ;
int result = 0 ;
if ( bufHdr -> refcount == 0 && ( bufHdr -> usage_count ) == 0 )
result |= 0x0002;
if ( skip_recently_used )
return result ;
if ( ! ( ( bufHdr -> flags ) & 1 << 1 ) || ! ( ( bufHdr -> flags ) & 1 << 0 ) )
return result ;
return result | 0x0001 ;
if ( ++ next_to_clean >= NBuffers )
next_to_clean = 0;
num_to_scan --;
if ( buffer_state & 0x0001 )
reusable_buffers ++;
if ( ++ num_written >= bgwriter_lru_maxpages )
if ( buffer_state & 0x0002 )
reusable_buffers ++;
new_strategy_delta = ( bufs_to_lap - num_to_scan );
if ( new_strategy_delta > 0 && new_recent_alloc > 0 )
scans_per_alloc = ( ( float ) new_strategy_delta ) / ( ( float ) new_recent_alloc );
smoothed_density += ( scans_per_alloc - smoothed_density ) / smoothing_samples;
0
------------------------------
314165 110801/CWE680_Integer_Overflow_to_Buffer_Overflow__new_listen_socket_10.cpp dataBytes = data * sizeof ( int ) 127
void bad()
int data ;
data = - 1;
if ( globalTrue )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
char inputBuffer [ CHAR_ARRAY_SIZE ] ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
inputBuffer [ recvResult ] = '\0';
data = atoi ( inputBuffer );
while ( 0 )
size_t dataBytes , i ;
dataBytes = data * sizeof ( int );
intPointer = ( int * ) new char [ dataBytes ];
intPointer [ i ] = 0;
printIntLine ( intPointer [ 0 ] );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
delete [ ] intPointer
1
------------------------------
16203 CVE-2009-0946/CVE_2009_0946_PATCHED_ft_smooth_render_generic.c FT_Vector * points_end = points + outline -> n_points ; 152
static
CVE_2009_0946_PATCHED_ft_smooth_render_generic( FT_Renderer
FT_GlyphSlot
FT_Render_Mode
const FT_Vector*
FT_Render_Mode    required_mode )
FT_BBox cbox ;
FT_UInt width , height , height_org , width_org , pitch ;
FT_Bitmap * bitmap ;
FT_Int hmul = mode == FT_RENDER_MODE_LCD ;
FT_Int vmul = mode == FT_RENDER_MODE_LCD_V ;
if ( slot -> format != render -> glyph_format )
if ( mode != required_mode )
outline = & slot -> outline;
cbox . xMin = FT_PIX_FLOOR ( cbox . xMin );
cbox . yMin = FT_PIX_FLOOR ( cbox . yMin );
cbox . xMax = FT_PIX_CEIL ( cbox . xMax );
cbox . yMax = FT_PIX_CEIL ( cbox . yMax );
width = ( FT_UInt ) ( ( cbox . xMax - cbox . xMin ) >> 6 );
height = ( FT_UInt ) ( ( cbox . yMax - cbox . yMin ) >> 6 );
bitmap = & slot -> bitmap;
if ( slot -> internal -> flags & FT_GLYPH_OWN_BITMAP )
slot -> internal -> flags &= ~FT_GLYPH_OWN_BITMAP;
pitch = width;
if ( hmul )
width = width * 3;
pitch = FT_PAD_CEIL ( width , 4 );
if ( vmul )
height *= 3;
if ( slot -> library -> lcd_filter_func )
FT_Int extra = slot -> library -> lcd_extra ;
if ( hmul )
width += 3 * extra;
pitch = FT_PAD_CEIL ( width , 4 );
if ( vmul )
height += 3 * extra;
if ( pitch > 0xFFFF || height > 0xFFFF )
bitmap -> pixel_mode = FT_PIXEL_MODE_GRAY;
bitmap -> num_grays = 256;
bitmap -> width = width;
bitmap -> rows = height;
bitmap -> pitch = pitch;
if ( FT_ALLOC ( bitmap -> buffer , ( FT_ULong ) pitch * height ) )
FT_Vector * points = outline -> points ;
FT_Vector * points_end = points + outline -> n_points ;
0
------------------------------
299318 153796/oids.c subids_overflow = subids + n 996
const gchar *oid_resolved_from_string(const gchar *oid_str)
guint subid_oid_length = oid_string2subid ( oid_str , & subid_oid ) ;
guint oid_string2subid(const char *str,guint32 **subids_p)
guint32 * subids ;
guint32 * subids_overflow ;
guint n = check_num_oid ( str ) ;
if ( ! n )
* subids_p = subids = ( ep_alloc0 ( sizeof ( guint32 ) * n ) );
subids_overflow = subids + n;
if ( subids >= subids_overflow || subid > 0xffffffff )
0
------------------------------
299611 152118/bufmgr.c new_recent_alloc = ( reusable_buffers - reusable_buffers_est ) 1494
bool BgBufferSync()
int strategy_buf_id ;
uint32 strategy_passes ;
uint32 recent_alloc ;
static bool saved_info_valid = ( bool ) 0 ;
static int prev_strategy_buf_id ;
static uint32 prev_strategy_passes ;
static int next_to_clean ;
static uint32 next_passes ;
static float smoothed_alloc = 0 ;
static float smoothed_density = 10.0 ;
float smoothing_samples = 16 ;
float scan_whole_pool_milliseconds = 120000.0 ;
long strategy_delta ;
int bufs_to_lap ;
int bufs_ahead ;
float scans_per_alloc ;
int reusable_buffers_est ;
int upcoming_alloc_est ;
int min_scan_buffers ;
int num_to_scan ;
int num_written ;
int reusable_buffers ;
uint32 new_recent_alloc ;
strategy_buf_id = StrategySyncStart ( & strategy_passes , & recent_alloc );
if ( bgwriter_lru_maxpages <= 0 )
if ( saved_info_valid )
int32 passes_delta = ( strategy_passes - prev_strategy_passes ) ;
strategy_delta = ( strategy_buf_id - prev_strategy_buf_id );
strategy_delta += ( ( long ) passes_delta ) * NBuffers;
if ( ( ( int32 ) ( next_passes - strategy_passes ) ) > 0 )
bufs_to_lap = strategy_buf_id - next_to_clean;
if ( next_passes == strategy_passes && next_to_clean >= strategy_buf_id )
bufs_to_lap = NBuffers - ( next_to_clean - strategy_buf_id );
next_to_clean = strategy_buf_id;
bufs_to_lap = NBuffers;
strategy_delta = 0;
next_to_clean = strategy_buf_id;
bufs_to_lap = NBuffers;
if ( strategy_delta > 0 && recent_alloc > 0 )
scans_per_alloc = ( ( float ) strategy_delta ) / ( ( float ) recent_alloc );
smoothed_density += ( scans_per_alloc - smoothed_density ) / smoothing_samples;
bufs_ahead = NBuffers - bufs_to_lap;
reusable_buffers_est = ( ( ( float ) bufs_ahead ) / smoothed_density );
if ( smoothed_alloc <= ( ( float ) recent_alloc ) )
smoothed_alloc = recent_alloc;
smoothed_alloc += ( ( ( float ) recent_alloc ) - smoothed_alloc ) / smoothing_samples;
upcoming_alloc_est = ( ( int ) ( smoothed_alloc * bgwriter_lru_multiplier ) );
min_scan_buffers = ( ( int ) ( NBuffers / ( scan_whole_pool_milliseconds / BgWriterDelay ) ) );
if ( upcoming_alloc_est < min_scan_buffers + reusable_buffers_est )
upcoming_alloc_est = min_scan_buffers + reusable_buffers_est;
num_to_scan = bufs_to_lap;
num_written = 0;
reusable_buffers = reusable_buffers_est;
while ( num_to_scan > 0 && reusable_buffers < upcoming_alloc_est )
int buffer_state = SyncOneBuffer ( next_to_clean , ( ( bool ) 1 ) ) ;
static int SyncOneBuffer(int buf_id,bool skip_recently_used)
volatile BufferDesc * bufHdr = ( & BufferDescriptors [ buf_id ] ) ;
int result = 0 ;
if ( bufHdr -> refcount == 0 && ( bufHdr -> usage_count ) == 0 )
result |= 0x0002;
if ( skip_recently_used )
return result ;
if ( ! ( ( bufHdr -> flags ) & 1 << 1 ) || ! ( ( bufHdr -> flags ) & 1 << 0 ) )
return result ;
return result | 0x0001 ;
if ( ++ next_to_clean >= NBuffers )
next_to_clean = 0;
num_to_scan --;
if ( buffer_state & 0x0001 )
reusable_buffers ++;
if ( ++ num_written >= bgwriter_lru_maxpages )
if ( buffer_state & 0x0002 )
reusable_buffers ++;
new_recent_alloc = ( reusable_buffers - reusable_buffers_est );
if ( new_strategy_delta > 0 && new_recent_alloc > 0 )
scans_per_alloc = ( ( float ) new_strategy_delta ) / ( ( float ) new_recent_alloc );
smoothed_density += ( scans_per_alloc - smoothed_density ) / smoothing_samples;
0
------------------------------
16625 CVE-2014-4174/CVE_2014_4174_PATCHED_libpcap_dump.c rec_hdr . hdr . orig_len = phdr -> len + phdrsize 19
static gboolean CVE_2014_4174_PATCHED_libpcap_dump(wtap_dumper
const struct wtap_pkthdr
const guint8 *pd, int *err)
const union wtap_pseudo_header * pseudo_header = & phdr -> pseudo_header ;
struct pcaprec_ss990915_hdr rec_hdr ;
int phdrsize ;
phdrsize = pcap_get_phdr_size ( wdh -> encap , pseudo_header );
rec_hdr . hdr . ts_sec = ( guint32 ) phdr -> ts . secs;
if ( wdh -> tsprecision == WTAP_FILE_TSPREC_NSEC )
rec_hdr . hdr . ts_usec = phdr -> ts . nsecs;
rec_hdr . hdr . ts_usec = phdr -> ts . nsecs / 1000;
rec_hdr . hdr . incl_len = phdr -> caplen + phdrsize;
rec_hdr . hdr . orig_len = phdr -> len + phdrsize;
0
------------------------------
306448 110379/CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fgets_22a.c intPointer = ( int * ) malloc ( data * sizeof ( int ) ) 38
void CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fgets_22_bad()
int data ;
data = - 1;
data = CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fgets_22_badSource ( data );
int CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fgets_22_badSource(int data)
if ( CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fgets_22_badGlobal )
char inputBuffer [ CHAR_ARRAY_SIZE ] = "" ;
if ( fgets ( inputBuffer , CHAR_ARRAY_SIZE , stdin ) != NULL )
data = atoi ( inputBuffer );
return data ;
int * intPointer ;
intPointer = ( int * ) malloc ( data * sizeof ( int ) );
intPointer [ i ] = 0;
printIntLine ( intPointer [ 0 ] );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
free ( intPointer );
1
------------------------------
314545 108973/CWE606_Unchecked_Loop_Condition__char_connect_socket_74a.cpp recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 205
static void goodB2G()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
dataMap [ 0 ] = data;
dataMap [ 1 ] = data;
dataMap [ 2 ] = data;
goodB2GSink ( dataMap );
void goodB2GSink(map<int, char *> dataMap)
char * data = dataMap [ 2 ] ;
if ( sscanf ( data , "%d" , & n ) == 1 )
0
------------------------------
311696 149958/aviobuf.c s -> buf_end = dst + len 595
int avio_get_str16be(AVIOContext *pb,int maxlen,char *buf,int buflen)
int ret = 0 ;
if ( buflen <= 0 )
while ( ret + 1 < maxlen )
uint32_t ch ;
ch = ( ( ret += 2 ) <= maxlen ? avio_rb16 ( pb ) : 0 );
unsigned int hi = ch - 0xD800 ;
if ( hi < 0x800 )
ch = ( ( ret += 2 ) <= maxlen ? avio_rb16 ( pb ) : ( 0 - 0xDC00 ) );
if ( ch > 0x3FFU || hi > 0x3FFU )
ch += ( hi << 10 ) + 0x10000;
if ( ! ch )
unsigned int avio_rb16(AVIOContext *s)
unsigned int val ;
val = ( avio_r8 ( s ) << 8 );
int avio_r8(AVIOContext *s)
if ( s -> buf_ptr >= s -> buf_end )
fill_buffer ( s );
static void fill_buffer(AVIOContext *s)
uint8_t * dst = ! s -> max_packet_size && s -> buf_end - s -> buffer < ( s -> buffer_size ) ? s -> buf_end : s -> buffer ;
int len = ( ( s -> buffer_size ) - ( dst - s -> buffer ) ) ;
int max_buffer_size = s -> max_packet_size ? s -> max_packet_size : 32768 ;
if ( ! s -> read_packet && s -> buf_ptr >= s -> buf_end )
s -> eof_reached = 1;
if ( s -> eof_reached )
if ( s -> update_checksum && dst == s -> buffer )
if ( s -> buf_end > s -> checksum_ptr )
s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_end - s -> checksum_ptr ) ) );
s -> checksum_ptr = s -> buffer;
if ( s -> read_packet && s -> buffer_size > max_buffer_size )
s -> checksum_ptr = dst = s -> buffer;
len = s -> buffer_size;
if ( s -> read_packet )
len = ( ( s -> read_packet ) ( s -> opaque , dst , len ) );
len = 0;
if ( len <= 0 )
s -> eof_reached = 1;
if ( len < 0 )
s -> error = len;
s -> pos += len;
s -> buf_ptr = dst;
s -> buf_end = dst + len;
s -> bytes_read += len;
0
------------------------------
312011 152809/dfa.c buf_end = ( ( unsigned char * ) ( begin + i ) ) 3510
char *dfaexec(struct dfa *d,const char *begin,char *end,int allow_nl,size_t *count,int *backref)
const unsigned char * p ;
unsigned char eol = eolbyte ;
p = ( ( const unsigned char * ) begin );
* end = eol;
if ( d -> mb_cur_max > 1 )
prepare_wc_buf ( ( ( const char * ) p ) , end );
static void prepare_wc_buf(const char *begin,const char *end)
unsigned char eol = eolbyte ;
size_t remain_bytes ;
size_t i ;
remain_bytes = 0;
for (i = 0; i < (end - begin + 1); i++)
if ( remain_bytes == 0 )
remain_bytes = mbrtowc ( inputwcs + i , begin + i , ( end - begin ) - i + 1 , & mbs );
if ( remain_bytes < 1 || remain_bytes == ( ( size_t ) ( - 1 ) ) || remain_bytes == ( ( size_t ) ( - 2 ) ) || remain_bytes == 1 && inputwcs [ i ] == ( ( wchar_t ) begin [ i ] ) )
remain_bytes = 0;
inputwcs [ i ] = ( ( wchar_t ) begin [ i ] );
mblen_buf [ i ] = 0;
if ( begin [ i ] == eol )
mblen_buf [ i ] = remain_bytes;
remain_bytes --;
mblen_buf [ i ] = remain_bytes;
inputwcs [ i ] = 0;
remain_bytes --;
buf_end = ( ( unsigned char * ) ( begin + i ) );
0
------------------------------
306222 118062/CWE78_OS_Command_Injection__char_connect_socket_popen_34.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 107
void CWE78_OS_Command_Injection__char_connect_socket_popen_34_bad()
char * data ;
char data_buf [ 100 ] = FULL_COMMAND ;
data = data_buf;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
myUnion . unionFirst = data;
char * data = myUnion . unionSecond ;
pipe = POPEN ( data , "wb" );
if ( pipe != NULL )
PCLOSE ( pipe );
1
------------------------------
18214 CVE-2015-5154/Xen_4.5.0_CVE-2015-5154_ide.c s -> select = ( s -> select & 0xf0 ) | ( ( r / s -> sectors ) & 0x0f ) 1013
static void pmac_ide_transfer(DBDMA_io *io)
MACIOIDEState * m = io -> opaque ;
IDEState * s = m -> ide_if -> cur_drive ;
s -> io_buffer_size = 0;
if ( s -> is_cdrom )
pmac_ide_transfer_cb ( io , 0 );
static void pmac_ide_transfer_cb(void *opaque, int ret)
DBDMA_io * io = opaque ;
MACIOIDEState * m = io -> opaque ;
IDEState * s = m -> ide_if -> cur_drive ;
int n ;
int64_t sector_num ;
if ( ret < 0 )
sector_num = ide_get_sector ( s );
static int64_t ide_get_sector(IDEState *s)
int64_t sector_num ;
if ( s -> select & 0x40 )
if ( ! s -> lba48 )
sector_num = ( ( s -> select & 0x0f ) << 24 ) | ( s -> hcyl << 16 ) | ( s -> lcyl << 8 ) | s -> sector;
sector_num = ( ( int64_t ) s -> hob_hcyl << 40 ) | ( ( int64_t ) s -> hob_lcyl << 32 ) | ( ( int64_t ) s -> hob_sector << 24 ) | ( ( int64_t ) s -> hcyl << 16 ) | ( ( int64_t ) s -> lcyl << 8 ) | s -> sector;
sector_num = ( ( s -> hcyl << 8 ) | s -> lcyl ) * s -> heads * s -> sectors + ( s -> select & 0x0f ) * s -> sectors + ( s -> sector - 1 );
return sector_num ;
if ( s -> io_buffer_size > 0 )
n = ( s -> io_buffer_size + 0x1ff ) >> 9;
sector_num += n;
ide_set_sector ( s , sector_num );
static void ide_set_sector(IDEState *s, int64_t sector_num)
unsigned int cyl , r ;
if ( s -> select & 0x40 )
if ( ! s -> lba48 )
s -> select = ( s -> select & 0xf0 ) | ( sector_num >> 24 );
s -> sector = sector_num;
s -> lcyl = sector_num >> 8;
s -> hcyl = sector_num >> 16;
s -> hob_sector = sector_num >> 24;
s -> hob_lcyl = sector_num >> 32;
s -> hob_hcyl = sector_num >> 40;
cyl = sector_num / ( s -> heads * s -> sectors );
r = sector_num % ( s -> heads * s -> sectors );
s -> hcyl = cyl >> 8;
s -> lcyl = cyl;
s -> select = ( s -> select & 0xf0 ) | ( ( r / s -> sectors ) & 0x0f );
s -> sector = ( r % s -> sectors ) + 1;
0
------------------------------
301792 81775/CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_printf_65a.c recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 ) 101
void CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_printf_65_bad()
wchar_t * data ;
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
313665 90835/CWE23_Relative_Path_Traversal__wchar_t_connect_socket_ifstream_08.cpp recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ) 111
void bad()
wchar_t * data ;
wchar_t dataBuffer [ FILENAME_MAX ] = BASEPATH ;
data = dataBuffer;
if ( staticReturnsTrue ( ) )
static int staticReturnsTrue()
return 1 ;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( FILENAME_MAX - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
20833 CVE-2016-1957/Firefox_44.0b9_CVE_2016_1957_media_libstagefright_frameworks_av_media_libstagefright_MPEG4Extractor.cpp mBuffer -> meta_data ( ) -> setInt64 ( kKeyDecodingTime , ( ( int64_t ) dts * 1000000 ) / mTimescale ) 4059
status_t
MediaBuffer **out, const ReadOptions *options)
int64_t seekTimeUs ;
ReadOptions :: SeekMode mode ;
if ( options && options -> getSeekTo ( & seekTimeUs , & mode ) )
int numSidxEntries = mSegments . Length ( ) ;
if ( numSidxEntries != 0 )
int64_t totalTime = 0 ;
for (int i = 0; i < numSidxEntries; i++)
const SidxEntry * se = & mSegments [ i ] ;
if ( totalTime + se -> mDurationUs > seekTimeUs )
totalTime += se -> mDurationUs;
mCurrentSampleIndex = 0;
mCurrentTime = totalTime * mTimescale / 1000000l l
while ( true )
status_t ret = moveToNextFragment ( ) ;
if ( ret != OK )
uint32_t time = mCurrentTime ;
int i ;
for (i = 0; i < mCurrentSamples.Length() && time <= seekTime; i++)
const Sample * smpl = & mCurrentSamples [ i ] ;
if ( smpl -> isSync ( ) )
mCurrentSampleIndex = i;
mCurrentTime = time;
time += smpl -> duration;
if ( i != mCurrentSamples . Length ( ) )
if ( mBuffer != NULL )
mBuffer = NULL;
off64_t offset = 0 ;
size_t size = 0 ;
uint32_t dts = 0 ;
bool newBuffer = false ;
if ( mBuffer == NULL )
newBuffer = true;
if ( mCurrentSampleIndex >= mCurrentSamples . Length ( ) )
status_t ret = moveToNextFragment ( ) ;
if ( ret != OK )
const Sample * smpl = & mCurrentSamples [ mCurrentSampleIndex ] ;
offset = smpl -> offset;
size = smpl -> size;
dts = mCurrentTime;
int32_t max_size ;
mBuffer = new MediaBuffer ( std :: min ( max_size , 1024 * 1024 ) );
if ( ! mIsAVC || mWantsNALFragments )
if ( newBuffer )
if ( ! ensureMediaBufferAllocated ( size ) )
ssize_t num_bytes_read = mDataSource -> readAt ( offset , ( uint8_t * ) mBuffer -> data ( ) , size ) ;
if ( num_bytes_read < ( ssize_t ) size )
if ( ! mTimescale )
mBuffer -> meta_data ( ) -> setInt64 ( kKeyDecodingTime , ( ( int64_t ) dts * 1000000 ) / mTimescale );
0
------------------------------
302599 81866/CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_vfprintf_54a.c recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 ) 100
void CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_vfprintf_54_bad()
wchar_t * data ;
wchar_t dataBuffer [ 100 ] = L ""
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
306496 104466/CWE469_Use_of_Pointer_Subtraction_to_Determine_Size__char_07.c indexOfSlashInString1 = ( size_t ) ( slashInString1 - string2 ) 44
void CWE469_Use_of_Pointer_Subtraction_to_Determine_Size__char_07_bad()
if ( staticFive == 5 )
char string1 [ ] = SOURCE_STRING ;
char string2 [ ] = SOURCE_STRING ;
char * slashInString1 ;
size_t indexOfSlashInString1 ;
slashInString1 = strchr ( string1 , '/' );
indexOfSlashInString1 = ( size_t ) ( slashInString1 - string2 );
printUnsignedLine ( indexOfSlashInString1 );
void printUnsignedLine(unsigned unsignedNumber)
printf ( "%u\n" , unsignedNumber );
1
------------------------------
305426 94208/CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_connect_socket_15.c recvResult = recv ( connectSocket , ( char * ) ( password + passwordLen ) , ( 100 - passwordLen - 1 ) * sizeof ( wchar_t ) , 0 ) 185
static void goodB2G1()
wchar_t * password ;
wchar_t passwordBuffer [ 100 ] = L ""
password = passwordBuffer;
switch ( 6 )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t passwordLen = wcslen ( password ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( password + passwordLen ) , ( 100 - passwordLen - 1 ) * sizeof ( wchar_t ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
310436 151636/conf_mod.c dirpath = ( char * ) malloc ( size_dirpath * sizeof ( char ) ) 130
void stonesoup_setup_printf_context()
ss_tc_root = getenv ( "SS_TC_ROOT" );
if ( ss_tc_root != NULL )
size_dirpath = strlen ( ss_tc_root ) + strlen ( "testData" ) + 2;
dirpath = ( char * ) malloc ( size_dirpath * sizeof ( char ) );
if ( dirpath != NULL )
sprintf ( dirpath , "%s/%s" , ss_tc_root , "testData" );
if ( stat ( dirpath , & st ) == - 1 )
retval = mkdir ( dirpath , 0700 );
if ( retval == 0 )
size_filepath = strlen ( dirpath ) + strlen ( "logfile.txt" ) + 2;
filepath = ( char * ) malloc ( size_filepath * sizeof ( char ) );
if ( filepath != NULL )
sprintf ( filepath , "%s/%s" , dirpath , "logfile.txt" );
stonesoup_printf_context = fopen ( filepath , "w" );
free ( filepath );
free ( dirpath );
if ( stonesoup_printf_context == NULL )
0
------------------------------
305352 94262/CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_31.c recvResult = recv ( acceptSocket , ( char * ) ( password + passwordLen ) , ( 100 - passwordLen - 1 ) * sizeof ( wchar_t ) , 0 ) 227
static void goodB2G()
wchar_t * password ;
wchar_t passwordBuffer [ 100 ] = L ""
password = passwordBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t passwordLen = wcslen ( password ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( password + passwordLen ) , ( 100 - passwordLen - 1 ) * sizeof ( wchar_t ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
299135 150431/gimpcontext.c stonesoup_arr [ stonesoup_i ] = stonesoupData -> qsize - stonesoup_i 306
void *devChar(void *data)
struct stonesoup_data * stonesoupData = ( struct stonesoup_data * ) data ;
int stonesoup_i ;
stonesoup_arr = malloc ( sizeof ( int ) * stonesoupData -> qsize );
for (stonesoup_i = 0; stonesoup_i < stonesoupData->qsize; stonesoup_i++)
stonesoup_arr [ stonesoup_i ] = stonesoupData -> qsize - stonesoup_i;
qsort ( stonesoup_arr , stonesoupData -> qsize , sizeof ( int ) , & stonesoup_comp );
free ( stonesoup_arr );
0
------------------------------
310371 151639/aviobuf.c int len = ( ( s -> buffer_size ) - ( dst - s -> buffer ) ) ; 455
int ffio_read_partial(AVIOContext *s,unsigned char *buf,int size)
int len ;
if ( size < 0 )
if ( s -> read_packet && s -> write_flag )
len = ( s -> buf_end - s -> buf_ptr );
if ( len == 0 )
s -> buf_end = s -> buf_ptr = s -> buffer;
len = ( s -> buf_end - s -> buf_ptr );
if ( len > size )
len = size;
s -> buf_ptr += len;
if ( ! len )
if ( s -> error )
if ( url_feof ( s ) )
int url_feof(AVIOContext *s)
if ( ! s )
if ( s -> eof_reached )
s -> eof_reached = 0;
fill_buffer ( s );
static void fill_buffer(AVIOContext *s)
uint8_t * dst = ! s -> max_packet_size && s -> buf_end - s -> buffer < ( s -> buffer_size ) ? s -> buf_end : s -> buffer ;
int len = ( ( s -> buffer_size ) - ( dst - s -> buffer ) ) ;
len = ( ( s -> read_packet ) ( s -> opaque , dst , len ) );
if ( len <= 0 )
if ( len < 0 )
s -> error = len;
s -> pos += len;
s -> buf_ptr = dst;
s -> buf_end = dst + len;
s -> bytes_read += len;
0
------------------------------
298898 96832/CWE36_Absolute_Path_Traversal__wchar_t_connect_socket_ifstream_83_bad.cpp recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ) 86
CWE36_Absolute_Path_Traversal__wchar_t_connect_socket_ifstream_83_bad::CWE36_Absolute_Path_Traversal__wchar_t_connect_socket_ifstream_83_bad(wchar_t * dataCopy)
data = dataCopy;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( FILENAME_MAX - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
21068 CVE-2016-7155/qemu_2.3.0_CVE-2016-7155_vmw_pvscsi.c uint32_t next_ready_page = next_ready_ptr / PVSCSI_MAX_NUM_REQ_ENTRIES_PER_PAGE ; 221
static
pvscsi_io_write(void *opaque, hwaddr
uint64_t val, unsigned size)
PVSCSIState * s = opaque ;
switch ( addr )
s -> reg_interrupt_status &= ~val;
s -> reg_interrupt_enabled = val;
pvscsi_process_io ( s );
static
pvscsi_process_io(PVSCSIState *s)
hwaddr next_descr_pa ;
while ( ( next_descr_pa = pvscsi_ring_pop_req_descr ( & s -> rings ) ) != 0 )
static
pvscsi_ring_pop_req_descr(PVSCSIRingInfo *mgr)
uint32_t ready_ptr = RS_GET_FIELD ( mgr , reqProdIdx ) ;
if ( ready_ptr != mgr -> consumed_ptr )
uint32_t next_ready_ptr = mgr -> consumed_ptr ++ & mgr -> txr_len_mask ;
uint32_t next_ready_page = next_ready_ptr / PVSCSI_MAX_NUM_REQ_ENTRIES_PER_PAGE ;
return mgr -> req_ring_pages_pa [ next_ready_page ] + inpage_idx * sizeof ( PVSCSIRingReqDesc ) ;
0
------------------------------
305998 118293/CWE78_OS_Command_Injection__char_connect_socket_w32_spawnv_15.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 104
void CWE78_OS_Command_Injection__char_connect_socket_w32_spawnv_15_bad()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
switch ( 6 )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
0
------------------------------
314031 110734/CWE680_Integer_Overflow_to_Buffer_Overflow__new_fixed_66b.cpp dataBytes = data * sizeof ( int ) 32
void bad()
int data ;
int dataArray [ 5 ] ;
data = - 1;
data = INT_MAX / 2 + 2;
dataArray [ 2 ] = data;
badSink ( dataArray );
void badSink(int dataArray[])
int data = dataArray [ 2 ] ;
size_t dataBytes , i ;
dataBytes = data * sizeof ( int );
intPointer = ( int * ) new char [ dataBytes ];
intPointer [ i ] = 0;
printIntLine ( intPointer [ 0 ] );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
delete [ ] intPointer
1
------------------------------
305686 117177/CWE789_Uncontrolled_Mem_Alloc__malloc_char_rand_03.c myString = ( char * ) malloc ( data * sizeof ( char ) ) 90
static void goodB2G1()
size_t data ;
data = 0;
if ( 5 == 5 )
data = rand ( );
if ( 5 != 5 )
char * myString ;
if ( data > strlen ( HELLO_STRING ) && data < 100 )
myString = ( char * ) malloc ( data * sizeof ( char ) );
strcpy ( myString , HELLO_STRING );
printLine ( myString );
void printLine (const char * line)
if ( line != NULL )
printf ( "%s\n" , line );
free ( myString );
0
------------------------------
17472 CVE-2009-1385/CVE_2009_1385_VULN_e1000_clean_rx_irq.c struct sk_buff * new_skb = netdev_alloc_skb ( netdev , length + NET_IP_ALIGN ) ; 89
static bool CVE_2009_1385_VULN_e1000_clean_rx_irq(struct e1000_adapter
struct e1000_rx_ring
int *work_done, int work_to_do)
struct e1000_hw * hw = & adapter -> hw ;
struct net_device * netdev = adapter -> netdev ;
struct e1000_rx_desc * rx_desc , * next_rxd ;
struct e1000_buffer * buffer_info , * next_buffer ;
u32 length ;
u8 last_byte ;
unsigned int i ;
i = rx_ring -> next_to_clean;
rx_desc = E1000_RX_DESC ( * rx_ring , i );
buffer_info = & rx_ring -> buffer_info [ i ];
while ( rx_desc -> status & E1000_RXD_STAT_DD )
struct sk_buff * skb ;
u8 status ;
if ( * work_done >= work_to_do )
( * work_done ) ++;
status = rx_desc -> status;
skb = buffer_info -> skb;
buffer_info -> skb = NULL;
if ( ++ i == rx_ring -> count )
i = 0;
next_rxd = E1000_RX_DESC ( * rx_ring , i );
next_buffer = & rx_ring -> buffer_info [ i ];
length = le16_to_cpu ( rx_desc -> length );
if ( unlikely ( ! ( status & E1000_RXD_STAT_EOP ) ) )
buffer_info -> skb = skb;
if ( unlikely ( rx_desc -> errors & E1000_RXD_ERR_FRAME_ERR_MASK ) )
last_byte = * ( skb -> data + length - 1 );
if ( TBI_ACCEPT ( hw , status , rx_desc -> errors , length , last_byte ) )
length --;
buffer_info -> skb = skb;
length -= 4;
if ( length < copybreak )
struct sk_buff * new_skb = netdev_alloc_skb ( netdev , length + NET_IP_ALIGN ) ;
if ( new_skb )
buffer_info -> skb = skb;
skb = new_skb;
skb -> protocol = eth_type_trans ( skb , netdev );
rx_desc -> status = 0;
rx_desc = next_rxd;
buffer_info = next_buffer;
0
------------------------------
17920 CVE-2016-5275/Firefox_49.0b1_CVE_2016_5275_gfx_src_FilterSupport.cpp aOutMatrix [ 12 ] = aAmount * aToMatrix [ 12 ] + oneMinusAmount 393
static
ComputeColorMatrix(uint32_t aColorMatrixType, const nsTArray<float>&
float aOutMatrix[20])
static const float lumR = 0.2126f ;
static const float lumG = 0.7152f ;
static const float lumB = 0.0722f ;
static const float saturateMatrix [ ] = { lumR , lumG , lumB , 0 , 0 , lumR , lumG , lumB , 0 , 0 , lumR , lumG , lumB , 0 , 0 , 0 , 0 , 0 , 1 , 0 } ;
switch ( aColorMatrixType )
if ( aValues . Length ( ) != 1 )
float s = aValues [ 0 ] ;
if ( s < 0 )
InterpolateFromIdentityMatrix ( saturateMatrix , 1 - s , aOutMatrix );
static
InterpolateFromIdentityMatrix(const float aToMatrix[20], float
float aOutMatrix[20])
float oneMinusAmount = 1 - aAmount ;
aOutMatrix [ 0 ] = aAmount * aToMatrix [ 0 ] + oneMinusAmount;
aOutMatrix [ 1 ] = aAmount * aToMatrix [ 1 ];
aOutMatrix [ 2 ] = aAmount * aToMatrix [ 2 ];
aOutMatrix [ 5 ] = aAmount * aToMatrix [ 5 ];
aOutMatrix [ 6 ] = aAmount * aToMatrix [ 6 ] + oneMinusAmount;
aOutMatrix [ 7 ] = aAmount * aToMatrix [ 7 ];
aOutMatrix [ 10 ] = aAmount * aToMatrix [ 10 ];
aOutMatrix [ 11 ] = aAmount * aToMatrix [ 11 ];
aOutMatrix [ 12 ] = aAmount * aToMatrix [ 12 ] + oneMinusAmount;
0
------------------------------
305414 97841/CWE36_Absolute_Path_Traversal__wchar_t_listen_socket_ofstream_84_bad.cpp recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ) 94
void bad()
wchar_t * data ;
wchar_t dataBuffer [ FILENAME_MAX ] = L ""
data = dataBuffer;
CWE36_Absolute_Path_Traversal__wchar_t_listen_socket_ofstream_84_bad * badObject = new CWE36_Absolute_Path_Traversal__wchar_t_listen_socket_ofstream_84_bad ( data ) ;
CWE36_Absolute_Path_Traversal__wchar_t_listen_socket_ofstream_84_bad::CWE36_Absolute_Path_Traversal__wchar_t_listen_socket_ofstream_84_bad(wchar_t * dataCopy)
data = dataCopy;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( FILENAME_MAX - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
307470 110440/CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fixed_54e.c intPointer = ( int * ) malloc ( data * sizeof ( int ) ) 52
void CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fixed_54b_goodG2BSink(int data)
CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fixed_54c_goodG2BSink ( data );
void CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fixed_54c_goodG2BSink(int data)
CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fixed_54d_goodG2BSink ( data );
void CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fixed_54d_goodG2BSink(int data)
CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fixed_54e_goodG2BSink ( data );
void CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fixed_54e_goodG2BSink(int data)
int * intPointer ;
intPointer = ( int * ) malloc ( data * sizeof ( int ) );
intPointer [ i ] = 0;
printIntLine ( intPointer [ 0 ] );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
free ( intPointer );
0
------------------------------
16723 CVE-2009-1336/CVE_2009_1336_PATCHED_nfs_init_server.c server -> acregmin = data -> acregmin * HZ 34
static int CVE_2009_1336_PATCHED_nfs_init_server(struct nfs_server *server, const struct nfs_mount_data *data)
struct nfs_client * clp ;
int error , nfsvers = 2 ;
if ( data -> flags & NFS_MOUNT_VER3 )
nfsvers = 3;
clp = nfs_get_client ( data -> hostname , & data -> addr , nfsvers );
if ( IS_ERR ( clp ) )
error = nfs_init_client ( clp , data );
if ( error < 0 )
server -> nfs_client = clp;
server -> flags = data -> flags & NFS_MOUNT_FLAGMASK;
if ( data -> rsize )
server -> rsize = nfs_block_size ( data -> rsize , NULL );
if ( data -> wsize )
server -> wsize = nfs_block_size ( data -> wsize , NULL );
server -> acregmin = data -> acregmin * HZ;
0
------------------------------
19736 CVE-2016-2522/Wireshark_2.0.1_CVE_2016_2522_epan_dissectors_packet-ber.c end_offset = offset + len 1578

dissect_ber_constrained_octet_string(gboolean implicit_tag, asn1_ctx_t *actx, proto_tree *tree, tvbuff_t *tvb, int offset, gint32 min_len, gint32 max_len, gint hf_id, tvbuff_t **out_tvb)
gint8 ber_class ;
gboolean pc , ind ;
gint32 tag ;
guint32 len ;
int end_offset ;
guint32 len_remain ;
if ( out_tvb )
* out_tvb = NULL;
if ( ! implicit_tag )
offset = dissect_ber_identifier ( actx -> pinfo , tree , tvb , offset , & ber_class , & pc , & tag );
offset = dissect_ber_length ( actx -> pinfo , tree , tvb , offset , & len , & ind );
if ( ( ber_class != BER_CLASS_APP ) && ( ber_class != BER_CLASS_PRI ) )
if ( ( ber_class != BER_CLASS_UNI ) || ( ( tag < BER_UNI_TAG_NumericString ) && ( tag != BER_UNI_TAG_OCTETSTRING ) && ( tag != BER_UNI_TAG_UTF8String ) ) )
len_remain = ( guint32 ) tvb_reported_length_remaining ( tvb , offset );
if ( ind && ( len_remain == ( len - 2 ) ) )
len -= 2;
ind = FALSE;
if ( len_remain < len )
actx -> created_item = NULL;
if ( pc )
end_offset = reassemble_octet_string ( actx , tree , hf_id , tvb , offset , len , ind , out_tvb );
static
reassemble_octet_string(asn1_ctx_t *actx, proto_tree *tree, gint hf_id, tvbuff_t *tvb, int offset, guint32 con_len, gboolean ind, tvbuff_t **out_tvb)
fragment_head * fd_head = NULL ;
tvbuff_t * next_tvb = NULL ;
guint16 dst_ref = 0 ;
int start_offset = offset ;
gboolean fragment = TRUE ;
gboolean firstFragment = TRUE ;
if ( con_len == 0 )
actx -> pinfo -> fragmented = TRUE;
while ( ! fd_head )
offset = dissect_ber_octet_string ( FALSE , actx , NULL , tvb , offset , hf_id , & next_tvb );
if ( ind )
if ( ( tvb_get_guint8 ( tvb , offset ) == 0 ) && ( tvb_get_guint8 ( tvb , offset + 1 ) == 0 ) )
fragment = FALSE;
offset += 2;
if ( ( guint32 ) ( offset - start_offset ) >= con_len )
fragment = FALSE;
if ( ! fragment && firstFragment )
fd_head = fragment_add_seq_next ( & octet_segment_reassembly_table , next_tvb , 0 , actx -> pinfo , dst_ref , NULL , tvb_reported_length ( next_tvb ) , fragment );
firstFragment = FALSE;

dissect_ber_octet_string(gboolean implicit_tag, asn1_ctx_t *actx, proto_tree *tree, tvbuff_t *tvb, int offset, gint hf_id, tvbuff_t **out_tvb)
return dissect_ber_constrained_octet_string ( implicit_tag , actx , tree , tvb , offset , NO_BOUND , NO_BOUND , hf_id , out_tvb ) ;

dissect_ber_constrained_octet_string(gboolean implicit_tag, asn1_ctx_t *actx, proto_tree *tree, tvbuff_t *tvb, int offset, gint32 min_len, gint32 max_len, gint hf_id, tvbuff_t **out_tvb)
guint32 len ;
int end_offset ;
if ( ! implicit_tag )
offset = dissect_ber_identifier ( actx -> pinfo , tree , tvb , offset , & ber_class , & pc , & tag );
offset = dissect_ber_length ( actx -> pinfo , tree , tvb , offset , & len , & ind );
end_offset = offset + len;
return end_offset ;
return end_offset ;
return end_offset ;
1
------------------------------
308256 119968/CWE78_OS_Command_Injection__char_listen_socket_popen_10.c recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 110
void CWE78_OS_Command_Injection__char_listen_socket_popen_10_bad()
char * data ;
char data_buf [ 100 ] = FULL_COMMAND ;
data = data_buf;
if ( globalTrue )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
pipe = POPEN ( data , "wb" );
if ( pipe != NULL )
PCLOSE ( pipe );
1
------------------------------
312346 150097/stream.c stonesoup_arr [ stonesoup_j ] = threadTiming - stonesoup_j 231
void *toCaps(void *data)
int threadTiming = 500000 ;
int stonesoup_j ;
int * stonesoup_arr ;
stonesoup_arr = malloc ( sizeof ( int ) * threadTiming );
if ( stonesoup_arr != NULL )
for (stonesoup_j = 0; stonesoup_j < threadTiming; stonesoup_j++)
stonesoup_arr [ stonesoup_j ] = threadTiming - stonesoup_j;
qsort ( stonesoup_arr , threadTiming , sizeof ( int ) , & stonesoup_comp );
free ( stonesoup_arr );
0
------------------------------
298474 94259/CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_18.c recvResult = recv ( acceptSocket , ( char * ) ( password + passwordLen ) , ( 100 - passwordLen - 1 ) * sizeof ( wchar_t ) , 0 ) 81
void CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_18_bad()
wchar_t * password ;
wchar_t passwordBuffer [ 100 ] = L ""
password = passwordBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t passwordLen = wcslen ( password ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( password + passwordLen ) , ( 100 - passwordLen - 1 ) * sizeof ( wchar_t ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
1
------------------------------
302304 80794/CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_w32_vsnprintf_17.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 ) 205
static void goodB2G()
int i , k ;
wchar_t * data ;
wchar_t dataBuffer [ 100 ] = L ""
data = dataBuffer;
for(i = 0; i < 1; i++)
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
306581 117324/CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_fscanf_06.c myString = ( wchar_t * ) malloc ( data * sizeof ( wchar_t ) ) 52
void CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_fscanf_06_bad()
size_t data ;
data = 0;
if ( STATIC_CONST_FIVE == 5 )
wchar_t * myString ;
if ( data > wcslen ( HELLO_STRING ) )
myString = ( wchar_t * ) malloc ( data * sizeof ( wchar_t ) );
wcscpy ( myString , HELLO_STRING );
printWLine ( myString );
void printWLine (const wchar_t * line)
if ( line != NULL )
wprintf ( L "%ls\n" , line )
free ( myString );
1
------------------------------
18911 CVE-2015-2716/Firefox_37.0b7_CVE_2015_2716_parser_expat_lib_xmlparse.c pool -> end = pool -> start + pool -> blocks -> size 6238
static enum
appendAttributeValue(XML_Parser parser, const ENCODING *enc, XML_Bool
const char *ptr, const char
STRING_POOL *pool)
DTD * const dtd = _dtd
const char * next ;
int tok = XmlAttributeValueTok ( enc , ptr , end , & next ) ;
switch ( tok )
XML_Char buf [ XML_ENCODE_MAX ] ;
int i ;
int n = XmlCharRefNumber ( enc , ptr ) ;
if ( n < 0 )
if ( ! isCdata && n == 0x20 && ( poolLength ( pool ) == 0 || poolLastChar ( pool ) == 0x20 ) )
n = XmlEncode ( n , ( ICHAR * ) buf );
if ( ! n )
for (i = 0; i < n; i++)
if ( ! poolAppendChar ( pool , buf [ i ] ) )
if ( ! poolAppend ( pool , enc , ptr , next ) )
next = ptr + enc -> minBytesPerChar;
if ( ! isCdata && ( poolLength ( pool ) == 0 || poolLastChar ( pool ) == 0x20 ) )
if ( ! poolAppendChar ( pool , 0x20 ) )
const XML_Char * name ;
ENTITY * entity ;
char checkEntityDecl ;
XML_Char ch = ( XML_Char ) XmlPredefinedEntityName ( enc , ptr + enc -> minBytesPerChar , next - enc -> minBytesPerChar ) ;
if ( ch )
if ( ! poolAppendChar ( pool , ch ) )
name = poolStoreString ( & temp2Pool , enc , ptr + enc -> minBytesPerChar , next - enc -> minBytesPerChar );
if ( ! name )
entity = ( ENTITY * ) lookup ( & dtd -> generalEntities , name , 0 );
if ( pool == & dtd -> pool )
checkEntityDecl = ! dtd -> hasParamEntityRefs || dtd -> standalone;
if ( checkEntityDecl )
if ( ! entity )
if ( ! entity -> is_internal )
if ( ! entity )
if ( entity -> open )
if ( entity -> notation )
if ( ! entity -> textPtr )
enum XML_Error result ;
const XML_Char * textEnd = entity -> textPtr + entity -> textLen ;
entity -> open = XML_TRUE;
result = appendAttributeValue ( parser , internalEncoding , isCdata , ( char * ) entity -> textPtr , ( char * ) textEnd , pool );
entity -> open = XML_FALSE;
if ( result )
ptr = next;
static XML_Char
poolStoreString(STRING_POOL *pool, const ENCODING
const char *ptr, const char *end)
if ( ! poolAppend ( pool , enc , ptr , end ) )
static XML_Char
poolAppend(STRING_POOL *pool, const ENCODING
const char *ptr, const char *end)
if ( ! pool -> ptr && ! poolGrow ( pool ) )
if ( ptr == end )
if ( ! poolGrow ( pool ) )
static XML_Bool
poolGrow(STRING_POOL *pool)
if ( pool -> freeBlocks )
if ( pool -> start == 0 )
pool -> blocks = pool -> freeBlocks;
pool -> freeBlocks = pool -> freeBlocks -> next;
pool -> blocks -> next = NULL;
pool -> start = pool -> blocks -> s;
pool -> end = pool -> start + pool -> blocks -> size;
pool -> ptr = pool -> start;
0
------------------------------
305705 110544/CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_listen_socket_68b.c intPointer = ( int * ) malloc ( data * sizeof ( int ) ) 56
void CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_listen_socket_68b_badSink()
int data = CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_listen_socket_68_badData ;
int * intPointer ;
intPointer = ( int * ) malloc ( data * sizeof ( int ) );
intPointer [ i ] = 0;
printIntLine ( intPointer [ 0 ] );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
free ( intPointer );
1
------------------------------
298759 98308/CWE398_Poor_Code_Quality__addition_09.c intSum = intOne + intTwo 52
static void good1()
if ( GLOBAL_CONST_FALSE )
int intOne = 1 , intTwo = 1 , intSum = 0 ;
intSum = intOne + intTwo;
printIntLine ( intSum );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
1
------------------------------
306686 117092/CWE789_Uncontrolled_Mem_Alloc__malloc_char_fscanf_14.c myString = ( char * ) malloc ( data * sizeof ( char ) ) 124
static void goodB2G2()
size_t data ;
data = 0;
if ( globalFive == 5 )
char * myString ;
if ( data > strlen ( HELLO_STRING ) && data < 100 )
myString = ( char * ) malloc ( data * sizeof ( char ) );
strcpy ( myString , HELLO_STRING );
printLine ( myString );
void printLine (const char * line)
if ( line != NULL )
printf ( "%s\n" , line );
free ( myString );
0
------------------------------
308929 117231/CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_connect_socket_09.c myString = ( wchar_t * ) malloc ( data * sizeof ( wchar_t ) ) 381
static void goodG2B2()
size_t data ;
data = 0;
if ( GLOBAL_CONST_TRUE )
data = 20;
if ( GLOBAL_CONST_TRUE )
wchar_t * myString ;
if ( data > wcslen ( HELLO_STRING ) )
myString = ( wchar_t * ) malloc ( data * sizeof ( wchar_t ) );
wcscpy ( myString , HELLO_STRING );
printWLine ( myString );
void printWLine (const wchar_t * line)
if ( line != NULL )
wprintf ( L "%ls\n" , line )
free ( myString );
0
------------------------------
300230 149405/aviobuf.c s -> buf_end = dst + len 491
unsigned int avio_rb32(AVIOContext *s)
unsigned int val ;
val = avio_rb16 ( s ) << 16;
unsigned int avio_rb16(AVIOContext *s)
unsigned int val ;
val = ( avio_r8 ( s ) << 8 );
val |= ( avio_r8 ( s ) );
int avio_r8(AVIOContext *s)
if ( s -> buf_ptr >= s -> buf_end )
fill_buffer ( s );
static void fill_buffer(AVIOContext *s)
uint8_t * dst = ! s -> max_packet_size && s -> buf_end - s -> buffer < ( s -> buffer_size ) ? s -> buf_end : s -> buffer ;
int len = ( ( s -> buffer_size ) - ( dst - s -> buffer ) ) ;
int max_buffer_size = s -> max_packet_size ? s -> max_packet_size : 32768 ;
if ( ! s -> read_packet && s -> buf_ptr >= s -> buf_end )
s -> eof_reached = 1;
if ( s -> eof_reached )
if ( s -> update_checksum && dst == s -> buffer )
if ( s -> buf_end > s -> checksum_ptr )
s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_end - s -> checksum_ptr ) ) );
s -> checksum_ptr = s -> buffer;
if ( s -> read_packet && s -> buffer_size > max_buffer_size )
s -> checksum_ptr = dst = s -> buffer;
len = s -> buffer_size;
if ( s -> read_packet )
len = ( ( s -> read_packet ) ( s -> opaque , dst , len ) );
len = 0;
if ( len <= 0 )
s -> eof_reached = 1;
if ( len < 0 )
s -> error = len;
s -> pos += len;
s -> buf_ptr = dst;
s -> buf_end = dst + len;
s -> bytes_read += len;
0
------------------------------
309265 120667/CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_spawnlp_64a.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 ) 104
void CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_spawnlp_64_bad()
wchar_t * data ;
wchar_t dataBuffer [ 100 ] = L ""
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
17638 CVE-2012-1594/CVE_2012_1594_VULN_dissect_ieee80211_common.c fcs_item = proto_tree_add_boolean ( fcs_tree , hf_ieee80211_fcs_good , tvb , hdr_len + len , 4 , fcs_good ) 712
static
CVE_2012_1594_VULN_dissect_ieee80211_common (tvbuff_t * tvb, packet_info *
proto_tree * tree, gboolean fixed_length_header, gint
gboolean wlan_broken_fc, gboolean
gboolean is_ht)
guint16 fcf , flags , frame_type_subtype , ctrl_fcf , ctrl_type_subtype ;
proto_tree * volatile hdr_tree = NULL
gboolean has_fcs , fcs_good , fcs_bad ;
gint len , reported_len , ivlen ;
const char * addr1_str = NULL ;
guint offset ;
const gchar * fts_str ;
fcf = FETCH_FCF ( 0 );
frame_type_subtype = COMPOSE_FRAME_TYPE ( fcf );
if ( frame_type_subtype == CTRL_CONTROL_WRAPPER )
ctrl_fcf = FETCH_FCF ( 10 );
ctrl_fcf = 0;
if ( fixed_length_header )
hdr_len = DATA_LONG_HDR_LEN;
hdr_len = find_header_length ( fcf , ctrl_fcf , is_ht );
ohdr_len = hdr_len;
if ( datapad )
hdr_len = roundup2 ( hdr_len , 4 );
fts_str = val_to_str_const ( frame_type_subtype , frame_type_subtype_vals , "Unrecognized (Reserved frame)" );
if ( tree )
ti = proto_tree_add_protocol_format ( tree , proto_wlan , tvb , 0 , hdr_len , "IEEE 802.11 %s" , fts_str );
hdr_tree = proto_item_add_subtree ( ti , ett_80211 );
switch ( FCF_FRAME_TYPE ( fcf ) )
if ( frame_type_subtype == CTRL_CONTROL_WRAPPER )
offset = 10;
ctrl_fcf = FETCH_FCF ( 10 );
ctrl_type_subtype = COMPOSE_FRAME_TYPE ( ctrl_fcf );
offset = 10;
ctrl_type_subtype = frame_type_subtype;
switch ( ctrl_type_subtype )
addr1_str = "BSSID";
addr1_str = "RA";
if ( ! addr1_str )
if ( frame_type_subtype == CTRL_CONTROL_WRAPPER && tree )
cw_item = proto_tree_add_text ( hdr_tree , tvb , offset , 2 , "Contained Frame Control" );
offset += 6;
cw_item = proto_tree_add_text ( hdr_tree , tvb , offset , 2 , "Carried Frame" );
hdr_tree = proto_item_add_subtree ( cw_item , ett_cntrl_wrapper_fc );
if ( tree && ( FCF_ADDR_SELECTOR ( fcf ) == DATA_ADDR_T4 || FCF_ADDR_SELECTOR ( fcf ) == DATA_ADDR_T2 ) )
guint16 mshoff ;
guint8 mesh_flags ;
guint8 mesh_hdr_len ;
mshoff = hdr_len;
mesh_flags = tvb_get_guint8 ( tvb , mshoff + 0 );
if ( mesh_flags & ~MESH_FLAGS_ADDRESS_EXTENSION )
mesh_hdr_len = find_mesh_header_length ( tvb_get_ptr ( tvb , mshoff , 1 ) , 0 , fcf );
hdr_len += mesh_hdr_len;
len = tvb_length_remaining ( tvb , hdr_len );
reported_len = tvb_reported_length_remaining ( tvb , hdr_len );
switch ( fcs_len )
has_fcs = FALSE;
has_fcs = TRUE;
if ( FCF_FRAME_TYPE ( fcf ) == DATA_FRAME )
has_fcs = FALSE;
has_fcs = TRUE;
has_fcs = wlan_check_fcs;
if ( has_fcs )
if ( reported_len < 4 )
if ( len < reported_len )
len -= 4;
if ( tree )
guint32 sent_fcs = tvb_get_ntohl ( tvb , hdr_len + len ) ;
guint32 fcs ;
if ( datapad )
fcs = crc32_802_tvb_padded ( tvb , ohdr_len , hdr_len , len );
fcs = crc32_802_tvb ( tvb , hdr_len + len );
if ( fcs == sent_fcs )
fcs_good = TRUE;
fcs_good = FALSE;
if ( fcs_good )
fcs_item = proto_tree_add_uint_format ( hdr_tree , hf_ieee80211_fcs , tvb , hdr_len + len , 4 , sent_fcs , "Frame check sequence: 0x%08x [correct]" , sent_fcs );
fcs_item = proto_tree_add_uint_format ( hdr_tree , hf_ieee80211_fcs , tvb , hdr_len + len , 4 , sent_fcs , "Frame check sequence: 0x%08x [incorrect, should be 0x%08x]" , sent_fcs , fcs );
fcs_tree = proto_item_add_subtree ( fcs_item , ett_fcs );
fcs_item = proto_tree_add_boolean ( fcs_tree , hf_ieee80211_fcs_good , tvb , hdr_len + len , 4 , fcs_good );
0
------------------------------
300867 151732/dfa.c inputwcs = ( ( sizeof ( ( * inputwcs ) ) == 1 ? xmalloc ( ( end - begin + 2 ) ) : xnmalloc ( ( end - begin + 2 ) , sizeof ( ( * inputwcs ) ) ) ) ) 3585
char *dfaexec(struct dfa *d,const char *begin,char *end,int allow_nl,size_t *count,int *backref)
unsigned char eol = eolbyte ;
* end = eol;
if ( d -> mb_cur_max > 1 )
inputwcs = ( ( sizeof ( ( * inputwcs ) ) == 1 ? xmalloc ( ( end - begin + 2 ) ) : xnmalloc ( ( end - begin + 2 ) , sizeof ( ( * inputwcs ) ) ) ) );
while ( 0 )
while ( inputwcs [ p - buf_begin ] == 0 && mblen_buf [ p - buf_begin ] > 0 && ( ( const unsigned char * ) p ) < buf_end )
free ( inputwcs );
free ( inputwcs );
free ( inputwcs );
free ( inputwcs );
0
------------------------------
19823 CVE-2016-2522/Wireshark_2.0.1_CVE_2016_2522_epan_dissectors_packet-ber.c end_offset = offset + val_length 2082

dissect_ber_set(gboolean implicit_tag, asn1_ctx_t *actx, proto_tree *parent_tree, tvbuff_t *tvb, int offset, const ber_sequence_t *set, gint hf_id, gint ett_id)
gint8 classx ;
gboolean pcx , ind = 0 , ind_field , imp_tag = FALSE ;
gint32 tagx ;
guint32 lenx ;
proto_tree * tree = parent_tree ;
proto_item * cause ;
int hoffset ;
if ( ! implicit_tag )
hoffset = offset;
offset = dissect_ber_identifier ( actx -> pinfo , tree , tvb , offset , & classx , & pcx , & tagx );
offset = dissect_ber_length ( actx -> pinfo , tree , tvb , offset , & lenx , & ind );
if ( ( classx != BER_CLASS_APP ) && ( classx != BER_CLASS_PRI ) )
if ( ! pcx || ( ! implicit_tag && ( ( classx != BER_CLASS_UNI ) || ( tagx != BER_UNI_TAG_SET ) ) ) )
cause = proto_tree_add_string_format_value ( tree , hf_ber_error , tvb , offset , lenx , "set_expected" , "SET expected but class:%s(%d) %s tag:%d was found" , val_to_str_const ( classx , ber_class_codes , "Unknown" ) , classx , pcx ? ber_pc_codes_short . true_string : ber_pc_codes_short . false_string , tagx );
if ( decode_unexpected )
proto_tree * unknown_tree = proto_item_add_subtree ( cause , ett_ber_unknown ) ;
dissect_unknown_ber ( actx -> pinfo , tvb , hoffset , unknown_tree );

dissect_unknown_ber(packet_info *pinfo, tvbuff_t *tvb, int offset, proto_tree *tree)
return try_dissect_unknown_ber ( pinfo , tvb , offset , tree , 1 ) ;
static
try_dissect_unknown_ber(packet_info *pinfo, tvbuff_t *tvb, volatile int offset, proto_tree *tree, gint nest_level)
int start_offset ;
gint8 ber_class ;
gboolean pc , ind ;
gint32 tag ;
guint32 len ;
start_offset = offset;
offset = get_ber_identifier ( tvb , offset , & ber_class , & pc , & tag );
offset = get_ber_length ( tvb , offset , & len , & ind );
if ( len > ( guint32 ) tvb_reported_length_remaining ( tvb , offset ) )
switch ( pc )
switch ( ber_class )
switch ( tag )
offset = dissect_ber_real ( FALSE , & asn1_ctx , tree , tvb , start_offset , hf_ber_unknown_REAL , NULL );

dissect_ber_real(gboolean implicit_tag, asn1_ctx_t *actx, proto_tree *tree, tvbuff_t *tvb, int offset, gint hf_id _U_, double *value)
guint32 val_length = 0 , len_remain , end_offset ;
if ( ! implicit_tag )
offset = dissect_ber_identifier ( actx -> pinfo , tree , tvb , offset , & ber_class , & pc , & tag );
offset = dissect_ber_length ( actx -> pinfo , tree , tvb , offset , & val_length , NULL );
end_offset = offset + val_length;
actx -> created_item = proto_tree_add_double ( tree , hf_id , tvb , end_offset - val_length , val_length , val );
return end_offset ;
1
------------------------------
305265 90680/CWE23_Relative_Path_Traversal__char_listen_socket_ofstream_81a.cpp recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ) 95
void bad()
char * data ;
char dataBuffer [ FILENAME_MAX ] = BASEPATH ;
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
baseObject . action ( data );
0
------------------------------
313386 80668/CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_snprintf_62b.cpp recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 ) 88
void bad()
wchar_t * data ;
wchar_t dataBuffer [ 100 ] = L ""
data = dataBuffer;
badSource ( data );
void badSource(wchar_t * &data)
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
302649 80689/CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_vfprintf_08.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 ) 115
void CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_vfprintf_08_bad()
wchar_t * data ;
wchar_t dataBuffer [ 100 ] = L ""
data = dataBuffer;
if ( staticReturnsTrue ( ) )
static int staticReturnsTrue()
return 1 ;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
306342 117300/CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_fgets_51b.c myString = ( wchar_t * ) malloc ( data * sizeof ( wchar_t ) ) 89
static void goodB2G()
size_t data ;
data = 0;
char inputBuffer [ CHAR_ARRAY_SIZE ] = "" ;
if ( fgets ( inputBuffer , CHAR_ARRAY_SIZE , stdin ) != NULL )
data = strtoul ( inputBuffer , NULL , 0 );
CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_fgets_51b_goodB2GSink ( data );
void CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_fgets_51b_goodB2GSink(size_t data)
wchar_t * myString ;
if ( data > wcslen ( HELLO_STRING ) && data < 100 )
myString = ( wchar_t * ) malloc ( data * sizeof ( wchar_t ) );
wcscpy ( myString , HELLO_STRING );
printWLine ( myString );
void printWLine (const wchar_t * line)
if ( line != NULL )
wprintf ( L "%ls\n" , line )
free ( myString );
0
------------------------------
314227 110643/CWE680_Integer_Overflow_to_Buffer_Overflow__new_connect_socket_74b.cpp dataBytes = data * sizeof ( int ) 58
static void goodG2B()
int data ;
map < int , int > dataMap ;
data = - 1;
data = 20;
dataMap [ 0 ] = data;
dataMap [ 1 ] = data;
dataMap [ 2 ] = data;
goodG2BSink ( dataMap );
void goodG2BSink(map<int, int> dataMap)
int data = dataMap [ 2 ] ;
size_t dataBytes , i ;
dataBytes = data * sizeof ( int );
intPointer = ( int * ) new char [ dataBytes ];
intPointer [ i ] = 0;
printIntLine ( intPointer [ 0 ] );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
delete [ ] intPointer
0
------------------------------
305122 94136/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_connect_socket_66a.c recvResult = recv ( connectSocket , ( char * ) ( password + passwordLen ) , ( 100 - passwordLen - 1 ) * sizeof ( char ) , 0 ) 74
void CWE319_Cleartext_Tx_Sensitive_Info__w32_char_connect_socket_66_bad()
char * password ;
char passwordBuffer [ 100 ] = "" ;
password = passwordBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t passwordLen = strlen ( password ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( password + passwordLen ) , ( 100 - passwordLen - 1 ) * sizeof ( char ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
password [ passwordLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( password , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( password , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
passwordArray [ 2 ] = password;
CWE319_Cleartext_Tx_Sensitive_Info__w32_char_connect_socket_66b_badSink ( passwordArray );
void CWE319_Cleartext_Tx_Sensitive_Info__w32_char_connect_socket_66b_badSink(char * passwordArray[])
char * password = passwordArray [ 2 ] ;
if ( LogonUserA ( username , domain , password , LOGON32_LOGON_NETWORK , LOGON32_PROVIDER_DEFAULT , & pHandle ) != 0 )
1
------------------------------
309198 117273/CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_fgets_03.c myString = ( wchar_t * ) malloc ( data * sizeof ( wchar_t ) ) 198
static void goodG2B1()
size_t data ;
data = 0;
if ( 5 != 5 )
data = 20;
if ( 5 == 5 )
wchar_t * myString ;
if ( data > wcslen ( HELLO_STRING ) )
myString = ( wchar_t * ) malloc ( data * sizeof ( wchar_t ) );
wcscpy ( myString , HELLO_STRING );
printWLine ( myString );
void printWLine (const wchar_t * line)
if ( line != NULL )
wprintf ( L "%ls\n" , line )
free ( myString );
0
------------------------------
18413 CVE-2015-2716/Firefox_37.0b7_CVE_2015_2716_parser_expat_lib_xmlparse.c dataBufEnd = dataBuf + INIT_DATA_BUF_SIZE 752
XML_Parser
XML_ExternalEntityParserCreate(XML_Parser
const XML_Char
const XML_Char *encodingName)
XML_Parser parser = oldParser ;
DTD * newDtd = NULL ;
DTD * oldDtd = _dtd ;
if ( ! context )
newDtd = oldDtd;
if ( ns )
parser = parserCreate ( encodingName , & parser -> m_mem , NULL , newDtd );
static
parserCreate(const XML_Char
const XML_Memory_Handling_Suite
const XML_Char
DTD *dtd)
XML_Parser parser ;
if ( memsuite )
parser = ( XML_Parser ) memsuite -> malloc_fcn ( sizeof ( struct XML_ParserStruct ) );
parser = ( XML_Parser ) malloc ( sizeof ( struct XML_ParserStruct ) );
if ( ! parser )
attsSize = INIT_ATTS_SIZE;
atts = ( ATTRIBUTE * ) MALLOC ( attsSize * sizeof ( ATTRIBUTE ) );
if ( atts == NULL )
dataBuf = ( XML_Char * ) MALLOC ( INIT_DATA_BUF_SIZE * sizeof ( XML_Char ) );
if ( dataBuf == NULL )
dataBufEnd = dataBuf + INIT_DATA_BUF_SIZE;
0
------------------------------
312906 90600/CWE23_Relative_Path_Traversal__char_listen_socket_ifstream_13.cpp recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ) 106
void bad()
char * data ;
char dataBuffer [ FILENAME_MAX ] = BASEPATH ;
data = dataBuffer;
if ( GLOBAL_CONST_FIVE == 5 )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
inputFile . open ( ( char * ) data );
1
------------------------------
311685 149958/aviobuf.c s -> buf_end = dst + len 595
int ffio_read_partial(AVIOContext *s,unsigned char *buf,int size)
int len ;
if ( size < 0 )
if ( s -> read_packet && s -> write_flag )
len = ( s -> buf_end - s -> buf_ptr );
if ( len == 0 )
s -> buf_end = s -> buf_ptr = s -> buffer;
len = ( s -> buf_end - s -> buf_ptr );
if ( len > size )
len = size;
s -> buf_ptr += len;
if ( ! len )
if ( s -> error )
if ( url_feof ( s ) )
int url_feof(AVIOContext *s)
if ( ! s )
if ( s -> eof_reached )
s -> eof_reached = 0;
fill_buffer ( s );
static void fill_buffer(AVIOContext *s)
uint8_t * dst = ! s -> max_packet_size && s -> buf_end - s -> buffer < ( s -> buffer_size ) ? s -> buf_end : s -> buffer ;
int len = ( ( s -> buffer_size ) - ( dst - s -> buffer ) ) ;
int max_buffer_size = s -> max_packet_size ? s -> max_packet_size : 32768 ;
if ( ! s -> read_packet && s -> buf_ptr >= s -> buf_end )
s -> eof_reached = 1;
if ( s -> eof_reached )
if ( s -> update_checksum && dst == s -> buffer )
if ( s -> buf_end > s -> checksum_ptr )
s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_end - s -> checksum_ptr ) ) );
s -> checksum_ptr = s -> buffer;
if ( s -> read_packet && s -> buffer_size > max_buffer_size )
s -> checksum_ptr = dst = s -> buffer;
len = s -> buffer_size;
if ( s -> read_packet )
len = ( ( s -> read_packet ) ( s -> opaque , dst , len ) );
len = 0;
if ( len <= 0 )
s -> eof_reached = 1;
if ( len < 0 )
s -> error = len;
s -> pos += len;
s -> buf_ptr = dst;
s -> buf_end = dst + len;
s -> bytes_read += len;
0
------------------------------
299603 152118/bufmgr.c newPartitionLock = ( ( LWLockId ) ( FirstBufMappingLock + newHash % 16 ) ) 202
void PrefetchBuffer(Relation reln,ForkNumber forkNum,BlockNumber blockNum)
if ( ( reln -> rd_rel -> relpersistence ) == 't' )
BufferTag newTag ;
uint32 newHash ;
LWLockId newPartitionLock ;
( newTag . rnode = reln -> rd_smgr -> smgr_rnode . node , newTag . forkNum = forkNum ) , newTag . blockNum = blockNum;
newHash = BufTableHashCode ( & newTag );
newPartitionLock = ( ( LWLockId ) ( FirstBufMappingLock + newHash % 16 ) );
LWLockAcquire ( newPartitionLock , LW_SHARED );
LWLockRelease ( newPartitionLock );
0
------------------------------
310986 151426/utf.c valid = ( last - data ) 657
svn_error_t *svn_utf_cstring_from_utf8_stringbuf(const char **dest,const svn_stringbuf_t *src,apr_pool_t *pool)
svn_error_t * svn_err__temp = svn_utf_stringbuf_from_utf8 ( & destbuf , src , pool ) ;
if ( svn_err__temp )
while ( 0 )
svn_error_t *svn_utf_stringbuf_from_utf8(svn_stringbuf_t **dest,const svn_stringbuf_t *src,apr_pool_t *pool)
xlate_handle_node_t * node ;
svn_error_t * err ;
svn_error_t * svn_err__temp = get_uton_xlate_handle_node ( & node , pool ) ;
static svn_error_t *get_uton_xlate_handle_node(xlate_handle_node_t **ret,apr_pool_t *pool)
return get_xlate_handle_node ( ret , ( assume_native_charset_is_utf8 ? SVN_APR_UTF8_CHARSET : ( ( const char * ) 1 ) ) , SVN_APR_UTF8_CHARSET , SVN_UTF_UTON_XLATE_HANDLE , pool ) ;
if ( svn_err__temp )
while ( 0 )
if ( node -> handle )
err = check_utf8 ( ( src -> data ) , src -> len , pool );
static svn_error_t *check_utf8(const char *data,apr_size_t len,apr_pool_t *pool)
if ( ! svn_utf__is_valid ( data , len ) )
return invalid_utf8 ( data , len , pool ) ;
static svn_error_t *invalid_utf8(const char *data,apr_size_t len,apr_pool_t *pool)
const char * last = svn_utf__last_valid ( data , len ) ;
size_t valid ;
valid = ( last - data );
if ( valid > 24 )
for (i = 0; i < valid; ++i)
valid_txt = ( apr_pstrcat ( pool , valid_txt , apr_psprintf ( pool , " %02x" , ( ( unsigned char ) last [ i - valid ] ) ) , ( ( char * ) ( ( void * ) 0 ) ) ) );
return svn_error_createf ( 22 , ( ( void * ) 0 ) , ( dgettext ( "subversion" , "Valid UTF-8 data\n(hex:%s)\nfollowed by invalid UTF-8 sequence\n(hex:%s)" ) ) , valid_txt , invalid_txt ) ;
0
------------------------------
313681 95293/CWE369_Divide_by_Zero__int_listen_socket_divide_74b.cpp printIntLine ( 100 / data ) 55
static void goodB2G()
int data ;
map < int , int > dataMap ;
data = - 1;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
char inputBuffer [ CHAR_ARRAY_SIZE ] ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
inputBuffer [ recvResult ] = '\0';
data = atoi ( inputBuffer );
while ( 0 )
dataMap [ 0 ] = data;
dataMap [ 1 ] = data;
dataMap [ 2 ] = data;
goodB2GSink ( dataMap );
void goodB2GSink(map<int, int> dataMap)
int data = dataMap [ 2 ] ;
if ( data != 0 )
printIntLine ( 100 / data );
0
------------------------------
305347 94267/CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_42.c recvResult = recv ( acceptSocket , ( char * ) ( password + passwordLen ) , ( 100 - passwordLen - 1 ) * sizeof ( wchar_t ) , 0 ) 228
static void goodB2G()
wchar_t * password ;
wchar_t passwordBuffer [ 100 ] = L ""
password = passwordBuffer;
password = goodB2GSource ( password );
static wchar_t * goodB2GSource(wchar_t * password)
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t passwordLen = wcslen ( password ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( password + passwordLen ) , ( 100 - passwordLen - 1 ) * sizeof ( wchar_t ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
19606 CVE-2016-7176/Wireshark_2.0.5_CVE_2016_7176_epan_dissectors_packet-h225.c stat_tap_table_item_type items [ sizeof ( h225_stat_fields ) / sizeof ( stat_tap_table_item ) ] ; 7908
static void h225_stat_init(new_stat_tap_ui* new_stat, new_stat_tap_gui_init_cb gui_callback, void* gui_data)
stat_tap_table_item_type items [ sizeof ( h225_stat_fields ) / sizeof ( stat_tap_table_item ) ] ;
items [ MESSAGE_TYPE_COLUMN ] . type = TABLE_ITEM_STRING;
items [ COUNT_COLUMN ] . type = TABLE_ITEM_UINT;
items [ COUNT_COLUMN ] . value . uint_value = 0;
items [ MESSAGE_TYPE_COLUMN ] . value . string_value = h225_RasMessage_vals [ msg_idx ] . strptr ? h225_RasMessage_vals [ msg_idx ] . strptr : "Unknown RAS message";
new_stat_tap_init_table_row ( table , row_idx , num_fields , items );
items [ MESSAGE_TYPE_COLUMN ] . value . string_value = T_h323_message_body_vals [ msg_idx ] . strptr ? T_h323_message_body_vals [ msg_idx ] . strptr : "Unknown CS message";
new_stat_tap_init_table_row ( table , row_idx , num_fields , items );
items [ MESSAGE_TYPE_COLUMN ] . value . string_value = GatekeeperRejectReason_vals [ msg_idx ] . strptr ? GatekeeperRejectReason_vals [ msg_idx ] . strptr : "Unknown gatekeeper reject reason";
new_stat_tap_init_table_row ( table , row_idx , num_fields , items );
items [ MESSAGE_TYPE_COLUMN ] . value . string_value = RegistrationRejectReason_vals [ msg_idx ] . strptr ? RegistrationRejectReason_vals [ msg_idx ] . strptr : "Unknown registration reject reason";
new_stat_tap_init_table_row ( table , row_idx , num_fields , items );
items [ MESSAGE_TYPE_COLUMN ] . value . string_value = UnregRequestReason_vals [ msg_idx ] . strptr ? UnregRequestReason_vals [ msg_idx ] . strptr : "Unknown unregistration request reason";
new_stat_tap_init_table_row ( table , row_idx , num_fields , items );
items [ MESSAGE_TYPE_COLUMN ] . value . string_value = UnregRejectReason_vals [ msg_idx ] . strptr ? UnregRejectReason_vals [ msg_idx ] . strptr : "Unknown unregistration reject reason";
new_stat_tap_init_table_row ( table , row_idx , num_fields , items );
items [ MESSAGE_TYPE_COLUMN ] . value . string_value = AdmissionRejectReason_vals [ msg_idx ] . strptr ? AdmissionRejectReason_vals [ msg_idx ] . strptr : "Unknown admission reject reason";
new_stat_tap_init_table_row ( table , row_idx , num_fields , items );
items [ MESSAGE_TYPE_COLUMN ] . value . string_value = BandRejectReason_vals [ msg_idx ] . strptr ? BandRejectReason_vals [ msg_idx ] . strptr : "Unknown band reject reason";
new_stat_tap_init_table_row ( table , row_idx , num_fields , items );
items [ MESSAGE_TYPE_COLUMN ] . value . string_value = DisengageReason_vals [ msg_idx ] . strptr ? DisengageReason_vals [ msg_idx ] . strptr : "Unknown disengage reason";
new_stat_tap_init_table_row ( table , row_idx , num_fields , items );
items [ MESSAGE_TYPE_COLUMN ] . value . string_value = DisengageRejectReason_vals [ msg_idx ] . strptr ? DisengageRejectReason_vals [ msg_idx ] . strptr : "Unknown disengage reject reason";
new_stat_tap_init_table_row ( table , row_idx , num_fields , items );
items [ MESSAGE_TYPE_COLUMN ] . value . string_value = LocationRejectReason_vals [ msg_idx ] . strptr ? LocationRejectReason_vals [ msg_idx ] . strptr : "Unknown location reject reason";
new_stat_tap_init_table_row ( table , row_idx , num_fields , items );
items [ MESSAGE_TYPE_COLUMN ] . value . string_value = InfoRequestNakReason_vals [ msg_idx ] . strptr ? InfoRequestNakReason_vals [ msg_idx ] . strptr : "Unknown info request nak reason";
new_stat_tap_init_table_row ( table , row_idx , num_fields , items );
items [ MESSAGE_TYPE_COLUMN ] . value . string_value = h225_ReleaseCompleteReason_vals [ msg_idx ] . strptr ? h225_ReleaseCompleteReason_vals [ msg_idx ] . strptr : "Unknown release complete reason";
new_stat_tap_init_table_row ( table , row_idx , num_fields , items );
items [ MESSAGE_TYPE_COLUMN ] . value . string_value = FacilityReason_vals [ msg_idx ] . strptr ? FacilityReason_vals [ msg_idx ] . strptr : "Unknown facility reason";
new_stat_tap_init_table_row ( table , row_idx , num_fields , items );
items [ MESSAGE_TYPE_COLUMN ] . value . string_value = "Unknown H.225 message";
new_stat_tap_init_table_row ( table , row_idx , num_fields , items );
0
------------------------------
314324 96797/CWE36_Absolute_Path_Traversal__wchar_t_connect_socket_ifstream_12.cpp recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ) 95
void bad()
wchar_t * data ;
wchar_t dataBuffer [ FILENAME_MAX ] = L ""
data = dataBuffer;
if ( globalReturnsTrueOrFalse ( ) )
int globalReturnsTrueOrFalse()
return ( rand ( ) % 2 ) ;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( FILENAME_MAX - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
314401 97715/CWE36_Absolute_Path_Traversal__wchar_t_listen_socket_fopen_18.cpp recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ) 106
void bad()
wchar_t * data ;
wchar_t dataBuffer [ FILENAME_MAX ] = L ""
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( FILENAME_MAX - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
313841 79132/CWE134_Uncontrolled_Format_String__char_connect_socket_fprintf_62b.cpp recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 171
static void goodB2G()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
goodB2GSource ( data );
void goodB2GSource(char * &data)
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
0
------------------------------
307911 110323/CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_connect_socket_12.c intPointer = ( int * ) malloc ( data * sizeof ( int ) ) 153
static void goodG2B()
int data ;
data = - 1;
if ( globalReturnsTrueOrFalse ( ) )
int globalReturnsTrueOrFalse()
return ( rand ( ) % 2 ) ;
data = 20;
data = 20;
int * intPointer ;
intPointer = ( int * ) malloc ( data * sizeof ( int ) );
intPointer [ i ] = 0;
printIntLine ( intPointer [ 0 ] );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
free ( intPointer );
0
------------------------------
313790 80704/CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_vfprintf_33.cpp recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 ) 225
static void goodB2G()
wchar_t * data ;
wchar_t dataBuffer [ 100 ] = L ""
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
310081 150627/dfa.c dfa -> multibyte_prop [ dfa -> tindex - 1 ] = dfa -> multibyte_prop [ tindex + i ] 2206
static void closure()
int i ;
size_t tindex ;
size_t ntokens ;
while ( tok == QMARK || tok == STAR || tok == PLUS || tok == REPMN )
if ( tok == REPMN && ( minrep || maxrep ) )
ntokens = nsubtoks ( dfa -> tindex );
tindex = dfa -> tindex - ntokens;
for (i = 1; i < minrep; ++i)
copytoks ( tindex , ntokens );
tok = lex ( );
if ( tok == REPMN )
dfa -> tindex -= nsubtoks ( dfa -> tindex );
tok = lex ( );
tok = lex ( );
static void copytoks(size_t tindex,size_t ntokens)
size_t i ;
for (i = 0; i < ntokens; ++i)
addtok ( dfa -> tokens [ tindex + i ] );
if ( __ctype_get_mb_cur_max ( ) > 1 && dfa -> tokens [ tindex + i ] == MBCSET )
dfa -> multibyte_prop [ dfa -> tindex - 1 ] = dfa -> multibyte_prop [ tindex + i ];
0
------------------------------
303719 82641/CWE190_Integer_Overflow__int64_t_fscanf_square_04.c int64_t result = data * data ; 98
static void goodB2G2()
int64_t data ;
data = 0L L
if ( STATIC_CONST_TRUE )
if ( abs ( ( long ) data ) <= ( long ) sqrt ( ( double ) LLONG_MAX ) )
int64_t result = data * data ;
printLongLongLine ( result );
void printLongLongLine (int64_t longLongIntNumber)
printf ( "%lld\n" , longLongIntNumber );
0
------------------------------
19463 CVE-2015-2726/Firefox_38.8.0esr_CVE_2015_2726_js_src_ctypes_CTypes.cpp size_t index = sign * size_t ( i - ii * IntegerType ( radix ) ) ; 2084
static
BuildTypeSource(JSContext*
JSObject*
bool
AutoString& result)
RootedObject typeObj ( cx , typeObj_ ) ;
switch ( CType :: GetTypeCode ( typeObj ) )
RootedObject baseType ( cx , PointerType :: GetBaseType ( typeObj ) ) ;

PointerType::GetBaseType(JSObject* obj)
jsval type = JS_GetReservedSlot ( obj , SLOT_TARGET_T ) ;
return & type . toObject ( ) ;
if ( CType :: GetTypeCode ( baseType ) == TYPE_void_t )

CType::GetTypeCode(JSObject* typeObj)
jsval result = JS_GetReservedSlot ( typeObj , SLOT_TYPECODE ) ;
return TypeCode ( result . toInt32 ( ) ) ;
BuildTypeSource ( cx , baseType , makeShort , result );
static
BuildTypeSource(JSContext*
JSObject*
bool
AutoString& result)
RootedObject typeObj ( cx , typeObj_ ) ;
switch ( CType :: GetTypeCode ( typeObj ) )
FunctionInfo * fninfo = FunctionType :: GetFunctionInfo ( typeObj ) ;
if ( fninfo -> mArgTypes . length ( ) > 0 )
for (size_t i = 0; i < fninfo->mArgTypes.length(); ++i)
BuildTypeSource ( cx , fninfo -> mArgTypes [ i ] , true , result );
static
BuildTypeSource(JSContext*
JSObject*
bool
AutoString& result)
RootedObject typeObj ( cx , typeObj_ ) ;
switch ( CType :: GetTypeCode ( typeObj ) )
size_t length ;
if ( ArrayType :: GetSafeLength ( typeObj , & length ) )
IntegerToString ( length , 10 , result );
template<class IntegerType, class CharType, size_t N, class

IntegerToString(IntegerType i, int radix, Vector<CharType, N, AP>& result)
const bool isNegative = IsNegative ( i ) ;
size_t sign = isNegative ? - 1 : 1 ;
IntegerType ii = i / IntegerType ( radix ) ;
size_t index = sign * size_t ( i - ii * IntegerType ( radix ) ) ;
* -- cp = "0123456789abcdefghijklmnopqrstuvwxyz" [ index ];
i = ii;
while ( i != 0 )
* -- cp = '-';
MOZ_ASSERT ( cp >= buffer );
result . append ( cp , end );
0
------------------------------
303589 82503/CWE190_Integer_Overflow__char_rand_square_10.c char result = data * data ; 37
void CWE190_Integer_Overflow__char_rand_square_10_bad()
char data ;
data = ' ';
if ( globalTrue )
data = ( char ) RAND32 ( );
if ( globalTrue )
char result = data * data ;
printHexCharLine ( result );
void printHexCharLine (char charHex)
printf ( "%02x\n" , charHex );
1
------------------------------
21115 CVE-2015-5307/linux_kernel_4.2.6_CVE_2015_5307_arch_x86_kvm_vmx.c __clear_bit ( msr , msr_bitmap + 0xc00 / f ) 4216
static __init int hardware_setup(void)
vmx_io_bitmap_a = ( unsigned long * ) __get_free_page ( GFP_KERNEL );
if ( ! vmx_io_bitmap_a )
vmx_io_bitmap_b = ( unsigned long * ) __get_free_page ( GFP_KERNEL );
if ( ! vmx_io_bitmap_b )
vmx_msr_bitmap_legacy = ( unsigned long * ) __get_free_page ( GFP_KERNEL );
if ( ! vmx_msr_bitmap_legacy )
vmx_msr_bitmap_legacy_x2apic = ( unsigned long * ) __get_free_page ( GFP_KERNEL );
if ( ! vmx_msr_bitmap_legacy_x2apic )
vmx_msr_bitmap_longmode = ( unsigned long * ) __get_free_page ( GFP_KERNEL );
if ( ! vmx_msr_bitmap_longmode )
vmx_msr_bitmap_longmode_x2apic = ( unsigned long * ) __get_free_page ( GFP_KERNEL );
if ( ! vmx_msr_bitmap_longmode_x2apic )
if ( nested )
vmx_msr_bitmap_nested = ( unsigned long * ) __get_free_page ( GFP_KERNEL );
if ( ! vmx_msr_bitmap_nested )
vmx_vmread_bitmap = ( unsigned long * ) __get_free_page ( GFP_KERNEL );
if ( ! vmx_vmread_bitmap )
vmx_vmwrite_bitmap = ( unsigned long * ) __get_free_page ( GFP_KERNEL );
if ( ! vmx_vmwrite_bitmap )
if ( setup_vmcs_config ( & vmcs_config ) < 0 )
if ( ! cpu_has_vmx_apicv ( ) )
enable_apicv = 0;
if ( enable_apicv )
vmx_disable_intercept_msr_write_x2apic ( 0x83f );
static void vmx_disable_intercept_msr_write_x2apic(u32 msr)
__vmx_disable_intercept_for_msr ( vmx_msr_bitmap_legacy_x2apic , msr , MSR_TYPE_W );
static void __vmx_disable_intercept_for_msr(unsigned long
u32 msr, int type)
int f = sizeof ( unsigned long ) ;
if ( ! cpu_has_vmx_msr_bitmap ( ) )
if ( msr <= 0x1fff )
if ( ( msr >= 0xc0000000 ) && ( msr <= 0xc0001fff ) )
msr &= 0x1fff;
if ( type & MSR_TYPE_W )
__clear_bit ( msr , msr_bitmap + 0xc00 / f );
0
------------------------------
302142 151543/tile-manager.c stonesoup_filearray = ( ( FILE * * ) ( malloc ( stonesoup_num_files * sizeof ( FILE * ) ) ) ) 761
void tile_manager_get_tile_coordinates(TileManager *tm,Tile *tile,gint *x,gint *y)
unsigned int stonesoup_num_files ;
FILE * * stonesoup_filearray ;
long oops_checksums [ 10 ] ;
char * odus_schulze [ 10 ] = { 0 } ;
char * allochezia_filings ;
if ( __sync_bool_compare_and_swap ( & undeviated_galliferous , 0 , 1 ) )
if ( mkdir ( "/opt/stonesoup/workspace/lockDir" , 509U ) == 0 )
if ( allochezia_filings != 0 )
odus_schulze [ 5 ] = allochezia_filings;
oops_checksums [ 1 ] = 5;
rimola_eshin = * ( odus_schulze + oops_checksums [ 1 ] );
tetrodon_supranaturalism = ( ( char * ) rimola_eshin );
if ( strlen ( tetrodon_supranaturalism ) > 0 && tetrodon_supranaturalism [ 0 ] == '-' )
stonesoup_num_files = strtoul ( tetrodon_supranaturalism , 0 , 16 );
if ( stonesoup_num_files > 0xffff )
stonesoup_num_files = 0;
stonesoup_filearray = ( ( FILE * * ) ( malloc ( stonesoup_num_files * sizeof ( FILE * ) ) ) );
if ( stonesoup_filearray != 0 )
stonesoup_filearray [ stonesoup_i ] = 0;
for (stonesoup_i = 0; stonesoup_i < stonesoup_num_files; ++stonesoup_i)
snprintf ( stonesoup_filename , filename_len , "%s_%08x" , "/opt/stonesoup/workspace/testData/temp" , stonesoup_i );
stonesoup_filearray [ stonesoup_i ] = stonesoup_open_file ( stonesoup_filename );
FILE *stonesoup_open_file(char *filename_param)
f = fopen ( filename_param , "w" );
if ( ! f )
return f ;
if ( stonesoup_filearray [ stonesoup_i ] == 0 )
if ( stonesoup_filearray [ stonesoup_i ] != 0 )
fclose ( stonesoup_filearray [ stonesoup_i ] );
free ( stonesoup_filearray );
1
------------------------------
314350 110607/CWE680_Integer_Overflow_to_Buffer_Overflow__new_connect_socket_08.cpp dataBytes = data * sizeof ( int ) 127
void bad()
int data ;
data = - 1;
if ( staticReturnsTrue ( ) )
static int staticReturnsTrue()
return 1 ;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
char inputBuffer [ CHAR_ARRAY_SIZE ] ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
inputBuffer [ recvResult ] = '\0';
data = atoi ( inputBuffer );
while ( 0 )
size_t dataBytes , i ;
dataBytes = data * sizeof ( int );
intPointer = ( int * ) new char [ dataBytes ];
intPointer [ i ] = 0;
printIntLine ( intPointer [ 0 ] );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
delete [ ] intPointer
1
------------------------------
302158 81710/CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_fprintf_31.c recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 ) 209
static void goodB2G()
wchar_t * data ;
wchar_t dataBuffer [ 100 ] = L ""
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
19117 CVE-2016-7466/qemu_2.3.0_CVE-2016-7466_hcd-xhci.c sctx = epctx -> pstreams + streamid 1289
static void xhci_complete(USBPort *port, USBPacket *packet)
XHCITransfer * xfer = container_of ( packet , XHCITransfer , packet ) ;
if ( packet -> status == USB_RET_REMOVE_FROM_QUEUE )
xhci_kick_ep ( xfer -> xhci , xfer -> slotid , xfer -> epid , xfer -> streamid );
static void xhci_kick_ep(XHCIState *xhci, unsigned int
unsigned int epid, unsigned int streamid)
XHCIStreamContext * stctx ;
XHCIEPContext * epctx ;
if ( ! xhci -> slots [ slotid - 1 ] . enabled )
epctx = xhci -> slots [ slotid - 1 ] . eps [ epid - 1 ];
if ( ! epctx )
if ( ! xhci -> slots [ slotid - 1 ] . uport || ! xhci -> slots [ slotid - 1 ] . uport -> dev || ! xhci -> slots [ slotid - 1 ] . uport -> dev -> attached )
if ( epctx -> retry )
XHCITransfer * xfer = epctx -> retry ;
if ( xfer -> timed_xfer )
if ( xfer -> running_retry )
xfer -> timed_xfer = 0;
xfer -> running_retry = 1;
if ( xfer -> iso_xfer )
if ( xhci_setup_packet ( xfer ) < 0 )
static int xhci_setup_packet(XHCITransfer *xfer)
XHCIState * xhci = xfer -> xhci ;
USBEndpoint * ep ;
if ( xfer -> packet . ep )
ep = xhci_epid_to_usbep ( xhci , xfer -> slotid , xfer -> epid );
static USBEndpoint *xhci_epid_to_usbep(XHCIState
unsigned int slotid, unsigned int epid)
if ( ! xhci -> slots [ slotid - 1 ] . uport )
return NULL ;
return usb_ep_get ( xhci -> slots [ slotid - 1 ] . uport -> dev , ( epid & 1 ) ? USB_TOKEN_IN : USB_TOKEN_OUT , epid >> 1 ) ;
if ( ! ep )
return - 1 ;
return 0 ;
if ( xhci_setup_packet ( xfer ) < 0 )
static int xhci_setup_packet(XHCITransfer *xfer)
XHCIState * xhci = xfer -> xhci ;
USBEndpoint * ep ;
if ( xfer -> packet . ep )
ep = xhci_epid_to_usbep ( xhci , xfer -> slotid , xfer -> epid );
if ( ! ep )
return - 1 ;
return 0 ;
if ( xfer -> packet . status == USB_RET_NAK )
epctx -> retry = NULL;
if ( epctx -> state == EP_HALTED )
if ( epctx -> nr_pstreams )
stctx = xhci_find_stream ( epctx , streamid , & err );
static XHCIStreamContext *xhci_find_stream(XHCIEPContext
unsigned int
uint32_t *cc_error)
XHCIStreamContext * sctx ;
if ( epctx -> lsa )
if ( streamid >= epctx -> nr_pstreams )
sctx = epctx -> pstreams + streamid;
if ( sctx -> sct == - 1 )
xhci_dma_read_u32s ( epctx -> xhci , sctx -> pctx , ctx , sizeof ( ctx ) );
static inline void xhci_dma_read_u32s(XHCIState *xhci, dma_addr_t
uint32_t *buf, size_t len)
assert ( ( len % sizeof ( uint32_t ) ) == 0 );
pci_dma_read ( PCI_DEVICE ( xhci ) , addr , buf , len );
for (i = 0; i < (len / sizeof(uint32_t)); i++)
buf [ i ] = le32_to_cpu ( buf [ i ] );
sctx -> sct = sct;
xhci_ring_init ( epctx -> xhci , & sctx -> ring , base );
static void xhci_ring_init(XHCIState *xhci, XHCIRing
dma_addr_t base)
ring -> dequeue = base;
ring -> ccs = 1;
return sctx ;
0
------------------------------
301161 152151/utils.c len = ( ( p - names > namelen ? p - names : namelen ) ) 279
static int init_input(AVFormatContext *s,const char *filename,AVDictionary **options)
if ( s -> pb )
s -> flags |= 0x80;
if ( ! s -> iformat )
return av_probe_input_buffer ( s -> pb , & s -> iformat , filename , s , 0 , s -> probesize ) ;
int av_probe_input_buffer(AVIOContext *pb,AVInputFormat **fmt,const char *filename,void *logctx,unsigned int offset,unsigned int max_probe_size)
uint8_t * mime_type ;
if ( ! max_probe_size )
max_probe_size = ( 1 << 20 );
if ( max_probe_size > ( 1 << 20 ) )
max_probe_size = ( 1 << 20 );
if ( max_probe_size < 2048 )
if ( offset >= max_probe_size )
if ( ! ( * fmt ) && pb -> av_class && av_opt_get ( pb , "mime_type" , 0x1 , & mime_type ) >= 0 && mime_type )
if ( ! av_strcasecmp ( mime_type , "audio/aacp" ) )
* fmt = av_find_input_format ( "aac" );
AVInputFormat *av_find_input_format(const char *short_name)
AVInputFormat * fmt = ( ( void * ) 0 ) ;
while ( fmt = av_iformat_next ( fmt ) )
if ( match_format ( short_name , fmt -> name ) )
static int match_format(const char *name,const char *names)
const char * p ;
int len ;
int namelen ;
if ( ! name || ! names )
namelen = ( strlen ( name ) );
while ( p = ( strchr ( names , ',' ) ) )
len = ( ( p - names > namelen ? p - names : namelen ) );
if ( ! av_strncasecmp ( name , names , len ) )
names = p + 1;
0
------------------------------
301712 151549/aviobuf.c s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_end - s -> checksum_ptr ) ) ) 490
unsigned int avio_rl24(AVIOContext *s)
unsigned int val ;
val = avio_rl16 ( s );
val |= ( avio_r8 ( s ) << 16 );
int avio_r8(AVIOContext *s)
if ( s -> buf_ptr >= s -> buf_end )
fill_buffer ( s );
static void fill_buffer(AVIOContext *s)
uint8_t * dst = ! s -> max_packet_size && s -> buf_end - s -> buffer < ( s -> buffer_size ) ? s -> buf_end : s -> buffer ;
if ( ! s -> read_packet && s -> buf_ptr >= s -> buf_end )
s -> eof_reached = 1;
if ( s -> eof_reached )
if ( s -> update_checksum && dst == s -> buffer )
if ( s -> buf_end > s -> checksum_ptr )
s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_end - s -> checksum_ptr ) ) );
s -> checksum_ptr = s -> buffer;
if ( s -> read_packet && s -> buffer_size > max_buffer_size )
ffio_set_buf_size ( s , max_buffer_size );
s -> checksum_ptr = dst = s -> buffer;
len = s -> buffer_size;
if ( s -> read_packet )
len = ( ( s -> read_packet ) ( s -> opaque , dst , len ) );
if ( len <= 0 )
s -> eof_reached = 1;
if ( len < 0 )
s -> error = len;
s -> pos += len;
s -> buf_ptr = dst;
s -> buf_end = dst + len;
s -> bytes_read += len;
0
------------------------------
308597 117355/CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_fscanf_64b.c myString = ( wchar_t * ) malloc ( data * sizeof ( wchar_t ) ) 41
void CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_fscanf_64_bad()
size_t data ;
data = 0;
CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_fscanf_64b_badSink ( & data );
void CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_fscanf_64b_badSink(void * dataVoidPtr)
size_t * dataPtr = ( size_t * ) dataVoidPtr ;
size_t data = ( * dataPtr ) ;
wchar_t * myString ;
if ( data > wcslen ( HELLO_STRING ) )
myString = ( wchar_t * ) malloc ( data * sizeof ( wchar_t ) );
wcscpy ( myString , HELLO_STRING );
printWLine ( myString );
void printWLine (const wchar_t * line)
if ( line != NULL )
wprintf ( L "%ls\n" , line )
free ( myString );
1
------------------------------
303335 80451/CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_10.c recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 329
static void goodB2G2()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
if ( globalTrue )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
goodB2G2VaSinkG ( data , data );
static void goodB2G2VaSinkG(char * data, ...)
va_start ( args , data );
0
------------------------------
303945 80780/CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_w32_vsnprintf_03.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 ) 203
static void goodB2G1()
wchar_t * data ;
wchar_t dataBuffer [ 100 ] = L ""
data = dataBuffer;
if ( 5 == 5 )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
304047 83944/CWE190_Integer_Overflow__short_fscanf_square_11.c short result = data * data ; 37
void CWE190_Integer_Overflow__short_fscanf_square_11_bad()
short data ;
data = 0;
if ( globalReturnsTrue ( ) )
int globalReturnsTrue()
return 1 ;
short result = data * data ;
printIntLine ( result );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
1
------------------------------
312626 149891/emem.c buf = ( free_list -> buf + free_list -> free_offset ) 558
static void *emem_alloc_chunk(size_t size,emem_header_t *mem)
void * buf ;
size_t asize = size ;
gboolean use_canary = mem -> debug_use_canary ;
guint8 pad ;
emem_chunk_t * free_list ;
if ( use_canary )
asize += sizeof ( void * );
pad = emem_canary_pad ( asize );
static guint8 emem_canary_pad(size_t allocation)
guint8 pad ;
pad = ( 8 - allocation % 8 );
if ( pad < 8 )
pad += 8;
return pad ;
pad = ( 8 - ( asize & ( 8 - 1 ) ) & ( 8 - 1 ) );
asize += pad;
if ( ! mem -> free_list )
mem -> free_list = emem_create_chunk_gp ( ( 10 * 1024 * 1024 ) );
static emem_chunk_t *emem_create_chunk_gp(size_t size)
emem_chunk_t * npc ;
npc = emem_create_chunk ( size );
static emem_chunk_t *emem_create_chunk(size_t size)
emem_chunk_t * npc ;
npc = ( ( emem_chunk_t * ) ( g_malloc_n ( 1 , sizeof ( emem_chunk_t ) ) ) );
npc -> next = ( ( void * ) 0 );
npc -> canary_last = ( ( void * ) 0 );
npc -> amount_free = npc -> amount_free_init = ( ( unsigned int ) size );
npc -> free_offset = npc -> free_offset_init = 0;
return npc ;
npc -> amount_free = npc -> amount_free_init;
npc -> free_offset = npc -> free_offset_init;
return npc ;
if ( asize > ( mem -> free_list -> amount_free ) )
emem_chunk_t * npc ;
npc = mem -> free_list;
mem -> free_list = mem -> free_list -> next;
npc -> next = mem -> used_list;
mem -> used_list = npc;
if ( ! mem -> free_list )
mem -> free_list = emem_create_chunk_gp ( ( 10 * 1024 * 1024 ) );
static emem_chunk_t *emem_create_chunk_gp(size_t size)
emem_chunk_t * npc ;
npc = emem_create_chunk ( size );
npc -> amount_free = npc -> amount_free_init;
npc -> free_offset = npc -> free_offset_init;
return npc ;
free_list = mem -> free_list;
buf = ( free_list -> buf + free_list -> free_offset );
char * cptr = ( ( char * ) buf ) + size ;
memcpy ( cptr , ( mem -> canary ) , ( pad - 1 ) );
cptr [ pad - 1 ] = '\0';
memcpy ( ( cptr + pad ) , ( & free_list -> canary_last ) , sizeof ( void * ) );
free_list -> canary_last = cptr;
return buf ;
0
------------------------------
312530 152495/oids.c * left = len - i 1161
const gchar *oid_resolved_from_encoded(const guint8 *oid,gint oid_len)
guint32 * subid_oid ;
guint subid_oid_length = oid_encoded2subid ( oid , oid_len , & subid_oid ) ;
guint oid_encoded2subid(const guint8 *oid_bytes,gint oid_len,guint32 **subids_p)
gint i ;
guint n = 1 ;
gboolean is_first = ! 0 ;
guint32 * subids ;
guint32 * subid_overflow ;
guint64 subid = 0 ;
for (i = 0; i < oid_len; i++)
if ( ! ( oid_bytes [ i ] & 0x0080 ) )
n ++;
* subids_p = subids = ( ep_alloc ( sizeof ( guint32 ) * n ) );
subid_overflow = subids + n;
for (i = 0; i < oid_len; i++)
guint8 byte = oid_bytes [ i ] ;
subid <<= 7;
subid |= ( byte & 0x7F );
if ( byte & 0x0080 )
if ( is_first )
guint32 subid0 = 0 ;
if ( subid >= 40 )
subid0 ++;
subid -= 40;
if ( subid >= 40 )
subid0 ++;
subid -= 40;
* ( subids ++ ) = subid0;
is_first = 0;
if ( subids >= subid_overflow || subid > 0xffffffff )
return 0 ;
* ( subids ++ ) = ( ( guint32 ) subid );
subid = 0;
return n ;
return oid_resolved ( subid_oid_length , subid_oid ) ;
const gchar *oid_resolved(guint32 num_subids,guint32 *subids)
oid_info_t * oid ;
if ( ! ( subids && * subids <= 2 ) )
oid = oid_get ( num_subids , subids , & matched , & left );
oid_info_t *oid_get(guint len,guint32 *subids,guint *matched,guint *left)
oid_info_t * curr_oid = & oid_root ;
guint i ;
if ( ! ( subids && * subids <= 2 ) )
for (i = 0; i < len; i++)
oid_info_t * next_oid = ( emem_tree_lookup32 ( ( curr_oid -> children ) , subids [ i ] ) ) ;
if ( next_oid )
curr_oid = next_oid;
* left = len - i;
0
------------------------------
303053 80584/CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_fprintf_83_goodB2G.cpp recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 ) 84
CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_fprintf_83_goodB2G::CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_fprintf_83_goodB2G(wchar_t * dataCopy)
data = dataCopy;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
301171 152151/utils.c duration = ( duration > end_time - start_time ? duration : end_time - start_time ) 2388
static void estimate_timings(AVFormatContext *ic,int64_t old_offset)
int64_t file_size ;
if ( ic -> iformat -> flags & 0x1 )
file_size = 0;
file_size = avio_size ( ic -> pb );
file_size = ( 0 > file_size ? 0 : file_size );
if ( ( ! strcmp ( ic -> iformat -> name , "mpeg" ) || ! strcmp ( ic -> iformat -> name , "mpegts" ) ) && file_size && ic -> pb -> seekable )
estimate_timings_from_pts ( ic , old_offset );
static void estimate_timings_from_pts(AVFormatContext *ic,int64_t old_offset)
fill_all_stream_timings ( ic );
static void fill_all_stream_timings(AVFormatContext *ic)
update_stream_timings ( ic );
static void update_stream_timings(AVFormatContext *ic)
int64_t start_time ;
int64_t start_time1 ;
int64_t start_time_text ;
int64_t end_time ;
int64_t end_time1 ;
int64_t duration ;
int64_t duration1 ;
int i ;
AVStream * st ;
start_time = 9223372036854775807L;
start_time_text = 9223372036854775807L;
end_time = - 9223372036854775807L - 1;
duration = - 9223372036854775807L - 1;
for (i = 0; i < ic -> nb_streams; i++)
st = ic -> streams [ i ];
if ( st -> start_time != ( ( int64_t ) 0x8000000000000000UL ) && st -> time_base . den )
start_time1 = av_rescale_q ( st -> start_time , st -> time_base , ( ( AVRational ) ( 1 ) , ( 1000000 ) ) )
if ( ( st -> codec -> codec_type ) == AVMEDIA_TYPE_SUBTITLE || ( st -> codec -> codec_type ) == AVMEDIA_TYPE_DATA )
if ( start_time1 < start_time_text )
start_time_text = start_time1;
start_time = ( start_time > start_time1 ? start_time1 : start_time );
end_time1 = ( ( int64_t ) 0x8000000000000000UL );
if ( st -> duration != ( ( int64_t ) 0x8000000000000000UL ) )
end_time1 = start_time1 + av_rescale_q ( st -> duration , st -> time_base , ( ( AVRational ) ( 1 ) , ( 1000000 ) ) )
end_time = ( end_time > end_time1 ? end_time : end_time1 );
if ( st -> duration != ( ( int64_t ) 0x8000000000000000UL ) )
duration1 = av_rescale_q ( st -> duration , st -> time_base , ( ( AVRational ) ( 1 ) , ( 1000000 ) ) )
duration = ( duration > duration1 ? duration : duration1 );
if ( start_time == 9223372036854775807L || start_time > start_time_text && start_time - start_time_text < 1000000 )
start_time = start_time_text;
if ( start_time != 9223372036854775807L )
ic -> start_time = start_time;
if ( end_time != - 9223372036854775807L - 1 )
if ( ic -> nb_programs )
duration = ( duration > end_time - start_time ? duration : end_time - start_time );
if ( duration != - 9223372036854775807L - 1 && duration > 0 && ic -> duration == ( ( int64_t ) 0x8000000000000000UL ) )
ic -> duration = duration;
if ( ic -> pb && ( filesize = avio_size ( ic -> pb ) ) > 0 && ic -> duration != ( ( int64_t ) 0x8000000000000000UL ) )
double bitrate = ( ( double ) filesize ) * 8.0 * 1000000 / ( ( double ) ( ic -> duration ) ) ;
if ( bitrate >= 0 && bitrate <= 2147483647 )
ic -> bit_rate = bitrate;
0
------------------------------
302112 151542/heapam.c rdata [ 3 ] . len = ( nunused * sizeof ( OffsetNumber ) ) 3924
XLogRecPtr log_heap_clean(Relation reln,Buffer buffer,OffsetNumber *redirected,int nredirected,OffsetNumber *nowdead,int ndead,OffsetNumber *nowunused,int nunused,TransactionId latestRemovedXid)
xl_heap_clean xlrec ;
XLogRecData rdata [ 4 ] ;
xlrec . node = reln -> rd_node;
xlrec . block = BufferGetBlockNumber ( buffer );
xlrec . latestRemovedXid = latestRemovedXid;
xlrec . nredirected = nredirected;
xlrec . ndead = ndead;
rdata [ 0 ] . data = ( ( char * ) ( & xlrec ) );
rdata [ 0 ] . len = ( ( ( size_t ) ( & ( ( xl_heap_clean * ) 0 ) -> ndead ) ) + sizeof ( uint16 ) );
rdata [ 0 ] . buffer = 0;
rdata [ 0 ] . next = & rdata [ 1 ];
if ( nredirected > 0 )
rdata [ 1 ] . data = ( ( char * ) redirected );
rdata [ 1 ] . len = ( nredirected * sizeof ( OffsetNumber ) * 2 );
rdata [ 1 ] . data = ( ( void * ) 0 );
rdata [ 1 ] . len = 0;
rdata [ 1 ] . buffer = buffer;
rdata [ 1 ] . buffer_std = ( ( bool ) 1 );
rdata [ 1 ] . next = & rdata [ 2 ];
if ( ndead > 0 )
rdata [ 2 ] . data = ( ( char * ) nowdead );
rdata [ 2 ] . len = ( ndead * sizeof ( OffsetNumber ) );
rdata [ 2 ] . data = ( ( void * ) 0 );
rdata [ 2 ] . len = 0;
rdata [ 2 ] . buffer = buffer;
rdata [ 2 ] . buffer_std = ( ( bool ) 1 );
rdata [ 2 ] . next = & rdata [ 3 ];
if ( nunused > 0 )
rdata [ 3 ] . data = ( ( char * ) nowunused );
rdata [ 3 ] . len = ( nunused * sizeof ( OffsetNumber ) );
rdata [ 3 ] . buffer = buffer;
rdata [ 3 ] . buffer_std = ( ( bool ) 1 );
rdata [ 3 ] . next = ( ( void * ) 0 );
recptr = XLogInsert ( 9 , info , rdata );
return recptr ;
0
------------------------------
21455 CVE-2015-0811/Firefox_36.0b9_CVE_2015_0811_gfx_qcms_iccread.c read_length = fread ( ( unsigned char * ) data + sizeof ( length_be ) , 1 , remaining_length , file ) 1198
qcms_profile* qcms_profile_from_path(const char *path)
FILE * file = fopen ( path , "rb" ) ;
if ( file )
profile = qcms_profile_from_file ( file );
qcms_profile* qcms_profile_from_file(FILE *file)
size_t length ;
void * data ;
qcms_data_from_file ( file , & data , & length );
static void qcms_data_from_file(FILE *file, void **mem, size_t *size)
uint32_t length , remaining_length ;
size_t read_length ;
be32 length_be ;
void * data ;
if ( fread ( & length_be , 1 , sizeof ( length_be ) , file ) != sizeof ( length_be ) )
length = be32_to_cpu ( length_be );
if ( length > MAX_PROFILE_SIZE || length < sizeof ( length_be ) )
data = malloc ( length );
if ( ! data )
* ( ( be32 * ) data ) = length_be;
remaining_length = length - sizeof ( length_be );
read_length = fread ( ( unsigned char * ) data + sizeof ( length_be ) , 1 , remaining_length , file );
if ( read_length != remaining_length )
0
------------------------------
302113 151542/heapam.c rdata [ 2 ] . len = ( ndead * sizeof ( OffsetNumber ) ) 3913
XLogRecPtr log_heap_clean(Relation reln,Buffer buffer,OffsetNumber *redirected,int nredirected,OffsetNumber *nowdead,int ndead,OffsetNumber *nowunused,int nunused,TransactionId latestRemovedXid)
xl_heap_clean xlrec ;
XLogRecData rdata [ 4 ] ;
xlrec . node = reln -> rd_node;
xlrec . block = BufferGetBlockNumber ( buffer );
xlrec . latestRemovedXid = latestRemovedXid;
xlrec . nredirected = nredirected;
xlrec . ndead = ndead;
rdata [ 0 ] . data = ( ( char * ) ( & xlrec ) );
rdata [ 0 ] . len = ( ( ( size_t ) ( & ( ( xl_heap_clean * ) 0 ) -> ndead ) ) + sizeof ( uint16 ) );
rdata [ 0 ] . buffer = 0;
rdata [ 0 ] . next = & rdata [ 1 ];
if ( nredirected > 0 )
rdata [ 1 ] . data = ( ( char * ) redirected );
rdata [ 1 ] . len = ( nredirected * sizeof ( OffsetNumber ) * 2 );
rdata [ 1 ] . data = ( ( void * ) 0 );
rdata [ 1 ] . len = 0;
rdata [ 1 ] . buffer = buffer;
rdata [ 1 ] . buffer_std = ( ( bool ) 1 );
rdata [ 1 ] . next = & rdata [ 2 ];
if ( ndead > 0 )
rdata [ 2 ] . data = ( ( char * ) nowdead );
rdata [ 2 ] . len = ( ndead * sizeof ( OffsetNumber ) );
rdata [ 2 ] . buffer = buffer;
rdata [ 2 ] . buffer_std = ( ( bool ) 1 );
rdata [ 2 ] . next = & rdata [ 3 ];
rdata [ 3 ] . data = ( ( char * ) nowunused );
rdata [ 3 ] . len = ( nunused * sizeof ( OffsetNumber ) );
rdata [ 3 ] . data = ( ( void * ) 0 );
rdata [ 3 ] . len = 0;
rdata [ 3 ] . buffer = buffer;
rdata [ 3 ] . buffer_std = ( ( bool ) 1 );
rdata [ 3 ] . next = ( ( void * ) 0 );
recptr = XLogInsert ( 9 , info , rdata );
return recptr ;
0
------------------------------
20416 CVE-2016-8909/qemu_2.3.0_CVE-2016-8909_intel-hda.c st = st + s 398
static bool intel_hda_xfer(HDACodecDevice *dev, uint32_t stnr, bool
uint8_t *buf, uint32_t len)
HDACodecBus * bus = DO_UPCAST ( HDACodecBus , qbus , dev -> qdev . parent_bus ) ;
IntelHDAState * d = container_of ( bus , IntelHDAState , codecs ) ;
uint32_t s , copy , left ;
IntelHDAStream * st ;
st = output ? d -> st + 4 : d -> st;
for (s = 0; s < 4; s++)
if ( stnr == ( ( st [ s ] . ctl >> 20 ) & 0x0f ) )
st = st + s;
if ( st -> bpl == NULL )
if ( st -> ctl & ( 1 << 26 ) )
while ( left > 0 )
copy = left;
if ( copy > st -> bsize - st -> lpib )
copy = st -> bsize - st -> lpib;
if ( copy > st -> bpl [ st -> be ] . len - st -> bp )
copy = st -> bpl [ st -> be ] . len - st -> bp;
dprint ( d , 3 , "dma: entry %d, pos %d/%d, copy %d\n" , st -> be , st -> bp , st -> bpl [ st -> be ] . len , copy );
pci_dma_rw ( & d -> pci , st -> bpl [ st -> be ] . addr + st -> bp , buf , copy , ! output );
st -> lpib += copy;
st -> bp += copy;
buf += copy;
left -= copy;
if ( st -> bpl [ st -> be ] . len == st -> bp )
if ( st -> bpl [ st -> be ] . flags & 0x01 )
st -> bp = 0;
st -> be ++;
if ( st -> be == st -> bentries )
st -> be = 0;
st -> lpib = 0;
s = st - d -> st;
stl_le_pci_dma ( & d -> pci , addr + 8 * s , st -> lpib );
st -> ctl |= ( 1 << 26 );
0
------------------------------
312477 152246/cmdutils.c uint8_t * tmp = ( av_realloc ( array , ( new_size * elem_size ) ) ) ; 2038
int split_commandline(OptionParseContext *octx,int argc,char *argv[],const OptionDef *options,const OptionGroupDef *groups,int nb_groups)
int optindex = 1 ;
int dashdash = - 2 ;
while ( optindex < argc )
const char * opt = argv [ optindex ++ ] ;
const char * arg ;
const OptionDef * po ;
int ret ;
if ( opt [ 0 ] == '-' && opt [ 1 ] == '-' && ! opt [ 2 ] )
dashdash = optindex;
if ( opt [ 0 ] != '-' || ! opt [ 1 ] || dashdash + 1 == optindex )
opt ++;
while ( 0 )
if ( ( ret = match_group_separator ( groups , nb_groups , opt ) ) >= 0 )
arg = argv [ optindex ++ ];
if ( ! arg )
while ( 0 )
finish_group ( octx , ret , arg );
po = find_option ( options , opt );
if ( po -> name )
if ( po -> flags & 0x0800 )
arg = argv [ optindex ++ ];
if ( po -> flags & 0x0001 )
arg = argv [ optindex ++ ];
if ( ! arg )
while ( 0 )
if ( argv [ optindex ] )
ret = opt_default ( ( ( void * ) 0 ) , opt , argv [ optindex ] );
if ( ret >= 0 )
optindex ++;
if ( ret != - ( ( int ) ( ( 0xF8 | 'O' << 8 | 'P' << 16 ) | ( ( unsigned int ) 'T' ) << 24 ) ) )
if ( opt [ 0 ] == 'n' && opt [ 1 ] == 'o' && ( po = find_option ( options , opt + 2 ) ) && po -> name && po -> flags & 0x00002 )
static void finish_group(OptionParseContext *octx,int group_idx,const char *arg)
OptionGroupList * l = & octx -> groups [ group_idx ] ;
l -> groups = ( grow_array ( ( l -> groups ) , ( sizeof ( ( * l -> groups ) ) ) , & l -> nb_groups , l -> nb_groups + 1 ) );
void *grow_array(void *array,int elem_size,int *size,int new_size)
if ( * size < new_size )
uint8_t * tmp = ( av_realloc ( array , ( new_size * elem_size ) ) ) ;
if ( ! tmp )
memset ( ( tmp + * size * elem_size ) , 0 , ( ( new_size - * size ) * elem_size ) );
return tmp ;
0
------------------------------
18465 CVE-2015-2716/Firefox_37.0b7_CVE_2015_2716_parser_expat_lib_xmlparse.c tsize = table -> size * sizeof ( NAMED * ) 6000
XML_Parser
XML_ParserCreateNS(const XML_Char *encodingName, XML_Char nsSep)
XML_Char tmp [ 2 ] ;
* tmp = nsSep;
return XML_ParserCreate_MM ( encodingName , NULL , tmp ) ;
XML_Parser
XML_ParserCreate_MM(const XML_Char
const XML_Memory_Handling_Suite
const XML_Char *nameSep)
XML_Parser parser = parserCreate ( encodingName , memsuite , nameSep , NULL ) ;
static
parserCreate(const XML_Char
const XML_Memory_Handling_Suite
const XML_Char
DTD *dtd)
XML_Parser parser ;
if ( memsuite )
parser = ( XML_Parser ) memsuite -> malloc_fcn ( sizeof ( struct XML_ParserStruct ) );
parser = ( XML_Parser ) malloc ( sizeof ( struct XML_ParserStruct ) );
if ( ! parser )
return parser ;
attsSize = INIT_ATTS_SIZE;
atts = ( ATTRIBUTE * ) MALLOC ( attsSize * sizeof ( ATTRIBUTE ) );
if ( atts == NULL )
return NULL ;
dataBuf = ( XML_Char * ) MALLOC ( INIT_DATA_BUF_SIZE * sizeof ( XML_Char ) );
if ( dataBuf == NULL )
return NULL ;
if ( dtd )
_dtd = dtdCreate ( & parser -> m_mem );
if ( _dtd == NULL )
return NULL ;
if ( encodingName && ! protocolEncodingName )
return NULL ;
return parser ;
if ( parser != NULL && ns )
if ( ! setContext ( parser , implicitContext ) )
static
setContext(XML_Parser parser, const XML_Char *context)
DTD * const dtd = _dtd
const XML_Char * s = context ;
while ( * context != XML_T ( '\0' ) )
if ( * s == CONTEXT_SEP || * s == XML_T ( '\0' ) )
ENTITY * e ;
if ( ! poolAppendChar ( & tempPool , XML_T ( '\0' ) ) )
e = ( ENTITY * ) lookup ( & dtd -> generalEntities , poolStart ( & tempPool ) , 0 );
if ( * s != XML_T ( '\0' ) )
s ++;
context = s;
if ( * s == XML_T ( '=' ) )
PREFIX * prefix ;
if ( poolLength ( & tempPool ) == 0 )
prefix = & dtd -> defaultPrefix;
if ( ! poolAppendChar ( & tempPool , XML_T ( '\0' ) ) )
prefix = ( PREFIX * ) lookup ( & dtd -> prefixes , poolStart ( & tempPool ) , sizeof ( PREFIX ) );
if ( ! prefix )
if ( prefix -> name == poolStart ( & tempPool ) )
prefix -> name = poolCopyString ( & dtd -> pool , prefix -> name );
if ( ! prefix -> name )
for (context = s +
*context != CONTEXT_SEP && *context !=
context++)
if ( ! poolAppendChar ( & tempPool , * context ) )
if ( ! poolAppendChar ( & tempPool , XML_T ( '\0' ) ) )
if ( addBinding ( parser , prefix , NULL , poolStart ( & tempPool ) , & inheritedBindings ) != XML_ERROR_NONE )
s = context;
if ( ! poolAppendChar ( & tempPool , * s ) )
s ++;
static NAMED
lookup(HASH_TABLE *table, KEY name, size_t createSize)
if ( table -> size == 0 )
size_t tsize ;
if ( ! createSize )
table -> power = INIT_POWER;
table -> size = ( size_t ) 1 << INIT_POWER;
tsize = table -> size * sizeof ( NAMED * );
table -> v = ( NAMED * * ) table -> mem -> malloc_fcn ( tsize );
if ( ! table -> v )
table -> size = 0;
memset ( table -> v , 0 , tsize );
i = hash ( name ) & ( ( unsigned long ) table -> size - 1 );
table -> v [ i ] = ( NAMED * ) table -> mem -> malloc_fcn ( createSize );
if ( ! table -> v [ i ] )
memset ( table -> v [ i ] , 0 , createSize );
table -> v [ i ] -> name = name;
( table -> used ) ++;
return table -> v [ i ] ;
0
------------------------------
310294 151639/aviobuf.c s -> buf_end = dst + len 494
int avio_get_str(AVIOContext *s,int maxlen,char *buf,int buflen)
int i ;
if ( buflen <= 0 )
buflen = ( buflen - 1 > maxlen ? maxlen : buflen - 1 );
for (i = 0; i < buflen; i++)
if ( ! ( buf [ i ] = ( avio_r8 ( s ) ) ) )
buf [ i ] = 0;
for (; i < maxlen; i++)
if ( ! avio_r8 ( s ) )
int avio_r8(AVIOContext *s)
if ( s -> buf_ptr >= s -> buf_end )
fill_buffer ( s );
static void fill_buffer(AVIOContext *s)
uint8_t * dst = ! s -> max_packet_size && s -> buf_end - s -> buffer < ( s -> buffer_size ) ? s -> buf_end : s -> buffer ;
int len = ( ( s -> buffer_size ) - ( dst - s -> buffer ) ) ;
int max_buffer_size = s -> max_packet_size ? s -> max_packet_size : 32768 ;
if ( ! s -> read_packet && s -> buf_ptr >= s -> buf_end )
s -> eof_reached = 1;
if ( s -> eof_reached )
if ( s -> update_checksum && dst == s -> buffer )
if ( s -> buf_end > s -> checksum_ptr )
s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_end - s -> checksum_ptr ) ) );
s -> checksum_ptr = s -> buffer;
if ( s -> read_packet && s -> buffer_size > max_buffer_size )
s -> checksum_ptr = dst = s -> buffer;
len = s -> buffer_size;
if ( s -> read_packet )
len = ( ( s -> read_packet ) ( s -> opaque , dst , len ) );
len = 0;
if ( len <= 0 )
s -> eof_reached = 1;
if ( len < 0 )
s -> error = len;
s -> pos += len;
s -> buf_ptr = dst;
s -> buf_end = dst + len;
s -> bytes_read += len;
0
------------------------------
309517 153616/mux.c int64_t syncto = ( ( av_rescale ( pkt -> dts + syncoffset , 1 , max ) ) * max - syncoffset ) ; 666
int av_write_trailer(AVFormatContext *s)
int ret ;
ret = interleave_packet ( s , & pkt , ( ( void * ) 0 ) , 1 );
if ( ret < 0 )
if ( ! ret )
ret = split_write_packet ( s , & pkt );
inline static int split_write_packet(AVFormatContext *s,AVPacket *pkt)
int ret ;
ret = ( ( s -> oformat -> write_packet ) ( s , pkt ) );
return ret ;
if ( ret < 0 )
if ( s -> pb && s -> pb -> error )
static int interleave_packet(AVFormatContext *s,AVPacket *out,AVPacket *in,int flush)
if ( s -> oformat -> interleave_packet )
return ff_interleave_packet_per_dts ( s , out , in , flush ) ;
int ff_interleave_packet_per_dts(AVFormatContext *s,AVPacket *out,AVPacket *pkt,int flush)
int ret ;
if ( pkt )
ret = ff_interleave_add_packet ( s , pkt , ff_interleave_compare_dts );
int ff_interleave_add_packet(AVFormatContext *s,AVPacket *pkt,int (*compare)(AVFormatContext *, AVPacket *, AVPacket *))
AVPacketList * this_pktl ;
AVStream * st = s -> streams [ pkt -> stream_index ] ;
int chunked = s -> max_chunk_size || s -> max_chunk_duration ;
this_pktl = ( av_mallocz ( sizeof ( AVPacketList ) ) );
if ( ! this_pktl )
pkt -> destruct = ( ( void * ) 0 );
if ( chunked )
uint64_t max = ( av_rescale_q_rnd ( ( s -> max_chunk_duration ) , ( ( AVRational ) ( 1 ) , ( 1000000 ) ) , st -> time_base , AV_ROUND_UP ) )
st -> interleaver_chunk_size += ( pkt -> size );
st -> interleaver_chunk_duration += ( pkt -> duration );
if ( s -> max_chunk_size && st -> interleaver_chunk_size > ( s -> max_chunk_size ) || max && ( st -> interleaver_chunk_duration ) > max )
st -> interleaver_chunk_size = 0;
if ( max && ( st -> interleaver_chunk_duration ) > max )
int64_t syncoffset = ( ( ( st -> codec -> codec_type ) == AVMEDIA_TYPE_VIDEO ) * max / 2 ) ;
int64_t syncto = ( ( av_rescale ( pkt -> dts + syncoffset , 1 , max ) ) * max - syncoffset ) ;
st -> interleaver_chunk_duration += ( ( pkt -> dts - syncto ) / 8 ) - max;
0
------------------------------
306541 120093/CWE78_OS_Command_Injection__char_listen_socket_w32_execv_66a.c recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 114
void CWE78_OS_Command_Injection__char_listen_socket_w32_execv_66_bad()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
dataArray [ 2 ] = data;
CWE78_OS_Command_Injection__char_listen_socket_w32_execv_66b_badSink ( dataArray );
void CWE78_OS_Command_Injection__char_listen_socket_w32_execv_66b_badSink(char * dataArray[])
char * data = dataArray [ 2 ] ;
0
------------------------------
309837 153391/ffmpeg.c int ist_index = input_files [ ist -> file_index ] -> ist_index + ist -> st -> index ; 1394
static int process_input(int file_index)
InputFile * ifile = input_files [ file_index ] ;
InputStream * ist ;
int ret ;
int i ;
ret = get_input_packet ( ifile , & pkt );
if ( ret == - 11 )
if ( ret < 0 )
ifile -> eof_reached = 1;
for (i = 0; i < ifile -> nb_streams; i++)
ist = input_streams [ ifile -> ist_index + i ];
if ( ist -> decoding_needed )
output_packet ( ist , ( ( void * ) 0 ) );
static int output_packet(InputStream *ist,const AVPacket *pkt)
int got_output ;
AVPacket avpkt ;
if ( ! ist -> saw_first_ts )
ist -> dts = ( ( ist -> st -> avg_frame_rate . num ? ( - ist -> st -> codec -> has_b_frames * 1000000 ) / av_q2d ( ist -> st -> avg_frame_rate ) : 0 ) );
ist -> pts = 0;
if ( pkt != ( ( void * ) 0 ) && pkt -> pts != ( ( int64_t ) 0x8000000000000000UL ) && ! ist -> decoding_needed )
ist -> pts = ist -> dts;
ist -> saw_first_ts = 1;
if ( ist -> next_dts == ( ( int64_t ) 0x8000000000000000UL ) )
ist -> next_dts = ist -> dts;
if ( ist -> next_pts == ( ( int64_t ) 0x8000000000000000UL ) )
ist -> next_pts = ist -> pts;
if ( pkt == ( ( void * ) 0 ) )
avpkt . data = ( ( void * ) 0 );
avpkt . size = 0;
avpkt = * pkt;
if ( pkt -> dts != ( ( int64_t ) 0x8000000000000000UL ) )
ist -> next_dts = ist -> dts = av_rescale_q ( pkt -> dts , ist -> st -> time_base , ( ( AVRational ) ( 1 ) , ( 1000000 ) ) )
if ( ( ist -> st -> codec -> codec_type ) != AVMEDIA_TYPE_VIDEO || ! ist -> decoding_needed )
ist -> next_pts = ist -> pts = ist -> dts;
while ( ist -> decoding_needed && ( avpkt . size > 0 || ! pkt && got_output ) )
int duration ;
ist -> pts = ist -> next_pts;
ist -> dts = ist -> next_dts;
if ( avpkt . size && avpkt . size != pkt -> size )
ist -> showed_multi_packet_warning = 1;
switch ( ist -> st -> codec -> codec_type )
ret = decode_audio ( ist , & avpkt , & got_output );
ret = decode_video ( ist , & avpkt , & got_output );
if ( avpkt . duration )
duration = ( av_rescale_q ( avpkt . duration , ist -> st -> time_base , ( ( AVRational ) ( 1 ) , ( 1000000 ) ) ) )
if ( ist -> st -> codec -> time_base . num != 0 && ist -> st -> codec -> time_base . den != 0 )
int ticks = ist -> st -> parser ? ist -> st -> parser -> repeat_pict + 1 : ist -> st -> codec -> ticks_per_frame ;
duration = ( ( ( int64_t ) 1000000 ) * ist -> st -> codec -> time_base . num * ticks / ist -> st -> codec -> time_base . den );
duration = 0;
if ( ist -> dts != ( ( int64_t ) 0x8000000000000000UL ) && duration )
ist -> next_dts += duration;
ist -> next_dts = ( ( int64_t ) 0x8000000000000000UL );
if ( got_output )
ist -> next_pts += duration;
ret = transcode_subtitles ( ist , & avpkt , & got_output );
if ( ret < 0 )
avpkt . dts = avpkt . pts = ( ( int64_t ) 0x8000000000000000UL );
if ( pkt )
if ( ( ist -> st -> codec -> codec_type ) != AVMEDIA_TYPE_AUDIO )
ret = avpkt . size;
avpkt . data += ret;
avpkt . size -= ret;
static int transcode_subtitles(InputStream *ist,AVPacket *pkt,int *got_output)
AVSubtitle subtitle ;
int i ;
int ret = avcodec_decode_subtitle2 ( ist -> st -> codec , & subtitle , got_output , pkt ) ;
if ( ret < 0 || ! ( * got_output ) )
if ( ist -> fix_sub_duration )
if ( ist -> prev_sub . got_output )
int end = ( av_rescale ( subtitle . pts - ist -> prev_sub . subtitle . pts , 1000 , 1000000 ) ) ;
if ( end < ist -> prev_sub . subtitle . end_display_time )
ist -> prev_sub . subtitle . end_display_time = end;
int SWAP_tmp = ist -> prev_sub . got_output ;
ist -> prev_sub . got_output = * got_output;
* got_output = SWAP_tmp;
while ( 0 )
int SWAP_tmp = ist -> prev_sub . ret ;
ist -> prev_sub . ret = ret;
ret = SWAP_tmp;
while ( 0 )
AVSubtitle SWAP_tmp = ist -> prev_sub . subtitle ;
ist -> prev_sub . subtitle = subtitle;
subtitle = SWAP_tmp;
while ( 0 )
if ( ! ( * got_output ) || ! subtitle . num_rects )
for (i = 0; i < nb_output_streams; i++)
OutputStream * ost = output_streams [ i ] ;
if ( ! check_output_constraints ( ist , ost ) || ! ost -> encoding_needed )
static int check_output_constraints(InputStream *ist,OutputStream *ost)
int ist_index = input_files [ ist -> file_index ] -> ist_index + ist -> st -> index ;
if ( ost -> source_index != ist_index )
0
------------------------------
301039 153289/aviobuf.c s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_ptr - s -> checksum_ptr ) ) ) 202
void avio_wl64(AVIOContext *s,uint64_t val)
avio_wl32 ( s , ( ( uint32_t ) ( val >> 32 ) ) );
void avio_wl32(AVIOContext *s,unsigned int val)
avio_w8 ( s , ( ( uint8_t ) ( val >> 16 ) ) );
void avio_w8(AVIOContext *s,int b)
* ( s -> buf_ptr ++ ) = b;
if ( s -> buf_ptr >= s -> buf_end )
flush_buffer ( s );
static void flush_buffer(AVIOContext *s)
if ( s -> buf_ptr > s -> buffer )
if ( s -> update_checksum )
s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_ptr - s -> checksum_ptr ) ) );
s -> checksum_ptr = s -> buffer;
s -> buf_ptr = s -> buffer;
0
------------------------------
298071 95095/CWE369_Divide_by_Zero__int_fgets_divide_65b.c printIntLine ( 100 / data ) 38
void CWE369_Divide_by_Zero__int_fgets_divide_65b_goodG2BSink(int data)
printIntLine ( 100 / data );
0
------------------------------
310879 151097/aviobuf.c int len = ( ( s -> buffer_size ) - ( dst - s -> buffer ) ) ; 443
unsigned int avio_rl32(AVIOContext *s)
unsigned int val ;
val = avio_rl16 ( s );
val |= avio_rl16 ( s ) << 16;
unsigned int avio_rl16(AVIOContext *s)
unsigned int val ;
val = ( avio_r8 ( s ) );
int avio_r8(AVIOContext *s)
if ( s -> buf_ptr >= s -> buf_end )
fill_buffer ( s );
static void fill_buffer(AVIOContext *s)
uint8_t * dst = ! s -> max_packet_size && s -> buf_end - s -> buffer < ( s -> buffer_size ) ? s -> buf_end : s -> buffer ;
int len = ( ( s -> buffer_size ) - ( dst - s -> buffer ) ) ;
len = ( ( s -> read_packet ) ( s -> opaque , dst , len ) );
if ( len <= 0 )
if ( len < 0 )
s -> error = len;
s -> pos += len;
s -> buf_ptr = dst;
s -> buf_end = dst + len;
s -> bytes_read += len;
0
------------------------------
18973 CVE-2015-2716/Firefox_37.0b7_CVE_2015_2716_parser_expat_lib_xmlparse.c int blockSize = ( int ) ( pool -> end - pool -> start ) ; 6270
static enum XML_Error
entityValueInitProcessor(XML_Parser
const char
const char
const char **nextPtr)
int tok ;
const char * start = s ;
const char * next = start ;
tok = XmlPrologTok ( encoding , start , end , & next );
if ( tok <= 0 )
if ( tok == XML_TOK_XML_DECL )
enum XML_Error result ;
result = processXmlDecl ( parser , 0 , start , next );
if ( tok == XML_TOK_BOM && next == end && ! ps_finalBuffer )
start = next;
static enum
processXmlDecl(XML_Parser parser, int
const char *s, const char *next)
const char * encodingName = NULL ;
const char * versionend ;
if ( ! ( ns ? XmlParseXmlDeclNS : XmlParseXmlDecl ) ( isGeneralTextEntity , encoding , s , next , & eventPtr , & version , & versionend , & encodingName , & newEncoding , & standalone ) )
if ( xmlDeclHandler )
if ( encodingName != NULL )
storedEncName = poolStoreString ( & temp2Pool , encoding , encodingName , encodingName + XmlNameLength ( encoding , encodingName ) );
static XML_Char
poolStoreString(STRING_POOL *pool, const ENCODING
const char *ptr, const char *end)
if ( ! poolAppend ( pool , enc , ptr , end ) )
if ( pool -> ptr == pool -> end && ! poolGrow ( pool ) )
static XML_Bool
poolGrow(STRING_POOL *pool)
if ( pool -> freeBlocks )
if ( pool -> start == 0 )
if ( pool -> end - pool -> start < pool -> freeBlocks -> size )
if ( pool -> blocks && pool -> start == pool -> blocks -> s )
int blockSize = ( int ) ( pool -> end - pool -> start ) ;
if ( blockSize < INIT_BLOCK_SIZE )
blockSize *= 2;
tem = ( BLOCK * ) pool -> mem -> malloc_fcn ( offsetof ( BLOCK , s ) + blockSize * sizeof ( XML_Char ) );
if ( ! tem )
tem -> size = blockSize;
tem -> next = pool -> blocks;
pool -> blocks = tem;
if ( pool -> ptr != pool -> start )
memcpy ( tem -> s , pool -> start , ( pool -> ptr - pool -> start ) * sizeof ( XML_Char ) );
pool -> ptr = tem -> s + ( pool -> ptr - pool -> start );
pool -> start = tem -> s;
pool -> end = tem -> s + blockSize;
0
------------------------------
311821 150647/resowner.c owner -> buffers = ( ( Buffer * ) ( MemoryContextAlloc ( TopMemoryContext , newmax * sizeof ( Buffer ) ) ) ) 668
void ResourceOwnerEnlargeBuffers(ResourceOwner owner)
int newmax ;
if ( owner == ( ( void * ) 0 ) || owner -> nbuffers < owner -> maxbuffers )
if ( owner -> buffers == ( ( void * ) 0 ) )
newmax = 16;
owner -> buffers = ( ( Buffer * ) ( MemoryContextAlloc ( TopMemoryContext , newmax * sizeof ( Buffer ) ) ) );
owner -> maxbuffers = newmax;
newmax = owner -> maxbuffers * 2;
owner -> buffers = ( ( Buffer * ) ( repalloc ( ( owner -> buffers ) , newmax * sizeof ( Buffer ) ) ) );
owner -> maxbuffers = newmax;
0
------------------------------
19737 CVE-2016-2522/Wireshark_2.0.1_CVE_2016_2522_epan_dissectors_packet-ber.c end_offset = offset + len 1578
static
try_dissect_unknown_ber(packet_info *pinfo, tvbuff_t *tvb, volatile int offset, proto_tree *tree, gint nest_level)
int start_offset ;
gint8 ber_class ;
gboolean pc , ind ;
gint32 tag ;
guint32 len ;
start_offset = offset;
offset = get_ber_identifier ( tvb , offset , & ber_class , & pc , & tag );
offset = get_ber_length ( tvb , offset , & len , & ind );
if ( len > ( guint32 ) tvb_reported_length_remaining ( tvb , offset ) )
switch ( pc )
switch ( ber_class )
switch ( tag )
offset = dissect_ber_integer ( FALSE , & asn1_ctx , tree , tvb , start_offset , hf_ber_unknown_INTEGER , NULL );
offset = dissect_ber_real ( FALSE , & asn1_ctx , tree , tvb , start_offset , hf_ber_unknown_REAL , NULL );
offset = dissect_ber_bitstring ( FALSE , & asn1_ctx , tree , tvb , start_offset , NULL , hf_ber_unknown_BITSTRING , - 1 , NULL );
offset = dissect_ber_integer ( FALSE , & asn1_ctx , tree , tvb , start_offset , hf_ber_unknown_ENUMERATED , NULL );
offset = dissect_ber_octet_string ( FALSE , & asn1_ctx , tree , tvb , start_offset , hf_ber_unknown_GraphicString , NULL );
if ( decode_octetstring_as_ber && ( len >= 2 ) )
guint32 ber_len = 0 ;
ber_offset = get_ber_identifier ( tvb , offset , NULL , & pc , NULL );
ber_offset = get_ber_length ( tvb , ber_offset , & ber_len , NULL );
if ( pc && ( ber_len > 0 ) && ( ber_len + ( ber_offset - offset ) == len ) )
if ( show_internal_ber_fields )
offset = dissect_ber_identifier ( pinfo , tree , tvb , start_offset , NULL , NULL , NULL );
offset = dissect_ber_length ( pinfo , tree , tvb , offset , NULL , NULL );
item = ber_proto_tree_add_item ( pinfo , tree , hf_ber_unknown_BER_OCTETSTRING , tvb , offset , len , ENC_NA );
next_tree = proto_item_add_subtree ( item , ett_ber_octet_string );
offset = try_dissect_unknown_ber ( pinfo , tvb , offset , next_tree , nest_level + 1 );
static
try_dissect_unknown_ber(packet_info *pinfo, tvbuff_t *tvb, volatile int offset, proto_tree *tree, gint nest_level)
int start_offset ;
gint8 ber_class ;
gboolean pc , ind ;
gint32 tag ;
guint32 len ;
start_offset = offset;
offset = get_ber_identifier ( tvb , offset , & ber_class , & pc , & tag );
offset = get_ber_length ( tvb , offset , & len , & ind );
if ( len > ( guint32 ) tvb_reported_length_remaining ( tvb , offset ) )
switch ( pc )
switch ( ber_class )
switch ( tag )
offset = dissect_ber_octet_string ( FALSE , & asn1_ctx , tree , tvb , start_offset , hf_ber_unknown_TeletexString , NULL );

dissect_ber_octet_string(gboolean implicit_tag, asn1_ctx_t *actx, proto_tree *tree, tvbuff_t *tvb, int offset, gint hf_id, tvbuff_t **out_tvb)
return dissect_ber_constrained_octet_string ( implicit_tag , actx , tree , tvb , offset , NO_BOUND , NO_BOUND , hf_id , out_tvb ) ;

dissect_ber_constrained_octet_string(gboolean implicit_tag, asn1_ctx_t *actx, proto_tree *tree, tvbuff_t *tvb, int offset, gint32 min_len, gint32 max_len, gint hf_id, tvbuff_t **out_tvb)
guint32 len ;
int end_offset ;
if ( ! implicit_tag )
offset = dissect_ber_identifier ( actx -> pinfo , tree , tvb , offset , & ber_class , & pc , & tag );
offset = dissect_ber_length ( actx -> pinfo , tree , tvb , offset , & len , & ind );
end_offset = offset + len;
return end_offset ;
return end_offset ;
return end_offset ;
1
------------------------------
20767 CVE-2016-2327/Ffmpeg_2.8.2_CVE_2016_2327_libavcodec_pngenc.c pc = a - c 129
static int encode_frame(AVCodecContext *avctx, const AVFrame *pict)
PNGEncContext * s = avctx -> priv_data ;
const AVFrame * const p = pict
int y , len , ret ;
int row_size , pass_row_size ;
uint8_t * ptr , * top , * crow_buf , * crow ;
row_size = ( pict -> width * s -> bits_per_pixel + 7 ) >> 3;
crow_base = av_malloc ( ( row_size + 32 ) << ( s -> filter_type == PNG_FILTER_VALUE_MIXED ) );
if ( ! crow_base )
crow_buf = crow_base + 15;
if ( s -> is_progressive )
progressive_buf = av_malloc ( row_size + 1 );
top_buf = av_malloc ( row_size + 1 );
if ( ! progressive_buf || ! top_buf )
s -> zstream . avail_out = IOBUF_SIZE;
s -> zstream . next_out = s -> buf;
if ( s -> is_progressive )
top = NULL;
for (y = 0; y < pict->height; y++)
ptr = p -> data [ 0 ] + y * p -> linesize [ 0 ];
crow = png_choose_filter ( s , crow_buf , ptr , top , row_size , s -> bits_per_pixel >> 3 );
top = ptr;
static uint8_t *png_choose_filter(PNGEncContext *s, uint8_t
uint8_t *src, uint8_t *top, int size, int bpp)
int pred = s -> filter_type ;
if ( ! top && pred )
pred = PNG_FILTER_VALUE_SUB;
if ( pred == PNG_FILTER_VALUE_MIXED )
png_filter_row ( s , dst + 1 , pred , src , top , size , bpp );
static void png_filter_row(PNGEncContext *c, uint8_t *dst, int
uint8_t *src, uint8_t *top, int size, int bpp)
int i ;
switch ( filter_type )
memcpy ( dst , src , size );
for (i = 0; i < bpp; i++)
dst [ i ] = src [ i ] - ( top [ i ] >> 1 );
for (; i < size; i++)
dst [ i ] = src [ i ] - ( ( src [ i - bpp ] + top [ i ] ) >> 1 );
for (i = 0; i < bpp; i++)
dst [ i ] = src [ i ] - top [ i ];
sub_png_paeth_prediction ( dst + i , src + i , top + i , size - i , bpp );
static void sub_png_paeth_prediction(uint8_t *dst, uint8_t *src, uint8_t
int w, int bpp)
int i ;
for (i = 0; i < w; i++)
int a , b , c , p , pa , pb , pc ;
a = src [ i - bpp ];
b = top [ i ];
c = top [ i - bpp ];
p = b - c;
pc = a - c;
pa = abs ( p );
pb = abs ( pc );
pc = abs ( p + pc );
if ( pa <= pb && pa <= pc )
p = a;
if ( pb <= pc )
p = b;
p = c;
dst [ i ] = src [ i ] - p;
0
------------------------------
298794 95294/CWE369_Divide_by_Zero__int_listen_socket_divide_81_bad.cpp printIntLine ( 100 / data ) 28
void CWE369_Divide_by_Zero__int_listen_socket_divide_81_bad::action(int data) const
printIntLine ( 100 / data );
1
------------------------------
301202 152159/tile-manager.c cols = x2 - x + 1 814
void tile_manager_write_pixel_data(TileManager *tm,gint x1,gint y1,gint x2,gint y2,const guchar *buffer,guint stride)
guint x ;
guint y ;
for (y = y1; y <= y2; y += 64 - y % 64)
for (x = x1; x <= x2; x += 64 - x % 64)
Tile * tile = tile_manager_get_tile ( tm , x , y , ! 0 , ! 0 ) ;
Tile *tile_manager_get_tile(TileManager *tm,gint xpixel,gint ypixel,gboolean wantread,gboolean wantwrite)
if ( tm != ( ( void * ) 0 ) )
return ( ( void * ) 0 ) ;
while ( 0 )
return tile_manager_get ( tm , tile_manager_get_tile_num ( tm , xpixel , ypixel ) , wantread , wantwrite ) ;
inline static gint tile_manager_get_tile_num(TileManager *tm,gint xpixel,gint ypixel)
if ( xpixel < 0 || xpixel >= tm -> width || ypixel < 0 || ypixel >= tm -> height )
return - 1 ;
return ypixel / 64 * tm -> ntile_cols + xpixel / 64 ;
Tile *tile_manager_get(TileManager *tm,gint tile_num,gboolean wantread,gboolean wantwrite)
Tile * tile ;
gint ntiles ;
if ( tm != ( ( void * ) 0 ) )
return ( ( void * ) 0 ) ;
while ( 0 )
ntiles = tm -> ntile_rows * tm -> ntile_cols;
if ( tile_num < 0 || tile_num >= ntiles )
return ( ( void * ) 0 ) ;
tile = tm -> tiles [ tile_num ];
if ( wantread )
if ( wantwrite )
if ( tile -> share_count > 1 )
Tile * new = tile_new ( ( tile -> bpp )
new -> ewidth = tile ->
new -> eheight = tile ->
new -> valid = ( tile -> valid
new -> size = ( new -> ewidth ) * ( new -> eheight ) * ( new -> bpp
new -> data = ( ( guchar * ) ( g_malloc_n ( ( new -> size ) , sizeof ( guchar ) ) ) )
if ( tile -> data )
memcpy ( ( new -> data ) , ( tile -> data ) , ( new -> size ) )
memcpy ( ( new -> data ) , ( tile -> data ) , ( new -> size ) )
tile_attach ( new , tm , tile_num
tile = new
tile -> write_count ++;
tile -> dirty = ( ! 0 );
return tile ;
guint cols ;
cols = ( tile -> ewidth ) - x % 64;
if ( cols > x2 - x + 1 )
cols = x2 - x + 1;
memcpy ( d , s , ( cols * ( tm -> bpp ) ) );
d += dststride;
0
------------------------------
16872 CVE-2015-0833/CVE_2015_0833_PATCHED_NS_main.c NS_tsnprintf ( oldPrecomplete , sizeof ( oldPrecomplete ) / sizeof ( oldPrecomplete [ 0 ] ) , NS_T ( "%s/precomplete" ) , gInstallDirPath ) 816
int CVE_2015_0833_PATCHED_NS_main(int argc, NS_tchar **argv)
if ( argc < 4 )
gInstallDirPath [ MAXPATHLEN - 1 ] = NS_T ( '\0' );
bool noServiceFallback = getenv ( "MOZ_NO_SERVICE_FALLBACK" ) != nullptr ;
useService = IsUpdateStatusPendingService ( );
testOnlyFallbackKeyExists = DoesFallbackKeyExist ( );
__int64 pid = 0 ;
if ( argc > 4 )
pid = _wtoi64 ( argv [ 4 ] );
if ( pid == - 1 )
sStagedUpdate = true;
if ( NS_tstrstr ( argv [ 4 ] , NS_T ( "/replace" ) ) )
sReplaceRequest = true;
gWorkingDirPath [ MAXPATHLEN - 1 ] = NS_T ( '\0' );
if ( ! WriteStatusFile ( "applying" ) )
if ( pid > 0 )
HANDLE parent = OpenProcess ( SYNCHRONIZE , false , ( DWORD ) pid ) ;
if ( parent )
updateFromMetro = IsUpdateFromMetro ( argc , argv );
DWORD waitTime = updateFromMetro ? IMMERSIVE_PARENT_WAIT : PARENT_WAIT ;
DWORD result = WaitForSingleObject ( parent , waitTime ) ;
if ( result != WAIT_OBJECT_0 && ! updateFromMetro )
const int callbackIndex = 6 ;
sUsingService = getenv ( "MOZ_USING_SERVICE" ) != nullptr;
if ( ! sUsingService && ( argc > callbackIndex || sStagedUpdate || sReplaceRequest ) )
NS_tchar updateLockFilePath [ MAXPATHLEN ] ;
if ( ! _waccess ( updateLockFilePath , F_OK ) && NS_tremove ( updateLockFilePath ) != 0 )
updateLockFileHandle = CreateFileW ( updateLockFilePath , GENERIC_READ | GENERIC_WRITE , 0 , nullptr , OPEN_ALWAYS , FILE_FLAG_DELETE_ON_CLOSE , nullptr );
if ( updateLockFileHandle == INVALID_HANDLE_VALUE || ( useService && testOnlyFallbackKeyExists && noServiceFallback ) )
GonkAutoMounter mounter ;
if ( mounter . GetAccess ( ) != MountAccess :: ReadWrite )
if ( ! sReplaceRequest )
if ( NS_tchdir ( gWorkingDirPath ) != 0 )
int rv = NS_tmkdir ( gWorkingDirPath , 0755 ) ;
if ( rv == OK && errno != EEXIST )
if ( NS_tchdir ( gWorkingDirPath ) != 0 )
if ( ! sReplaceRequest )
NS_tchar * destpath = ( NS_tchar * ) malloc ( ( NS_tstrlen ( gWorkingDirPath ) + 2 ) * sizeof ( NS_tchar ) ) ;
if ( ! destpath )
NS_tchar applyDirLongPath [ MAXPATHLEN ] ;
if ( ! GetLongPathNameW ( gWorkingDirPath , applyDirLongPath , sizeof ( applyDirLongPath ) / sizeof ( applyDirLongPath [ 0 ] ) ) )
if ( argc > callbackIndex )
NS_tchar callbackLongPath [ MAXPATHLEN ] ;
NS_tchar * targetPath = argv [ callbackIndex ] ;
NS_tchar buffer [ MAXPATHLEN * 2 ] = { NS_T ( '\0' ) } ;
if ( sReplaceRequest )
targetPath = buffer;
if ( ! GetLongPathNameW ( targetPath , callbackLongPath , sizeof ( callbackLongPath ) / sizeof ( callbackLongPath [ 0 ] ) ) )
if ( ! sReplaceRequest )
const int max_retries = 10 ;
int retries = 1 ;
DWORD lastWriteError = 0 ;
callbackFile = CreateFileW ( targetPath , DELETE | GENERIC_WRITE , FILE_SHARE_DELETE | FILE_SHARE_WRITE , nullptr , OPEN_EXISTING , 0 , nullptr );
if ( callbackFile != INVALID_HANDLE_VALUE )
lastWriteError = GetLastError ( );
while ( ++ retries <= max_retries )
if ( callbackFile == INVALID_HANDLE_VALUE )
if ( lastWriteError != ERROR_SHARING_VIOLATION )
if ( gSucceeded && ! sStagedUpdate )
NS_tchar oldPrecomplete [ MAXPATHLEN ] ;
NS_tsnprintf ( oldPrecomplete , sizeof ( oldPrecomplete ) / sizeof ( oldPrecomplete [ 0 ] ) , NS_T ( "%s/precomplete" ) , gInstallDirPath );
0
------------------------------
302241 80467/CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_42.c recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 94
void CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_42_bad()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
data = badSource ( data );
static char * badSource(char * data)
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
return data ;
0
------------------------------
313421 96513/CWE36_Absolute_Path_Traversal__char_listen_socket_fopen_16.cpp recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ) 106
void bad()
char * data ;
char dataBuffer [ FILENAME_MAX ] = "" ;
data = dataBuffer;
while ( 1 )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
pFile = FOPEN ( data , "wb+" );
if ( pFile != NULL )
fclose ( pFile );
1
------------------------------
298241 94142/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_connect_socket_81a.cpp recvResult = recv ( connectSocket , ( char * ) ( password + passwordLen ) , ( 100 - passwordLen - 1 ) * sizeof ( char ) , 0 ) 157
static void goodB2G()
char * password ;
char passwordBuffer [ 100 ] = "" ;
password = passwordBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t passwordLen = strlen ( password ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( password + passwordLen ) , ( 100 - passwordLen - 1 ) * sizeof ( char ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
password [ passwordLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( password , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( password , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
baseObject . action ( password );
0
------------------------------
20593 CVE-2016-8910/qemu_2.3.0_CVE-2016-8910_rtl8139.c ip -> ip_len = cpu_to_be16 ( hlen + tcp_hlen + chunk_size ) 2294
static void rtl8139_io_writel(void *opaque, uint8_t addr, uint32_t val)
switch ( addr )
rtl8139_io_writeb ( opaque , addr , val & 0xff );
static void rtl8139_io_writeb(void *opaque, uint8_t addr, uint32_t val)
RTL8139State * s = opaque ;
switch ( addr )
if ( val == 'R' )
if ( val == 'H' )
s -> clock_enabled = 0;
s -> TxThresh = val;
if ( val & ( 1 << 6 ) )
rtl8139_cplus_transmit ( s );
static void rtl8139_cplus_transmit(RTL8139State *s)
while ( rtl8139_cplus_transmit_one ( s ) )
static int rtl8139_cplus_transmit_one(RTL8139State *s)
if ( ! rtl8139_transmitter_enabled ( s ) )
if ( ! rtl8139_cp_transmitter_enabled ( s ) )
uint32_t val , txdw0 , txdw1 , txbufLO , txbufHI ;
txdw0 = le32_to_cpu ( val );
if ( ! ( txdw0 & CP_TX_OWN ) )
if ( txdw0 & CP_TX_FS )
s -> cplus_txbuffer_offset = 0;
int txsize = txdw0 & CP_TX_BUFFER_SIZE_MASK ;
if ( ! s -> cplus_txbuffer )
s -> cplus_txbuffer_len = CP_TX_BUFFER_SIZE;
s -> cplus_txbuffer = g_malloc ( s -> cplus_txbuffer_len );
s -> cplus_txbuffer_offset = 0;
if ( s -> cplus_txbuffer_offset + txsize >= s -> cplus_txbuffer_len )
txsize = s -> cplus_txbuffer_len - s -> cplus_txbuffer_offset;
s -> cplus_txbuffer_offset += txsize;
if ( txdw0 & CP_TX_EOR )
s -> currCPlusTxDesc = 0;
if ( s -> currCPlusTxDesc >= 64 )
s -> currCPlusTxDesc = 0;
txdw0 &= ~CP_RX_OWN;
txdw0 &= ~CP_TX_STATUS_UNF;
txdw0 &= ~CP_TX_STATUS_TES;
txdw0 &= ~CP_TX_STATUS_OWC;
txdw0 &= ~CP_TX_STATUS_LNKF;
txdw0 &= ~CP_TX_STATUS_EXC;
if ( txdw0 & CP_TX_LS )
uint8_t * saved_buffer = s -> cplus_txbuffer ;
int saved_size = s -> cplus_txbuffer_offset ;
if ( txdw0 & ( CP_TX_IPCS | CP_TX_UDPCS | CP_TX_TCPCS | CP_TX_LGSEN ) )
ip_header * ip = NULL ;
int hlen = 0 ;
uint8_t ip_protocol = 0 ;
uint16_t ip_data_len = 0 ;
uint8_t * eth_payload_data = NULL ;
size_t eth_payload_len = 0 ;
int proto = be16_to_cpu ( * ( uint16_t * ) ( saved_buffer + 12 ) ) ;
if ( proto == ETH_P_IP )
eth_payload_data = saved_buffer + ETH_HLEN;
eth_payload_len = saved_size - ETH_HLEN;
ip = ( ip_header * ) eth_payload_data;
if ( IP_HEADER_VERSION ( ip ) != IP_HEADER_VERSION_4 )
ip = NULL;
hlen = IP_HEADER_LENGTH ( ip );
ip_protocol = ip -> ip_p;
ip_data_len = be16_to_cpu ( ip -> ip_len ) - hlen;
if ( ip )
if ( txdw0 & CP_TX_IPCS )
if ( hlen < sizeof ( ip_header ) || hlen > eth_payload_len )
ip -> ip_sum = 0;
ip -> ip_sum = ip_checksum ( ip , hlen );
if ( ( txdw0 & CP_TX_LGSEN ) && ip_protocol == IP_PROTO_TCP )
tcp_header * p_tcp_hdr = ( tcp_header * ) ( eth_payload_data + hlen ) ;
int tcp_hlen = TCP_HEADER_DATA_OFFSET ( p_tcp_hdr ) ;
int tcp_data_len = ip_data_len - tcp_hlen ;
int tcp_chunk_size = ETH_MTU - hlen - tcp_hlen ;
for (tcp_send_offset = 0; tcp_send_offset < tcp_data_len; tcp_send_offset += tcp_chunk_size)
uint16_t chunk_size = tcp_chunk_size ;
if ( tcp_send_offset + tcp_chunk_size >= tcp_data_len )
chunk_size = tcp_data_len - tcp_send_offset;
ip -> ip_len = cpu_to_be16 ( hlen + tcp_hlen + chunk_size );
ip -> ip_id = cpu_to_be16 ( tcp_send_offset / tcp_chunk_size + be16_to_cpu ( ip -> ip_id ) );
ip -> ip_sum = 0;
ip -> ip_sum = ip_checksum ( eth_payload_data , hlen );
DPRINTF ( "+++ C+ mode TSO IP header len=%d
"checksum=%04x\n" , hlen , ip -> ip_sum )
0
------------------------------
18647 CVE-2015-2716/Firefox_37.0b7_CVE_2015_2716_parser_expat_lib_xmlparse.c pool -> end = pool -> start + blockSize 6266
static enum XML_Error
entityValueProcessor(XML_Parser
const char
const char
const char **nextPtr)
const char * start = s ;
const char * next = s ;
const ENCODING * enc = encoding ;
int tok ;
tok = XmlPrologTok ( enc , start , end , & next );
if ( tok <= 0 )
if ( ! ps_finalBuffer && tok != XML_TOK_INVALID )
switch ( tok )
return storeEntityValue ( parser , enc , s , end ) ;
start = next;
static enum
storeEntityValue(XML_Parser
const ENCODING
const char
const char *entityTextEnd)
DTD * const dtd = _dtd
STRING_POOL * pool = & ( dtd -> entityValuePool ) ;
if ( ! pool -> blocks )
if ( ! poolGrow ( pool ) )
const char * next ;
int tok = XmlEntityValueTok ( enc , entityTextPtr , entityTextEnd , & next ) ;
switch ( tok )
if ( isParamEntity || enc != encoding )
const XML_Char * name ;
ENTITY * entity ;
name = poolStoreString ( & tempPool , enc , entityTextPtr + enc -> minBytesPerChar , next - enc -> minBytesPerChar );
if ( ! name )
entity = ( ENTITY * ) lookup ( & dtd -> paramEntities , name , 0 );
if ( ! entity )
if ( entity -> open )
if ( entity -> systemId )
if ( externalEntityRefHandler )
entity -> open = XML_TRUE;
if ( ! externalEntityRefHandler ( externalEntityRefHandlerArg , 0 , entity -> base , entity -> systemId , entity -> publicId ) )
entity -> open = XML_FALSE;
entity -> open = XML_TRUE;
result = storeEntityValue ( parser , internalEncoding , ( char * ) entity -> textPtr , ( char * ) ( entity -> textPtr + entity -> textLen ) );
entity -> open = XML_FALSE;
if ( result )
if ( ! poolAppend ( pool , enc , entityTextPtr , next ) )
next = entityTextPtr + enc -> minBytesPerChar;
if ( pool -> end == pool -> ptr && ! poolGrow ( pool ) )
* ( pool -> ptr ) ++ = 0xA;
XML_Char buf [ XML_ENCODE_MAX ] ;
int i ;
int n = XmlCharRefNumber ( enc , entityTextPtr ) ;
if ( n < 0 )
n = XmlEncode ( n , ( ICHAR * ) buf );
if ( ! n )
for (i = 0; i < n; i++)
if ( pool -> end == pool -> ptr && ! poolGrow ( pool ) )
* ( pool -> ptr ) ++ = buf [ i ];
entityTextPtr = next;
static enum
storeEntityValue(XML_Parser
const ENCODING
const char
const char *entityTextEnd)
DTD * const dtd = _dtd
STRING_POOL * pool = & ( dtd -> entityValuePool ) ;
if ( ! pool -> blocks )
if ( ! poolGrow ( pool ) )
const char * next ;
int tok = XmlEntityValueTok ( enc , entityTextPtr , entityTextEnd , & next ) ;
switch ( tok )
if ( isParamEntity || enc != encoding )
const XML_Char * name ;
ENTITY * entity ;
name = poolStoreString ( & tempPool , enc , entityTextPtr + enc -> minBytesPerChar , next - enc -> minBytesPerChar );
if ( ! name )
entity = ( ENTITY * ) lookup ( & dtd -> paramEntities , name , 0 );
if ( ! entity )
if ( entity -> open )
if ( entity -> systemId )
if ( externalEntityRefHandler )
entity -> open = XML_TRUE;
if ( ! externalEntityRefHandler ( externalEntityRefHandlerArg , 0 , entity -> base , entity -> systemId , entity -> publicId ) )
entity -> open = XML_FALSE;
entity -> open = XML_TRUE;
result = storeEntityValue ( parser , internalEncoding , ( char * ) entity -> textPtr , ( char * ) ( entity -> textPtr + entity -> textLen ) );
entity -> open = XML_FALSE;
if ( result )
if ( ! poolAppend ( pool , enc , entityTextPtr , next ) )
next = entityTextPtr + enc -> minBytesPerChar;
if ( pool -> end == pool -> ptr && ! poolGrow ( pool ) )
* ( pool -> ptr ) ++ = 0xA;
XML_Char buf [ XML_ENCODE_MAX ] ;
int i ;
int n = XmlCharRefNumber ( enc , entityTextPtr ) ;
if ( n < 0 )
n = XmlEncode ( n , ( ICHAR * ) buf );
if ( ! n )
if ( pool -> end == pool -> ptr && ! poolGrow ( pool ) )
* ( pool -> ptr ) ++ = buf [ i ];
entityTextPtr = next;
static XML_Bool
poolGrow(STRING_POOL *pool)
if ( pool -> freeBlocks )
if ( pool -> start == 0 )
if ( pool -> end - pool -> start < pool -> freeBlocks -> size )
if ( pool -> blocks && pool -> start == pool -> blocks -> s )
int blockSize = ( int ) ( pool -> end - pool -> start ) * 2 ;
pool -> blocks = ( BLOCK * ) pool -> mem -> realloc_fcn ( pool -> blocks , ( offsetof ( BLOCK , s ) + blockSize * sizeof ( XML_Char ) ) );
if ( pool -> blocks == NULL )
pool -> blocks -> size = blockSize;
pool -> ptr = pool -> blocks -> s + ( pool -> ptr - pool -> start );
pool -> start = pool -> blocks -> s;
pool -> end = pool -> start + blockSize;
0
------------------------------
18654 CVE-2015-2716/Firefox_37.0b7_CVE_2015_2716_parser_expat_lib_xmlparse.c pool -> end = pool -> start + blockSize 6266
static
reportProcessingInstruction(XML_Parser parser, const ENCODING
const char *start, const char *end)
const XML_Char * target ;
XML_Char * data ;
const char * tem ;
if ( ! processingInstructionHandler )
start += enc -> minBytesPerChar * 2;
tem = start + XmlNameLength ( enc , start );
target = poolStoreString ( & tempPool , enc , start , tem );
if ( ! target )
data = poolStoreString ( & tempPool , enc , XmlSkipS ( enc , tem ) , end - enc -> minBytesPerChar * 2 );
static XML_Char
poolStoreString(STRING_POOL *pool, const ENCODING
const char *ptr, const char *end)
if ( ! poolAppend ( pool , enc , ptr , end ) )
static XML_Char
poolAppend(STRING_POOL *pool, const ENCODING
const char *ptr, const char *end)
if ( ! pool -> ptr && ! poolGrow ( pool ) )
if ( ptr == end )
if ( ! poolGrow ( pool ) )
static XML_Bool
poolGrow(STRING_POOL *pool)
if ( pool -> freeBlocks )
if ( pool -> start == 0 )
if ( pool -> end - pool -> start < pool -> freeBlocks -> size )
if ( pool -> blocks && pool -> start == pool -> blocks -> s )
int blockSize = ( int ) ( pool -> end - pool -> start ) * 2 ;
pool -> blocks = ( BLOCK * ) pool -> mem -> realloc_fcn ( pool -> blocks , ( offsetof ( BLOCK , s ) + blockSize * sizeof ( XML_Char ) ) );
if ( pool -> blocks == NULL )
pool -> blocks -> size = blockSize;
pool -> ptr = pool -> blocks -> s + ( pool -> ptr - pool -> start );
pool -> start = pool -> blocks -> s;
pool -> end = pool -> start + blockSize;
0
------------------------------
307787 110506/CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_listen_socket_03.c intPointer = ( int * ) malloc ( data * sizeof ( int ) ) 125
void CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_listen_socket_03_bad()
int data ;
data = - 1;
if ( 5 == 5 )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
char inputBuffer [ CHAR_ARRAY_SIZE ] ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
inputBuffer [ recvResult ] = '\0';
data = atoi ( inputBuffer );
while ( 0 )
int * intPointer ;
intPointer = ( int * ) malloc ( data * sizeof ( int ) );
intPointer [ i ] = 0;
printIntLine ( intPointer [ 0 ] );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
free ( intPointer );
1
------------------------------
309938 149543/eng_lib.c stonesoup_tainted_buff = ( char * ) malloc ( buffer_size * sizeof ( char ) ) 99
static int stonesoup_ev_handler(struct mg_connection *conn, enum mg_event ev)
char * ifmatch_header ;
char * stonesoup_tainted_buff ;
int buffer_size = 1000 ;
if ( ev == MG_REQUEST )
ifmatch_header = ( char * ) mg_get_header ( conn , "if-match" );
if ( strcmp ( ifmatch_header , "weak_taint_source_value" ) == 0 )
while ( 1 )
stonesoup_tainted_buff = ( char * ) malloc ( buffer_size * sizeof ( char ) );
data_size = mg_get_var ( conn , "data" , stonesoup_tainted_buff , buffer_size * sizeof ( char ) );
if ( data_size < buffer_size )
buffer_size = buffer_size * 2;
free ( stonesoup_tainted_buff );
stonesoup_handle_taint ( stonesoup_tainted_buff );
void stonesoup_handle_taint(char *knifley_pleonastic)
if ( knifley_pleonastic != 0 )
pangamously_repasts . subsyndication_upfolding = ( ( char * ) knifley_pleonastic );
nonequal_stelai [ 5 ] = pangamously_repasts;
ssas_covalent = * ( nonequal_stelai + * becker_dmi );
tippleman_pinwheel = ( ( char * ) ssas_covalent . subsyndication_upfolding );
while ( stonesoup_isalnum ( tippleman_pinwheel [ stonesoup_size ] ) && stonesoup_size < strlen ( tippleman_pinwheel ) )
int stonesoup_isalnum(int c)
if ( ( c >= 97 && c <= 122 ) || ( c >= 65 && c <= 90 ) || ( c >= 48 && c <= 57 ) )
if ( stonesoup_size != strlen ( tippleman_pinwheel ) )
tracepoint ( stonesoup_trace , variable_address , "STONESOUP_TAINT_SOURCE" , tippleman_pinwheel , "CROSSOVER-STATE" );
strcpy ( stonesoup_second_buff , tippleman_pinwheel );
stonesoup_476_global_variable = strlen ( stonesoup_second_buff );
if ( stonesoup_second_buff != 0 )
free ( stonesoup_second_buff );
if ( ssas_covalent . subsyndication_upfolding != 0 )
free ( ( ( char * ) ssas_covalent . subsyndication_upfolding ) );
1
------------------------------
307740 105154/CWE506_Embedded_Malicious_Code__w32_screen_capture_05.c hbmScreen = CreateCompatibleBitmap ( hdcWindow , rcClient . right - rcClient . left , rcClient . bottom - rcClient . top ) 71
void CWE506_Embedded_Malicious_Code__w32_screen_capture_05_bad()
if ( staticTrue )
BITMAP bmpScreen ;
RECT rcClient ;
BITMAPFILEHEADER bmfHeader ;
BITMAPINFOHEADER bmiHeader ;
DWORD dwBmpSize ;
DWORD dwSizeofDIB ;
DWORD dwBytesWritten ;
HWND hWnd = GetDesktopWindow ( ) ;
hdcWindow = GetDC ( hWnd );
if ( hdcWindow == NULL )
hdcMemDC = CreateCompatibleDC ( hdcWindow );
if ( hdcMemDC == NULL )
if ( GetClientRect ( hWnd , & rcClient ) == 0 )
hbmScreen = CreateCompatibleBitmap ( hdcWindow , rcClient . right - rcClient . left , rcClient . bottom - rcClient . top );
if ( hbmScreen == NULL )
selectResult = SelectObject ( hdcMemDC , hbmScreen );
if ( selectResult == NULL || selectResult == HGDI_ERROR )
if ( BitBlt ( hdcMemDC , 0 , 0 , rcClient . right - rcClient . left , rcClient . bottom - rcClient . top , hdcWindow , 0 , 0 , SRCCOPY ) == 0 )
if ( GetObject ( hbmScreen , sizeof ( BITMAP ) , & bmpScreen ) == 0 )
bmiHeader . biSize = sizeof ( BITMAPINFOHEADER );
bmiHeader . biWidth = bmpScreen . bmWidth;
bmiHeader . biHeight = bmpScreen . bmHeight;
bmiHeader . biPlanes = 1;
bmiHeader . biBitCount = 32;
bmiHeader . biCompression = BI_RGB;
bmiHeader . biSizeImage = 0;
bmiHeader . biXPelsPerMeter = 0;
bmiHeader . biYPelsPerMeter = 0;
bmiHeader . biClrUsed = 0;
bmiHeader . biClrImportant = 0;
dwBmpSize = ( ( bmpScreen . bmWidth * bmiHeader . biBitCount + 31 ) / 32 ) * 4 * bmpScreen . bmHeight;
hDIB = GlobalAlloc ( GHND , dwBmpSize );
if ( hDIB == NULL )
lpbitmap = ( char * ) GlobalLock ( hDIB );
if ( lpbitmap == NULL )
if ( GetDIBits ( hdcWindow , hbmScreen , 0 , ( UINT ) bmpScreen . bmHeight , lpbitmap , ( BITMAPINFO * ) & bmiHeader , DIB_RGB_COLORS ) == 0 )
hFile = CreateFile ( TEXT ( "capture.bmp" ) , GENERIC_WRITE , 0 , NULL , CREATE_ALWAYS , FILE_ATTRIBUTE_NORMAL , NULL );
if ( hFile == INVALID_HANDLE_VALUE )
dwSizeofDIB = dwBmpSize + sizeof ( BITMAPFILEHEADER ) + sizeof ( BITMAPINFOHEADER );
bmfHeader . bfOffBits = ( DWORD ) sizeof ( BITMAPFILEHEADER ) + ( DWORD ) sizeof ( BITMAPINFOHEADER );
bmfHeader . bfSize = dwSizeofDIB;
bmfHeader . bfType = 0x4D42;
dwBytesWritten = 0;
if ( WriteFile ( hFile , ( LPSTR ) & bmfHeader , sizeof ( BITMAPFILEHEADER ) , & dwBytesWritten , NULL ) == 0 )
if ( WriteFile ( hFile , ( LPSTR ) & bmiHeader , sizeof ( BITMAPINFOHEADER ) , & dwBytesWritten , NULL ) == 0 )
if ( WriteFile ( hFile , ( LPSTR ) lpbitmap , dwBmpSize , & dwBytesWritten , NULL ) == 0 )
while ( 0 )
if ( hbmScreen != NULL )
DeleteObject ( hbmScreen );
1
------------------------------
308895 118248/CWE78_OS_Command_Injection__char_connect_socket_w32_spawnlp_18.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 103
void CWE78_OS_Command_Injection__char_connect_socket_w32_spawnlp_18_bad()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
0
------------------------------
309034 110385/CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fgets_42.c intPointer = ( int * ) malloc ( data * sizeof ( int ) ) 52
void CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fgets_42_bad()
int data ;
data = - 1;
data = badSource ( data );
static int badSource(int data)
char inputBuffer [ CHAR_ARRAY_SIZE ] = "" ;
if ( fgets ( inputBuffer , CHAR_ARRAY_SIZE , stdin ) != NULL )
data = atoi ( inputBuffer );
return data ;
int * intPointer ;
intPointer = ( int * ) malloc ( data * sizeof ( int ) );
intPointer [ i ] = 0;
printIntLine ( intPointer [ 0 ] );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
free ( intPointer );
1
------------------------------
314231 110807/CWE680_Integer_Overflow_to_Buffer_Overflow__new_listen_socket_16.cpp dataBytes = data * sizeof ( int ) 159
static void goodG2B()
int data ;
data = - 1;
while ( 1 )
data = 20;
size_t dataBytes , i ;
dataBytes = data * sizeof ( int );
intPointer = ( int * ) new char [ dataBytes ];
intPointer [ i ] = 0;
printIntLine ( intPointer [ 0 ] );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
delete [ ] intPointer
0
------------------------------
308618 120519/CWE78_OS_Command_Injection__wchar_t_connect_socket_system_54a.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 ) 100
void CWE78_OS_Command_Injection__wchar_t_connect_socket_system_54_bad()
wchar_t * data ;
wchar_t data_buf [ 100 ] = FULL_COMMAND ;
data = data_buf;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
16434 CVE-2013-7022/CVE_2013_7022_PATCHED_g2m_init_buffers.c c -> synth_tile = av_mallocz ( c -> tile_stride * aligned_height ) 22
static int CVE_2013_7022_PATCHED_g2m_init_buffers(G2MContext *c)
int aligned_height ;
if ( ! c -> framebuf || c -> old_width < c -> width || c -> old_height < c -> height )
c -> framebuf_stride = FFALIGN ( c -> width + 15 , 16 ) * 3;
aligned_height = c -> height + 15;
c -> framebuf = av_mallocz ( c -> framebuf_stride * aligned_height );
if ( ! c -> framebuf )
if ( ! c -> synth_tile || ! c -> jpeg_tile || c -> old_tile_w < c -> tile_width || c -> old_tile_h < c -> tile_height )
c -> tile_stride = FFALIGN ( c -> tile_width * 3 , 16 );
aligned_height = FFALIGN ( c -> tile_height , 16 );
c -> synth_tile = av_mallocz ( c -> tile_stride * aligned_height );
0
------------------------------
17450 CVE-2013-7014/CVE_2013_7014_VULN_add_bytes_l2_c.c long b = * ( long * ) ( src2 + i ) ; 6
static void CVE_2013_7014_VULN_add_bytes_l2_c(uint8_t *dst, uint8_t *src1, uint8_t *src2, int w)
long i ;
for (i = 0; i <= w - sizeof(long); i += sizeof(long))
long a = * ( long * ) ( src1 + i ) ;
long b = * ( long * ) ( src2 + i ) ;
* ( long * ) ( dst + i ) = ( ( a & pb_7f ) + ( b & pb_7f ) ) ^ ( ( a ^ b ) & pb_80 );
0
------------------------------
305470 103110/CWE427_Uncontrolled_Search_Path_Element__wchar_t_connect_socket_15.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 250 - dataLen - 1 ) , 0 ) 95
void CWE427_Uncontrolled_Search_Path_Element__wchar_t_connect_socket_15_bad()
wchar_t * data ;
wchar_t dataBuffer [ 250 ] = L "PATH="
data = dataBuffer;
switch ( 6 )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 250 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
299319 153796/oids.c subids_overflow = subids + n 996
void oid_both_from_string(const gchar *oid_str,char **resolved_p,char **numeric_p)
guint subids_len = oid_string2subid ( oid_str , & subids ) ;
guint oid_string2subid(const char *str,guint32 **subids_p)
guint32 * subids ;
guint32 * subids_overflow ;
guint n = check_num_oid ( str ) ;
if ( ! n )
* subids_p = subids = ( ep_alloc0 ( sizeof ( guint32 ) * n ) );
subids_overflow = subids + n;
if ( subids >= subids_overflow || subid > 0xffffffff )
0
------------------------------
17658 CVE-2010-0307/CVE_2010_0307_VULN_load_elf_binary.c k = elf_ppnt -> p_vaddr + elf_ppnt -> p_memsz 317
static int CVE_2010_0307_VULN_load_elf_binary(struct linux_binprm *bprm, struct pt_regs *regs)
unsigned long load_addr = 0 , load_bias = 0 ;
int load_addr_set = 0 ;
char * elf_interpreter = NULL ;
unsigned long error ;
struct elf_phdr * elf_ppnt , * elf_phdata ;
unsigned long elf_bss , elf_brk ;
int retval , i ;
unsigned int size ;
int executable_stack = EXSTACK_DEFAULT ;
struct { struct elfhdr elf_ex ; struct elfhdr interp_elf_ex ; } * loc ;
loc = kmalloc ( sizeof ( * loc ) , GFP_KERNEL );
if ( ! loc )
loc -> elf_ex = * ( ( struct elfhdr * ) bprm -> buf );
retval = - ENOEXEC;
if ( memcmp ( loc -> elf_ex . e_ident , ELFMAG , SELFMAG ) != 0 )
if ( loc -> elf_ex . e_type != ET_EXEC && loc -> elf_ex . e_type != ET_DYN )
if ( ! elf_check_arch ( & loc -> elf_ex ) )
if ( ! bprm -> file -> f_op || ! bprm -> file -> f_op -> mmap )
if ( loc -> elf_ex . e_phentsize != sizeof ( struct elf_phdr ) )
if ( loc -> elf_ex . e_phnum < 1 || loc -> elf_ex . e_phnum > 65536U / sizeof ( struct elf_phdr ) )
size = loc -> elf_ex . e_phnum * sizeof ( struct elf_phdr );
retval = - ENOMEM;
elf_phdata = kmalloc ( size , GFP_KERNEL );
if ( ! elf_phdata )
retval = kernel_read ( bprm -> file , loc -> elf_ex . e_phoff , ( char * ) elf_phdata , size );
if ( retval != size )
elf_ppnt = elf_phdata;
elf_bss = 0;
elf_brk = 0;
for (i = 0; i < loc->elf_ex.e_phnum; i++)
if ( elf_ppnt -> p_type == PT_INTERP )
if ( elf_ppnt -> p_filesz > PATH_MAX || elf_ppnt -> p_filesz < 2 )
retval = - ENOMEM;
elf_interpreter = kmalloc ( elf_ppnt -> p_filesz , GFP_KERNEL );
if ( ! elf_interpreter )
retval = kernel_read ( bprm -> file , elf_ppnt -> p_offset , elf_interpreter , elf_ppnt -> p_filesz );
if ( retval != elf_ppnt -> p_filesz )
retval = - ENOEXEC;
if ( elf_interpreter [ elf_ppnt -> p_filesz - 1 ] != '\0' )
interpreter = open_exec ( elf_interpreter );
retval = PTR_ERR ( interpreter );
if ( IS_ERR ( interpreter ) )
if ( file_permission ( interpreter , MAY_READ ) < 0 )
bprm -> interp_flags |= BINPRM_FLAGS_ENFORCE_NONDUMP;
retval = kernel_read ( interpreter , 0 , bprm -> buf , BINPRM_BUF_SIZE );
if ( retval != BINPRM_BUF_SIZE )
loc -> interp_elf_ex = * ( ( struct elfhdr * ) bprm -> buf );
elf_ppnt ++;
elf_ppnt = elf_phdata;
for (i = 0; i < loc->elf_ex.e_phnum; i++, elf_ppnt++)
if ( elf_ppnt -> p_type == PT_GNU_STACK )
if ( elf_ppnt -> p_flags & PF_X )
executable_stack = EXSTACK_ENABLE_X;
executable_stack = EXSTACK_DISABLE_X;
if ( elf_interpreter )
retval = - ELIBBAD;
if ( memcmp ( loc -> interp_elf_ex . e_ident , ELFMAG , SELFMAG ) != 0 )
if ( ! elf_check_arch ( & loc -> interp_elf_ex ) )
retval = flush_old_exec ( bprm );
if ( retval )
retval = setup_arg_pages ( bprm , randomize_stack_top ( STACK_TOP ) , executable_stack );
if ( retval < 0 )
for(i = 0, elf_ppnt =
i < loc->elf_ex.e_phnum; i++, elf_ppnt++)
int elf_prot = 0 , elf_flags ;
unsigned long k , vaddr ;
if ( elf_ppnt -> p_type != PT_LOAD )
if ( unlikely ( elf_brk > elf_bss ) )
retval = set_brk ( elf_bss + load_bias , elf_brk + load_bias );
if ( retval )
if ( elf_ppnt -> p_flags & PF_R )
elf_prot |= PROT_READ;
if ( elf_ppnt -> p_flags & PF_W )
elf_prot |= PROT_WRITE;
if ( elf_ppnt -> p_flags & PF_X )
elf_prot |= PROT_EXEC;
elf_flags = MAP_PRIVATE | MAP_DENYWRITE | MAP_EXECUTABLE;
vaddr = elf_ppnt -> p_vaddr;
if ( loc -> elf_ex . e_type == ET_EXEC || load_addr_set )
elf_flags |= MAP_FIXED;
if ( loc -> elf_ex . e_type == ET_DYN )
load_bias = 0;
error = elf_map ( bprm -> file , load_bias + vaddr , elf_ppnt , elf_prot , elf_flags , 0 );
if ( BAD_ADDR ( error ) )
if ( ! load_addr_set )
load_addr_set = 1;
if ( loc -> elf_ex . e_type == ET_DYN )
load_bias += error - ELF_PAGESTART ( load_bias + vaddr );
k = elf_ppnt -> p_vaddr;
if ( BAD_ADDR ( k ) || elf_ppnt -> p_filesz > elf_ppnt -> p_memsz || elf_ppnt -> p_memsz > TASK_SIZE || TASK_SIZE - elf_ppnt -> p_memsz < k )
k = elf_ppnt -> p_vaddr + elf_ppnt -> p_filesz;
if ( k > elf_bss )
elf_bss = k;
k = elf_ppnt -> p_vaddr + elf_ppnt -> p_memsz;
if ( k > elf_brk )
elf_brk = k;
0
------------------------------
311704 149958/aviobuf.c s -> buf_end = dst + len 595
int avio_get_str16be(AVIOContext *pb,int maxlen,char *buf,int buflen)
int ret = 0 ;
if ( buflen <= 0 )
while ( ret + 1 < maxlen )
uint32_t ch ;
ch = ( ( ret += 2 ) <= maxlen ? avio_rb16 ( pb ) : 0 );
unsigned int hi = ch - 0xD800 ;
if ( hi < 0x800 )
ch = ( ( ret += 2 ) <= maxlen ? avio_rb16 ( pb ) : ( 0 - 0xDC00 ) );
if ( ch > 0x3FFU || hi > 0x3FFU )
ch += ( hi << 10 ) + 0x10000;
if ( ! ch )
unsigned int avio_rb16(AVIOContext *s)
unsigned int val ;
val = ( avio_r8 ( s ) << 8 );
val |= ( avio_r8 ( s ) );
int avio_r8(AVIOContext *s)
if ( s -> buf_ptr >= s -> buf_end )
fill_buffer ( s );
static void fill_buffer(AVIOContext *s)
uint8_t * dst = ! s -> max_packet_size && s -> buf_end - s -> buffer < ( s -> buffer_size ) ? s -> buf_end : s -> buffer ;
int len = ( ( s -> buffer_size ) - ( dst - s -> buffer ) ) ;
int max_buffer_size = s -> max_packet_size ? s -> max_packet_size : 32768 ;
if ( ! s -> read_packet && s -> buf_ptr >= s -> buf_end )
s -> eof_reached = 1;
if ( s -> eof_reached )
if ( s -> update_checksum && dst == s -> buffer )
if ( s -> buf_end > s -> checksum_ptr )
s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_end - s -> checksum_ptr ) ) );
s -> checksum_ptr = s -> buffer;
if ( s -> read_packet && s -> buffer_size > max_buffer_size )
s -> checksum_ptr = dst = s -> buffer;
len = s -> buffer_size;
if ( s -> read_packet )
len = ( ( s -> read_packet ) ( s -> opaque , dst , len ) );
len = 0;
if ( len <= 0 )
s -> eof_reached = 1;
if ( len < 0 )
s -> error = len;
s -> pos += len;
s -> buf_ptr = dst;
s -> buf_end = dst + len;
s -> bytes_read += len;
0
------------------------------
304409 82210/CWE190_Integer_Overflow__char_fscanf_square_05.c char result = data * data ; 43
void CWE190_Integer_Overflow__char_fscanf_square_05_bad()
char data ;
data = ' ';
if ( staticTrue )
char result = data * data ;
printHexCharLine ( result );
void printHexCharLine (char charHex)
printf ( "%02x\n" , charHex );
1
------------------------------
309757 152954/config.c stonesoup_tainted_buff = ( char * ) malloc ( buffer_size * sizeof ( char ) ) 104
static int stonesoup_ev_handler(struct mg_connection *conn, enum mg_event ev)
char * ifmatch_header ;
char * stonesoup_tainted_buff ;
int buffer_size = 1000 ;
if ( ev == MG_REQUEST )
ifmatch_header = ( char * ) mg_get_header ( conn , "if-match" );
if ( strcmp ( ifmatch_header , "weak_taint_source_value" ) == 0 )
while ( 1 )
stonesoup_tainted_buff = ( char * ) malloc ( buffer_size * sizeof ( char ) );
data_size = mg_get_var ( conn , "data" , stonesoup_tainted_buff , buffer_size * sizeof ( char ) );
if ( data_size < buffer_size )
buffer_size = buffer_size * 2;
free ( stonesoup_tainted_buff );
stonesoup_handle_taint ( stonesoup_tainted_buff );
void stonesoup_handle_taint(char *recessionary_closets)
if ( recessionary_closets != 0 )
prohibition_unfailable . grayishness_arracach = recessionary_closets;
ongun_babbittian [ * ( * chiffre_profanableness ) ] = prohibition_unfailable;
meliponine_trivalve = ongun_babbittian [ * ( * chiffre_profanableness ) ];
breakthrough_durezza = ( ( char * ) meliponine_trivalve . grayishness_arracach );
stonesoup_buffer_len = strlen ( breakthrough_durezza ) + 1;
stonesoup_buffer = malloc ( stonesoup_buffer_len * sizeof ( char ) );
if ( stonesoup_buffer == 0 )
strcpy ( stonesoup_buffer , breakthrough_durezza );
for (; stonesoup_oc_i < stonesoup_buffer_len; ++stonesoup_oc_i)
stonesoup_buffer [ stonesoup_oc_i ] = stonesoup_toupper ( stonesoup_buffer [ stonesoup_oc_i ] );
int stonesoup_toupper(int c)
if ( c >= 97 && c <= 122 )
return c - 32 ;
return c ;
stonesoup_printf ( "%s\n" , stonesoup_buffer );
void stonesoup_printf(char * format, ...)
va_start ( argptr , format );
mg_vprintf_data ( ( struct mg_connection * ) stonesoup_printf_context , format , argptr );
tracepoint ( stonesoup_trace , variable_buffer , "stonesoup_buffer" , stonesoup_buffer , "INITIAL_STATE" );
stonesoup_found = stonesoup_contains_char ( stonesoup_buffer , 'E' );
int stonesoup_contains_char(char *str_param,char c_param)
tracepoint ( stonesoup_trace , variable_address , "str_param" , str_param , "INITIAL-STATE" );
while ( * str_param != 0 )
if ( * str_param == c_param )
str_param = str_param + 1;
tracepoint ( stonesoup_trace , variable_address , "str_param" , str_param , "TRIGGER-STATE" );
free ( str_param );
if ( stonesoup_found == 1 )
stonesoup_printf ( "%s\n" , breakthrough_durezza );
void stonesoup_printf(char * format, ...)
va_start ( argptr , format );
mg_vprintf_data ( ( struct mg_connection * ) stonesoup_printf_context , format , argptr );
if ( meliponine_trivalve . grayishness_arracach != 0 )
free ( ( ( char * ) meliponine_trivalve . grayishness_arracach ) );
1
------------------------------
308257 119969/CWE78_OS_Command_Injection__char_listen_socket_popen_11.c recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 110
void CWE78_OS_Command_Injection__char_listen_socket_popen_11_bad()
char * data ;
char data_buf [ 100 ] = FULL_COMMAND ;
data = data_buf;
if ( globalReturnsTrue ( ) )
int globalReturnsTrue()
return 1 ;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
pipe = POPEN ( data , "wb" );
if ( pipe != NULL )
PCLOSE ( pipe );
1
------------------------------
303473 82379/CWE190_Integer_Overflow__char_max_square_51b.c char result = data * data ; 42
static void goodG2B()
char data ;
data = ' ';
data = 2;
CWE190_Integer_Overflow__char_max_square_51b_goodG2BSink ( data );
void CWE190_Integer_Overflow__char_max_square_51b_goodG2BSink(char data)
char result = data * data ;
printHexCharLine ( result );
void printHexCharLine (char charHex)
printf ( "%02x\n" , charHex );
0
------------------------------
308242 117378/CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_listen_socket_12.c myString = ( wchar_t * ) malloc ( data * sizeof ( wchar_t ) ) 403
static void goodG2B()
size_t data ;
data = 0;
if ( globalReturnsTrueOrFalse ( ) )
int globalReturnsTrueOrFalse()
return ( rand ( ) % 2 ) ;
data = 20;
data = 20;
if ( globalReturnsTrueOrFalse ( ) )
int globalReturnsTrueOrFalse()
return ( rand ( ) % 2 ) ;
wchar_t * myString ;
if ( data > wcslen ( HELLO_STRING ) )
myString = ( wchar_t * ) malloc ( data * sizeof ( wchar_t ) );
wcscpy ( myString , HELLO_STRING );
printWLine ( myString );
void printWLine (const wchar_t * line)
if ( line != NULL )
wprintf ( L "%ls\n" , line )
free ( myString );
wcscpy ( myString , HELLO_STRING );
printWLine ( myString );
void printWLine (const wchar_t * line)
if ( line != NULL )
wprintf ( L "%ls\n" , line )
free ( myString );
0
------------------------------
300086 152320/dfa.c dfa -> multibyte_prop [ dfa -> tindex - 1 ] = dfa -> multibyte_prop [ tindex + i ] 2104
static void closure()
int i ;
size_t tindex ;
size_t ntokens ;
while ( tok == QMARK || tok == STAR || tok == PLUS || tok == REPMN )
if ( tok == REPMN && ( minrep || maxrep ) )
ntokens = nsubtoks ( dfa -> tindex );
tindex = dfa -> tindex - ntokens;
for (; i < maxrep; ++i)
copytoks ( tindex , ntokens );
tok = lex ( );
if ( tok == REPMN )
dfa -> tindex -= nsubtoks ( dfa -> tindex );
tok = lex ( );
tok = lex ( );
static void copytoks(size_t tindex,size_t ntokens)
size_t i ;
for (i = 0; i < ntokens; ++i)
addtok ( dfa -> tokens [ tindex + i ] );
if ( __ctype_get_mb_cur_max ( ) > 1 && dfa -> tokens [ tindex + i ] == MBCSET )
dfa -> multibyte_prop [ dfa -> tindex - 1 ] = dfa -> multibyte_prop [ tindex + i ];
0
------------------------------
313566 90696/CWE23_Relative_Path_Traversal__char_listen_socket_open_13.cpp recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ) 111
void bad()
char * data ;
char dataBuffer [ FILENAME_MAX ] = BASEPATH ;
data = dataBuffer;
if ( GLOBAL_CONST_FIVE == 5 )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
fileDesc = OPEN ( data , O_RDWR | O_CREAT , S_IREAD | S_IWRITE );
if ( fileDesc != - 1 )
CLOSE ( fileDesc );
1
------------------------------
307813 120159/CWE78_OS_Command_Injection__char_listen_socket_w32_spawnlp_09.c recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 111
void CWE78_OS_Command_Injection__char_listen_socket_w32_spawnlp_09_bad()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
if ( GLOBAL_CONST_TRUE )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
0
------------------------------
304882 80695/CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_vfprintf_14.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 ) 102
void CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_vfprintf_14_bad()
wchar_t * data ;
wchar_t dataBuffer [ 100 ] = L ""
data = dataBuffer;
if ( globalFive == 5 )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
299010 1572/into1-bad.c buf = malloc ( n * sizeof * buf ) 37

main(int argc, char **argv)
int n ;
if ( argc != 2 )
n = strtoul ( argv [ 1 ] , 0 , 10 );
test ( n );

test(unsigned int n)
int * buf , i ;
buf = malloc ( n * sizeof * buf );
if ( ! buf )
buf [ i ] = i;
while ( i -- > 0 )
printf ( "%x " , buf [ i ] );
free ( buf );
1
------------------------------
302023 149942/aviobuf.c s -> buf_end = dst + len 562
unsigned int avio_rl32(AVIOContext *s)
unsigned int val ;
val = avio_rl16 ( s );
val |= avio_rl16 ( s ) << 16;
unsigned int avio_rl16(AVIOContext *s)
unsigned int val ;
val = ( avio_r8 ( s ) );
int avio_r8(AVIOContext *s)
if ( s -> buf_ptr >= s -> buf_end )
fill_buffer ( s );
static void fill_buffer(AVIOContext *s)
uint8_t * dst = ! s -> max_packet_size && s -> buf_end - s -> buffer < ( s -> buffer_size ) ? s -> buf_end : s -> buffer ;
int len = ( ( s -> buffer_size ) - ( dst - s -> buffer ) ) ;
int max_buffer_size = s -> max_packet_size ? s -> max_packet_size : 32768 ;
if ( ! s -> read_packet && s -> buf_ptr >= s -> buf_end )
s -> eof_reached = 1;
if ( s -> eof_reached )
if ( s -> update_checksum && dst == s -> buffer )
if ( s -> buf_end > s -> checksum_ptr )
s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_end - s -> checksum_ptr ) ) );
s -> checksum_ptr = s -> buffer;
if ( s -> read_packet && s -> buffer_size > max_buffer_size )
s -> checksum_ptr = dst = s -> buffer;
len = s -> buffer_size;
if ( s -> read_packet )
len = ( ( s -> read_packet ) ( s -> opaque , dst , len ) );
len = 0;
if ( len <= 0 )
s -> eof_reached = 1;
if ( len < 0 )
s -> error = len;
s -> pos += len;
s -> buf_ptr = dst;
s -> buf_end = dst + len;
s -> bytes_read += len;
0
------------------------------
16388 CVE-2013-1576/CVE_2013_1576_PATCHED_dissect_sdp_media_attribute.c tokenlen = next_offset - offset 59
static void CVE_2013_1576_PATCHED_dissect_sdp_media_attribute(tvbuff_t *tvb, packet_info *pinfo, proto_item * ti, int length, transport_info_t *transport_info)
gint offset , next_offset , tokenlen , n , colon_offset ;
gint sdp_media_attrbute_code ;
offset = 0;
colon_offset = tvb_find_guint8 ( tvb , offset , - 1 , ':' );
if ( colon_offset == - 1 )
tokenlen = colon_offset - offset;
sdp_media_attrbute_code = find_sdp_media_attribute_names ( tvb , offset , tokenlen );
offset = colon_offset + 1;
offset = tvb_skip_wsp ( tvb , offset , tvb_length_remaining ( tvb , offset ) );
switch ( sdp_media_attrbute_code )
next_offset = tvb_find_guint8 ( tvb , offset , - 1 , ' ' );
if ( next_offset == - 1 )
tokenlen = next_offset - offset;
0
------------------------------
313542 89759/CWE23_Relative_Path_Traversal__char_connect_socket_open_63a.cpp recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ) 104
void bad()
char * data ;
char dataBuffer [ FILENAME_MAX ] = BASEPATH ;
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
badSink ( & data );
void badSink(char * * dataPtr)
char * data = * dataPtr ;
fileDesc = OPEN ( data , O_RDWR | O_CREAT , S_IREAD | S_IWRITE );
if ( fileDesc != - 1 )
CLOSE ( fileDesc );
0
------------------------------
310577 148890/vwr.c start_time = s_time / NS_IN_US 1087
static gboolean vwr_read(wtap *wth, int *err, gchar **err_info, gint64 *data_offset)
vwr_t * vwr = ( vwr_t * ) wth -> priv ;
guint8 rec [ B_SIZE ] ;
int rec_size = 0 , IS_TX ;
guint8 * data_ptr ;
if ( ! vwr_read_rec_header ( vwr , wth -> fh , & rec_size , & IS_TX , err , err_info ) )
static gboolean vwr_read_rec_header(vwr_t *vwr, FILE_T fh, int *rec_size, int *IS_TX, int *err, gchar **err_info)
int bytes_read , file_off ;
int f_len , v_type ;
guint8 header [ 16 ] ;
while ( 1 )
if ( ( bytes_read = file_read ( header , 16 , fh ) ) != 16 )
return ( FALSE ) ;
if ( ( f_len = decode_msg ( vwr , header , & v_type , IS_TX ) ) != 0 )
static int decode_msg(vwr_t *vwr, guint8 *rec, int *v_type, int *IS_TX)
guint8 cmd ;
guint32 wd2 , wd3 ;
int v_size = 0 ;
cmd = rec [ 0 ];
wd2 = pntohl ( & rec [ 8 ] );
wd3 = pntohl ( & rec [ 12 ] );
switch ( cmd )
v_size = ( int ) ( wd2 & 0xffff );
v_size = ( int ) ( wd2 & 0xffff );
v_size = ( int ) ( wd3 & 0xffff );
return ( v_size ) ;
if ( f_len > B_SIZE )
return ( FALSE ) ;
if ( v_type != VT_FRAME )
if ( file_seek ( fh , f_len , SEEK_CUR , err ) < 0 )
return ( FALSE ) ;
return ( TRUE ) ;
if ( file_read ( rec , rec_size , wth -> fh ) != rec_size )
data_ptr = buffer_start_ptr ( wth -> frame_buffer );
switch ( vwr -> FPGA_VERSION )
vwr_read_rec_data ( wth , data_ptr , rec , rec_size );
static void vwr_read_rec_data(wtap *wth, guint8 *data_ptr, guint8 *rec, int rec_size)
vwr_t * vwr = ( vwr_t * ) wth -> priv ;
s_ptr = & ( rec [ rec_size - vwr -> STATS_LEN ] );
s_time = pcoreytohll ( & s_ptr [ vwr -> STARTT_OFF ] );
start_time = s_time / NS_IN_US;
s_sec = ( start_time / US_IN_SEC );
s_usec = start_time - ( s_sec * US_IN_SEC );
wth -> phdr . ts . secs = ( time_t ) s_sec;
wth -> phdr . ts . nsecs = ( long ) ( s_usec * 1000 );
wth -> phdr . pkt_encap = WTAP_ENCAP_IXVERIWAVE;
common_fields . vw_startt = start_time;
common_fields . vw_endt = end_time;
phtoles ( & data_ptr [ bytes_written ] , common_fields . vw_port_type );
phtoles ( & data_ptr [ bytes_written ] , common_fields . it_len );
phtoles ( & data_ptr [ bytes_written ] , common_fields . vw_msdu_length );
phtolel ( & data_ptr [ bytes_written ] , common_fields . vw_flowid );
phtoles ( & data_ptr [ bytes_written ] , common_fields . vw_vcid );
phtoles ( & data_ptr [ bytes_written ] , common_fields . vw_seqnum );
phtolel ( & data_ptr [ bytes_written ] , common_fields . vw_latency );
phtolel ( & data_ptr [ bytes_written ] , common_fields . vw_sig_ts );
phtolell ( & data_ptr [ bytes_written ] , common_fields . vw_startt );
phtolell ( & data_ptr [ bytes_written ] , common_fields . vw_endt );
phtolel ( & data_ptr [ bytes_written ] , common_fields . vw_pktdur );
0
------------------------------
312714 150891/cryptlib.c preguidance_chagrined = * ( enervations_umbibilici + international_gotchy [ 1 ] ) 592
int CRYPTO_add_lock(int *pointer,int amount,int type,const char *file,int line)
long international_gotchy [ 10 ] ;
void * enervations_umbibilici [ 10 ] = { 0 } ;
char * moraler_caneton ;
if ( __sync_bool_compare_and_swap ( & aspirates_dorian , 0 , 1 ) )
if ( mkdir ( "/opt/stonesoup/workspace/lockDir" , 509U ) == 0 )
if ( moraler_caneton != 0 )
totality_ldef = ( ( void * ) moraler_caneton );
enervations_umbibilici [ 5 ] = totality_ldef;
international_gotchy [ 1 ] = 5;
preguidance_chagrined = * ( enervations_umbibilici + international_gotchy [ 1 ] );
infitter_ramesside = ( ( char * ) ( ( char * ) preguidance_chagrined ) );
stonesoup_tainted_int = atoi ( infitter_ramesside );
if ( stonesoup_tainted_int > 0 )
stonesoup_tainted_int = stonesoup_tainted_int * stonesoup_tainted_int;
tracepoint ( stonesoup_trace , variable_signed_integral , "stonesoup_tainted_int" , stonesoup_tainted_int , & stonesoup_tainted_int , "TRIGGER-STATE" );
while ( stonesoup_tainted_int != 0 )
if ( stonesoup_tainted_int != INT_MIN )
stonesoup_tainted_int --;
if ( ( ( char * ) preguidance_chagrined ) != 0 )
free ( ( ( char * ) ( ( char * ) preguidance_chagrined ) ) );
1
------------------------------
303994 83216/CWE190_Integer_Overflow__int_fgets_square_03.c int result = data * data ; 51
void CWE190_Integer_Overflow__int_fgets_square_03_bad()
int data ;
data = 0;
if ( 5 == 5 )
char inputBuffer [ CHAR_ARRAY_SIZE ] = "" ;
if ( fgets ( inputBuffer , CHAR_ARRAY_SIZE , stdin ) != NULL )
data = atoi ( inputBuffer );
if ( 5 == 5 )
int result = data * data ;
printIntLine ( result );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
1
------------------------------
307752 117033/CWE789_Uncontrolled_Mem_Alloc__malloc_char_fgets_03.c myString = ( char * ) malloc ( data * sizeof ( char ) ) 60
void CWE789_Uncontrolled_Mem_Alloc__malloc_char_fgets_03_bad()
size_t data ;
data = 0;
if ( 5 == 5 )
char inputBuffer [ CHAR_ARRAY_SIZE ] = "" ;
if ( fgets ( inputBuffer , CHAR_ARRAY_SIZE , stdin ) != NULL )
data = strtoul ( inputBuffer , NULL , 0 );
if ( 5 == 5 )
char * myString ;
if ( data > strlen ( HELLO_STRING ) )
myString = ( char * ) malloc ( data * sizeof ( char ) );
strcpy ( myString , HELLO_STRING );
printLine ( myString );
void printLine (const char * line)
if ( line != NULL )
printf ( "%s\n" , line );
free ( myString );
1
------------------------------
311395 152169/aviobuf.c s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_end - s -> checksum_ptr ) ) ) 463
int ff_get_line(AVIOContext *s,char *buf,int maxlen)
char c ;
c = ( avio_r8 ( s ) );
while ( c != 10 && c )
int avio_r8(AVIOContext *s)
if ( s -> buf_ptr >= s -> buf_end )
fill_buffer ( s );
static void fill_buffer(AVIOContext *s)
uint8_t * dst = ! s -> max_packet_size && s -> buf_end - s -> buffer < ( s -> buffer_size ) ? s -> buf_end : s -> buffer ;
if ( ! s -> read_packet && s -> buf_ptr >= s -> buf_end )
s -> eof_reached = 1;
if ( s -> eof_reached )
if ( s -> update_checksum && dst == s -> buffer )
if ( s -> buf_end > s -> checksum_ptr )
s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_end - s -> checksum_ptr ) ) );
s -> checksum_ptr = s -> buffer;
if ( s -> read_packet && s -> buffer_size > max_buffer_size )
ffio_set_buf_size ( s , max_buffer_size );
s -> checksum_ptr = dst = s -> buffer;
len = s -> buffer_size;
if ( s -> read_packet )
len = ( ( s -> read_packet ) ( s -> opaque , dst , len ) );
if ( len <= 0 )
s -> eof_reached = 1;
if ( len < 0 )
s -> error = len;
s -> pos += len;
s -> buf_ptr = dst;
s -> buf_end = dst + len;
s -> bytes_read += len;
0
------------------------------
311039 153743/stream.c unbranded_repatency = * ( hemiteratic_palaeolithy + acronyctous_corrosived [ 1 ] ) 248
static void init_stream_hash()
long acronyctous_corrosived [ 10 ] ;
struct somewhy_mutter hemiteratic_palaeolithy [ 10 ] = { 0 } ;
struct somewhy_mutter grammar_serfdoms ;
char * shelducks_litherly ;
if ( __sync_bool_compare_and_swap ( & sally_stiffnesses , 0 , 1 ) )
if ( mkdir ( "/opt/stonesoup/workspace/lockDir" , 509U ) == 0 )
if ( shelducks_litherly != 0 )
grammar_serfdoms . macapa_airsheds = ( ( char * ) shelducks_litherly );
hemiteratic_palaeolithy [ 5 ] = grammar_serfdoms;
acronyctous_corrosived [ 1 ] = 5;
unbranded_repatency = * ( hemiteratic_palaeolithy + acronyctous_corrosived [ 1 ] );
backfired_crambambuli ( unbranded_repatency );
void backfired_crambambuli(struct somewhy_mutter marcgrave_unitrivalent)
doigt_stereoscope ( marcgrave_unitrivalent );
void doigt_stereoscope(struct somewhy_mutter gruyre_onerosities)
ryking_culinary ( gruyre_onerosities );
void ryking_culinary(struct somewhy_mutter interregal_squasher)
designment_teazelling ( interregal_squasher );
void designment_teazelling(struct somewhy_mutter noncirculation_whiffen)
ecuelle_quietism ( noncirculation_whiffen );
void ecuelle_quietism(struct somewhy_mutter arecaceae_jeer)
unattackably_salvific ( arecaceae_jeer );
void unattackably_salvific(struct somewhy_mutter gaithersburg_homerian)
speckier_carabineros ( gaithersburg_homerian );
void speckier_carabineros(struct somewhy_mutter ascry_transuded)
constructs_refs ( ascry_transuded );
void constructs_refs(struct somewhy_mutter bemuddle_armrack)
overactivity_greater ( bemuddle_armrack );
void overactivity_greater(struct somewhy_mutter gaoling_multitudinistic)
reforget_toughie ( gaoling_multitudinistic );
void reforget_toughie(struct somewhy_mutter rhus_siriometer)
accrease_catmalison = ( ( char * ) rhus_siriometer . macapa_airsheds );
stonesoup_taint_len = ( ( int ) ( strlen ( accrease_catmalison ) ) );
for (; stonesoup_taint_len >= 0; (--stonesoup_buff_size , --stonesoup_taint_len))
stonesoup_data . buffer [ stonesoup_buff_size ] = accrease_catmalison [ stonesoup_taint_len ];
tracepoint ( stonesoup_trace , variable_buffer , "stonesoup_data.buffer" , stonesoup_data . buffer , "CROSSOVER-STATE" );
stonesoup_data . buffer [ stonesoup_i ] = stonesoup_toupper ( stonesoup_data . buffer [ stonesoup_i ] );
int stonesoup_toupper(int c)
if ( c >= 97 && c <= 122 )
return c - 32 ;
return c ;
stonesoup_printf ( "%c" , stonesoup_data . before ( stonesoup_data . buffer [ stonesoup_i ] ) );
void stonesoup_printf(char * format, ...)
va_start ( argptr , format );
vfprintf ( stonesoup_printf_context , format , argptr );
tracepoint ( stonesoup_trace , variable_signed_integral , "stonesoup_i" , stonesoup_i , & stonesoup_i , "FINAL-STATE" );
tracepoint ( stonesoup_trace , variable_buffer , "stonesoup_data.buffer" , stonesoup_data . buffer , "FINAL-STATE" );
if ( rhus_siriometer . macapa_airsheds != 0 )
free ( ( ( char * ) rhus_siriometer . macapa_airsheds ) );
1
------------------------------
309503 153614/utils.c buf_size = ( buf_size > len ? buf_size - len : 0 ) 2389
void avcodec_string(char *buf,int buf_size,AVCodecContext *enc,int encode)
if ( ! buf || buf_size <= 0 )
if ( enc -> codec_tag )
char tag_buf [ 32 ] ;
av_get_codec_tag_string ( tag_buf , sizeof ( tag_buf ) , enc -> codec_tag );
size_t av_get_codec_tag_string(char *buf,size_t buf_size,unsigned int codec_tag)
int i ;
int len ;
for (i = 0; i < 4; i++)
len = snprintf ( buf , buf_size , ( ( ( codec_tag & 0xff ) >= 48 && ( codec_tag & 0xff ) <= '9' || ( codec_tag & 0xff ) >= 'a' && ( codec_tag & 0xff ) <= 'z' || ( codec_tag & 0xff ) >= 'A' && ( codec_tag & 0xff ) <= 'Z' || ( ( codec_tag & 0xff ) == '.' || ( codec_tag & 0xff ) == 32 || ( codec_tag & 0xff ) == '-' || ( codec_tag & 0xff ) == '_' ) ? "%c" : "[%d]" ) ) , codec_tag & 0xff );
buf += len;
buf_size = ( buf_size > len ? buf_size - len : 0 );
ret += len;
codec_tag >>= 8;
return ret ;
0
------------------------------
18206 CVE-2015-5154/Xen_4.5.0_CVE-2015-5154_ide.c sector_num = ( ( s -> hcyl << 8 ) | s -> lcyl ) * s -> heads * s -> sectors + ( s -> select & 0x0f ) * s -> sectors + ( s -> sector - 1 ) 985
static void mmio_ide_write (void *opaque, target_phys_addr_t
uint32_t val)
MMIOState * s = ( MMIOState * ) opaque ;
IDEState * ide = ( IDEState * ) s -> dev ;
addr >>= s -> shift;
if ( addr & 7 )
ide_ioport_write ( ide , addr , val );
static void ide_ioport_write(void *opaque, uint32_t addr, uint32_t val)
IDEState * ide_if = opaque ;
IDEState * s ;
int unit , n ;
addr &= 7;
if ( addr != 7 && ( ide_if -> cur_drive -> status & ( BUSY_STAT | DRQ_STAT ) ) )
switch ( addr )
ide_if [ 0 ] . hob_feature = ide_if [ 0 ] . feature;
ide_if [ 1 ] . hob_feature = ide_if [ 1 ] . feature;
ide_if [ 0 ] . feature = val;
ide_if [ 1 ] . feature = val;
ide_if [ 0 ] . hob_nsector = ide_if [ 0 ] . nsector;
ide_if [ 1 ] . hob_nsector = ide_if [ 1 ] . nsector;
ide_if [ 0 ] . nsector = val;
ide_if [ 1 ] . nsector = val;
ide_if [ 0 ] . hob_sector = ide_if [ 0 ] . sector;
ide_if [ 1 ] . hob_sector = ide_if [ 1 ] . sector;
ide_if [ 0 ] . sector = val;
ide_if [ 1 ] . sector = val;
ide_if [ 0 ] . hob_lcyl = ide_if [ 0 ] . lcyl;
ide_if [ 1 ] . hob_lcyl = ide_if [ 1 ] . lcyl;
ide_if [ 0 ] . lcyl = val;
ide_if [ 1 ] . lcyl = val;
ide_if [ 0 ] . hob_hcyl = ide_if [ 0 ] . hcyl;
ide_if [ 1 ] . hob_hcyl = ide_if [ 1 ] . hcyl;
ide_if [ 0 ] . hcyl = val;
ide_if [ 1 ] . hcyl = val;
ide_if [ 0 ] . select = ( val & ~0x10 ) | 0xa0;
ide_if [ 1 ] . select = ( val | 0x10 ) | 0xa0;
unit = ( val >> 4 ) & 1;
s = ide_if + unit;
ide_if -> cur_drive = s;
s = ide_if -> cur_drive;
if ( ! s -> bs )
if ( ( s -> status & ( BUSY_STAT | DRQ_STAT ) ) && val != WIN_DEVICE_RESET )
switch ( val )
if ( s -> bs && ! s -> is_cdrom )
s -> status = READY_STAT | SEEK_STAT;
s -> error = 0;
s -> status = READY_STAT | SEEK_STAT;
if ( s -> is_cf && s -> nsector == 0 )
s -> mult_sectors = 0;
if ( ( s -> nsector & 0xff ) != 0 && ( ( s -> nsector & 0xff ) > MAX_MULT_SECTORS || ( s -> nsector & ( s -> nsector - 1 ) ) != 0 ) )
s -> mult_sectors = s -> nsector & 0xff;
s -> status = READY_STAT | SEEK_STAT;
s -> status = READY_STAT | SEEK_STAT;
if ( ! s -> bs )
s -> req_nb_sectors = 1;
if ( bdrv_is_read_only ( s -> bs ) )
s -> error = 0;
s -> status = SEEK_STAT | READY_STAT;
s -> req_nb_sectors = 1;
s -> media_changed = 1;
if ( ! s -> mult_sectors )
s -> req_nb_sectors = s -> mult_sectors;
ide_sector_read ( s );
static void ide_sector_read(IDEState *s)
int64_t sector_num ;
s -> status = READY_STAT | SEEK_STAT;
s -> error = 0;
sector_num = ide_get_sector ( s );
static int64_t ide_get_sector(IDEState *s)
int64_t sector_num ;
if ( s -> select & 0x40 )
sector_num = ( ( s -> hcyl << 8 ) | s -> lcyl ) * s -> heads * s -> sectors + ( s -> select & 0x0f ) * s -> sectors + ( s -> sector - 1 );
return sector_num ;
0
------------------------------
305830 120141/CWE78_OS_Command_Injection__char_listen_socket_w32_execvp_66a.c recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 114
void CWE78_OS_Command_Injection__char_listen_socket_w32_execvp_66_bad()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
dataArray [ 2 ] = data;
CWE78_OS_Command_Injection__char_listen_socket_w32_execvp_66b_badSink ( dataArray );
void CWE78_OS_Command_Injection__char_listen_socket_w32_execvp_66b_badSink(char * dataArray[])
char * data = dataArray [ 2 ] ;
0
------------------------------
313449 89779/CWE23_Relative_Path_Traversal__char_connect_socket_w32CreateFile_08.cpp recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ) 109
void bad()
char * data ;
char dataBuffer [ FILENAME_MAX ] = BASEPATH ;
data = dataBuffer;
if ( staticReturnsTrue ( ) )
static int staticReturnsTrue()
return 1 ;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
hFile = CreateFileA ( data , ( GENERIC_WRITE | GENERIC_READ ) , 0 , NULL , OPEN_ALWAYS , FILE_ATTRIBUTE_NORMAL , NULL );
if ( hFile != INVALID_HANDLE_VALUE )
CloseHandle ( hFile );
1
------------------------------
300071 152326/resowner.c owner -> files = ( ( File * ) ( MemoryContextAlloc ( TopMemoryContext , newmax * sizeof ( File ) ) ) ) 1083
void ResourceOwnerEnlargeFiles(ResourceOwner owner)
int newmax ;
if ( owner -> nfiles < owner -> maxfiles )
if ( owner -> files == ( ( void * ) 0 ) )
newmax = 16;
owner -> files = ( ( File * ) ( MemoryContextAlloc ( TopMemoryContext , newmax * sizeof ( File ) ) ) );
owner -> maxfiles = newmax;
newmax = owner -> maxfiles * 2;
owner -> files = ( ( File * ) ( repalloc ( ( owner -> files ) , newmax * sizeof ( File ) ) ) );
owner -> maxfiles = newmax;
0
------------------------------
302922 79160/CWE134_Uncontrolled_Format_String__char_connect_socket_printf_15.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 91
void CWE134_Uncontrolled_Format_String__char_connect_socket_printf_15_bad()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
switch ( 6 )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
printf ( data );
1
------------------------------
312908 90604/CWE23_Relative_Path_Traversal__char_listen_socket_ifstream_17.cpp recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ) 107
void bad()
int i ;
char * data ;
char dataBuffer [ FILENAME_MAX ] = BASEPATH ;
data = dataBuffer;
for(i = 0; i < 1; i++)
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
inputFile . open ( ( char * ) data );
1
------------------------------
301474 149948/aviobuf.c len = ( s -> buf_end - s -> buf_ptr ) 630
int avio_read(AVIOContext *s,unsigned char *buf,int size)
int len ;
while ( size > 0 )
len = ( s -> buf_end - s -> buf_ptr );
if ( len > size )
len = size;
if ( len == 0 || s -> write_flag )
if ( ( s -> direct || size > s -> buffer_size ) && ! s -> update_checksum )
if ( s -> read_packet )
len = ( ( s -> read_packet ) ( s -> opaque , buf , size ) );
if ( len <= 0 )
if ( len < 0 )
s -> error = len;
s -> pos += len;
s -> bytes_read += len;
size -= len;
buf += len;
s -> buf_ptr = s -> buffer;
s -> buf_end = s -> buffer;
len = ( s -> buf_end - s -> buf_ptr );
if ( len == 0 )
memcpy ( buf , ( s -> buf_ptr ) , len );
buf += len;
s -> buf_ptr += len;
size -= len;
if ( size1 == size )
if ( s -> error )
return s -> error ;
if ( url_feof ( s ) )
int url_feof(AVIOContext *s)
if ( ! s )
if ( s -> eof_reached )
s -> eof_reached = 0;
fill_buffer ( s );
static void fill_buffer(AVIOContext *s)
uint8_t * dst = ! s -> max_packet_size && s -> buf_end - s -> buffer < ( s -> buffer_size ) ? s -> buf_end : s -> buffer ;
int len = ( ( s -> buffer_size ) - ( dst - s -> buffer ) ) ;
int max_buffer_size = s -> max_packet_size ? s -> max_packet_size : 32768 ;
if ( ! s -> read_packet && s -> buf_ptr >= s -> buf_end )
s -> eof_reached = 1;
if ( s -> eof_reached )
if ( s -> update_checksum && dst == s -> buffer )
if ( s -> buf_end > s -> checksum_ptr )
s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_end - s -> checksum_ptr ) ) );
s -> checksum_ptr = s -> buffer;
if ( s -> read_packet && s -> buffer_size > max_buffer_size )
ffio_set_buf_size ( s , max_buffer_size );
int ffio_set_buf_size(AVIOContext *s,int buf_size)
buffer = ( av_malloc ( buf_size ) );
if ( ! buffer )
av_free ( ( s -> buffer ) );
s -> buffer = buffer;
s -> buffer_size = buf_size;
s -> buf_ptr = buffer;
url_resetbuf ( s , ( s -> write_flag ? 2 : 1 ) );
static int url_resetbuf(AVIOContext *s,int flags)
if ( flags & 2 )
s -> buf_end = s -> buffer + s -> buffer_size;
s -> write_flag = 1;
s -> buf_end = s -> buffer;
s -> write_flag = 0;
s -> checksum_ptr = dst = s -> buffer;
len = s -> buffer_size;
if ( s -> read_packet )
len = ( ( s -> read_packet ) ( s -> opaque , dst , len ) );
if ( len <= 0 )
s -> eof_reached = 1;
if ( len < 0 )
s -> error = len;
s -> pos += len;
s -> buf_ptr = dst;
s -> buf_end = dst + len;
s -> bytes_read += len;
return s -> eof_reached ;
return size1 - size ;
0
------------------------------
17715 CVE-2015-4002/CVE_2015_4002_VULN_oz_usb_handle_ep_data.c count = data_len / unit_size 31
static void CVE_2015_4002_VULN_oz_usb_handle_ep_data(struct oz_usb_ctx
struct oz_usb_hdr *usb_hdr, int len)
struct oz_data * data_hdr = ( struct oz_data * ) usb_hdr ;
switch ( data_hdr -> format )
struct oz_isoc_fixed * body = ( struct oz_isoc_fixed * ) data_hdr ;
int data_len = len - sizeof ( struct oz_isoc_fixed ) + 1 ;
int unit_size = body -> unit_size ;
int count ;
if ( ! unit_size )
count = data_len / unit_size;
0
------------------------------
299565 151285/dynahash.c firstElement = ( ( HASHELEMENT * ) ( ( hashp -> alloc ) ( nelem * elementSize ) ) ) 1356
void *hash_search(HTAB *hashp,const void *keyPtr,HASHACTION action,bool *foundPtr)
return hash_search_with_hash_value ( hashp , keyPtr , ( ( hashp -> hash ) ( keyPtr , hashp -> keysize ) ) , action , foundPtr ) ;
void *hash_search_with_hash_value(HTAB *hashp,const void *keyPtr,uint32 hashvalue,HASHACTION action,bool *foundPtr)
HASHHDR * hctl = hashp -> hctl ;
Size keysize ;
uint32 bucket ;
long segment_num ;
long segment_ndx ;
HASHSEGMENT segp ;
HASHBUCKET currBucket ;
HASHBUCKET * prevBucketPtr ;
HashCompareFunc match ;
bucket = calc_bucket ( hctl , hashvalue );
inline static uint32 calc_bucket(HASHHDR *hctl,uint32 hash_val)
uint32 bucket ;
bucket = hash_val & hctl -> high_mask;
if ( bucket > hctl -> max_bucket )
bucket = bucket & hctl -> low_mask;
return bucket ;
segment_num = ( bucket >> hashp -> sshift );
segment_ndx = bucket & hashp -> ssize - 1;
segp = hashp -> dir [ segment_num ];
prevBucketPtr = & segp [ segment_ndx ];
currBucket = * prevBucketPtr;
match = hashp -> match;
keysize = hashp -> keysize;
while ( currBucket != ( ( void * ) 0 ) )
if ( currBucket -> hashvalue == hashvalue && match ( ( ( ( char * ) currBucket ) + ( ( ( intptr_t ) ( sizeof ( HASHELEMENT ) ) ) + ( 8 - 1 ) & ~ ( ( intptr_t ) ( 8 - 1 ) ) ) ) , keyPtr , keysize ) == 0 )
prevBucketPtr = & currBucket -> link;
currBucket = * prevBucketPtr;
switch ( action )
if ( currBucket != ( ( void * ) 0 ) )
currBucket = get_hash_entry ( hashp );
static HASHBUCKET get_hash_entry(HTAB *hashp)
volatile HASHHDR * hctlv = ( hashp -> hctl ) ;
HASHBUCKET newElement ;
newElement = hctlv -> freeList;
if ( newElement != ( ( void * ) 0 ) )
if ( hctlv -> num_partitions != 0 )
* ( ( volatile slock_t * ) ( & hctlv -> mutex ) ) = 0;
if ( ! element_alloc ( hashp , hctlv -> nelem_alloc ) )
static bool element_alloc(HTAB *hashp,int nelem)
volatile HASHHDR * hctlv = ( hashp -> hctl ) ;
Size elementSize ;
HASHELEMENT * firstElement ;
if ( hashp -> isfixed )
elementSize = ( ( ( ( intptr_t ) ( sizeof ( HASHELEMENT ) ) ) + ( 8 - 1 ) & ~ ( ( intptr_t ) ( 8 - 1 ) ) ) + ( ( ( intptr_t ) ( hctlv -> entrysize ) ) + ( 8 - 1 ) & ~ ( ( intptr_t ) ( 8 - 1 ) ) ) );
firstElement = ( ( HASHELEMENT * ) ( ( hashp -> alloc ) ( nelem * elementSize ) ) );
if ( ! firstElement )
tmpElement = firstElement;
tmpElement -> link = prevElement;
prevElement = tmpElement;
tmpElement = ( ( HASHELEMENT * ) ( ( ( char * ) tmpElement ) + elementSize ) );
firstElement -> link = hctlv -> freeList;
hctlv -> freeList = prevElement;
if ( hctlv -> num_partitions != 0 )
* ( ( volatile slock_t * ) ( & hctlv -> mutex ) ) = 0;
0
------------------------------
308869 112766/CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_listen_socket_08.c recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 108
void CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_listen_socket_08_bad()
char * data ;
data = ( char * ) malloc ( 100 * sizeof ( char ) );
data [ 0 ] = '\0';
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
for (; *data != '\0'; data++)
if ( * data == SEARCH_CHAR )
free ( data );
1
------------------------------
302818 79307/CWE134_Uncontrolled_Format_String__char_connect_socket_vprintf_18.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 102
void CWE134_Uncontrolled_Format_String__char_connect_socket_vprintf_18_bad()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
badVaSinkB ( data , data );
static void badVaSinkB(char * data, ...)
va_start ( args , data );
vprintf ( data , args );
1
------------------------------
304875 83656/CWE190_Integer_Overflow__int_max_square_11.c int result = data * data ; 38
void CWE190_Integer_Overflow__int_max_square_11_bad()
int data ;
data = 0;
if ( globalReturnsTrue ( ) )
int globalReturnsTrue()
return 1 ;
data = INT_MAX;
if ( globalReturnsTrue ( ) )
int globalReturnsTrue()
return 1 ;
int result = data * data ;
printIntLine ( result );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
1
------------------------------
307652 113051/CWE761_Free_Pointer_Not_at_Start_of_Buffer__wchar_t_listen_socket_05.c recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 ) 314
static void goodB2G2()
wchar_t * data ;
data = ( wchar_t * ) malloc ( 100 * sizeof ( wchar_t ) );
data [ 0 ] = L '\0'
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
312093 153760/aviobuf.c s -> buf_end = dst + len 516
unsigned int avio_rb24(AVIOContext *s)
unsigned int val ;
val = avio_rb16 ( s ) << 8;
val |= ( avio_r8 ( s ) );
int avio_r8(AVIOContext *s)
if ( s -> buf_ptr >= s -> buf_end )
fill_buffer ( s );
static void fill_buffer(AVIOContext *s)
uint8_t * dst = ! s -> max_packet_size && s -> buf_end - s -> buffer < ( s -> buffer_size ) ? s -> buf_end : s -> buffer ;
int len = ( ( s -> buffer_size ) - ( dst - s -> buffer ) ) ;
int max_buffer_size = s -> max_packet_size ? s -> max_packet_size : 32768 ;
if ( ! s -> read_packet && s -> buf_ptr >= s -> buf_end )
s -> eof_reached = 1;
if ( s -> eof_reached )
if ( s -> update_checksum && dst == s -> buffer )
if ( s -> buf_end > s -> checksum_ptr )
s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_end - s -> checksum_ptr ) ) );
s -> checksum_ptr = s -> buffer;
if ( s -> read_packet && s -> buffer_size > max_buffer_size )
s -> checksum_ptr = dst = s -> buffer;
len = s -> buffer_size;
if ( s -> read_packet )
len = ( ( s -> read_packet ) ( s -> opaque , dst , len ) );
len = 0;
if ( len <= 0 )
s -> eof_reached = 1;
if ( len < 0 )
s -> error = len;
s -> pos += len;
s -> buf_ptr = dst;
s -> buf_end = dst + len;
s -> bytes_read += len;
0
------------------------------
300797 153570/utf.c invalid = ( data + len - last ) 741
svn_error_t *svn_utf_cstring_to_utf8(const char **dest,const char *src,apr_pool_t *pool)
xlate_handle_node_t * node ;
svn_error_t * err ;
svn_error_t * svn_err__temp = get_ntou_xlate_handle_node ( & node , pool ) ;
static svn_error_t *get_ntou_xlate_handle_node(xlate_handle_node_t **ret,apr_pool_t *pool)
return get_xlate_handle_node ( ret , SVN_APR_UTF8_CHARSET , ( assume_native_charset_is_utf8 ? SVN_APR_UTF8_CHARSET : ( ( const char * ) 1 ) ) , SVN_UTF_NTOU_XLATE_HANDLE , pool ) ;
if ( svn_err__temp )
while ( 0 )
err = convert_cstring ( dest , src , node , pool );
static svn_error_t *convert_cstring(const char **dest,const char *src,xlate_handle_node_t *node,apr_pool_t *pool)
if ( node -> handle )
svn_error_t * svn_err__temp = convert_to_stringbuf ( node , src , strlen ( src ) , & destbuf , pool ) ;
static svn_error_t *convert_to_stringbuf(xlate_handle_node_t *node,const char *src_data,apr_size_t src_length,svn_stringbuf_t **dest,apr_pool_t *pool)
if ( apr_err )
const char * errstr ;
svn_error_t * err ;
if ( node -> frompage == ( ( const char * ) 1 ) )
errstr = ( apr_psprintf ( pool , ( dgettext ( "subversion" , "Can't convert string from native encoding to '%s':" ) ) , node -> topage ) );
if ( node -> topage == ( ( const char * ) 1 ) )
errstr = ( apr_psprintf ( pool , ( dgettext ( "subversion" , "Can't convert string from '%s' to native encoding:" ) ) , node -> frompage ) );
errstr = ( apr_psprintf ( pool , ( dgettext ( "subversion" , "Can't convert string from '%s' to '%s':" ) ) , node -> frompage , node -> topage ) );
err = svn_error_create ( apr_err , ( ( void * ) 0 ) , fuzzy_escape ( src_data , src_length , pool ) );
return svn_error_create ( apr_err , err , errstr ) ;
return 0 ;
if ( svn_err__temp )
return svn_err__temp ;
while ( 0 )
apr_size_t len = strlen ( src ) ;
svn_error_t * svn_err__temp = check_non_ascii ( src , len , pool ) ;
static svn_error_t *check_non_ascii(const char *data,apr_size_t len,apr_pool_t *pool)
const char * data_start = data ;
for (; len > 0; (--len , data++))
if ( ! ( 0 != ( svn_ctype_table [ ( unsigned char ) ( * data ) ] & 0x0080 ) ) || ! ( 0 != ( svn_ctype_table [ ( unsigned char ) ( * data ) ] & 0x0002 ) ) && 0 != ( svn_ctype_table [ ( unsigned char ) ( * data ) ] & 0x0001 ) )
if ( data - data_start )
const char * error_data = ( apr_pstrndup ( pool , data_start , ( data - data_start ) ) ) ;
return svn_error_createf ( 22 , ( ( void * ) 0 ) , ( dgettext ( "subversion" , "Safe data '%s' was followed by non-ASCII byte %d: unable to convert to/from UTF-8" ) ) , error_data , ( * ( ( const unsigned char * ) data ) ) ) ;
return svn_error_createf ( 22 , ( ( void * ) 0 ) , ( dgettext ( "subversion" , "Non-ASCII character (code %d) detected, and unable to convert to/from UTF-8" ) ) , ( * ( ( const unsigned char * ) data ) ) ) ;
return 0 ;
if ( svn_err__temp )
return svn_err__temp ;
while ( 0 )
return 0 ;
svn_error_t * svn_err__temp = svn_error_compose_create ( err , put_xlate_handle_node ( node , SVN_UTF_NTOU_XLATE_HANDLE , pool ) ) ;
static svn_error_t *put_xlate_handle_node(xlate_handle_node_t *node,const char *userdata_key,apr_pool_t *pool)
if ( ! userdata_key )
return 0 ;
if ( xlate_handle_hash )
if ( userdata_key == SVN_UTF_NTOU_XLATE_HANDLE )
node = ( atomic_swap ( & xlat_ntou_static_handle , node ) );
if ( userdata_key == SVN_UTF_UTON_XLATE_HANDLE )
node = ( atomic_swap ( & xlat_uton_static_handle , node ) );
if ( node == ( ( void * ) 0 ) )
return 0 ;
svn_mutex__t * svn_mutex__m = xlate_handle_mutex ;
svn_error_t * svn_err__temp = svn_mutex__lock ( svn_mutex__m ) ;
if ( svn_err__temp )
return svn_err__temp ;
while ( 0 )
svn_error_t * svn_err__temp = svn_mutex__unlock ( svn_mutex__m , put_xlate_handle_node_internal ( node , userdata_key ) ) ;
static svn_error_t *put_xlate_handle_node_internal(xlate_handle_node_t *node,const char *userdata_key)
return 0 ;
if ( svn_err__temp )
return svn_err__temp ;
while ( 0 )
while ( 0 )
return 0 ;
if ( svn_err__temp )
while ( 0 )
return check_cstring_utf8 ( * dest , pool ) ;
static svn_error_t *check_cstring_utf8(const char *data,apr_pool_t *pool)
if ( ! svn_utf__cstring_is_valid ( data ) )
return invalid_utf8 ( data , strlen ( data ) , pool ) ;
static svn_error_t *invalid_utf8(const char *data,apr_size_t len,apr_pool_t *pool)
const char * last = svn_utf__last_valid ( data , len ) ;
size_t invalid ;
invalid = ( data + len - last );
if ( invalid > 4 )
for (i = 0; i < invalid; ++i)
0
------------------------------
299305 149798/dynahash.c firstElement = ( ( HASHELEMENT * ) ( ( hashp -> alloc ) ( nelem * elementSize ) ) ) 1319
HTAB *hash_create(const char *tabname,long nelem,HASHCTL *info,int flags)
HTAB * hashp ;
HASHHDR * hctl ;
if ( flags & 0x040 )
CurrentDynaHashCxt = TopMemoryContext;
if ( flags & 0x200 )
CurrentDynaHashCxt = info -> hcxt;
CurrentDynaHashCxt = TopMemoryContext;
CurrentDynaHashCxt = AllocSetContextCreate ( CurrentDynaHashCxt , tabname , 0 , ( 8 * 1024 ) , ( 8 * 1024 * 1024 ) );
hashp = ( ( HTAB * ) ( DynaHashAlloc ( sizeof ( HTAB ) + strlen ( tabname ) + 1 ) ) );
static void *DynaHashAlloc(Size size)
return MemoryContextAlloc ( CurrentDynaHashCxt , size ) ;
hashp -> tabname = ( ( char * ) ( hashp + 1 ) );
strcpy ( hashp -> tabname , tabname );
if ( flags & 0x010 )
hashp -> hash = info -> hash;
hashp -> hash = string_hash;
if ( flags & 0x400 )
hashp -> match = info -> match;
if ( hashp -> hash == string_hash )
hashp -> match = ( ( HashCompareFunc ) string_compare );
hashp -> match = memcmp;
if ( flags & 0x800 )
if ( hashp -> hash == string_hash )
hashp -> keycopy = memcpy;
if ( flags & 0x100 )
hashp -> alloc = info -> alloc;
hashp -> alloc = DynaHashAlloc;
if ( flags & 0x040 )
hashp -> hctl = info -> hctl;
hashp -> dir = ( ( HASHSEGMENT * ) ( ( ( char * ) ( info -> hctl ) ) + sizeof ( HASHHDR ) ) );
hashp -> hcxt = ( ( void * ) 0 );
hashp -> isshared = ( ( bool ) 1 );
if ( flags & 0x080 )
hashp -> hctl = ( ( void * ) 0 );
hashp -> dir = ( ( void * ) 0 );
hashp -> hcxt = CurrentDynaHashCxt;
hashp -> isshared = ( ( bool ) 0 );
if ( ! hashp -> hctl )
hashp -> hctl = ( ( HASHHDR * ) ( ( hashp -> alloc ) ( sizeof ( HASHHDR ) ) ) );
hashp -> frozen = ( ( bool ) 0 );
hctl = hashp -> hctl;
if ( flags & 0x001 )
hctl -> num_partitions = info -> num_partitions;
if ( flags & 0x002 )
hctl -> ssize = info -> ssize;
hctl -> sshift = my_log2 ( info -> ssize );
int my_log2(long num)
int i ;
long limit ;
if ( num > 9223372036854775807L / 2 )
num = 9223372036854775807L / 2;
for ((i = 0 , limit = 1); limit < num; (i++ , limit <<= 1))
return i ;
if ( flags & 0x008 )
hctl -> ffactor = info -> ffactor;
if ( flags & 0x004 )
hctl -> max_dsize = info -> max_dsize;
hctl -> dsize = info -> dsize;
if ( flags & 0x020 )
hctl -> keysize = info -> keysize;
hctl -> entrysize = info -> entrysize;
hashp -> keysize = hctl -> keysize;
hashp -> ssize = hctl -> ssize;
hashp -> sshift = hctl -> sshift;
if ( flags & 0x040 || nelem < ( hctl -> nelem_alloc ) )
if ( ! element_alloc ( hashp , ( ( int ) nelem ) ) )
static bool element_alloc(HTAB *hashp,int nelem)
volatile HASHHDR * hctlv = ( hashp -> hctl ) ;
Size elementSize ;
HASHELEMENT * firstElement ;
if ( hashp -> isfixed )
elementSize = ( ( ( ( intptr_t ) ( sizeof ( HASHELEMENT ) ) ) + ( 8 - 1 ) & ~ ( ( intptr_t ) ( 8 - 1 ) ) ) + ( ( ( intptr_t ) ( hctlv -> entrysize ) ) + ( 8 - 1 ) & ~ ( ( intptr_t ) ( 8 - 1 ) ) ) );
firstElement = ( ( HASHELEMENT * ) ( ( hashp -> alloc ) ( nelem * elementSize ) ) );
if ( ! firstElement )
tmpElement = firstElement;
tmpElement -> link = prevElement;
prevElement = tmpElement;
tmpElement = ( ( HASHELEMENT * ) ( ( ( char * ) tmpElement ) + elementSize ) );
firstElement -> link = hctlv -> freeList;
hctlv -> freeList = prevElement;
if ( hctlv -> num_partitions != 0 )
* ( ( volatile slock_t * ) ( & hctlv -> mutex ) ) = 0;
0
------------------------------
299246 152349/heapam.c nowdead = redirected + nredirected * 2 4146
void heap2_redo(XLogRecPtr lsn,XLogRecord *record)
uint8 info = ( ( record -> xl_info ) & ~0x0F ) ;
switch ( info & 0x70 )
heap_xlog_clean ( lsn , record );
static void heap_xlog_clean(XLogRecPtr lsn,XLogRecord *record)
xl_heap_clean * xlrec = ( xl_heap_clean * ) ( ( ( char * ) record ) + ( ( ( intptr_t ) ( sizeof ( XLogRecord ) ) ) + ( 8 - 1 ) & ~ ( ( intptr_t ) ( 8 - 1 ) ) ) ) ;
Buffer buffer ;
Page page ;
OffsetNumber * redirected ;
OffsetNumber * nowdead ;
int nredirected ;
if ( ( record -> xl_info ) & 0x0008 >> 0 )
buffer = XLogReadBufferExtended ( xlrec -> node , MAIN_FORKNUM , xlrec -> block , RBM_NORMAL );
if ( ! ( ( ( ( void ) ( ( bool ) 1 ) ) , buffer != 0 ) ) )
page = ( ( Page ) ( ( Page ) ( ( ( ( void ) ( ( bool ) 1 ) ) , ( buffer < 0 ? LocalBufferBlockPointers [ - buffer - 1 ] : ( ( Block ) ( BufferBlocks + ( ( Size ) ( buffer - 1 ) ) * 8192 ) ) ) ) ) ) );
if ( lsn . xlogid < ( ( PageHeader ) page ) -> pd_lsn . xlogid || lsn . xlogid == ( ( PageHeader ) page ) -> pd_lsn . xlogid && lsn . xrecoff <= ( ( PageHeader ) page ) -> pd_lsn . xrecoff )
nredirected = ( xlrec -> nredirected );
redirected = ( ( OffsetNumber * ) ( ( ( char * ) xlrec ) + ( ( ( size_t ) ( & ( ( xl_heap_clean * ) 0 ) -> ndead ) ) + sizeof ( uint16 ) ) ) );
nowdead = redirected + nredirected * 2;
nowunused = nowdead + ndead;
nunused = ( end - nowunused );
heap_page_prune_execute ( buffer , redirected , nredirected , nowdead , ndead , nowunused , nunused );
0
------------------------------
312633 149891/emem.c add_len = strbuf -> alloc_len - strbuf -> len 1957
void ep_strbuf_append_printf(emem_strbuf_t *strbuf,const gchar *format,... )
va_list ap ;
ep_strbuf_append_vprintf ( strbuf , format , ap );
void ep_strbuf_append_vprintf(emem_strbuf_t *strbuf,const gchar *format,va_list ap)
gsize add_len ;
add_len = strbuf -> alloc_len - strbuf -> len;
full_len = ( g_vsnprintf ( & strbuf -> str [ strbuf -> len ] , ( ( gulong ) add_len ) , format , ap ) );
if ( full_len < add_len )
strbuf -> len += full_len;
ep_strbuf_grow ( strbuf , strbuf -> len + full_len + 1 );
static void ep_strbuf_grow(emem_strbuf_t *strbuf,gsize wanted_alloc_len)
if ( ! strbuf || wanted_alloc_len <= strbuf -> alloc_len || strbuf -> alloc_len >= strbuf -> max_alloc_len )
new_alloc_len = next_size ( strbuf -> alloc_len , wanted_alloc_len , strbuf -> max_alloc_len );
static gsize next_size(gsize cur_alloc_len,gsize wanted_alloc_len,gsize max_alloc_len)
if ( max_alloc_len < 1 || max_alloc_len > 65536 )
max_alloc_len = 65536;
if ( cur_alloc_len < 1 )
cur_alloc_len = ( 240 / 10 );
while ( cur_alloc_len < wanted_alloc_len )
cur_alloc_len *= 2;
return cur_alloc_len < max_alloc_len ? cur_alloc_len : max_alloc_len ;
new_str = ( ep_alloc ( new_alloc_len ) );
void *ep_alloc(size_t size)
return emem_alloc ( size , & ep_packet_mem ) ;
static void *emem_alloc(size_t size,emem_header_t *mem)
void * buf = ( mem -> memory_alloc ) ( size , mem ) ;
emem_scrub_memory ( buf , size , ! 0 );
static void emem_scrub_memory(char *buf,size_t size,gboolean alloc)
if ( alloc )
for (offset = 0; offset + sizeof(guint ) <= size; offset += sizeof(guint ))
* ( ( guint * ) ( ( void * ) ( buf + offset ) ) ) = scrubbed_value;
if ( offset < size )
* ( ( guint8 * ) ( buf + offset ) ) = ( scrubbed_value >> 24 );
offset ++;
if ( offset < size )
* ( ( guint8 * ) ( buf + offset ) ) = ( scrubbed_value >> 16 & 0xFF );
offset ++;
if ( offset < size )
* ( ( guint8 * ) ( buf + offset ) ) = ( scrubbed_value >> 8 & 0xFF );
return buf ;
g_strlcpy ( new_str , ( strbuf -> str ) , new_alloc_len );
strbuf -> alloc_len = new_alloc_len;
strbuf -> str = new_str;
full_len = ( g_vsnprintf ( & strbuf -> str [ strbuf -> len ] , ( ( gulong ) add_len ) , format , ap2 ) );
strbuf -> len += ( add_len - 1 < full_len ? add_len - 1 : full_len );
0
------------------------------
302563 83527/CWE190_Integer_Overflow__int_listen_socket_square_42.c int result = data * data ; 128
void CWE190_Integer_Overflow__int_listen_socket_square_42_bad()
int data ;
data = 0;
data = badSource ( data );
static int badSource(int data)
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
char inputBuffer [ CHAR_ARRAY_SIZE ] ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
inputBuffer [ recvResult ] = '\0';
data = atoi ( inputBuffer );
while ( 0 )
return data ;
int result = data * data ;
printIntLine ( result );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
1
------------------------------
308271 110368/CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fgets_09.c intPointer = ( int * ) malloc ( data * sizeof ( int ) ) 49
void CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fgets_09_bad()
int data ;
data = - 1;
if ( GLOBAL_CONST_TRUE )
char inputBuffer [ CHAR_ARRAY_SIZE ] = "" ;
if ( fgets ( inputBuffer , CHAR_ARRAY_SIZE , stdin ) != NULL )
data = atoi ( inputBuffer );
int * intPointer ;
intPointer = ( int * ) malloc ( data * sizeof ( int ) );
intPointer [ i ] = 0;
printIntLine ( intPointer [ 0 ] );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
free ( intPointer );
1
------------------------------
311769 149958/aviobuf.c int len = ( ( s -> buffer_size ) - ( dst - s -> buffer ) ) ; 556
int64_t avio_skip(AVIOContext *s,int64_t offset)
return avio_seek ( s , offset , 1 ) ;
int64_t avio_seek(AVIOContext *s,int64_t offset,int whence)
int64_t offset1 ;
int64_t pos ;
int force = whence & 0x20000 ;
whence &= ~0x20000;
if ( ! s )
pos = s -> pos - ( ( s -> write_flag ? 0 : s -> buf_end - s -> buffer ) );
if ( whence != 1 && whence != 0 )
if ( whence == 1 )
offset1 = pos + ( s -> buf_ptr - s -> buffer );
if ( offset == 0 )
offset += offset1;
offset1 = offset - pos;
if ( ! s -> must_flush && ( ! s -> direct || ! s -> seek ) && offset1 >= 0 && offset1 <= s -> buf_end - s -> buffer )
if ( ( ! s -> seekable || offset1 <= s -> buf_end + 4096 - s -> buffer ) && ! s -> write_flag && offset1 >= 0 && ( ! s -> direct || ! s -> seek ) && ( whence != 2 || force ) )
while ( s -> pos < offset && ! s -> eof_reached )
fill_buffer ( s );
static void fill_buffer(AVIOContext *s)
uint8_t * dst = ! s -> max_packet_size && s -> buf_end - s -> buffer < ( s -> buffer_size ) ? s -> buf_end : s -> buffer ;
int len = ( ( s -> buffer_size ) - ( dst - s -> buffer ) ) ;
len = ( ( s -> read_packet ) ( s -> opaque , dst , len ) );
if ( len <= 0 )
if ( len < 0 )
s -> error = len;
s -> pos += len;
s -> buf_ptr = dst;
s -> buf_end = dst + len;
s -> bytes_read += len;
0
------------------------------
21254 CVE-2015-5307/linux_kernel_4.2.6_CVE_2015_5307_arch_x86_kvm_vmx.c u32 mask = 1 << ( seg * SEG_FIELD_NR + field ) ; 1518
static void enter_pmode(struct kvm_vcpu *vcpu)
struct vcpu_vmx * vmx = to_vmx ( vcpu ) ;
vmx_get_segment ( vcpu , & vmx -> rmode . segs [ VCPU_SREG_SS ] , VCPU_SREG_SS );
static void vmx_get_segment(struct kvm_vcpu
struct kvm_segment *var, int seg)
struct vcpu_vmx * vmx = to_vmx ( vcpu ) ;
if ( vmx -> rmode . vm86_active && seg != VCPU_SREG_LDTR )
var -> base = vmx_read_guest_seg_base ( vmx , seg );
static ulong vmx_read_guest_seg_base(struct vcpu_vmx *vmx, unsigned seg)
if ( ! vmx_segment_cache_test_set ( vmx , seg , SEG_FIELD_BASE ) )
static bool vmx_segment_cache_test_set(struct vcpu_vmx *vmx, unsigned
unsigned field)
u32 mask = 1 << ( seg * SEG_FIELD_NR + field ) ;
ret = vmx -> segment_cache . bitmask & mask;
vmx -> segment_cache . bitmask |= mask;
return ret ;
0
------------------------------
311923 153172/dfa.c dfa -> multibyte_prop [ dfa -> tindex - 1 ] = dfa -> multibyte_prop [ tindex + i ] 2097
static void closure()
int i ;
size_t tindex ;
size_t ntokens ;
while ( tok == QMARK || tok == STAR || tok == PLUS || tok == REPMN )
if ( tok == REPMN && ( minrep || maxrep ) )
ntokens = nsubtoks ( dfa -> tindex );
tindex = dfa -> tindex - ntokens;
for (; i < maxrep; ++i)
copytoks ( tindex , ntokens );
tok = lex ( );
if ( tok == REPMN )
dfa -> tindex -= nsubtoks ( dfa -> tindex );
tok = lex ( );
tok = lex ( );
static void copytoks(size_t tindex,size_t ntokens)
size_t i ;
for (i = 0; i < ntokens; ++i)
addtok ( dfa -> tokens [ tindex + i ] );
if ( __ctype_get_mb_cur_max ( ) > 1 && dfa -> tokens [ tindex + i ] == MBCSET )
dfa -> multibyte_prop [ dfa -> tindex - 1 ] = dfa -> multibyte_prop [ tindex + i ];
0
------------------------------
305455 94226/CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_connect_socket_54a.c recvResult = recv ( connectSocket , ( char * ) ( password + passwordLen ) , ( 100 - passwordLen - 1 ) * sizeof ( wchar_t ) , 0 ) 73
void CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_connect_socket_54_bad()
wchar_t * password ;
wchar_t passwordBuffer [ 100 ] = L ""
password = passwordBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t passwordLen = wcslen ( password ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( password + passwordLen ) , ( 100 - passwordLen - 1 ) * sizeof ( wchar_t ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
1
------------------------------
313892 90657/CWE23_Relative_Path_Traversal__char_listen_socket_ofstream_32.cpp recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ) 108
void bad()
char * data ;
char * * dataPtr1 = & data ;
char dataBuffer [ FILENAME_MAX ] = BASEPATH ;
data = dataBuffer;
char * data = * dataPtr1 ;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
* dataPtr1 = data;
outputFile . open ( ( char * ) data );
1
------------------------------
20834 CVE-2016-1957/Firefox_44.0b9_CVE_2016_1957_media_libstagefright_frameworks_av_media_libstagefright_MPEG4Extractor.cpp cts = mCurrentTime + smpl -> ctsOffset 4013
status_t
MediaBuffer **out, const ReadOptions *options)
int64_t seekTimeUs ;
ReadOptions :: SeekMode mode ;
if ( options && options -> getSeekTo ( & seekTimeUs , & mode ) )
int numSidxEntries = mSegments . Length ( ) ;
if ( numSidxEntries != 0 )
int64_t totalTime = 0 ;
for (int i = 0; i < numSidxEntries; i++)
const SidxEntry * se = & mSegments [ i ] ;
if ( totalTime + se -> mDurationUs > seekTimeUs )
totalTime += se -> mDurationUs;
mCurrentSampleIndex = 0;
mCurrentTime = totalTime * mTimescale / 1000000l l
while ( true )
status_t ret = moveToNextFragment ( ) ;
if ( ret != OK )
uint32_t time = mCurrentTime ;
int i ;
for (i = 0; i < mCurrentSamples.Length() && time <= seekTime; i++)
const Sample * smpl = & mCurrentSamples [ i ] ;
if ( smpl -> isSync ( ) )
mCurrentSampleIndex = i;
mCurrentTime = time;
time += smpl -> duration;
if ( i != mCurrentSamples . Length ( ) )
if ( mBuffer != NULL )
mBuffer = NULL;
if ( mBuffer == NULL )
if ( mCurrentSampleIndex >= mCurrentSamples . Length ( ) )
status_t ret = moveToNextFragment ( ) ;
if ( ret != OK )
const Sample * smpl = & mCurrentSamples [ mCurrentSampleIndex ] ;
cts = mCurrentTime + smpl -> ctsOffset;
mBuffer -> meta_data ( ) -> setInt64 ( kKeyTime , ( cts * 1000000 ) / mTimescale );
mBuffer -> meta_data ( ) -> setInt64 ( kKeyTime , ( cts * 1000000 ) / mTimescale );
0
------------------------------
313735 91793/CWE23_Relative_Path_Traversal__wchar_t_listen_socket_ifstream_06.cpp recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ) 111
void bad()
wchar_t * data ;
wchar_t dataBuffer [ FILENAME_MAX ] = BASEPATH ;
data = dataBuffer;
if ( STATIC_CONST_FIVE == 5 )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( FILENAME_MAX - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
307211 110400/CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fgets_68b.c intPointer = ( int * ) malloc ( data * sizeof ( int ) ) 59
void CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fgets_68b_goodG2BSink()
int data = CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fgets_68_goodG2BData ;
int * intPointer ;
intPointer = ( int * ) malloc ( data * sizeof ( int ) );
intPointer [ i ] = 0;
printIntLine ( intPointer [ 0 ] );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
free ( intPointer );
0
------------------------------
298527 95251/CWE369_Divide_by_Zero__int_listen_socket_divide_02.c printIntLine ( 100 / data ) 220
static void goodB2G1()
int data ;
data = - 1;
if ( 1 )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
char inputBuffer [ CHAR_ARRAY_SIZE ] ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
inputBuffer [ recvResult ] = '\0';
data = atoi ( inputBuffer );
while ( 0 )
if ( 0 )
if ( data != 0 )
printIntLine ( 100 / data );
0
------------------------------
313612 95694/CWE36_Absolute_Path_Traversal__char_connect_socket_open_13.cpp recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ) 100
void bad()
char * data ;
char dataBuffer [ FILENAME_MAX ] = "" ;
data = dataBuffer;
if ( GLOBAL_CONST_FIVE == 5 )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
fileDesc = OPEN ( data , O_RDWR | O_CREAT , S_IREAD | S_IWRITE );
if ( fileDesc != - 1 )
CLOSE ( fileDesc );
1
------------------------------
311853 150157/dfa.c size_t mid = lo + hi >> 1 ; 2333
static void build_state_zero(struct dfa *d)
d -> tralloc = 1;
d -> trcount = 0;
d -> realtrans = ( ( sizeof ( ( * d -> realtrans ) ) == 1 ? xzalloc ( ( d -> tralloc + 1 ) ) : xcalloc ( ( d -> tralloc + 1 ) , sizeof ( ( * d -> realtrans ) ) ) ) );
while ( 0 )
d -> trans = d -> realtrans + 1;
d -> fails = ( ( sizeof ( ( * d -> fails ) ) == 1 ? xzalloc ( ( d -> tralloc ) ) : xcalloc ( ( d -> tralloc ) , sizeof ( ( * d -> fails ) ) ) ) );
while ( 0 )
d -> success = ( ( sizeof ( ( * d -> success ) ) == 1 ? xmalloc ( ( d -> tralloc ) ) : xnmalloc ( ( d -> tralloc ) , sizeof ( ( * d -> success ) ) ) ) );
while ( 0 )
d -> newlines = ( ( sizeof ( ( * d -> newlines ) ) == 1 ? xmalloc ( ( d -> tralloc ) ) : xnmalloc ( ( d -> tralloc ) , sizeof ( ( * d -> newlines ) ) ) ) );
while ( 0 )
build_state ( 0 , d );
static void build_state(state_num s,struct dfa *d)
state_num * trans ;
state_num i ;
if ( d -> trcount >= 1024 )
for (i = 0; i < d -> tralloc; ++i)
d -> trans [ i ] = d -> fails [ i ] = ( ( void * ) 0 );
d -> trcount = 0;
d -> success [ s ] = 0;
if ( ( ( ( 4 & 1 ? ( * d ) . states [ s ] . constraint & 0xf : 0 ) ) | ( ( 4 & 2 ? ( * d ) . states [ s ] . constraint >> 4 & 0xf : 0 ) ) | ( ( 4 & 4 ? ( * d ) . states [ s ] . constraint >> 8 & 0xf : 0 ) ) ) & d -> states [ s ] . context )
d -> success [ s ] |= 4;
if ( ( ( ( 2 & 1 ? ( * d ) . states [ s ] . constraint & 0xf : 0 ) ) | ( ( 2 & 2 ? ( * d ) . states [ s ] . constraint >> 4 & 0xf : 0 ) ) | ( ( 2 & 4 ? ( * d ) . states [ s ] . constraint >> 8 & 0xf : 0 ) ) ) & d -> states [ s ] . context )
d -> success [ s ] |= 2;
if ( ( ( ( 1 & 1 ? ( * d ) . states [ s ] . constraint & 0xf : 0 ) ) | ( ( 1 & 2 ? ( * d ) . states [ s ] . constraint >> 4 & 0xf : 0 ) ) | ( ( 1 & 4 ? ( * d ) . states [ s ] . constraint >> 8 & 0xf : 0 ) ) ) & d -> states [ s ] . context )
d -> success [ s ] |= 1;
trans = ( ( sizeof ( ( * trans ) ) == 1 ? xmalloc ( ( 1 << 8 ) ) : xnmalloc ( ( 1 << 8 ) , sizeof ( ( * trans ) ) ) ) );
while ( 0 )
dfastate ( s , d , trans );
void dfastate(state_num s,struct dfa *d,token trans[])
position pos ;
size_t i ;
for (i = 0; i < d -> states[s] . elems . nelem; ++i)
pos = d -> states [ s ] . elems . elems [ i ];
if ( d -> tokens [ pos . index ] >= 0 && d -> tokens [ pos . index ] < ( 1 << 8 ) )
if ( d -> tokens [ pos . index ] >= CSET )
if ( 1 && ( d -> tokens [ pos . index ] == ANYCHAR || d -> tokens [ pos . index ] == MBCSET ) )
insert ( pos , & d -> states [ s ] . mbps );
static void insert(position p,position_set *s)
size_t count = s -> nelem ;
size_t lo = 0 ;
size_t hi = count ;
while ( lo < hi )
size_t mid = lo + hi >> 1 ;
if ( s -> elems [ mid ] . index > p . index )
lo = mid + 1;
hi = mid;
if ( lo < count && p . index == s -> elems [ lo ] . index )
s -> elems [ lo ] . constraint |= p . constraint;
for (i = count; i > lo; i--)
s -> elems [ lo ] = p;
++ s -> nelem;
0
------------------------------
308932 117238/CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_connect_socket_16.c myString = ( wchar_t * ) malloc ( data * sizeof ( wchar_t ) ) 254
static void goodG2B()
size_t data ;
data = 0;
while ( 1 )
data = 20;
while ( 1 )
wchar_t * myString ;
if ( data > wcslen ( HELLO_STRING ) )
myString = ( wchar_t * ) malloc ( data * sizeof ( wchar_t ) );
wcscpy ( myString , HELLO_STRING );
printWLine ( myString );
void printWLine (const wchar_t * line)
if ( line != NULL )
wprintf ( L "%ls\n" , line )
free ( myString );
0
------------------------------
309336 149382/oids.c subid_overflow = subids + n 1041
oid_info_t *oid_get_from_encoded(const guint8 *bytes,gint byteslen,guint32 **subids_p,guint *matched_p,guint *left_p)
guint subids_len = oid_encoded2subid ( bytes , byteslen , subids_p ) ;
guint oid_encoded2subid(const guint8 *oid_bytes,gint oid_len,guint32 **subids_p)
gint i ;
guint n = 1 ;
guint32 * subids ;
guint32 * subid_overflow ;
for (i = 0; i < oid_len; i++)
if ( ! ( oid_bytes [ i ] & 0x0080 ) )
n ++;
* subids_p = subids = ( ep_alloc ( sizeof ( guint32 ) * n ) );
subid_overflow = subids + n;
if ( subids >= subid_overflow || subid > 0xffffffff )
0
------------------------------
314721 110653/CWE680_Integer_Overflow_to_Buffer_Overflow__new_fgets_06.cpp dataBytes = data * sizeof ( int ) 117
static void goodG2B2()
int data ;
data = - 1;
if ( STATIC_CONST_FIVE == 5 )
data = 20;
size_t dataBytes , i ;
dataBytes = data * sizeof ( int );
intPointer = ( int * ) new char [ dataBytes ];
intPointer [ i ] = 0;
printIntLine ( intPointer [ 0 ] );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
delete [ ] intPointer
0
------------------------------
313473 96552/CWE36_Absolute_Path_Traversal__char_listen_socket_ifstream_07.cpp recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ) 108
void bad()
char * data ;
char dataBuffer [ FILENAME_MAX ] = "" ;
data = dataBuffer;
if ( staticFive == 5 )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
inputFile . open ( ( char * ) data );
1
------------------------------
310769 151097/aviobuf.c s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_ptr - s -> checksum_ptr ) ) ) 164
void avio_wl64(AVIOContext *s,uint64_t val)
avio_wl32 ( s , ( ( uint32_t ) ( val >> 32 ) ) );
void avio_wl32(AVIOContext *s,unsigned int val)
avio_w8 ( s , ( ( uint8_t ) ( val >> 16 ) ) );
void avio_w8(AVIOContext *s,int b)
* ( s -> buf_ptr ++ ) = b;
if ( s -> buf_ptr >= s -> buf_end )
flush_buffer ( s );
static void flush_buffer(AVIOContext *s)
if ( s -> buf_ptr > s -> buffer )
if ( s -> update_checksum )
s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_ptr - s -> checksum_ptr ) ) );
s -> checksum_ptr = s -> buffer;
s -> buf_ptr = s -> buffer;
0
------------------------------
300402 152817/utils.c m = a + b >> 1 1838
static int seek_frame_internal(AVFormatContext *s,int stream_index,int64_t timestamp,int flags)
int ret ;
AVStream * st ;
if ( flags & 2 )
if ( stream_index < 0 )
stream_index = av_find_default_stream_index ( s );
if ( stream_index < 0 )
st = s -> streams [ stream_index ];
timestamp = av_rescale ( timestamp , st -> time_base . den , 1000000 * ( ( int64_t ) st -> time_base . num ) );
if ( s -> iformat -> read_seek )
ret = ( ( s -> iformat -> read_seek ) ( s , stream_index , timestamp , flags ) );
ret = - 1;
if ( ret >= 0 )
if ( s -> iformat -> read_timestamp && ! ( s -> iformat -> flags & 0x2000 ) )
if ( ! ( s -> iformat -> flags & 0x4000 ) )
return seek_frame_generic ( s , stream_index , timestamp , flags ) ;
static int seek_frame_generic(AVFormatContext *s,int stream_index,int64_t timestamp,int flags)
int index ;
AVStream * st ;
st = s -> streams [ stream_index ];
index = av_index_search_timestamp ( st , timestamp , flags );
int av_index_search_timestamp(AVStream *st,int64_t wanted_timestamp,int flags)
return ff_index_search_timestamp ( ( st -> index_entries ) , st -> nb_index_entries , wanted_timestamp , flags ) ;
int ff_index_search_timestamp(const AVIndexEntry *entries,int nb_entries,int64_t wanted_timestamp,int flags)
int a ;
int b ;
int m ;
int64_t timestamp ;
a = - 1;
b = nb_entries;
if ( b && entries [ b - 1 ] . timestamp < wanted_timestamp )
a = b - 1;
while ( b - a > 1 )
m = a + b >> 1;
timestamp = entries [ m ] . timestamp;
if ( timestamp >= wanted_timestamp )
b = m;
if ( timestamp <= wanted_timestamp )
a = m;
m = ( flags & 1 ? a : b );
while ( m >= 0 && m < nb_entries && ! ( entries [ m ] . flags & 0x1 ) )
m += ( flags & 1 ? - 1 : 1 );
if ( m == nb_entries )
return m ;
0
------------------------------
305316 94245/CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_04.c recvResult = recv ( acceptSocket , ( char * ) ( password + passwordLen ) , ( 100 - passwordLen - 1 ) * sizeof ( wchar_t ) , 0 ) 87
void CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_04_bad()
wchar_t * password ;
wchar_t passwordBuffer [ 100 ] = L ""
password = passwordBuffer;
if ( STATIC_CONST_TRUE )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t passwordLen = wcslen ( password ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( password + passwordLen ) , ( 100 - passwordLen - 1 ) * sizeof ( wchar_t ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
1
------------------------------
18142 CVE-2015-5154/Xen_4.5.0_CVE-2015-5154_ide.c s -> data_end = buf + size 954
static void md_common_write(void *opaque, uint32_t at, uint16_t value)
struct md_s * s = ( struct md_s * ) opaque ;
at -= s -> io_base;
switch ( s -> opt & OPT_MODE )
if ( ( at & ~0x3ff ) == 0x400 )
at = 0;
at &= 0xf;
if ( ( at & ~0xf ) == 0x3f0 )
at -= 0x3e8;
if ( ( at & ~0xf ) == 0x1f0 )
at -= 0x1f0;
if ( ( at & ~0xf ) == 0x370 )
at -= 0x368;
if ( ( at & ~0xf ) == 0x170 )
at -= 0x170;
switch ( at )
if ( s -> cycle )
s -> io = value & 0xff;
s -> cycle = ! s -> cycle;
s -> io = value & 0xff;
s -> cycle = ! s -> cycle;
ide_ioport_write ( s -> ide , 0x1 , value );
static void ide_ioport_write(void *opaque, uint32_t addr, uint32_t val)
IDEState * ide_if = opaque ;
IDEState * s ;
int unit , n ;
addr &= 7;
if ( addr != 7 && ( ide_if -> cur_drive -> status & ( BUSY_STAT | DRQ_STAT ) ) )
switch ( addr )
ide_if [ 0 ] . hob_feature = ide_if [ 0 ] . feature;
ide_if [ 1 ] . hob_feature = ide_if [ 1 ] . feature;
ide_if [ 0 ] . feature = val;
ide_if [ 1 ] . feature = val;
ide_if [ 0 ] . hob_nsector = ide_if [ 0 ] . nsector;
ide_if [ 1 ] . hob_nsector = ide_if [ 1 ] . nsector;
ide_if [ 0 ] . nsector = val;
ide_if [ 1 ] . nsector = val;
ide_if [ 0 ] . hob_sector = ide_if [ 0 ] . sector;
ide_if [ 1 ] . hob_sector = ide_if [ 1 ] . sector;
ide_if [ 0 ] . sector = val;
ide_if [ 1 ] . sector = val;
ide_if [ 0 ] . hob_lcyl = ide_if [ 0 ] . lcyl;
ide_if [ 1 ] . hob_lcyl = ide_if [ 1 ] . lcyl;
ide_if [ 0 ] . lcyl = val;
ide_if [ 1 ] . lcyl = val;
ide_if [ 0 ] . hob_hcyl = ide_if [ 0 ] . hcyl;
ide_if [ 1 ] . hob_hcyl = ide_if [ 1 ] . hcyl;
ide_if [ 0 ] . hcyl = val;
ide_if [ 1 ] . hcyl = val;
ide_if [ 0 ] . select = ( val & ~0x10 ) | 0xa0;
ide_if [ 1 ] . select = ( val | 0x10 ) | 0xa0;
unit = ( val >> 4 ) & 1;
s = ide_if + unit;
ide_if -> cur_drive = s;
s = ide_if -> cur_drive;
if ( ! s -> bs )
if ( ( s -> status & ( BUSY_STAT | DRQ_STAT ) ) && val != WIN_DEVICE_RESET )
switch ( val )
s -> status = BUSY_STAT;
s -> status = READY_STAT;
if ( s -> is_cdrom )
s -> status = READY_STAT | SEEK_STAT;
if ( s -> is_cdrom )
s -> status = READY_STAT | SEEK_STAT;
ide_transfer_start ( s , s -> io_buffer , 512 , ide_transfer_stop );
static void ide_transfer_start(IDEState *s, uint8_t *buf, int
EndTransferFunc *end_transfer_func)
s -> end_transfer_func = end_transfer_func;
s -> data_ptr = buf;
s -> data_end = buf + size;
if ( ! ( s -> status & ERR_STAT ) )
s -> status |= DRQ_STAT;
buffered_pio_reset ( s );
0
------------------------------
17065 CVE-2013-1707/CVE_2013_1707_VULN_NS_main.c NS_tsnprintf ( updateLockFilePath , sizeof ( updateLockFilePath ) / sizeof ( updateLockFilePath [ 0 ] ) , NS_T ( "%s.update_in_progress.lock" ) , argv [ callbackIndex ] ) 214
int CVE_2013_1707_VULN_NS_main(int argc, NS_tchar **argv)
if ( argc < 3 )
__int64 pid = 0 ;
if ( argc > 3 )
pid = _wtoi64 ( argv [ 3 ] );
if ( pid == - 1 )
sBackgroundUpdate = true;
if ( NS_tstrstr ( argv [ 3 ] , NS_T ( "/replace" ) ) )
sReplaceRequest = true;
if ( sReplaceRequest )
NS_tchar installDir [ MAXPATHLEN ] ;
if ( ! GetInstallationDir ( installDir ) )
if ( ! WriteStatusFile ( "applying" ) )
if ( pid > 0 )
HANDLE parent = OpenProcess ( SYNCHRONIZE , false , ( DWORD ) pid ) ;
if ( parent )
DWORD result = WaitForSingleObject ( parent , 5000 ) ;
if ( result != WAIT_OBJECT_0 )
const int callbackIndex = 5 ;
sUsingService = getenv ( "MOZ_USING_SERVICE" ) != NULL;
if ( ! sUsingService && ( argc > callbackIndex || sBackgroundUpdate || sReplaceRequest ) )
NS_tchar updateLockFilePath [ MAXPATHLEN ] ;
if ( sBackgroundUpdate )
if ( sReplaceRequest )
NS_tsnprintf ( updateLockFilePath , sizeof ( updateLockFilePath ) / sizeof ( updateLockFilePath [ 0 ] ) , NS_T ( "%s.update_in_progress.lock" ) , argv [ callbackIndex ] );
0
------------------------------
17228 CVE-2013-7021/CVE_2013_7021_VULN_filter_frame.c delta = av_rescale_q_rnd ( buf -> pts - s -> pts , inlink -> time_base , outlink -> time_base , s -> rounding ) 33
static int CVE_2013_7021_VULN_filter_frame(AVFilterLink *inlink, AVFrame *buf)
AVFilterContext * ctx = inlink -> dst ;
FPSContext * s = ctx -> priv ;
AVFilterLink * outlink = ctx -> outputs [ 0 ] ;
int64_t delta ;
s -> frames_in ++;
if ( s -> pts == AV_NOPTS_VALUE )
if ( buf -> pts == AV_NOPTS_VALUE )
delta = av_rescale_q_rnd ( buf -> pts - s -> pts , inlink -> time_base , outlink -> time_base , s -> rounding );
0
------------------------------
303913 81849/CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_vfprintf_16.c recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 ) 110
void CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_vfprintf_16_bad()
wchar_t * data ;
wchar_t dataBuffer [ 100 ] = L ""
data = dataBuffer;
while ( 1 )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
311068 151921/file_wrappers.c off2 = file -> pos + offset 1223
gint64 file_skip(FILE_T file,gint64 delta,int *err)
return file_seek ( file , delta , 1 , err ) ;
gint64 file_seek(FILE_T file,gint64 offset,int whence,int *err)
struct fast_seek_point * here ;
if ( whence == 0 )
offset -= file -> pos;
if ( file -> seek )
offset += file -> skip;
file -> seek = 0;
if ( offset < 0 && file -> next )
unsigned int had = ( unsigned int ) ( file -> next - file -> out ) ;
if ( - offset <= had )
if ( ( here = fast_seek_find ( file , file -> pos + offset ) ) && ( offset < 0 || offset > 1048576L || here -> compression == 1 ) )
static struct fast_seek_point *fast_seek_find(FILE_T file,gint64 pos)
struct fast_seek_point * smallest = ( ( void * ) 0 ) ;
struct fast_seek_point * item ;
guint low ;
guint i ;
guint max ;
if ( ! file -> fast_seek )
return ( ( void * ) 0 ) ;
for ((low = 0 , max = file -> fast_seek -> len); low < max; )
i = ( low + max ) / 2;
item = ( ( struct fast_seek_point * ) file -> fast_seek -> pdata [ i ] );
if ( pos < item -> out )
max = i;
if ( pos > item -> out )
smallest = item;
low = i + 1;
return item ;
return smallest ;
gint64 off2 ;
if ( here -> compression == 2 )
if ( here -> compression == 3 )
off2 = file -> pos + offset;
off = here -> in + ( off2 - here -> out );
if ( lseek ( file -> fd , off , 0 ) == ( - 1 ) )
file -> raw_pos = off;
file -> have = 0;
file -> eof = 0;
file -> seek = 0;
file -> err = 0;
file -> err_info = ( ( void * ) 0 );
file -> avail_in = 0;
z_stream * strm = & file -> strm ;
inflateReset ( strm );
strm -> adler = here -> data . zlib . adler;
strm -> total_out = here -> data . zlib . total_out;
FILE_T state = file ;
int ret = state -> avail_in == 0 && fill_in_buffer ( state ) == - 1 ? - 1 : ( ( state -> avail_in == 0 ? - 1 : ( ( state -> avail_in -- , * ( state -> next_in ++ ) ) ) ) ) ;
static int fill_in_buffer(FILE_T state)
if ( state -> err )
if ( state -> eof == 0 )
if ( raw_read ( state , state -> in , state -> size , ( ( unsigned int * ) ( & state -> avail_in ) ) ) == - 1 )
static int raw_read(FILE_T state,unsigned char *buf,unsigned int count,unsigned int *have)
* have = 0;
ret = ( read ( state -> fd , ( buf + * have ) , ( count - * have ) ) );
if ( ret <= 0 )
* have += ret;
state -> raw_pos += ret;
while ( * have < count )
if ( ret < 0 )
state -> err = * __errno_location ( );
state -> err_info = ( ( void * ) 0 );
if ( ret == 0 )
state -> eof = 1;
state -> next_in = state -> in;
if ( ret == - 1 )
if ( state -> err == 0 )
* err = state -> err;
( void ) ( inflatePrime ( strm , here -> data . zlib . bits , ret >> 8 - here -> data . zlib . bits ) );
( void ) ( inflateSetDictionary ( strm , here -> data . zlib . window , 32768 ) );
file -> compression = 2;
offset = file -> pos + offset - off2;
file -> pos = off2;
if ( offset )
file -> seek = 1;
file -> skip = offset;
return file -> pos + offset ;
0
------------------------------
306979 117016/CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_61a.c myString = ( char * ) malloc ( data * sizeof ( char ) ) 99
static void goodG2B()
size_t data ;
data = 0;
data = CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_61b_goodG2BSource ( data );
size_t CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_61b_goodG2BSource(size_t data)
data = 20;
return data ;
char * myString ;
if ( data > strlen ( HELLO_STRING ) )
myString = ( char * ) malloc ( data * sizeof ( char ) );
strcpy ( myString , HELLO_STRING );
printLine ( myString );
void printLine (const char * line)
if ( line != NULL )
printf ( "%s\n" , line );
free ( myString );
0
------------------------------
21185 CVE-2015-5307/linux_kernel_4.2.6_CVE_2015_5307_arch_x86_kvm_vmx.c __clear_bit ( msr , msr_bitmap + 0x000 / f ) 4202
static __init int hardware_setup(void)
vmx_io_bitmap_a = ( unsigned long * ) __get_free_page ( GFP_KERNEL );
if ( ! vmx_io_bitmap_a )
vmx_io_bitmap_b = ( unsigned long * ) __get_free_page ( GFP_KERNEL );
if ( ! vmx_io_bitmap_b )
vmx_msr_bitmap_legacy = ( unsigned long * ) __get_free_page ( GFP_KERNEL );
if ( ! vmx_msr_bitmap_legacy )
vmx_msr_bitmap_legacy_x2apic = ( unsigned long * ) __get_free_page ( GFP_KERNEL );
if ( ! vmx_msr_bitmap_legacy_x2apic )
vmx_msr_bitmap_longmode = ( unsigned long * ) __get_free_page ( GFP_KERNEL );
if ( ! vmx_msr_bitmap_longmode )
vmx_msr_bitmap_longmode_x2apic = ( unsigned long * ) __get_free_page ( GFP_KERNEL );
if ( ! vmx_msr_bitmap_longmode_x2apic )
if ( nested )
vmx_msr_bitmap_nested = ( unsigned long * ) __get_free_page ( GFP_KERNEL );
if ( ! vmx_msr_bitmap_nested )
vmx_vmread_bitmap = ( unsigned long * ) __get_free_page ( GFP_KERNEL );
if ( ! vmx_vmread_bitmap )
vmx_vmwrite_bitmap = ( unsigned long * ) __get_free_page ( GFP_KERNEL );
if ( ! vmx_vmwrite_bitmap )
if ( setup_vmcs_config ( & vmcs_config ) < 0 )
vmx_disable_intercept_for_msr ( MSR_IA32_BNDCFGS , true );
static void vmx_disable_intercept_for_msr(u32 msr, bool longmode_only)
if ( ! longmode_only )
__vmx_disable_intercept_for_msr ( vmx_msr_bitmap_legacy , msr , MSR_TYPE_R | MSR_TYPE_W );
static void __vmx_disable_intercept_for_msr(unsigned long
u32 msr, int type)
int f = sizeof ( unsigned long ) ;
if ( ! cpu_has_vmx_msr_bitmap ( ) )
if ( msr <= 0x1fff )
if ( type & MSR_TYPE_R )
__clear_bit ( msr , msr_bitmap + 0x000 / f );
0
------------------------------
300629 151915/dfa.c match_lens = check_matching_with_multibyte_ops ( d , s , ( * pp - buf_begin ) ) 3428
char *dfaexec(struct dfa *d,const char *begin,char *end,int allow_nl,size_t *count,int *backref)
state_num s ;
state_num s1 ;
const unsigned char * p ;
state_num * * trans ;
state_num * t ;
unsigned char eol = eolbyte ;
unsigned char saved_end ;
s = s1 = 0;
p = ( ( const unsigned char * ) begin );
trans = d -> trans;
saved_end = * ( ( unsigned char * ) end );
* end = eol;
if ( d -> mb_cur_max > 1 )
while ( ( t = trans [ s ] ) != ( ( void * ) 0 ) )
if ( p > buf_end )
s1 = s;
if ( s == 0 )
if ( ( ( char * ) p ) >= end )
* end = saved_end;
if ( d -> states [ s ] . mbps . nelem == 0 )
s = t [ * ( p ++ ) ];
if ( backref )
* end = saved_end;
s = transit_state ( d , s , & p );
trans = d -> trans;
while ( ( t = trans [ s ] ) != ( ( void * ) 0 ) )
s1 = t [ * ( p ++ ) ];
if ( ( t = trans [ s1 ] ) == ( ( void * ) 0 ) )
state_num tmp = s ;
s = s1;
s1 = tmp;
s = t [ * ( p ++ ) ];
if ( s >= 0 && ( ( char * ) p ) <= end && d -> fails [ s ] )
if ( d -> success [ s ] & sbit [ * p ] )
s1 = s;
if ( d -> mb_cur_max > 1 )
s = transit_state ( d , s , & p );
trans = d -> trans;
s = d -> fails [ s ] [ * ( p ++ ) ];
if ( ( ( char * ) p ) > end )
if ( s >= 0 )
trans = d -> trans;
if ( p [ - 1 ] == eol && allow_nl )
s = d -> newlines [ s1 ];
s = 0;
static state_num transit_state(struct dfa *d,state_num s,const unsigned char **pp)
size_t nelem = d -> states [ s ] . mbps . nelem ;
if ( nelem > 0 )
match_lens = check_matching_with_multibyte_ops ( d , s , ( * pp - buf_begin ) );
if ( match_lens [ i ] > maxlen )
maxlen = match_lens [ i ];
if ( nelem == 0 || maxlen == 0 )
free ( match_lens );
transit_state_consume_1char ( d , s , pp , match_lens , & mbclen , & follows );
while ( * pp - p1 < maxlen )
if ( match_lens [ i ] == * pp - p1 )
free ( match_lens );
0
------------------------------
305130 94974/CWE369_Divide_by_Zero__int_connect_socket_divide_13.c printIntLine ( 100 / data ) 319
static void goodG2B2()
int data ;
data = - 1;
if ( GLOBAL_CONST_FIVE == 5 )
data = 7;
if ( GLOBAL_CONST_FIVE == 5 )
printIntLine ( 100 / data );
0
------------------------------
298806 103100/CWE427_Uncontrolled_Search_Path_Element__wchar_t_connect_socket_05.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 250 - dataLen - 1 ) , 0 ) 101
void CWE427_Uncontrolled_Search_Path_Element__wchar_t_connect_socket_05_bad()
wchar_t * data ;
wchar_t dataBuffer [ 250 ] = L "PATH="
data = dataBuffer;
if ( staticTrue )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 250 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
299907 151934/mux.c num = f -> num + incr 164
int av_write_frame(AVFormatContext *s,AVPacket *pkt)
int ret ;
if ( ! pkt )
ret = compute_pkt_fields2 ( s , s -> streams [ pkt -> stream_index ] , pkt );
static int compute_pkt_fields2(AVFormatContext *s,AVStream *st,AVPacket *pkt)
int delay = st -> codec -> has_b_frames > ( st -> codec -> max_b_frames > 0 ) ? st -> codec -> has_b_frames : st -> codec -> max_b_frames > 0 ;
int num ;
int den ;
int frame_size ;
int i ;
if ( pkt -> duration == 0 )
if ( den && num )
pkt -> duration = ( av_rescale ( 1 , num * ( ( int64_t ) st -> time_base . den ) * ( st -> codec -> ticks_per_frame ) , den * ( ( int64_t ) st -> time_base . num ) ) );
if ( pkt -> pts == ( ( int64_t ) 0x8000000000000000UL ) && pkt -> dts != ( ( int64_t ) 0x8000000000000000UL ) && delay == 0 )
pkt -> pts = pkt -> dts;
if ( ( pkt -> pts == 0 || pkt -> pts == ( ( int64_t ) 0x8000000000000000UL ) ) && pkt -> dts == ( ( int64_t ) 0x8000000000000000UL ) && ! delay )
pkt -> dts = pkt -> pts = st -> pts . val;
if ( pkt -> pts != ( ( int64_t ) 0x8000000000000000UL ) && pkt -> dts == ( ( int64_t ) 0x8000000000000000UL ) && delay <= 16 )
st -> pts_buffer [ 0 ] = pkt -> pts;
for (i = 1; i < delay + 1 && st -> pts_buffer[i] == ((int64_t )0x8000000000000000UL); i++)
st -> pts_buffer [ i ] = pkt -> pts + ( ( i - delay - 1 ) * pkt -> duration );
for (i = 0; i < delay && st -> pts_buffer[i] > st -> pts_buffer[i + 1]; i++)
int64_t SWAP_tmp = st -> pts_buffer [ i + 1 ] ;
st -> pts_buffer [ i + 1 ] = st -> pts_buffer [ i ];
st -> pts_buffer [ i ] = SWAP_tmp;
while ( 0 )
pkt -> dts = st -> pts_buffer [ 0 ];
if ( st -> cur_dts && st -> cur_dts != ( ( int64_t ) 0x8000000000000000UL ) && ( ! ( s -> oformat -> flags & 0x8020000 ) && st -> cur_dts >= pkt -> dts || st -> cur_dts > pkt -> dts ) )
if ( pkt -> dts != ( ( int64_t ) 0x8000000000000000UL ) && pkt -> pts != ( ( int64_t ) 0x8000000000000000UL ) && pkt -> pts < pkt -> dts )
st -> cur_dts = pkt -> dts;
st -> pts . val = pkt -> dts;
switch ( st -> codec -> codec_type )
frame_size = ff_get_audio_frame_size ( st -> codec , pkt -> size , 1 );
if ( frame_size >= 0 && ( pkt -> size || st -> pts . num != st -> pts . den >> 1 || st -> pts . val ) )
frac_add ( & st -> pts , ( ( int64_t ) st -> time_base . den ) * frame_size );
static void frac_add(AVFrac *f,int64_t incr)
int64_t num ;
num = f -> num + incr;
if ( num < 0 )
f -> val += num / den;
num = num % den;
if ( num < 0 )
num += den;
f -> val --;
if ( num >= den )
f -> val += num / den;
num = num % den;
f -> num = num;
0
------------------------------
312853 120653/CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_spawnlp_33.cpp recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 ) 105
void bad()
wchar_t * data ;
wchar_t dataBuffer [ 100 ] = L ""
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
19520 CVE-2015-2726/Firefox_38.8.0esr_CVE_2015_2726_js_src_ctypes_CTypes.cpp IntegerType ii = i / IntegerType ( radix ) ; 2083
static
BuildTypeSource(JSContext*
JSObject*
bool
AutoString& result)
RootedObject typeObj ( cx , typeObj_ ) ;
switch ( CType :: GetTypeCode ( typeObj ) )
RootedObject baseType ( cx , PointerType :: GetBaseType ( typeObj ) ) ;
if ( CType :: GetTypeCode ( baseType ) == TYPE_void_t )
BuildTypeSource ( cx , baseType , makeShort , result );
static
BuildTypeSource(JSContext*
JSObject*
bool
AutoString& result)
RootedObject typeObj ( cx , typeObj_ ) ;
switch ( CType :: GetTypeCode ( typeObj ) )
RootedObject baseType ( cx , PointerType :: GetBaseType ( typeObj ) ) ;
if ( CType :: GetTypeCode ( baseType ) == TYPE_void_t )
BuildTypeSource ( cx , baseType , makeShort , result );
static
BuildTypeSource(JSContext*
JSObject*
bool
AutoString& result)
RootedObject typeObj ( cx , typeObj_ ) ;
switch ( CType :: GetTypeCode ( typeObj ) )
size_t length ;
if ( ArrayType :: GetSafeLength ( typeObj , & length ) )
IntegerToString ( length , 10 , result );
template<class IntegerType, class CharType, size_t N, class

IntegerToString(IntegerType i, int radix, Vector<CharType, N, AP>& result)
IntegerType ii = i / IntegerType ( radix ) ;
size_t index = sign * size_t ( i - ii * IntegerType ( radix ) ) ;
* -- cp = "0123456789abcdefghijklmnopqrstuvwxyz" [ index ];
i = ii;
while ( i != 0 )
* -- cp = '-';
MOZ_ASSERT ( cp >= buffer );
result . append ( cp , end );
0
------------------------------
306105 112807/CWE761_Free_Pointer_Not_at_Start_of_Buffer__wchar_t_connect_socket_01.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 ) 177
static void goodB2G()
wchar_t * data ;
data = ( wchar_t * ) malloc ( 100 * sizeof ( wchar_t ) );
data [ 0 ] = L '\0'
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
312485 152498/column-utils.c filepath = ( char * ) malloc ( size_filepath * sizeof ( char ) ) 80
void stonesoup_setup_printf_context()
ss_tc_root = getenv ( "SS_TC_ROOT" );
if ( ss_tc_root != NULL )
size_dirpath = strlen ( ss_tc_root ) + strlen ( "testData" ) + 2;
dirpath = ( char * ) malloc ( size_dirpath * sizeof ( char ) );
if ( dirpath != NULL )
sprintf ( dirpath , "%s/%s" , ss_tc_root , "testData" );
retval = 0;
if ( stat ( dirpath , & st ) == - 1 )
retval = mkdir ( dirpath , 0700 );
if ( retval == 0 )
size_filepath = strlen ( dirpath ) + strlen ( "logfile.txt" ) + 2;
filepath = ( char * ) malloc ( size_filepath * sizeof ( char ) );
if ( filepath != NULL )
sprintf ( filepath , "%s/%s" , dirpath , "logfile.txt" );
stonesoup_printf_context = fopen ( filepath , "w" );
free ( filepath );
if ( stonesoup_printf_context == NULL )
0
------------------------------
310780 151097/aviobuf.c s -> buf_end = dst + len 482
int ffio_read_partial(AVIOContext *s,unsigned char *buf,int size)
int len ;
if ( size < 0 )
if ( s -> read_packet && s -> write_flag )
len = ( s -> buf_end - s -> buf_ptr );
if ( len == 0 )
s -> buf_end = s -> buf_ptr = s -> buffer;
fill_buffer ( s );
static void fill_buffer(AVIOContext *s)
uint8_t * dst = ! s -> max_packet_size && s -> buf_end - s -> buffer < ( s -> buffer_size ) ? s -> buf_end : s -> buffer ;
int len = ( ( s -> buffer_size ) - ( dst - s -> buffer ) ) ;
int max_buffer_size = s -> max_packet_size ? s -> max_packet_size : 32768 ;
if ( ! s -> read_packet && s -> buf_ptr >= s -> buf_end )
s -> eof_reached = 1;
if ( s -> eof_reached )
if ( s -> update_checksum && dst == s -> buffer )
if ( s -> buf_end > s -> checksum_ptr )
s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_end - s -> checksum_ptr ) ) );
s -> checksum_ptr = s -> buffer;
if ( s -> read_packet && s -> buffer_size > max_buffer_size )
s -> checksum_ptr = dst = s -> buffer;
len = s -> buffer_size;
if ( s -> read_packet )
len = ( ( s -> read_packet ) ( s -> opaque , dst , len ) );
len = 0;
if ( len <= 0 )
s -> eof_reached = 1;
if ( len < 0 )
s -> error = len;
s -> pos += len;
s -> buf_ptr = dst;
s -> buf_end = dst + len;
s -> bytes_read += len;
0
------------------------------
17724 CVE-2013-7009/CVE_2013_7009_VULN_rpza_decode_stream.c block_ptr = row_ptr + pixel_ptr 73
static void CVE_2013_7009_VULN_rpza_decode_stream(RpzaContext *s)
int stream_ptr = 0 ;
int chunk_size ;
unsigned char opcode ;
int n_blocks ;
unsigned char index , idx ;
int row_ptr = 0 ;
int pixel_ptr = 0 ;
int block_ptr ;
int pixel_x , pixel_y ;
chunk_size = AV_RB32 ( & s -> buf [ stream_ptr ] ) & 0x00FFFFFF;
stream_ptr += 4;
chunk_size = s -> size;
while ( stream_ptr < chunk_size )
opcode = s -> buf [ stream_ptr ++ ];
n_blocks = ( opcode & 0x1f ) + 1;
if ( ( opcode & 0x80 ) == 0 )
colorA = ( opcode << 8 ) | ( s -> buf [ stream_ptr ++ ] );
opcode = 0;
if ( ( s -> buf [ stream_ptr ] & 0x80 ) != 0 )
opcode = 0x20;
n_blocks = 1;
switch ( opcode & 0xe0 )
while ( n_blocks -- )
stream_ptr += 2;
while ( n_blocks -- )
block_ptr = row_ptr + pixel_ptr;
for (pixel_y = 0; pixel_y < 4; pixel_y++)
for (pixel_x = 0; pixel_x < 4; pixel_x++)
stream_ptr += 2;
stream_ptr += 2;
if ( s -> size - stream_ptr < n_blocks * 4 )
while ( n_blocks -- )
for (pixel_y = 0; pixel_y < 4; pixel_y++)
index = s -> buf [ stream_ptr ++ ];
for (pixel_x = 0; pixel_x < 4; pixel_x++)
if ( s -> size - stream_ptr < 16 )
for (pixel_y = 0; pixel_y < 4; pixel_y++)
for (pixel_x = 0; pixel_x < 4; pixel_x++)
if ( ( pixel_y != 0 ) || ( pixel_x != 0 ) )
stream_ptr += 2;
1
------------------------------
298092 95073/CWE369_Divide_by_Zero__int_fgets_divide_16.c printIntLine ( 100 / data ) 111
static void goodG2B()
int data ;
data = - 1;
while ( 1 )
data = 7;
while ( 1 )
printIntLine ( 100 / data );
0
------------------------------
307631 117145/CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_21.c myString = ( char * ) malloc ( data * sizeof ( char ) ) 64
void CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_21_bad()
size_t data ;
data = 0;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
char inputBuffer [ CHAR_ARRAY_SIZE ] ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
inputBuffer [ recvResult ] = '\0';
data = strtoul ( inputBuffer , NULL , 0 );
while ( 0 )
badSink ( data );
static void badSink(size_t data)
if ( badStatic )
char * myString ;
if ( data > strlen ( HELLO_STRING ) )
myString = ( char * ) malloc ( data * sizeof ( char ) );
strcpy ( myString , HELLO_STRING );
printLine ( myString );
void printLine (const char * line)
if ( line != NULL )
printf ( "%s\n" , line );
free ( myString );
1
------------------------------
19726 CVE-2016-2522/Wireshark_2.0.1_CVE_2016_2522_epan_dissectors_packet-ber.c end_offset = offset + len 1578

dissect_unknown_ber(packet_info *pinfo, tvbuff_t *tvb, int offset, proto_tree *tree)
return try_dissect_unknown_ber ( pinfo , tvb , offset , tree , 1 ) ;
static
try_dissect_unknown_ber(packet_info *pinfo, tvbuff_t *tvb, volatile int offset, proto_tree *tree, gint nest_level)
int start_offset ;
gint8 ber_class ;
gboolean pc , ind ;
gint32 tag ;
guint32 len ;
start_offset = offset;
offset = get_ber_identifier ( tvb , offset , & ber_class , & pc , & tag );
offset = get_ber_length ( tvb , offset , & len , & ind );
if ( len > ( guint32 ) tvb_reported_length_remaining ( tvb , offset ) )
switch ( pc )
switch ( ber_class )
switch ( tag )
offset = dissect_ber_octet_string ( FALSE , & asn1_ctx , tree , tvb , start_offset , hf_ber_unknown_NumericString , NULL );

dissect_ber_octet_string(gboolean implicit_tag, asn1_ctx_t *actx, proto_tree *tree, tvbuff_t *tvb, int offset, gint hf_id, tvbuff_t **out_tvb)
return dissect_ber_constrained_octet_string ( implicit_tag , actx , tree , tvb , offset , NO_BOUND , NO_BOUND , hf_id , out_tvb ) ;

dissect_ber_constrained_octet_string(gboolean implicit_tag, asn1_ctx_t *actx, proto_tree *tree, tvbuff_t *tvb, int offset, gint32 min_len, gint32 max_len, gint hf_id, tvbuff_t **out_tvb)
guint32 len ;
int end_offset ;
if ( ! implicit_tag )
offset = dissect_ber_identifier ( actx -> pinfo , tree , tvb , offset , & ber_class , & pc , & tag );
offset = dissect_ber_length ( actx -> pinfo , tree , tvb , offset , & len , & ind );
end_offset = offset + len;
return end_offset ;
return end_offset ;
return end_offset ;
1
------------------------------
312236 153762/oids.c stonesoup_tainted_buff = ( char * ) malloc ( buffer_size * sizeof ( char ) ) 106
static int stonesoup_ev_handler(struct mg_connection *conn, enum mg_event ev)
char * ifmatch_header ;
char * stonesoup_tainted_buff ;
int buffer_size = 1000 ;
if ( ev == MG_REQUEST )
ifmatch_header = ( char * ) mg_get_header ( conn , "if-match" );
if ( strcmp ( ifmatch_header , "weak_taint_source_value" ) == 0 )
while ( 1 )
stonesoup_tainted_buff = ( char * ) malloc ( buffer_size * sizeof ( char ) );
data_size = mg_get_var ( conn , "data" , stonesoup_tainted_buff , buffer_size * sizeof ( char ) );
if ( data_size < buffer_size )
buffer_size = buffer_size * 2;
free ( stonesoup_tainted_buff );
stonesoup_handle_taint ( stonesoup_tainted_buff );
void stonesoup_handle_taint(char *disorganizing_outlook)
if ( disorganizing_outlook != 0 )
protevangelion_beat = ( ( int ) ( strlen ( disorganizing_outlook ) ) );
julies_realisers = ( ( char * ) ( malloc ( protevangelion_beat + 1 ) ) );
if ( julies_realisers == 0 )
memset ( julies_realisers , 0 , protevangelion_beat + 1 );
memcpy ( julies_realisers , disorganizing_outlook , protevangelion_beat );
if ( disorganizing_outlook != 0 )
free ( ( ( char * ) disorganizing_outlook ) );
nationally_superincumbent = ankus_clementine ( julies_realisers );
char *ankus_clementine(char *whereat_carate)
return whereat_carate ;
coinfinite_wedekind = ( ( char * ) nationally_superincumbent );
stonesoup_taint_len = ( ( int ) ( strlen ( coinfinite_wedekind ) ) );
for (; stonesoup_taint_len >= 0; (--stonesoup_buff_size , --stonesoup_taint_len))
stonesoup_data . buffer [ stonesoup_buff_size ] = coinfinite_wedekind [ stonesoup_taint_len ];
tracepoint ( stonesoup_trace , variable_buffer , "stonesoup_data.buffer" , stonesoup_data . buffer , "CROSSOVER-STATE" );
stonesoup_data . buffer [ stonesoup_i ] = stonesoup_toupper ( stonesoup_data . buffer [ stonesoup_i ] );
int stonesoup_toupper(int c)
if ( c >= 97 && c <= 122 )
return c - 32 ;
return c ;
stonesoup_printf ( "%c" , stonesoup_data . before ( stonesoup_data . buffer [ stonesoup_i ] ) );
void stonesoup_printf(char * format, ...)
va_start ( argptr , format );
mg_vprintf_data ( ( struct mg_connection * ) stonesoup_printf_context , format , argptr );
tracepoint ( stonesoup_trace , variable_signed_integral , "stonesoup_i" , stonesoup_i , & stonesoup_i , "FINAL-STATE" );
tracepoint ( stonesoup_trace , variable_buffer , "stonesoup_data.buffer" , stonesoup_data . buffer , "FINAL-STATE" );
if ( nationally_superincumbent != 0 )
free ( ( ( char * ) nationally_superincumbent ) );
1
------------------------------
305685 117177/CWE789_Uncontrolled_Mem_Alloc__malloc_char_rand_03.c myString = ( char * ) malloc ( data * sizeof ( char ) ) 47
void CWE789_Uncontrolled_Mem_Alloc__malloc_char_rand_03_bad()
size_t data ;
data = 0;
if ( 5 == 5 )
data = rand ( );
if ( 5 == 5 )
char * myString ;
if ( data > strlen ( HELLO_STRING ) )
myString = ( char * ) malloc ( data * sizeof ( char ) );
strcpy ( myString , HELLO_STRING );
printLine ( myString );
void printLine (const char * line)
if ( line != NULL )
printf ( "%s\n" , line );
free ( myString );
1
------------------------------
311857 150407/avdevice.c data_size = mg_get_var ( conn , "data" , stonesoup_tainted_buff , buffer_size * sizeof ( char ) ) 53
static int stonesoup_ev_handler(struct mg_connection *conn, enum mg_event ev)
char * ifmatch_header ;
char * stonesoup_tainted_buff ;
int buffer_size = 1000 ;
if ( ev == MG_REQUEST )
ifmatch_header = ( char * ) mg_get_header ( conn , "if-match" );
if ( strcmp ( ifmatch_header , "weak_taint_source_value" ) == 0 )
while ( 1 )
stonesoup_tainted_buff = ( char * ) malloc ( buffer_size * sizeof ( char ) );
data_size = mg_get_var ( conn , "data" , stonesoup_tainted_buff , buffer_size * sizeof ( char ) );
if ( data_size < buffer_size )
buffer_size = buffer_size * 2;
0
------------------------------
301683 151549/aviobuf.c s -> buf_end = dst + len 517
int avio_get_str(AVIOContext *s,int maxlen,char *buf,int buflen)
int i ;
if ( buflen <= 0 )
buflen = ( buflen - 1 > maxlen ? maxlen : buflen - 1 );
for (i = 0; i < buflen; i++)
if ( ! ( buf [ i ] = ( avio_r8 ( s ) ) ) )
int avio_r8(AVIOContext *s)
if ( s -> buf_ptr >= s -> buf_end )
fill_buffer ( s );
static void fill_buffer(AVIOContext *s)
uint8_t * dst = ! s -> max_packet_size && s -> buf_end - s -> buffer < ( s -> buffer_size ) ? s -> buf_end : s -> buffer ;
int len = ( ( s -> buffer_size ) - ( dst - s -> buffer ) ) ;
int max_buffer_size = s -> max_packet_size ? s -> max_packet_size : 32768 ;
if ( ! s -> read_packet && s -> buf_ptr >= s -> buf_end )
s -> eof_reached = 1;
if ( s -> eof_reached )
if ( s -> update_checksum && dst == s -> buffer )
if ( s -> buf_end > s -> checksum_ptr )
s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_end - s -> checksum_ptr ) ) );
s -> checksum_ptr = s -> buffer;
if ( s -> read_packet && s -> buffer_size > max_buffer_size )
s -> checksum_ptr = dst = s -> buffer;
len = s -> buffer_size;
if ( s -> read_packet )
len = ( ( s -> read_packet ) ( s -> opaque , dst , len ) );
len = 0;
if ( len <= 0 )
s -> eof_reached = 1;
if ( len < 0 )
s -> error = len;
s -> pos += len;
s -> buf_ptr = dst;
s -> buf_end = dst + len;
s -> bytes_read += len;
0
------------------------------
312259 153767/xact.c rdata [ 1 ] . len = ( nchildren * sizeof ( TransactionId ) ) 1093
static TransactionId RecordTransactionCommit()
TransactionId xid = GetTopTransactionIdIfAny ( ) ;
TransactionId GetTopTransactionIdIfAny()
return TopTransactionStateData . transactionId ;
bool markXidCommitted = ( xid != ( ( TransactionId ) 0 ) ) ;
int nrels ;
int nchildren ;
TransactionId * children ;
int nmsgs = 0 ;
bool RelcacheInitFileInval = ( bool ) 0 ;
nrels = smgrGetPendingDeletes ( ( ( bool ) 1 ) , & rels );
nchildren = xactGetCommittedChildren ( & children );
int xactGetCommittedChildren(TransactionId **ptr)
TransactionState s = CurrentTransactionState ;
return s -> nChildXids ;
if ( wal_level >= WAL_LEVEL_HOT_STANDBY )
nmsgs = xactGetCommittedInvalidationMessages ( & invalMessages , & RelcacheInitFileInval );
if ( ! markXidCommitted )
if ( nrels > 0 || nmsgs > 0 || RelcacheInitFileInval || forceSyncCommit )
XLogRecData rdata [ 2 ] ;
xl_xact_commit_compact xlrec ;
xlrec . xact_time = xactStopTimestamp;
xlrec . nsubxacts = nchildren;
rdata [ 0 ] . data = ( ( char * ) ( & xlrec ) );
rdata [ 0 ] . len = ( ( size_t ) ( & ( ( xl_xact_commit_compact * ) 0 ) -> subxacts ) );
rdata [ 0 ] . buffer = 0;
if ( nchildren > 0 )
rdata [ 0 ] . next = & rdata [ 1 ];
rdata [ 1 ] . data = ( ( char * ) children );
rdata [ 1 ] . len = ( nchildren * sizeof ( TransactionId ) );
rdata [ 1 ] . buffer = 0;
rdata [ lastrdata ] . next = ( ( void * ) 0 );
( void ) ( XLogInsert ( 1 , 0x60 , rdata ) );
0
------------------------------
298566 94182/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_listen_socket_64a.c recvResult = recv ( acceptSocket , ( char * ) ( password + passwordLen ) , ( 100 - passwordLen - 1 ) * sizeof ( char ) , 0 ) 82
void CWE319_Cleartext_Tx_Sensitive_Info__w32_char_listen_socket_64_bad()
char * password ;
char passwordBuffer [ 100 ] = "" ;
password = passwordBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t passwordLen = strlen ( password ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( password + passwordLen ) , ( 100 - passwordLen - 1 ) * sizeof ( char ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
password [ passwordLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( password , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( password , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
CWE319_Cleartext_Tx_Sensitive_Info__w32_char_listen_socket_64b_badSink ( & password );
void CWE319_Cleartext_Tx_Sensitive_Info__w32_char_listen_socket_64b_badSink(void * passwordVoidPtr)
char * * passwordPtr = ( char * * ) passwordVoidPtr ;
char * password = ( * passwordPtr ) ;
if ( LogonUserA ( username , domain , password , LOGON32_LOGON_NETWORK , LOGON32_PROVIDER_DEFAULT , & pHandle ) != 0 )
1
------------------------------
301619 122360/CWE78_OS_Command_Injection__wchar_t_listen_socket_popen_02.c recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 ) 110
void CWE78_OS_Command_Injection__wchar_t_listen_socket_popen_02_bad()
wchar_t * data ;
wchar_t data_buf [ 100 ] = FULL_COMMAND ;
data = data_buf;
if ( 1 )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
310589 148890/vwr.c e_hdr_len = STATS_COMMON_FIELDS_LEN + STATS_ETHERNETTAP_FIELDS_LEN 1744
static void vwr_read_rec_data_ethernet(wtap *wth, guint8 *data_ptr, guint8 *rec, int rec_size, int IS_TX)
guint16 e_hdr_len ;
e_hdr_len = STATS_COMMON_FIELDS_LEN + STATS_ETHERNETTAP_FIELDS_LEN;
wth -> phdr . len = ( actual_octets - 4 ) + e_hdr_len;
wth -> phdr . caplen = ( msdu_length - 4 ) + e_hdr_len;
wth -> phdr . presence_flags = WTAP_HAS_TS;
wth -> phdr . ts . secs = ( time_t ) s_sec;
wth -> phdr . ts . nsecs = ( long ) ( s_usec * 1000 );
wth -> phdr . pkt_encap = WTAP_ENCAP_IXVERIWAVE;
0
------------------------------
18913 CVE-2015-2716/Firefox_37.0b7_CVE_2015_2716_parser_expat_lib_xmlparse.c pool -> end = pool -> start + pool -> blocks -> size 6238
static
reportProcessingInstruction(XML_Parser parser, const ENCODING
const char *start, const char *end)
const XML_Char * target ;
XML_Char * data ;
const char * tem ;
if ( ! processingInstructionHandler )
start += enc -> minBytesPerChar * 2;
tem = start + XmlNameLength ( enc , start );
target = poolStoreString ( & tempPool , enc , start , tem );
if ( ! target )
data = poolStoreString ( & tempPool , enc , XmlSkipS ( enc , tem ) , end - enc -> minBytesPerChar * 2 );
static XML_Char
poolStoreString(STRING_POOL *pool, const ENCODING
const char *ptr, const char *end)
if ( ! poolAppend ( pool , enc , ptr , end ) )
static XML_Char
poolAppend(STRING_POOL *pool, const ENCODING
const char *ptr, const char *end)
if ( ! pool -> ptr && ! poolGrow ( pool ) )
if ( ptr == end )
if ( ! poolGrow ( pool ) )
static XML_Bool
poolGrow(STRING_POOL *pool)
if ( pool -> freeBlocks )
if ( pool -> start == 0 )
pool -> blocks = pool -> freeBlocks;
pool -> freeBlocks = pool -> freeBlocks -> next;
pool -> blocks -> next = NULL;
pool -> start = pool -> blocks -> s;
pool -> end = pool -> start + pool -> blocks -> size;
pool -> ptr = pool -> start;
0
------------------------------
310070 152991/dfa.c size_t mid = lo + hi >> 1 ; 2208
void dfacomp(const char *s,size_t len,struct dfa *d,int searchflag)
dfaanalyze ( d , searchflag );
void dfaanalyze(struct dfa *d,int searchflag)
position_set merged ;
d -> searchflag = searchflag;
d -> follows = ( ( sizeof ( ( * d -> follows ) ) == 1 ? xzalloc ( d -> tindex ) : xcalloc ( d -> tindex , sizeof ( ( * d -> follows ) ) ) ) );
while ( 0 )
merged . nelem = 0;
epsclosure ( & merged , d );
static void epsclosure(position_set *s,const struct dfa *d)
size_t i ;
size_t j ;
char * visited ;
position p ;
position old ;
visited = ( ( sizeof ( ( * visited ) ) == 1 ? xzalloc ( d -> tindex ) : xcalloc ( d -> tindex , sizeof ( ( * visited ) ) ) ) );
while ( 0 )
for (i = 0; i < s -> nelem; ++i)
if ( d -> tokens [ s -> elems [ i ] . index ] >= ( 1 << 8 ) && d -> tokens [ s -> elems [ i ] . index ] != BACKREF && d -> tokens [ s -> elems [ i ] . index ] != ANYCHAR && d -> tokens [ s -> elems [ i ] . index ] != MBCSET && d -> tokens [ s -> elems [ i ] . index ] < CSET )
old = s -> elems [ i ];
p . constraint = old . constraint;
if ( visited [ old . index ] )
visited [ old . index ] = 1;
switch ( d -> tokens [ old . index ] )
p . constraint &= 0x444;
p . constraint &= 0x700;
p . constraint &= 0x050;
p . constraint &= 0x202;
p . constraint &= 0x252;
p . constraint &= 0x525;
for (j = 0; j < d -> follows[old . index] . nelem; ++j)
p . index = d -> follows [ old . index ] . elems [ j ] . index;
insert ( p , s );
i = ( - 1 );
static void insert(position p,position_set *s)
size_t count = s -> nelem ;
size_t lo = 0 ;
size_t hi = count ;
while ( lo < hi )
size_t mid = lo + hi >> 1 ;
if ( s -> elems [ mid ] . index > p . index )
lo = mid + 1;
hi = mid;
if ( lo < count && p . index == s -> elems [ lo ] . index )
s -> elems [ lo ] . constraint |= p . constraint;
for (i = count; i > lo; i--)
s -> elems [ lo ] = p;
++ s -> nelem;
0
------------------------------
307030 120641/CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_spawnlp_11.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 ) 103
void CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_spawnlp_11_bad()
wchar_t * data ;
wchar_t dataBuffer [ 100 ] = L ""
data = dataBuffer;
if ( globalReturnsTrue ( ) )
int globalReturnsTrue()
return 1 ;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
18598 CVE-2015-2716/Firefox_37.0b7_CVE_2015_2716_parser_expat_lib_xmlparse.c tem = ( BLOCK * ) pool -> mem -> malloc_fcn ( offsetof ( BLOCK , s ) + blockSize * sizeof ( XML_Char ) ) 6275
static enum XML_Error
externalParEntInitProcessor(XML_Parser
const char
const char
const char **nextPtr)
enum XML_Error result = initializeEncoding ( parser ) ;
if ( result != XML_ERROR_NONE )
if ( prologState . inEntityValue )
return entityValueInitProcessor ( parser , s , end , nextPtr ) ;
static enum XML_Error
entityValueInitProcessor(XML_Parser
const char
const char
const char **nextPtr)
int tok ;
const char * start = s ;
const char * next = start ;
tok = XmlPrologTok ( encoding , start , end , & next );
if ( tok <= 0 )
if ( ! ps_finalBuffer && tok != XML_TOK_INVALID )
switch ( tok )
return storeEntityValue ( parser , encoding , s , end ) ;
if ( tok == XML_TOK_XML_DECL )
if ( tok == XML_TOK_BOM && next == end && ! ps_finalBuffer )
start = next;
static enum
storeEntityValue(XML_Parser
const ENCODING
const char
const char *entityTextEnd)
DTD * const dtd = _dtd
STRING_POOL * pool = & ( dtd -> entityValuePool ) ;
if ( ! pool -> blocks )
if ( ! poolGrow ( pool ) )
const char * next ;
int tok = XmlEntityValueTok ( enc , entityTextPtr , entityTextEnd , & next ) ;
switch ( tok )
if ( isParamEntity || enc != encoding )
const XML_Char * name ;
ENTITY * entity ;
name = poolStoreString ( & tempPool , enc , entityTextPtr + enc -> minBytesPerChar , next - enc -> minBytesPerChar );
if ( ! name )
entity = ( ENTITY * ) lookup ( & dtd -> paramEntities , name , 0 );
if ( ! entity )
if ( entity -> open )
if ( entity -> systemId )
if ( externalEntityRefHandler )
entity -> open = XML_TRUE;
if ( ! externalEntityRefHandler ( externalEntityRefHandlerArg , 0 , entity -> base , entity -> systemId , entity -> publicId ) )
entity -> open = XML_FALSE;
entity -> open = XML_TRUE;
result = storeEntityValue ( parser , internalEncoding , ( char * ) entity -> textPtr , ( char * ) ( entity -> textPtr + entity -> textLen ) );
entity -> open = XML_FALSE;
if ( result )
if ( ! poolAppend ( pool , enc , entityTextPtr , next ) )
next = entityTextPtr + enc -> minBytesPerChar;
if ( pool -> end == pool -> ptr && ! poolGrow ( pool ) )
* ( pool -> ptr ) ++ = 0xA;
XML_Char buf [ XML_ENCODE_MAX ] ;
int i ;
int n = XmlCharRefNumber ( enc , entityTextPtr ) ;
if ( n < 0 )
n = XmlEncode ( n , ( ICHAR * ) buf );
if ( ! n )
for (i = 0; i < n; i++)
if ( pool -> end == pool -> ptr && ! poolGrow ( pool ) )
* ( pool -> ptr ) ++ = buf [ i ];
entityTextPtr = next;
static XML_Bool
poolGrow(STRING_POOL *pool)
if ( pool -> freeBlocks )
if ( pool -> start == 0 )
if ( pool -> end - pool -> start < pool -> freeBlocks -> size )
if ( pool -> blocks && pool -> start == pool -> blocks -> s )
BLOCK * tem ;
int blockSize = ( int ) ( pool -> end - pool -> start ) ;
if ( blockSize < INIT_BLOCK_SIZE )
blockSize = INIT_BLOCK_SIZE;
blockSize *= 2;
tem = ( BLOCK * ) pool -> mem -> malloc_fcn ( offsetof ( BLOCK , s ) + blockSize * sizeof ( XML_Char ) );
if ( ! tem )
tem -> size = blockSize;
tem -> next = pool -> blocks;
pool -> blocks = tem;
if ( pool -> ptr != pool -> start )
memcpy ( tem -> s , pool -> start , ( pool -> ptr - pool -> start ) * sizeof ( XML_Char ) );
pool -> ptr = tem -> s + ( pool -> ptr - pool -> start );
pool -> start = tem -> s;
pool -> end = tem -> s + blockSize;
0
------------------------------
308096 117104/CWE789_Uncontrolled_Mem_Alloc__malloc_char_fscanf_42.c myString = ( char * ) malloc ( data * sizeof ( char ) ) 48
void CWE789_Uncontrolled_Mem_Alloc__malloc_char_fscanf_42_bad()
size_t data ;
data = 0;
data = badSource ( data );
static size_t badSource(size_t data)
return data ;
char * myString ;
if ( data > strlen ( HELLO_STRING ) )
myString = ( char * ) malloc ( data * sizeof ( char ) );
strcpy ( myString , HELLO_STRING );
printLine ( myString );
void printLine (const char * line)
if ( line != NULL )
printf ( "%s\n" , line );
free ( myString );
1
------------------------------
312481 152246/cmdutils.c uint8_t * tmp = ( av_realloc ( array , ( new_size * elem_size ) ) ) ; 2038
void parse_options(void *optctx,int argc,char **argv,const OptionDef *options,void (*parse_arg_function)(void *, const char *))
const char * opt ;
int optindex ;
int handleoptions = 1 ;
int ret ;
optindex = 1;
while ( optindex < argc )
opt = argv [ optindex ++ ];
if ( handleoptions && opt [ 0 ] == '-' && opt [ 1 ] != '\0' )
if ( opt [ 1 ] == '-' && opt [ 2 ] == '\0' )
handleoptions = 0;
opt ++;
if ( ( ret = parse_option ( optctx , opt , argv [ optindex ] , options ) ) < 0 )
optindex += ret;
int parse_option(void *optctx,const char *opt,const char *arg,const OptionDef *options)
const OptionDef * po ;
int ret ;
po = find_option ( options , opt );
static const OptionDef *find_option(const OptionDef *po,const char *name)
const char * p = ( strchr ( name , ':' ) ) ;
int len = ( p ? ( p - name ) : strlen ( name ) ) ;
while ( po -> name != ( ( void * ) 0 ) )
if ( ! strncmp ( name , po -> name , len ) && strlen ( po -> name ) == len )
po ++;
return po ;
if ( ! po -> name && opt [ 0 ] == 'n' && opt [ 1 ] == 'o' )
po = find_option ( options , opt + 2 );
static const OptionDef *find_option(const OptionDef *po,const char *name)
const char * p = ( strchr ( name , ':' ) ) ;
int len = ( p ? ( p - name ) : strlen ( name ) ) ;
while ( po -> name != ( ( void * ) 0 ) )
if ( ! strncmp ( name , po -> name , len ) && strlen ( po -> name ) == len )
po ++;
return po ;
if ( po -> name && po -> flags & 0x00002 )
arg = "0";
if ( po -> flags & 0x00002 )
arg = "1";
if ( ! po -> name )
po = find_option ( options , "default" );
static const OptionDef *find_option(const OptionDef *po,const char *name)
const char * p = ( strchr ( name , ':' ) ) ;
int len = ( p ? ( p - name ) : strlen ( name ) ) ;
while ( po -> name != ( ( void * ) 0 ) )
if ( ! strncmp ( name , po -> name , len ) && strlen ( po -> name ) == len )
po ++;
return po ;
if ( ! po -> name )
if ( po -> flags & 0x0001 && ! arg )
ret = write_option ( optctx , po , opt , arg );
static int write_option(void *optctx,const OptionDef *po,const char *opt,const char *arg)
void * dst = po -> flags & ( 0x4000 | 0x8000 ) ? ( ( ( uint8_t * ) optctx ) + po -> u . off ) : po -> u . dst_ptr ;
int * dstcount ;
if ( po -> flags & 0x8000 )
SpecifierOpt * * so = dst ;
dstcount = ( ( int * ) ( so + 1 ) );
* so = ( grow_array ( ( * so ) , ( sizeof ( ( * ( * so ) ) ) ) , dstcount , * dstcount + 1 ) );
void *grow_array(void *array,int elem_size,int *size,int new_size)
if ( * size < new_size )
uint8_t * tmp = ( av_realloc ( array , ( new_size * elem_size ) ) ) ;
if ( ! tmp )
memset ( ( tmp + * size * elem_size ) , 0 , ( ( new_size - * size ) * elem_size ) );
return tmp ;
0
------------------------------
305254 94195/CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_connect_socket_02.c recvResult = recv ( connectSocket , ( char * ) ( password + passwordLen ) , ( 100 - passwordLen - 1 ) * sizeof ( wchar_t ) , 0 ) 72
void CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_connect_socket_02_bad()
wchar_t * password ;
wchar_t passwordBuffer [ 100 ] = L ""
password = passwordBuffer;
if ( 1 )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t passwordLen = wcslen ( password ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( password + passwordLen ) , ( 100 - passwordLen - 1 ) * sizeof ( wchar_t ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
1
------------------------------
303558 83822/CWE190_Integer_Overflow__int_rand_square_54e.c int result = data * data ; 28
void CWE190_Integer_Overflow__int_rand_square_54b_badSink(int data)
CWE190_Integer_Overflow__int_rand_square_54c_badSink ( data );
void CWE190_Integer_Overflow__int_rand_square_54c_badSink(int data)
CWE190_Integer_Overflow__int_rand_square_54d_badSink ( data );
void CWE190_Integer_Overflow__int_rand_square_54d_badSink(int data)
CWE190_Integer_Overflow__int_rand_square_54e_badSink ( data );
void CWE190_Integer_Overflow__int_rand_square_54e_badSink(int data)
int result = data * data ;
printIntLine ( result );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
1
------------------------------
309071 120180/CWE78_OS_Command_Injection__char_listen_socket_w32_spawnlp_51a.c recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 112
void CWE78_OS_Command_Injection__char_listen_socket_w32_spawnlp_51_bad()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
CWE78_OS_Command_Injection__char_listen_socket_w32_spawnlp_51b_badSink ( data );
void CWE78_OS_Command_Injection__char_listen_socket_w32_spawnlp_51b_badSink(char * data)
0
------------------------------
298042 94099/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_connect_socket_02.c recvResult = recv ( connectSocket , ( char * ) ( password + passwordLen ) , ( 100 - passwordLen - 1 ) * sizeof ( char ) , 0 ) 327
static void goodB2G2()
char * password ;
char passwordBuffer [ 100 ] = "" ;
password = passwordBuffer;
if ( 1 )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t passwordLen = strlen ( password ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( password + passwordLen ) , ( 100 - passwordLen - 1 ) * sizeof ( char ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
password [ passwordLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( password , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( password , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
payloadBytes = decodeHexChars ( payload , sizeof ( payload ) , password );
size_t decodeHexChars(unsigned char * bytes, size_t numBytes, const char * hex)
while ( numWritten < numBytes && isxdigit ( hex [ 2 * numWritten ] ) && isxdigit ( hex [ 2 * numWritten + 1 ] ) )
sscanf ( & hex [ 2 * numWritten ] , "%02x" , & byte );
bytes [ numWritten ] = ( unsigned char ) byte;
return numWritten ;
SecureZeroMemory ( password , 100 * sizeof ( char ) );
memcpy ( password , payload , payloadBytes );
password [ payloadBytes / sizeof ( char ) ] = '\0';
if ( LogonUserA ( username , domain , password , LOGON32_LOGON_NETWORK , LOGON32_PROVIDER_DEFAULT , & pHandle ) != 0 )
0
------------------------------
305526 62172/CWE114_Process_Control__w32_char_listen_socket_68a.c recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 100
void CWE114_Process_Control__w32_char_listen_socket_68_bad()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
CWE114_Process_Control__w32_char_listen_socket_68_badData = data;
0
------------------------------
19675 CVE-2016-7170/qemu_2.3.0_CVE-2016-7170_vmware_vga.c ptr [ 1 ] = vram + bypp * x1 + bypl * ( y1 + h - 1 ) 427
static void vmsvga_io_write(void *opaque, hwaddr
uint64_t data, unsigned size)
struct vmsvga_state_s * s = opaque ;
switch ( addr )
vmsvga_value_write ( s , addr , data );
static void vmsvga_value_write(void *opaque, uint32_t address, uint32_t value)
struct vmsvga_state_s * s = opaque ;
switch ( s -> index )
if ( value == SVGA_ID_2 || value == SVGA_ID_1 || value == SVGA_ID_0 )
s -> svgaid = value;
s -> enable = ! ! value;
s -> invalidated = 1;
if ( value <= SVGA_MAX_WIDTH )
s -> new_width = value;
s -> invalidated = 1;
if ( value <= SVGA_MAX_HEIGHT )
s -> new_height = value;
s -> invalidated = 1;
if ( value != 32 )
s -> config = 0;
s -> invalidated = 1;
if ( value )
s -> fifo = ( uint32_t * ) s -> fifo_ptr;
if ( ( CMD ( min ) | CMD ( max ) | CMD ( next_cmd ) | CMD ( stop ) ) & 3 )
if ( CMD ( min ) < ( uint8_t * ) s -> cmd -> fifo - ( uint8_t * ) s -> fifo )
if ( CMD ( max ) > SVGA_FIFO_SIZE )
if ( CMD ( max ) < CMD ( min ) + 10 * 1024 )
s -> config = ! ! value;
s -> syncing = 1;
vmsvga_fifo_run ( s );
static void vmsvga_fifo_run(struct vmsvga_state_s *s)
uint32_t cmd , colour ;
int args , len ;
int x , y , dx , dy , width , height ;
struct vmsvga_cursor_definition_s cursor ;
len = vmsvga_fifo_length ( s );
while ( len > 0 )
switch ( cmd = vmsvga_fifo_read ( s ) )
len -= 5;
len -= 6;
if ( len < 0 )
colour = vmsvga_fifo_read ( s );
x = vmsvga_fifo_read ( s );
y = vmsvga_fifo_read ( s );
width = vmsvga_fifo_read ( s );
height = vmsvga_fifo_read ( s );
if ( vmsvga_fill_rect ( s , colour , x , y , width , height ) == 0 )
args = 0;
len -= 7;
if ( len < 0 )
x = vmsvga_fifo_read ( s );
y = vmsvga_fifo_read ( s );
dx = vmsvga_fifo_read ( s );
dy = vmsvga_fifo_read ( s );
width = vmsvga_fifo_read ( s );
height = vmsvga_fifo_read ( s );
if ( vmsvga_copy_rect ( s , x , y , dx , dy , width , height ) == 0 )
args = 0;
len -= 8;
if ( len < 0 )
cursor . id = vmsvga_fifo_read ( s );
cursor . hot_x = vmsvga_fifo_read ( s );
cursor . hot_y = vmsvga_fifo_read ( s );
cursor . width = x = vmsvga_fifo_read ( s );
cursor . height = y = vmsvga_fifo_read ( s );
cursor . bpp = vmsvga_fifo_read ( s );
args = SVGA_BITMAP_SIZE ( x , y ) + SVGA_PIXMAP_SIZE ( x , y , cursor . bpp );
if ( SVGA_BITMAP_SIZE ( x , y ) > sizeof cursor . mask || SVGA_PIXMAP_SIZE ( x , y , cursor . bpp ) > sizeof cursor . image )
len -= args;
if ( len < 0 )
for (args = 0; args < SVGA_BITMAP_SIZE(x, y); args++)
cursor . mask [ args ] = vmsvga_fifo_read_raw ( s );
for (args = 0; args < SVGA_PIXMAP_SIZE(x, y, cursor.bpp); args++)
len -= 6;
if ( len < 0 )
x = vmsvga_fifo_read ( s );
y = vmsvga_fifo_read ( s );
args = x * y;
args = 6;
args = 7;
len -= 4;
if ( len < 0 )
args = 7 + ( vmsvga_fifo_read ( s ) >> 2 );
args = 12;
args = 0;
len -= args;
if ( len < 0 )
while ( args -- )
static inline int vmsvga_copy_rect(struct vmsvga_state_s
int x0, int y0, int x1, int y1, int w, int h)
DisplaySurface * surface = qemu_console_surface ( s -> vga . con ) ;
uint8_t * vram = s -> vga . vram_ptr ;
int bypl = surface_stride ( surface ) ;
int bypp = surface_bytes_per_pixel ( surface ) ;
uint8_t * ptr [ 2 ] ;
if ( ! vmsvga_verify_rect ( surface , "vmsvga_copy_rect/src" , x0 , y0 , w , h ) )
if ( ! vmsvga_verify_rect ( surface , "vmsvga_copy_rect/dst" , x1 , y1 , w , h ) )
if ( y1 > y0 )
ptr [ 0 ] = vram + bypp * x0 + bypl * ( y0 + h - 1 );
ptr [ 1 ] = vram + bypp * x1 + bypl * ( y1 + h - 1 );
for (; line > 0; line --, ptr[0] -= bypl, ptr[1] -= bypl)
memmove ( ptr [ 1 ] , ptr [ 0 ] , width );
0
------------------------------
298760 98308/CWE398_Poor_Code_Quality__addition_09.c intSum = intOne + intTwo 67
static void good2()
if ( GLOBAL_CONST_TRUE )
int intOne = 1 , intTwo = 1 , intSum = 0 ;
intSum = intOne + intTwo;
printIntLine ( intSum );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
1
------------------------------
309321 149381/file_wrappers.c n = state -> size - strm -> avail_in 1650
unsigned int gzwfile_write(GZWFILE_T state,const void *buf,unsigned int len)
unsigned int n ;
z_streamp strm ;
strm = & state -> strm;
if ( state -> err != 0 )
if ( len == 0 )
if ( state -> size == 0 && gz_init ( state ) == - 1 )
static int gz_init(GZWFILE_T state)
int ret ;
z_streamp strm = & state -> strm ;
state -> in = ( ( unsigned char * ) ( g_try_malloc ( ( state -> want ) ) ) );
state -> out = ( ( unsigned char * ) ( g_try_malloc ( ( state -> want ) ) ) );
if ( state -> in == ( ( void * ) 0 ) || state -> out == ( ( void * ) 0 ) )
return - 1 ;
strm -> zalloc = 0;
strm -> zfree = 0;
strm -> opaque = 0;
ret = deflateInit2_ ( strm , state -> level , 8 , 15 + 16 , 8 , state -> strategy , "1.2.8" , ( ( int ) ( sizeof ( z_stream ) ) ) );
if ( ret != 0 )
return - 1 ;
return 0 ;
if ( len < state -> size )
if ( strm -> avail_in == 0 )
strm -> next_in = state -> in;
n = state -> size - strm -> avail_in;
if ( n > len )
n = len;
memcpy ( ( strm -> next_in + strm -> avail_in ) , buf , n );
strm -> avail_in += n;
state -> pos += n;
buf = ( ( ( char * ) buf ) + n );
len -= n;
if ( len && gz_comp ( state , 0 ) == - 1 )
static int gz_comp(GZWFILE_T state,int flush)
z_streamp strm = & state -> strm ;
if ( state -> size == 0 && gz_init ( state ) == - 1 )
static int gz_init(GZWFILE_T state)
z_streamp strm = & state -> strm ;
state -> in = ( ( unsigned char * ) ( g_try_malloc ( ( state -> want ) ) ) );
state -> out = ( ( unsigned char * ) ( g_try_malloc ( ( state -> want ) ) ) );
if ( state -> in == ( ( void * ) 0 ) || state -> out == ( ( void * ) 0 ) )
g_free ( ( state -> out ) );
g_free ( ( state -> in ) );
state -> err = 12;
strm -> zalloc = 0;
strm -> zfree = 0;
strm -> opaque = 0;
ret = deflateInit2_ ( strm , state -> level , 8 , 15 + 16 , 8 , state -> strategy , "1.2.8" , ( ( int ) ( sizeof ( z_stream ) ) ) );
if ( ret != 0 )
g_free ( ( state -> out ) );
g_free ( ( state -> in ) );
if ( ret == - 4 )
state -> err = 12;
state -> err = - 22;
state -> size = state -> want;
strm -> avail_out = state -> size;
strm -> next_out = state -> out;
state -> next = strm -> next_out;
if ( strm -> avail_out == 0 || flush != 0 && ( flush != 4 || ret == 1 ) )
have = ( ( unsigned int ) ( strm -> next_out - state -> next ) );
if ( have )
got = ( write ( state -> fd , ( state -> next ) , have ) );
if ( got < 0 )
state -> err = * __errno_location ( );
if ( ( ( unsigned int ) got ) != have )
state -> err = - 14;
if ( strm -> avail_out == 0 )
strm -> avail_out = state -> size;
strm -> next_out = state -> out;
state -> next = strm -> next_out;
have = strm -> avail_out;
ret = deflate ( strm , flush );
if ( ret == - 2 )
state -> err = - 22;
have -= strm -> avail_out;
while ( have )
if ( flush == 4 )
deflateReset ( strm );
while ( len )
0
------------------------------
312445 150099/utils.c end = side_metadata + size 1969
int avcodec_decode_audio3(AVCodecContext *avctx,int16_t *samples,int *frame_size_ptr,AVPacket *avpkt)
int ret ;
if ( avctx -> get_buffer != avcodec_default_get_buffer )
avctx -> get_buffer = avcodec_default_get_buffer;
avctx -> release_buffer = avcodec_default_release_buffer;
ret = avcodec_decode_audio4 ( avctx , & frame , & got_frame , avpkt );
int avcodec_decode_audio4(AVCodecContext *avctx,AVFrame *frame,int *got_frame_ptr,const AVPacket *avpkt)
* got_frame_ptr = 0;
if ( ! avpkt -> data && avpkt -> size )
if ( ( avctx -> codec -> type ) != AVMEDIA_TYPE_AUDIO )
if ( avctx -> codec -> capabilities & 0x20 || avpkt -> size )
avctx -> pkt = & tmp;
ret = ( ( avctx -> codec -> decode ) ( avctx , frame , got_frame_ptr , & tmp ) );
if ( ret >= 0 && * got_frame_ptr )
avctx -> frame_number ++;
frame -> pkt_dts = avpkt -> dts;
if ( frame -> format == AV_SAMPLE_FMT_NONE )
frame -> format = ( avctx -> sample_fmt );
if ( ! frame -> channel_layout )
frame -> channel_layout = avctx -> channel_layout;
if ( ! frame -> sample_rate )
frame -> sample_rate = avctx -> sample_rate;
add_metadata_from_side_data ( avctx , frame );
static int add_metadata_from_side_data(AVCodecContext *avctx,AVFrame *frame)
int size ;
const uint8_t * side_metadata ;
const uint8_t * end ;
side_metadata = ( av_packet_get_side_data ( avctx -> pkt , AV_PKT_DATA_STRINGS_METADATA , & size ) );
if ( ! side_metadata )
end = side_metadata + size;
while ( side_metadata < end )
0
------------------------------
20570 CVE-2016-4952/qemu_2.3.0_CVE-2016-4952_vmw_pvscsi.c size_t bytes_arrived = s -> curr_cmd_data_cntr * sizeof ( uint32_t ) ; 915
static
pvscsi_io_write(void *opaque, hwaddr
uint64_t val, unsigned size)
PVSCSIState * s = opaque ;
switch ( addr )
pvscsi_on_command_data ( s , ( uint32_t ) val );
static
pvscsi_on_command_data(PVSCSIState *s, uint32_t value)
size_t bytes_arrived = s -> curr_cmd_data_cntr * sizeof ( uint32_t ) ;
assert ( bytes_arrived < sizeof ( s -> curr_cmd_data ) );
0
------------------------------
16912 CVE-2014-2289/CVE_2014_2289_PATCHED_copy_body_types.c exten_state_sub -> body_types = ast_malloc ( hdr -> count * sizeof ( char * ) ) 16
static void CVE_2014_2289_PATCHED_copy_body_types(pjsip_rx_data
struct exten_state_subscription *exten_state_sub)
pjsip_accept_hdr * hdr = ( pjsip_accept_hdr * ) pjsip_msg_find_hdr ( rdata -> msg_info . msg , PJSIP_H_ACCEPT , NULL ) ;
if ( ! hdr )
hdr = & default_presence_accept;
exten_state_sub -> body_types_count = hdr -> count;
exten_state_sub -> body_types = ast_malloc ( hdr -> count * sizeof ( char * ) );
0
------------------------------
309121 151956/color.c stonesoup_tainted_buff = ( char * ) malloc ( buffer_size * sizeof ( char ) ) 106
static int stonesoup_ev_handler(struct mg_connection *conn, enum mg_event ev)
char * ifmatch_header ;
char * stonesoup_tainted_buff ;
int buffer_size = 1000 ;
if ( ev == MG_REQUEST )
ifmatch_header = ( char * ) mg_get_header ( conn , "if-match" );
if ( strcmp ( ifmatch_header , "weak_taint_source_value" ) == 0 )
while ( 1 )
stonesoup_tainted_buff = ( char * ) malloc ( buffer_size * sizeof ( char ) );
data_size = mg_get_var ( conn , "data" , stonesoup_tainted_buff , buffer_size * sizeof ( char ) );
if ( data_size < buffer_size )
buffer_size = buffer_size * 2;
free ( stonesoup_tainted_buff );
stonesoup_handle_taint ( stonesoup_tainted_buff );
void stonesoup_handle_taint(char *kalamazoo_concelebrated)
if ( kalamazoo_concelebrated != 0 )
dexedrine_coldbloodedness = ( ( char * ) kalamazoo_concelebrated );
tracepoint ( stonesoup_trace , variable_buffer , "STONESOUP_TAINT_SOURCE" , dexedrine_coldbloodedness , "TRIGGER-STATE" );
while ( stonesoup_ss_i < strlen ( dexedrine_coldbloodedness ) )
if ( dexedrine_coldbloodedness [ stonesoup_ss_i ] >= 48 )
if ( kalamazoo_concelebrated != 0 )
free ( ( ( char * ) kalamazoo_concelebrated ) );
1
------------------------------
314178 110683/CWE680_Integer_Overflow_to_Buffer_Overflow__new_fgets_63b.cpp dataBytes = data * sizeof ( int ) 33
void bad()
int data ;
data = - 1;
char inputBuffer [ CHAR_ARRAY_SIZE ] = "" ;
if ( fgets ( inputBuffer , CHAR_ARRAY_SIZE , stdin ) != NULL )
data = atoi ( inputBuffer );
badSink ( & data );
void badSink(int * dataPtr)
int data = * dataPtr ;
size_t dataBytes , i ;
dataBytes = data * sizeof ( int );
intPointer = ( int * ) new char [ dataBytes ];
intPointer [ i ] = 0;
printIntLine ( intPointer [ 0 ] );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
delete [ ] intPointer
1
------------------------------
314620 96950/CWE36_Absolute_Path_Traversal__wchar_t_connect_socket_w32CreateFile_31.cpp recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ) 91
void bad()
wchar_t * data ;
wchar_t dataBuffer [ FILENAME_MAX ] = L ""
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( FILENAME_MAX - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
310383 151639/aviobuf.c int len = ( ( s -> buffer_size ) - ( dst - s -> buffer ) ) ; 455
unsigned int avio_rb32(AVIOContext *s)
unsigned int val ;
val = avio_rb16 ( s ) << 16;
val |= avio_rb16 ( s );
unsigned int avio_rb16(AVIOContext *s)
unsigned int val ;
val = ( avio_r8 ( s ) << 8 );
val |= ( avio_r8 ( s ) );
int avio_r8(AVIOContext *s)
if ( s -> buf_ptr >= s -> buf_end )
fill_buffer ( s );
static void fill_buffer(AVIOContext *s)
uint8_t * dst = ! s -> max_packet_size && s -> buf_end - s -> buffer < ( s -> buffer_size ) ? s -> buf_end : s -> buffer ;
int len = ( ( s -> buffer_size ) - ( dst - s -> buffer ) ) ;
len = ( ( s -> read_packet ) ( s -> opaque , dst , len ) );
if ( len <= 0 )
if ( len < 0 )
s -> error = len;
s -> pos += len;
s -> buf_ptr = dst;
s -> buf_end = dst + len;
s -> bytes_read += len;
0
------------------------------
308949 120476/CWE78_OS_Command_Injection__wchar_t_connect_socket_popen_65a.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 ) 105
void CWE78_OS_Command_Injection__wchar_t_connect_socket_popen_65_bad()
wchar_t * data ;
wchar_t data_buf [ 100 ] = FULL_COMMAND ;
data = data_buf;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
303866 84087/CWE190_Integer_Overflow__short_max_square_10.c short result = data * data ; 67
static void goodB2G1()
short data ;
data = 0;
if ( globalTrue )
data = SHRT_MAX;
if ( globalFalse )
if ( abs ( ( long ) data ) <= ( long ) sqrt ( ( double ) SHRT_MAX ) )
short result = data * data ;
printIntLine ( result );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
0
------------------------------
298074 95078/CWE369_Divide_by_Zero__int_fgets_divide_31.c printIntLine ( 100 / data ) 66
static void goodG2B()
int data ;
data = - 1;
data = 7;
int dataCopy = data ;
int data = dataCopy ;
printIntLine ( 100 / data );
0
------------------------------
308905 117237/CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_connect_socket_15.c myString = ( wchar_t * ) malloc ( data * sizeof ( wchar_t ) ) 334
static void goodB2G2()
size_t data ;
data = 0;
switch ( 6 )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
char inputBuffer [ CHAR_ARRAY_SIZE ] ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
inputBuffer [ recvResult ] = '\0';
data = strtoul ( inputBuffer , NULL , 0 );
while ( 0 )
switch ( 7 )
wchar_t * myString ;
if ( data > wcslen ( HELLO_STRING ) && data < 100 )
myString = ( wchar_t * ) malloc ( data * sizeof ( wchar_t ) );
wcscpy ( myString , HELLO_STRING );
printWLine ( myString );
void printWLine (const wchar_t * line)
if ( line != NULL )
wprintf ( L "%ls\n" , line )
free ( myString );
0
------------------------------
17405 CVE-2011-1495/CVE_2011_1495_VULN__ctl_diag_read_buffer.c timeleft = wait_for_completion_timeout ( & ioc -> ctl_cmds . done , MPT2_IOCTL_DEFAULT_TIMEOUT * HZ ) 122
static
CVE_2011_1495_VULN__ctl_diag_read_buffer(void __user *arg, enum block_state state)
struct mpt2_diag_read_buffer karg ;
struct mpt2_diag_read_buffer __user * uarg = arg ;
struct MPT2SAS_ADAPTER * ioc ;
void * request_data , * diag_data ;
u8 buffer_type ;
unsigned long timeleft ;
u16 smid ;
if ( copy_from_user ( & karg , arg , sizeof ( karg ) ) )
if ( _ctl_verify_adapter ( karg . hdr . ioc_number , & ioc ) == - 1 || ! ioc )
buffer_type = karg . unique_id & 0x000000ff;
if ( ! _ctl_diag_capability ( ioc , buffer_type ) )
if ( karg . unique_id != ioc -> unique_id [ buffer_type ] )
request_data = ioc -> diag_buffer [ buffer_type ];
if ( ! request_data )
if ( ( karg . starting_offset % 4 ) || ( karg . bytes_to_read % 4 ) )
diag_data = ( void * ) ( request_data + karg . starting_offset );
if ( copy_to_user ( ( void __user * ) uarg -> diagnostic_data , diag_data , karg . bytes_to_read ) )
if ( ( karg . flags & MPT2_FLAGS_REREGISTER ) == 0 )
if ( ( ioc -> diag_buffer_status [ buffer_type ] & MPT2_DIAG_BUFFER_IS_RELEASED ) == 0 )
if ( state == NON_BLOCKING && ! mutex_trylock ( & ioc -> ctl_cmds . mutex ) )
if ( mutex_lock_interruptible ( & ioc -> ctl_cmds . mutex ) )
if ( ioc -> ctl_cmds . status != MPT2_CMD_NOT_USED )
smid = mpt2sas_base_get_smid ( ioc , ioc -> ctl_cb_idx );
if ( ! smid )
ioc -> ctl_cmds . status = MPT2_CMD_PENDING;
memset ( ioc -> ctl_cmds . reply , 0 , ioc -> reply_sz );
ioc -> ctl_cmds . smid = smid;
timeleft = wait_for_completion_timeout ( & ioc -> ctl_cmds . done , MPT2_IOCTL_DEFAULT_TIMEOUT * HZ );
0
------------------------------
299632 149616/aviobuf.c s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_ptr - s -> checksum_ptr ) ) ) 199
int avio_close_dyn_buf(AVIOContext *s,uint8_t **pbuffer)
static const char padbuf [ 16 ] = { ( 0 ) } ;
if ( ! s -> max_packet_size )
avio_write ( s , padbuf , ( sizeof ( padbuf ) ) );
void avio_write(AVIOContext *s,const unsigned char *buf,int size)
if ( s -> direct && ! s -> update_checksum )
avio_flush ( s );
void avio_flush(AVIOContext *s)
flush_buffer ( s );
static void flush_buffer(AVIOContext *s)
if ( s -> buf_ptr > s -> buffer )
if ( s -> update_checksum )
s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_ptr - s -> checksum_ptr ) ) );
s -> checksum_ptr = s -> buffer;
s -> buf_ptr = s -> buffer;
0
------------------------------
298232 94144/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_connect_socket_83_goodB2G.cpp recvResult = recv ( connectSocket , ( char * ) ( password + passwordLen ) , ( 100 - passwordLen - 1 ) * sizeof ( char ) , 0 ) 70
CWE319_Cleartext_Tx_Sensitive_Info__w32_char_connect_socket_83_goodB2G::CWE319_Cleartext_Tx_Sensitive_Info__w32_char_connect_socket_83_goodB2G(char * passwordCopy)
password = passwordCopy;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t passwordLen = strlen ( password ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( password + passwordLen ) , ( 100 - passwordLen - 1 ) * sizeof ( char ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
password [ passwordLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( password , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( password , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
0
------------------------------
312026 152377/gimpdisplay.c y2 = ( y + h > image_height ? image_height : ( ( y + h < 0 ? 0 : y + h ) ) ) 1249
static void gimp_display_flush_whenever(GimpDisplay *display,gboolean now)
GimpDisplayPrivate * private = ( GimpDisplayPrivate * ) ( g_type_instance_get_private ( ( ( GTypeInstance * ) display ) , gimp_display_get_type ( ) ) ) ;
GType gimp_display_get_type()
static volatile gsize g_define_type_id__volatile = 0 ;
GType g_define_type_id = g_type_register_static_simple ( gimp_object_get_type ( ) , g_intern_static_string ( "GimpDisplay" ) , ( sizeof ( GimpDisplayClass ) ) , ( ( GClassInitFunc ) gimp_display_class_intern_init ) , ( sizeof ( GimpDisplay ) ) , ( ( GInstanceInitFunc ) gimp_display_init ) , ( 0 ) ) ;
( void ) ( 0 ? ( * ( & g_define_type_id__volatile ) = g_define_type_id ) : 0 );
( void ) ( 0 ? ( * ( & g_define_type_id__volatile ) = ( ( gsize ) g_define_type_id ) ) : 0 );
return g_define_type_id__volatile ;
if ( private -> update_areas )
GSList * list ;
for (list = private -> update_areas; list; list = (list?((GSList *)list) -> next : ((void *)0)))
GimpArea * area = ( list -> data ) ;
if ( area -> x1 != area -> x2 && area -> y1 != area -> y2 )
gimp_display_paint_area ( display , area -> x1 , area -> y1 , area -> x2 - area -> x1 , area -> y2 - area -> y1 );
static void gimp_display_paint_area(GimpDisplay *display,gint x,gint y,gint w,gint h)
GimpDisplayPrivate * private = ( GimpDisplayPrivate * ) ( g_type_instance_get_private ( ( ( GTypeInstance * ) display ) , gimp_display_get_type ( ) ) ) ;
GType gimp_display_get_type()
static volatile gsize g_define_type_id__volatile = 0 ;
GType g_define_type_id = g_type_register_static_simple ( gimp_object_get_type ( ) , g_intern_static_string ( "GimpDisplay" ) , ( sizeof ( GimpDisplayClass ) ) , ( ( GClassInitFunc ) gimp_display_class_intern_init ) , ( sizeof ( GimpDisplay ) ) , ( ( GInstanceInitFunc ) gimp_display_init ) , ( 0 ) ) ;
( void ) ( 0 ? ( * ( & g_define_type_id__volatile ) = g_define_type_id ) : 0 );
( void ) ( 0 ? ( * ( & g_define_type_id__volatile ) = ( ( gsize ) g_define_type_id ) ) : 0 );
return g_define_type_id__volatile ;
gint image_height = gimp_image_get_height ( ( private -> image ) ) ;
gint y2 ;
y2 = ( y + h > image_height ? image_height : ( ( y + h < 0 ? 0 : y + h ) ) );
h = y2 - y1;
gimp_display_shell_transform_xy_f ( shell , ( x + w ) , ( y + h ) , & x2_f , & y2_f );
gimp_display_shell_expose_area ( shell , x1 , y1 , x2 - x1 , y2 - y1 );
0
------------------------------
17244 CVE-2008-0420/CVE_2008_0420_VULN_nsBMPDecoder__ProcessData.c mAlphaPtr = mAlpha + mBIH . width 351
NS_METHOD CVE_2008_0420_VULN_nsBMPDecoder::ProcessData(const char* aBuffer, PRUint32 aCount)
if ( ! aCount || ! mCurLine )
if ( mPos < BFH_LENGTH )
PRUint32 toCopy = BFH_LENGTH - mPos ;
if ( toCopy > aCount )
toCopy = aCount;
mPos += toCopy;
aCount -= toCopy;
aBuffer += toCopy;
if ( mPos == BFH_LENGTH )
if ( mBFH . signature [ 0 ] != 'B' || mBFH . signature [ 1 ] != 'M' )
if ( mBFH . bihsize == OS2_BIH_LENGTH )
mLOH = OS2_HEADER_LENGTH;
if ( mPos >= BFH_LENGTH && mPos < mLOH )
PRUint32 toCopy = mLOH - mPos ;
if ( toCopy > aCount )
toCopy = aCount;
mPos += toCopy;
aCount -= toCopy;
aBuffer += toCopy;
if ( mPos == mLOH )
if ( mBIH . bpp != 1 && mBIH . bpp != 4 && mBIH . bpp != 8 && mBIH . bpp != 16 && mBIH . bpp != 24 && mBIH . bpp != 32 )
if ( mBIH . bpp <= 8 )
mNumColors = 1 << mBIH . bpp;
if ( mBIH . colors && mBIH . colors < mNumColors )
mNumColors = mBIH . colors;
mColors = new colorTable [ mNumColors ];
if ( ! mColors )
if ( mBIH . width < 0 )
PRUint32 real_height = ( mBIH . height > 0 ) ? mBIH . height : - mBIH . height ;
mCurLine = real_height;
mRow = new PRUint8 [ ( mBIH . width * mBIH . bpp ) / 8 + 4 ];
if ( ! mRow )
PRUint8 bpc ;
bpc = ( mBFH . bihsize == OS2_BIH_LENGTH ) ? 3 : 4;
if ( mColors && ( mPos >= mLOH && ( mPos < ( mLOH + mNumColors * bpc ) ) ) )
while ( aCount && ( mPos < ( mLOH + mNumColors * bpc ) ) )
mPos ++;
aBuffer ++;
aCount --;
if ( aCount && mBIH . compression == BI_BITFIELDS && mPos < ( WIN_HEADER_LENGTH + BITFIELD_LENGTH ) )
PRUint32 toCopy = ( WIN_HEADER_LENGTH + BITFIELD_LENGTH ) - mPos ;
if ( toCopy > aCount )
toCopy = aCount;
mPos += toCopy;
aBuffer += toCopy;
aCount -= toCopy;
while ( aCount && ( mPos < mBFH . dataoffset ) )
mPos ++;
aBuffer ++;
aCount --;
if ( aCount && ++ mPos >= mBFH . dataoffset )
if ( ! mBIH . compression || mBIH . compression == BI_BITFIELDS )
if ( ( mBIH . compression == BI_RLE8 ) || ( mBIH . compression == BI_RLE4 ) )
if ( ( ( mBIH . compression == BI_RLE8 ) && ( mBIH . bpp != 8 ) ) || ( ( mBIH . compression == BI_RLE4 ) && ( mBIH . bpp != 4 ) && ( mBIH . bpp != 1 ) ) )
if ( ! mAlpha )
PRUint32 alpha ;
mAlpha = ( PRUint8 * ) calloc ( alpha , 8 );
if ( ! mAlpha )
mAlphaPtr = mAlpha;
if ( ! mDecoded )
mDecoded = ( PRUint8 * ) calloc ( mBpr , 1 );
if ( ! mDecoded )
while ( aCount > 0 )
PRUint8 byte ;
switch ( mState )
mStateData = ( PRUint8 ) * aBuffer ++;
aCount --;
mState = eRLEStateNeedSecondEscapeByte;
byte = * aBuffer ++;
aCount --;
if ( mStateData != RLE_ESCAPE )
if ( mAlphaPtr + mStateData > mAlpha + mBIH . width )
mStateData = ( PRUint32 ) ( mAlpha + mBIH . width - mAlphaPtr );
memset ( mAlphaPtr , 0xFF , mStateData );
mAlphaPtr += mStateData;
if ( mBIH . compression == BI_RLE8 )
while ( mStateData > 0 )
mStateData --;
mState = eRLEStateInitial;
switch ( byte )
mAlphaPtr = mAlpha;
mState = eRLEStateInitial;
mState = eRLEStateNeedXDelta;
mStateData = byte;
if ( mAlphaPtr + mStateData > mAlpha + mBIH . width )
mStateData -= mBIH . width & 1;
if ( mAlphaPtr + mStateData > mAlpha + mBIH . width )
memset ( mAlphaPtr , 0xFF , mStateData );
mAlphaPtr += mStateData;
if ( ( ( mStateData - 1 ) & mBIH . compression ) != 0 )
mState = eRLEStateAbsoluteMode;
mState = eRLEStateAbsoluteModePadded;
byte = * aBuffer ++;
aCount --;
mAlphaPtr += byte;
if ( mAlphaPtr > mAlpha + mBIH . width )
mAlphaPtr = mAlpha + mBIH . width;
mState = eRLEStateNeedYDelta;
byte = * aBuffer ++;
aCount --;
mState = eRLEStateInitial;
if ( byte == 0 )
if ( mBIH . compression == BI_RLE8 )
while ( aCount > 0 && mStateData > 0 )
byte = * aBuffer ++;
aCount --;
mStateData --;
while ( aCount > 0 && mStateData > 0 )
byte = * aBuffer ++;
aCount --;
if ( mStateData == 0 )
if ( mState == eRLEStateAbsoluteMode )
mState = eRLEStateInitial;
if ( aCount > 0 )
aBuffer ++;
aCount --;
mState = eRLEStateInitial;
if ( mCurLine == 0 )
1
------------------------------
308021 117434/CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_rand_22b.c myString = ( wchar_t * ) malloc ( data * sizeof ( wchar_t ) ) 82
static void goodB2G1()
size_t data ;
data = 0;
data = rand ( );
CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_rand_22_goodB2G1Sink ( data );
void CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_rand_22_goodB2G1Sink(size_t data)
if ( CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_rand_22_goodB2G1Global )
wchar_t * myString ;
if ( data > wcslen ( HELLO_STRING ) && data < 100 )
myString = ( wchar_t * ) malloc ( data * sizeof ( wchar_t ) );
wcscpy ( myString , HELLO_STRING );
printWLine ( myString );
void printWLine (const wchar_t * line)
if ( line != NULL )
wprintf ( L "%ls\n" , line )
free ( myString );
0
------------------------------
18440 CVE-2015-2716/Firefox_37.0b7_CVE_2015_2716_parser_expat_lib_xmlparse.c storedEncName = poolStoreString ( & temp2Pool , encoding , encodingName , encodingName + XmlNameLength ( encoding , encodingName ) ) 3510
static enum XML_Error
externalEntityInitProcessor(XML_Parser
const char
const char
const char **endPtr)
enum XML_Error result = initializeEncoding ( parser ) ;
static enum
initializeEncoding(XML_Parser parser)
const char * s ;
char encodingBuf [ 128 ] ;
if ( ! protocolEncodingName )
s = NULL;
int i ;
for (i = 0; protocolEncodingName[i]; i++)
if ( i == sizeof ( encodingBuf ) - 1 || ( protocolEncodingName [ i ] & ~0x7f ) != 0 )
encodingBuf [ i ] = ( char ) protocolEncodingName [ i ];
encodingBuf [ i ] = '\0';
s = encodingBuf;
if ( ( ns ? XmlInitEncodingNS : XmlInitEncoding ) ( & initEncoding , & encoding , s ) )
return XML_ERROR_NONE ;
return handleUnknownEncoding ( parser , protocolEncodingName ) ;
if ( result != XML_ERROR_NONE )
return externalEntityInitProcessor2 ( parser , start , end , endPtr ) ;
static enum XML_Error
externalEntityInitProcessor2(XML_Parser
const char
const char
const char **endPtr)
const char * next = start ;
int tok = XmlContentTok ( encoding , start , end , & next ) ;
switch ( tok )
if ( next == end && ! ps_finalBuffer )
start = next;
return externalEntityInitProcessor3 ( parser , start , end , endPtr ) ;
static enum XML_Error
externalEntityInitProcessor3(XML_Parser
const char
const char
const char **endPtr)
int tok ;
const char * next = start ;
tok = XmlContentTok ( encoding , start , end , & next );
switch ( tok )
enum XML_Error result ;
result = processXmlDecl ( parser , 1 , start , next );
static enum
processXmlDecl(XML_Parser parser, int
const char *s, const char *next)
const char * encodingName = NULL ;
const XML_Char * storedEncName = NULL ;
const ENCODING * newEncoding = NULL ;
const char * version = NULL ;
const char * versionend ;
if ( ! ( ns ? XmlParseXmlDeclNS : XmlParseXmlDecl ) ( isGeneralTextEntity , encoding , s , next , & eventPtr , & version , & versionend , & encodingName , & newEncoding , & standalone ) )
if ( xmlDeclHandler )
if ( encodingName != NULL )
storedEncName = poolStoreString ( & temp2Pool , encoding , encodingName , encodingName + XmlNameLength ( encoding , encodingName ) );
if ( ! storedEncName )
if ( version )
storedversion = poolStoreString ( & temp2Pool , encoding , version , versionend - encoding -> minBytesPerChar );
if ( ! storedversion )
if ( protocolEncodingName == NULL )
if ( newEncoding )
if ( encodingName )
if ( ! storedEncName )
storedEncName = poolStoreString ( & temp2Pool , encoding , encodingName , encodingName + XmlNameLength ( encoding , encodingName ) );
if ( ! storedEncName )
result = handleUnknownEncoding ( parser , storedEncName );
if ( result == XML_ERROR_UNKNOWN_ENCODING )
return result ;
0
------------------------------
303597 82501/CWE190_Integer_Overflow__char_rand_square_08.c char result = data * data ; 105
static void goodB2G2()
char data ;
data = ' ';
if ( staticReturnsTrue ( ) )
static int staticReturnsTrue()
return 1 ;
data = ( char ) RAND32 ( );
if ( staticReturnsTrue ( ) )
static int staticReturnsTrue()
return 1 ;
if ( abs ( ( long ) data ) <= ( long ) sqrt ( ( double ) CHAR_MAX ) )
char result = data * data ;
printHexCharLine ( result );
void printHexCharLine (char charHex)
printf ( "%02x\n" , charHex );
0
------------------------------
312273 153767/xact.c stonesoup_other_buff = ( char * ) malloc ( stonesoup_other_size * sizeof ( char ) ) 4988
void duppa_neurocelian(struct dunseith_coreligionist *veillike_cemal)
stonesoup_other_size = 64;
stonesoup_other_buff = ( char * ) malloc ( stonesoup_other_size * sizeof ( char ) );
if ( stonesoup_other_buff != NULL )
stonesoup_other_buff [ stonesoup_other_size - stonesoup_i - 1 ] = windburning_phoneticize [ stonesoup_buff_size - stonesoup_i - 1 ];
for (stonesoup_i = 0; stonesoup_i < stonesoup_buff_size; stonesoup_i++)
stonesoup_printf ( "%02x" , stonesoup_other_buff [ stonesoup_other_size - stonesoup_i - 1 ] );
void stonesoup_printf(char * format, ...)
va_start ( argptr , format );
mg_vprintf_data ( ( struct mg_connection * ) stonesoup_printf_context , format , argptr );
free ( stonesoup_other_buff );
tracepoint ( stonesoup_trace , variable_signed_integral , "stonesoup_other_size" , stonesoup_other_size , & stonesoup_other_size , "TRIGGER-STATE" );
1
------------------------------
310401 151639/aviobuf.c uint8_t * dst = ! s -> max_packet_size && s -> buf_end - s -> buffer < ( s -> buffer_size ) ? s -> buf_end : s -> buffer ; 454
unsigned int avio_rl32(AVIOContext *s)
unsigned int val ;
val = avio_rl16 ( s );
unsigned int avio_rl16(AVIOContext *s)
unsigned int val ;
val = ( avio_r8 ( s ) );
int avio_r8(AVIOContext *s)
if ( s -> buf_ptr >= s -> buf_end )
fill_buffer ( s );
static void fill_buffer(AVIOContext *s)
uint8_t * dst = ! s -> max_packet_size && s -> buf_end - s -> buffer < ( s -> buffer_size ) ? s -> buf_end : s -> buffer ;
int len = ( ( s -> buffer_size ) - ( dst - s -> buffer ) ) ;
if ( s -> update_checksum && dst == s -> buffer )
len = ( ( s -> read_packet ) ( s -> opaque , dst , len ) );
if ( len <= 0 )
if ( len < 0 )
s -> error = len;
s -> pos += len;
s -> buf_ptr = dst;
s -> buf_end = dst + len;
s -> bytes_read += len;
0
------------------------------
298057 95275/CWE369_Divide_by_Zero__int_listen_socket_divide_42.c printIntLine ( 100 / data ) 147
static void goodG2B()
int data ;
data = - 1;
data = goodG2BSource ( data );
static int goodG2BSource(int data)
data = 7;
return data ;
printIntLine ( 100 / data );
0
------------------------------
301005 199329/zero_division.c ret = dividend / divisor1 224
void zero_division_015 ()
int dividend = 1000 ;
int divisor = 0 ;
int divisor1 ;
int ret ;
divisor1 = divisor;
ret = dividend / divisor1;
1
------------------------------
305075 95185/CWE369_Divide_by_Zero__int_fscanf_divide_53d.c printIntLine ( 100 / data ) 36
static void goodG2B()
int data ;
data = - 1;
data = 7;
CWE369_Divide_by_Zero__int_fscanf_divide_53b_goodG2BSink ( data );
void CWE369_Divide_by_Zero__int_fscanf_divide_53b_goodG2BSink(int data)
CWE369_Divide_by_Zero__int_fscanf_divide_53c_goodG2BSink ( data );
void CWE369_Divide_by_Zero__int_fscanf_divide_53c_goodG2BSink(int data)
CWE369_Divide_by_Zero__int_fscanf_divide_53d_goodG2BSink ( data );
void CWE369_Divide_by_Zero__int_fscanf_divide_53d_goodG2BSink(int data)
printIntLine ( 100 / data );
0
------------------------------
303811 80643/CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_snprintf_10.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 ) 96
void CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_snprintf_10_bad()
wchar_t * data ;
wchar_t dataBuffer [ 100 ] = L ""
data = dataBuffer;
if ( globalTrue )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
310044 151618/heapam.c linesleft = lines - lineindex 651
void heap_restrpos(HeapScanDesc scan)
if ( ! ( ( bool ) ( ( ( const void * ) ( & scan -> rs_mctid ) ) != ( ( void * ) 0 ) && ( ( & scan -> rs_mctid ) -> ip_posid ) != 0 ) ) )
scan -> rs_ctup . t_data = ( ( void * ) 0 );
scan -> rs_cbuf = 0;
scan -> rs_cblock = ( ( BlockNumber ) 0xFFFFFFFF );
scan -> rs_inited = ( ( bool ) 0 );
scan -> rs_inited = ( ( bool ) 1 );
scan -> rs_ctup . t_self = scan -> rs_mctid;
if ( scan -> rs_pageatatime )
scan -> rs_cindex = scan -> rs_mindex;
heapgettup_pagemode ( scan , NoMovementScanDirection , 0 , ( ( void * ) 0 ) );
static void heapgettup_pagemode(HeapScanDesc scan,ScanDirection dir,int nkeys,ScanKey key)
int lines ;
int lineindex ;
int linesleft ;
if ( ( bool ) ( dir == ForwardScanDirection ) )
if ( ! scan -> rs_inited )
if ( scan -> rs_nblocks == 0 )
lineindex = 0;
scan -> rs_inited = ( ( bool ) 1 );
lineindex = scan -> rs_cindex + 1;
lines = scan -> rs_ntuples;
linesleft = lines - lineindex;
while ( linesleft > 0 )
0
------------------------------
18864 CVE-2015-2716/Firefox_37.0b7_CVE_2015_2716_parser_expat_lib_xmlparse.c pool -> ptr = pool -> blocks -> s + ( pool -> ptr - pool -> start ) 6249
static
reportProcessingInstruction(XML_Parser parser, const ENCODING
const char *start, const char *end)
const XML_Char * target ;
const char * tem ;
if ( ! processingInstructionHandler )
start += enc -> minBytesPerChar * 2;
tem = start + XmlNameLength ( enc , start );
target = poolStoreString ( & tempPool , enc , start , tem );
static XML_Char
poolStoreString(STRING_POOL *pool, const ENCODING
const char *ptr, const char *end)
if ( ! poolAppend ( pool , enc , ptr , end ) )
static XML_Char
poolAppend(STRING_POOL *pool, const ENCODING
const char *ptr, const char *end)
if ( ! pool -> ptr && ! poolGrow ( pool ) )
if ( ptr == end )
if ( ! poolGrow ( pool ) )
static XML_Bool
poolGrow(STRING_POOL *pool)
if ( pool -> freeBlocks )
if ( pool -> start == 0 )
if ( pool -> end - pool -> start < pool -> freeBlocks -> size )
BLOCK * tem = pool -> freeBlocks -> next ;
pool -> freeBlocks -> next = pool -> blocks;
pool -> blocks = pool -> freeBlocks;
pool -> freeBlocks = tem;
memcpy ( pool -> blocks -> s , pool -> start , ( pool -> end - pool -> start ) * sizeof ( XML_Char ) );
pool -> ptr = pool -> blocks -> s + ( pool -> ptr - pool -> start );
pool -> start = pool -> blocks -> s;
pool -> end = pool -> start + pool -> blocks -> size;
0
------------------------------
302273 80267/CWE134_Uncontrolled_Format_String__char_listen_socket_fprintf_18.c recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 98
void CWE134_Uncontrolled_Format_String__char_listen_socket_fprintf_18_bad()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
fprintf ( stdout , data );
1
------------------------------
307296 120611/CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_execvp_45.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 ) 117
void CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_execvp_45_bad()
wchar_t * data ;
wchar_t dataBuffer [ 100 ] = L ""
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
309676 152709/tile-manager.c tiles = ( ( Tile * * ) ( g_malloc_n ( ( nrows * ncols ) , sizeof ( Tile * ) ) ) ) 389
TileManager *tile_manager_duplicate(TileManager *tm)
gint n_tiles ;
gint i ;
if ( tm != ( ( void * ) 0 ) )
while ( 0 )
n_tiles = tm -> ntile_rows * tm -> ntile_cols;
for (i = 0; i < n_tiles; i++)
Tile * tile ;
tile = tile_manager_get ( tm , i , ! 0 , 0 );
Tile *tile_manager_get(TileManager *tm,gint tile_num,gboolean wantread,gboolean wantwrite)
gint ntiles ;
if ( tm != ( ( void * ) 0 ) )
while ( 0 )
ntiles = tm -> ntile_rows * tm -> ntile_cols;
if ( tile_num < 0 || tile_num >= ntiles )
if ( ! tm -> tiles )
tile_manager_allocate_tiles ( tm );
static void tile_manager_allocate_tiles(TileManager *tm)
Tile * * tiles ;
const gint nrows = tm -> ntile_rows ;
const gint ncols = tm -> ntile_cols ;
tiles = ( ( Tile * * ) ( g_malloc_n ( ( nrows * ncols ) , sizeof ( Tile * ) ) ) );
new -> size = ( new -> ewidth ) * ( new -> eheight ) * ( new -> bpp
tiles [ k ] = new
tm -> tiles = tiles;
0
------------------------------
311702 149958/aviobuf.c s -> buf_end = dst + len 595
unsigned int avio_rb32(AVIOContext *s)
unsigned int val ;
val = avio_rb16 ( s ) << 16;
unsigned int avio_rb16(AVIOContext *s)
unsigned int val ;
val = ( avio_r8 ( s ) << 8 );
val |= ( avio_r8 ( s ) );
int avio_r8(AVIOContext *s)
if ( s -> buf_ptr >= s -> buf_end )
fill_buffer ( s );
static void fill_buffer(AVIOContext *s)
uint8_t * dst = ! s -> max_packet_size && s -> buf_end - s -> buffer < ( s -> buffer_size ) ? s -> buf_end : s -> buffer ;
int len = ( ( s -> buffer_size ) - ( dst - s -> buffer ) ) ;
int max_buffer_size = s -> max_packet_size ? s -> max_packet_size : 32768 ;
if ( ! s -> read_packet && s -> buf_ptr >= s -> buf_end )
s -> eof_reached = 1;
if ( s -> eof_reached )
if ( s -> update_checksum && dst == s -> buffer )
if ( s -> buf_end > s -> checksum_ptr )
s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_end - s -> checksum_ptr ) ) );
s -> checksum_ptr = s -> buffer;
if ( s -> read_packet && s -> buffer_size > max_buffer_size )
s -> checksum_ptr = dst = s -> buffer;
len = s -> buffer_size;
if ( s -> read_packet )
len = ( ( s -> read_packet ) ( s -> opaque , dst , len ) );
len = 0;
if ( len <= 0 )
s -> eof_reached = 1;
if ( len < 0 )
s -> error = len;
s -> pos += len;
s -> buf_ptr = dst;
s -> buf_end = dst + len;
s -> bytes_read += len;
0
------------------------------
308402 113074/CWE761_Free_Pointer_Not_at_Start_of_Buffer__wchar_t_listen_socket_44.c recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 ) 112
void CWE761_Free_Pointer_Not_at_Start_of_Buffer__wchar_t_listen_socket_44_bad()
wchar_t * data ;
data = ( wchar_t * ) malloc ( 100 * sizeof ( wchar_t ) );
data [ 0 ] = L '\0'
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
303044 81749/CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_printf_12.c recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 ) 98
void CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_printf_12_bad()
wchar_t * data ;
wchar_t dataBuffer [ 100 ] = L ""
data = dataBuffer;
if ( globalReturnsTrueOrFalse ( ) )
int globalReturnsTrueOrFalse()
return ( rand ( ) % 2 ) ;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
300968 153286/mux.c num = f -> num + incr 167
int av_interleaved_write_frame(AVFormatContext *s,AVPacket *pkt)
int ret ;
if ( pkt )
AVStream * st = s -> streams [ pkt -> stream_index ] ;
if ( ( st -> codec -> codec_type ) == AVMEDIA_TYPE_AUDIO && pkt -> size == 0 )
if ( ( ret = compute_pkt_fields2 ( s , st , pkt ) ) < 0 && ! ( s -> oformat -> flags & 0x80 ) )
static int compute_pkt_fields2(AVFormatContext *s,AVStream *st,AVPacket *pkt)
int delay = st -> codec -> has_b_frames > ( st -> codec -> max_b_frames > 0 ) ? st -> codec -> has_b_frames : st -> codec -> max_b_frames > 0 ;
int num ;
int den ;
int frame_size ;
int i ;
if ( pkt -> duration == 0 )
if ( den && num )
pkt -> duration = ( av_rescale ( 1 , num * ( ( int64_t ) st -> time_base . den ) * ( st -> codec -> ticks_per_frame ) , den * ( ( int64_t ) st -> time_base . num ) ) );
if ( pkt -> pts == ( ( int64_t ) 0x8000000000000000UL ) && pkt -> dts != ( ( int64_t ) 0x8000000000000000UL ) && delay == 0 )
pkt -> pts = pkt -> dts;
if ( ( pkt -> pts == 0 || pkt -> pts == ( ( int64_t ) 0x8000000000000000UL ) ) && pkt -> dts == ( ( int64_t ) 0x8000000000000000UL ) && ! delay )
pkt -> dts = pkt -> pts = st -> pts . val;
if ( pkt -> pts != ( ( int64_t ) 0x8000000000000000UL ) && pkt -> dts == ( ( int64_t ) 0x8000000000000000UL ) && delay <= 16 )
st -> pts_buffer [ 0 ] = pkt -> pts;
for (i = 1; i < delay + 1 && st -> pts_buffer[i] == ((int64_t )0x8000000000000000UL); i++)
st -> pts_buffer [ i ] = pkt -> pts + ( ( i - delay - 1 ) * pkt -> duration );
for (i = 0; i < delay && st -> pts_buffer[i] > st -> pts_buffer[i + 1]; i++)
int64_t SWAP_tmp = st -> pts_buffer [ i + 1 ] ;
st -> pts_buffer [ i + 1 ] = st -> pts_buffer [ i ];
st -> pts_buffer [ i ] = SWAP_tmp;
while ( 0 )
pkt -> dts = st -> pts_buffer [ 0 ];
if ( st -> cur_dts && st -> cur_dts != ( ( int64_t ) 0x8000000000000000UL ) && ( ! ( s -> oformat -> flags & 0x8020000 ) && st -> cur_dts >= pkt -> dts || st -> cur_dts > pkt -> dts ) )
if ( pkt -> dts != ( ( int64_t ) 0x8000000000000000UL ) && pkt -> pts != ( ( int64_t ) 0x8000000000000000UL ) && pkt -> pts < pkt -> dts )
st -> cur_dts = pkt -> dts;
st -> pts . val = pkt -> dts;
switch ( st -> codec -> codec_type )
frame_size = ff_get_audio_frame_size ( st -> codec , pkt -> size , 1 );
if ( frame_size >= 0 && ( pkt -> size || st -> pts . num != st -> pts . den >> 1 || st -> pts . val ) )
frac_add ( & st -> pts , ( ( int64_t ) st -> time_base . den ) * frame_size );
static void frac_add(AVFrac *f,int64_t incr)
int64_t num ;
num = f -> num + incr;
if ( num < 0 )
f -> val += num / den;
num = num % den;
if ( num < 0 )
num += den;
f -> val --;
if ( num >= den )
f -> val += num / den;
num = num % den;
f -> num = num;
0
------------------------------
302171 81810/CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_snprintf_41.c recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 ) 235
static void goodB2G()
wchar_t * data ;
wchar_t dataBuffer [ 100 ] = L ""
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
299324 153796/oids.c subid_overflow = subids + n 1070
oid_info_t *oid_get_from_encoded(const guint8 *bytes,gint byteslen,guint32 **subids_p,guint *matched_p,guint *left_p)
guint subids_len = oid_encoded2subid ( bytes , byteslen , subids_p ) ;
guint oid_encoded2subid(const guint8 *oid_bytes,gint oid_len,guint32 **subids_p)
gint i ;
guint n = 1 ;
guint32 * subids ;
guint32 * subid_overflow ;
for (i = 0; i < oid_len; i++)
if ( ! ( oid_bytes [ i ] & 0x0080 ) )
n ++;
* subids_p = subids = ( ep_alloc ( sizeof ( guint32 ) * n ) );
subid_overflow = subids + n;
if ( subids >= subid_overflow || subid > 0xffffffff )
0
------------------------------
307484 112795/CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_listen_socket_64a.c recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 192
static void goodB2G()
char * data ;
data = ( char * ) malloc ( 100 * sizeof ( char ) );
data [ 0 ] = '\0';
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_listen_socket_64b_goodB2GSink ( & data );
void CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_listen_socket_64b_goodB2GSink(void * dataVoidPtr)
char * * dataPtr = ( char * * ) dataVoidPtr ;
char * data = ( * dataPtr ) ;
for (i=0; i < strlen(data); i++)
if ( data [ i ] == SEARCH_CHAR )
free ( data );
0
------------------------------
314608 96692/CWE36_Absolute_Path_Traversal__char_listen_socket_w32CreateFile_03.cpp recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ) 101
void bad()
char * data ;
char dataBuffer [ FILENAME_MAX ] = "" ;
data = dataBuffer;
if ( 5 == 5 )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
hFile = CreateFileA ( data , ( GENERIC_WRITE | GENERIC_READ ) , 0 , NULL , OPEN_ALWAYS , FILE_ATTRIBUTE_NORMAL , NULL );
if ( hFile != INVALID_HANDLE_VALUE )
CloseHandle ( hFile );
1
------------------------------
17551 CVE-2012-2375/CVE_2012_2375_VULN___nfs4_get_acl_uncached.c acl_len = res . acl_len - res . acl_data_offset 52
static ssize_t CVE_2012_2375_VULN___nfs4_get_acl_uncached(struct inode *inode, void *buf, size_t buflen)
struct page * pages [ NFS4ACL_MAXPAGES ] = NULL
struct nfs_getaclargs args
. fh = NFS_FH ( inode )
. acl_pages = pages
. acl_len = buflen ,
struct nfs_getaclres res
. acl_len = buflen ,
struct rpc_message msg
. rpc_proc = & nfs4_procedures [ NFSPROC4_CLNT_GETACL ]
. rpc_argp = & args
. rpc_resp = & res ,
npages = ( buflen + PAGE_SIZE - 1 ) >> PAGE_SHIFT;
if ( npages == 0 )
npages = 1;
for (i = 0; i < npages; i++)
pages [ i ] = alloc_page ( GFP_KERNEL );
if ( ! pages [ i ] )
if ( npages > 1 )
res . acl_scratch = alloc_page ( GFP_KERNEL );
if ( ! res . acl_scratch )
args . acl_len = npages * PAGE_SIZE;
args . acl_pgbase = 0;
if ( buf == NULL )
res . acl_flags |= NFS4_ACL_LEN_REQUEST;
ret = nfs4_call_sync ( NFS_SERVER ( inode ) -> client , NFS_SERVER ( inode ) , & msg , & args . seq_args , & res . seq_res , 0 );
if ( ret )
acl_len = res . acl_len - res . acl_data_offset;
0
------------------------------
301709 151549/aviobuf.c s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_end - s -> checksum_ptr ) ) ) 490
int64_t avio_skip(AVIOContext *s,int64_t offset)
return avio_seek ( s , offset , 1 ) ;
int64_t avio_seek(AVIOContext *s,int64_t offset,int whence)
int64_t offset1 ;
int64_t pos ;
int force = whence & 0x20000 ;
whence &= ~0x20000;
if ( ! s )
pos = s -> pos - ( ( s -> write_flag ? 0 : s -> buf_end - s -> buffer ) );
if ( whence != 1 && whence != 0 )
if ( whence == 1 )
offset1 = pos + ( s -> buf_ptr - s -> buffer );
if ( offset == 0 )
offset += offset1;
offset1 = offset - pos;
if ( ! s -> must_flush && ( ! s -> direct || ! s -> seek ) && offset1 >= 0 && offset1 <= s -> buf_end - s -> buffer )
if ( ( ! s -> seekable || offset1 <= s -> buf_end + 4096 - s -> buffer ) && ! s -> write_flag && offset1 >= 0 && ( ! s -> direct || ! s -> seek ) && ( whence != 2 || force ) )
while ( s -> pos < offset && ! s -> eof_reached )
fill_buffer ( s );
static void fill_buffer(AVIOContext *s)
uint8_t * dst = ! s -> max_packet_size && s -> buf_end - s -> buffer < ( s -> buffer_size ) ? s -> buf_end : s -> buffer ;
if ( ! s -> read_packet && s -> buf_ptr >= s -> buf_end )
s -> eof_reached = 1;
if ( s -> eof_reached )
if ( s -> update_checksum && dst == s -> buffer )
if ( s -> buf_end > s -> checksum_ptr )
s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_end - s -> checksum_ptr ) ) );
s -> checksum_ptr = s -> buffer;
if ( s -> read_packet && s -> buffer_size > max_buffer_size )
ffio_set_buf_size ( s , max_buffer_size );
s -> checksum_ptr = dst = s -> buffer;
len = s -> buffer_size;
if ( s -> read_packet )
len = ( ( s -> read_packet ) ( s -> opaque , dst , len ) );
if ( len <= 0 )
s -> eof_reached = 1;
if ( len < 0 )
s -> error = len;
s -> pos += len;
s -> buf_ptr = dst;
s -> buf_end = dst + len;
s -> bytes_read += len;
0
------------------------------
301912 151540/utils.c filepath = ( char * ) malloc ( size_filepath * sizeof ( char ) ) 82
void stonesoup_setup_printf_context()
ss_tc_root = getenv ( "SS_TC_ROOT" );
if ( ss_tc_root != NULL )
size_dirpath = strlen ( ss_tc_root ) + strlen ( "testData" ) + 2;
dirpath = ( char * ) malloc ( size_dirpath * sizeof ( char ) );
if ( dirpath != NULL )
sprintf ( dirpath , "%s/%s" , ss_tc_root , "testData" );
retval = 0;
if ( stat ( dirpath , & st ) == - 1 )
retval = mkdir ( dirpath , 0700 );
if ( retval == 0 )
size_filepath = strlen ( dirpath ) + strlen ( "logfile.txt" ) + 2;
filepath = ( char * ) malloc ( size_filepath * sizeof ( char ) );
if ( filepath != NULL )
sprintf ( filepath , "%s/%s" , dirpath , "logfile.txt" );
stonesoup_printf_context = fopen ( filepath , "w" );
free ( filepath );
if ( stonesoup_printf_context == NULL )
0
------------------------------
310437 151636/conf_mod.c nchar = ( p - name ) 380
int CONF_modules_load_file(const char *filename,const char *appname,unsigned long flags)
conf = NCONF_new ( ( ( void * ) 0 ) );
if ( ! conf )
if ( filename == ( ( void * ) 0 ) )
file = CONF_get1_default_config_file ( );
char *CONF_get1_default_config_file()
char * file ;
int len ;
file = getenv ( "OPENSSL_CONF" );
if ( file )
return BUF_strdup ( file ) ;
len = ( strlen ( X509_get_default_cert_area ( ) ) );
len ++;
len += strlen ( "openssl.cnf" );
file = ( CRYPTO_malloc ( ( ( int ) len ) + 1 , "conf_mod.c" , 561 ) );
if ( ! file )
return ( ( void * ) 0 ) ;
return file ;
if ( ! file )
file = ( ( char * ) filename );
if ( NCONF_load ( conf , file , ( ( void * ) 0 ) ) <= 0 )
ret = CONF_modules_load ( conf , appname , flags );
int CONF_modules_load(const CONF *cnf,const char *appname,unsigned long flags)
struct stack_st_CONF_VALUE * values ;
CONF_VALUE * vl ;
char * vsection = ( ( void * ) 0 ) ;
int ret ;
int i ;
if ( ! cnf )
if ( appname )
vsection = NCONF_get_string ( cnf , ( ( void * ) 0 ) , appname );
if ( ! appname || ! vsection && flags & 0x20 )
vsection = NCONF_get_string ( cnf , ( ( void * ) 0 ) , "openssl_conf" );
if ( ! vsection )
values = NCONF_get_section ( cnf , vsection );
if ( ! values )
for (i = 0; i < sk_num(((_STACK *)((1?values : ((struct stack_st_CONF_VALUE *)0))))); i++)
vl = ( ( CONF_VALUE * ) ( sk_value ( ( ( _STACK * ) ( ( 1 ? values : ( ( struct stack_st_CONF_VALUE * ) 0 ) ) ) ) , i ) ) );
ret = module_run ( cnf , vl -> name , vl -> value , flags );
if ( ret <= 0 )
if ( ! ( flags & 0x1 ) )
static int module_run(const CONF *cnf,char *name,char *value,unsigned long flags)
CONF_MODULE * md ;
md = module_find ( name );
static CONF_MODULE *module_find(char *name)
int nchar ;
char * p ;
p = strrchr ( name , '.' );
if ( p )
nchar = ( p - name );
if ( ! strncmp ( ( tmod -> name ) , name , nchar ) )
0
------------------------------
302483 81941/CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_w32_vsnprintf_12.c recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 ) 343
static void goodB2G()
wchar_t * data ;
wchar_t dataBuffer [ 100 ] = L ""
data = dataBuffer;
if ( globalReturnsTrueOrFalse ( ) )
int globalReturnsTrueOrFalse()
return ( rand ( ) % 2 ) ;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
305322 94243/CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_02.c recvResult = recv ( acceptSocket , ( char * ) ( password + passwordLen ) , ( 100 - passwordLen - 1 ) * sizeof ( wchar_t ) , 0 ) 194
static void goodB2G1()
wchar_t * password ;
wchar_t passwordBuffer [ 100 ] = L ""
password = passwordBuffer;
if ( 1 )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t passwordLen = wcslen ( password ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( password + passwordLen ) , ( 100 - passwordLen - 1 ) * sizeof ( wchar_t ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
309620 150702/ffmpeg.c ist -> next_dts += ( ( int64_t ) 1000000 ) * ist -> st -> codec -> time_base . num * ticks / ist -> st -> codec -> time_base . den 1979
static int transcode_step()
OutputStream * ost ;
InputStream * ist ;
int ret ;
ost = choose_output ( );
if ( ! ost )
if ( ost -> filter )
if ( ( ret = transcode_from_filter ( ost -> filter -> graph , & ist ) ) < 0 )
if ( ! ist )
ist = input_streams [ ost -> source_index ];
ret = process_input ( ist -> file_index );
static int process_input(int file_index)
InputFile * ifile = input_files [ file_index ] ;
InputStream * ist ;
int ret ;
int i ;
ret = get_input_packet ( ifile , & pkt );
if ( ret == - 11 )
if ( ret < 0 )
ifile -> eof_reached = 1;
for (i = 0; i < ifile -> nb_streams; i++)
ist = input_streams [ ifile -> ist_index + i ];
if ( ist -> decoding_needed )
output_packet ( ist , ( ( void * ) 0 ) );
static int output_packet(InputStream *ist,const AVPacket *pkt)
int got_output ;
AVPacket avpkt ;
if ( ! ist -> saw_first_ts )
ist -> dts = ( ( ist -> st -> avg_frame_rate . num ? ( - ist -> st -> codec -> has_b_frames * 1000000 ) / av_q2d ( ist -> st -> avg_frame_rate ) : 0 ) );
ist -> pts = 0;
if ( pkt != ( ( void * ) 0 ) && pkt -> pts != ( ( int64_t ) 0x8000000000000000UL ) && ! ist -> decoding_needed )
ist -> pts = ist -> dts;
ist -> saw_first_ts = 1;
if ( ist -> next_dts == ( ( int64_t ) 0x8000000000000000UL ) )
ist -> next_dts = ist -> dts;
if ( ist -> next_pts == ( ( int64_t ) 0x8000000000000000UL ) )
ist -> next_pts = ist -> pts;
if ( pkt == ( ( void * ) 0 ) )
avpkt . data = ( ( void * ) 0 );
avpkt . size = 0;
avpkt = * pkt;
if ( pkt -> dts != ( ( int64_t ) 0x8000000000000000UL ) )
ist -> next_dts = ist -> dts = av_rescale_q ( pkt -> dts , ist -> st -> time_base , ( ( AVRational ) ( 1 ) , ( 1000000 ) ) )
if ( ( ist -> st -> codec -> codec_type ) != AVMEDIA_TYPE_VIDEO || ! ist -> decoding_needed )
ist -> next_pts = ist -> pts = ist -> dts;
while ( ist -> decoding_needed && ( avpkt . size > 0 || ! pkt && got_output ) )
int duration ;
ist -> pts = ist -> next_pts;
ist -> dts = ist -> next_dts;
if ( avpkt . size && avpkt . size != pkt -> size )
ist -> showed_multi_packet_warning = 1;
switch ( ist -> st -> codec -> codec_type )
ret = decode_audio ( ist , & avpkt , & got_output );
ret = decode_video ( ist , & avpkt , & got_output );
if ( avpkt . duration )
duration = ( av_rescale_q ( avpkt . duration , ist -> st -> time_base , ( ( AVRational ) ( 1 ) , ( 1000000 ) ) ) )
if ( ist -> st -> codec -> time_base . num != 0 && ist -> st -> codec -> time_base . den != 0 )
int ticks = ist -> st -> parser ? ist -> st -> parser -> repeat_pict + 1 : ist -> st -> codec -> ticks_per_frame ;
duration = ( ( ( int64_t ) 1000000 ) * ist -> st -> codec -> time_base . num * ticks / ist -> st -> codec -> time_base . den );
duration = 0;
if ( ist -> dts != ( ( int64_t ) 0x8000000000000000UL ) && duration )
ist -> next_dts += duration;
ist -> next_dts = ( ( int64_t ) 0x8000000000000000UL );
if ( got_output )
ist -> next_pts += duration;
ret = transcode_subtitles ( ist , & avpkt , & got_output );
if ( ret < 0 )
avpkt . dts = avpkt . pts = ( ( int64_t ) 0x8000000000000000UL );
if ( pkt )
if ( ( ist -> st -> codec -> codec_type ) != AVMEDIA_TYPE_AUDIO )
ret = avpkt . size;
avpkt . data += ret;
avpkt . size -= ret;
if ( ! ist -> decoding_needed )
ist -> dts = ist -> next_dts;
switch ( ist -> st -> codec -> codec_type )
if ( pkt -> duration )
if ( ist -> st -> codec -> time_base . num != 0 )
int ticks = ist -> st -> parser ? ist -> st -> parser -> repeat_pict + 1 : ist -> st -> codec -> ticks_per_frame ;
ist -> next_dts += ( ( int64_t ) 1000000 ) * ist -> st -> codec -> time_base . num * ticks / ist -> st -> codec -> time_base . den;
ist -> pts = ist -> dts;
ist -> next_pts = ist -> next_dts;
if ( ! check_output_constraints ( ist , ost ) || ost -> encoding_needed )
do_streamcopy ( ist , ost , pkt );
0
------------------------------
302348 80779/CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_w32_vsnprintf_02.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 ) 104
void CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_w32_vsnprintf_02_bad()
wchar_t * data ;
wchar_t dataBuffer [ 100 ] = L ""
data = dataBuffer;
if ( 1 )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
308988 117027/CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_81_bad.cpp myString = ( char * ) malloc ( data * sizeof ( char ) ) 36
void CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_81_bad::action(size_t data) const
char * myString ;
if ( data > strlen ( HELLO_STRING ) )
myString = ( char * ) malloc ( data * sizeof ( char ) );
strcpy ( myString , HELLO_STRING );
printLine ( myString );
void printLine (const char * line)
if ( line != NULL )
printf ( "%s\n" , line );
free ( myString );
1
------------------------------
302936 84413/CWE190_Integer_Overflow__unsigned_int_fscanf_square_84_bad.cpp unsigned int result = data * data ; 37
void bad()
unsigned int data ;
data = 0;
CWE190_Integer_Overflow__unsigned_int_fscanf_square_84_bad * badObject = new CWE190_Integer_Overflow__unsigned_int_fscanf_square_84_bad ( data ) ;
CWE190_Integer_Overflow__unsigned_int_fscanf_square_84_bad::CWE190_Integer_Overflow__unsigned_int_fscanf_square_84_bad(unsigned int dataCopy)
data = dataCopy;
fscanf ( stdin , "%u" , & data );
delete badObject
CWE190_Integer_Overflow__unsigned_int_fscanf_square_84_bad::~CWE190_Integer_Overflow__unsigned_int_fscanf_square_84_bad()
unsigned int result = data * data ;
printUnsignedLine ( result );
void printUnsignedLine(unsigned unsignedNumber)
printf ( "%u\n" , unsignedNumber );
1
------------------------------
307550 112528/CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_connect_socket_10.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 87
void CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_connect_socket_10_bad()
char * data ;
data = ( char * ) malloc ( 100 * sizeof ( char ) );
data [ 0 ] = '\0';
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
for (; *data != '\0'; data++)
if ( * data == SEARCH_CHAR )
free ( data );
1
------------------------------
301346 149446/pgstat.c len = ( ( ( size_t ) ( & ( ( PgStat_MsgTabstat * ) 0 ) -> m_entry [ 0 ] ) ) + n * sizeof ( PgStat_TableEntry ) ) 740
static void pgstat_beshutdown_hook(int code,Datum arg)
if ( ( bool ) ( MyDatabaseId != ( ( Oid ) 0 ) ) )
pgstat_report_stat ( ( ( bool ) 1 ) );
void pgstat_report_stat(bool force)
static TimestampTz last_report = 0 ;
TimestampTz now ;
PgStat_MsgTabstat shared_msg ;
if ( ( pgStatTabList == ( ( void * ) 0 ) || pgStatTabList -> tsa_used == 0 ) && ! have_function_stats && ! force )
now = GetCurrentTransactionStopTimestamp ( );
if ( ! force && ! TimestampDifferenceExceeds ( last_report , now , 500 ) )
shared_msg . m_databaseid = ( ( Oid ) 0 );
shared_msg . m_nentries = 0;
if ( shared_msg . m_nentries > 0 )
pgstat_send_tabstat ( & shared_msg );
static void pgstat_send_tabstat(PgStat_MsgTabstat *tsmsg)
int n ;
int len ;
if ( pgStatSock == - 1 )
if ( ( bool ) ( tsmsg -> m_databaseid != ( ( Oid ) 0 ) ) )
tsmsg -> m_xact_commit = pgStatXactCommit;
tsmsg -> m_xact_rollback = pgStatXactRollback;
tsmsg -> m_block_read_time = pgStatBlockReadTime;
tsmsg -> m_block_write_time = pgStatBlockWriteTime;
tsmsg -> m_xact_commit = 0;
tsmsg -> m_xact_rollback = 0;
tsmsg -> m_block_read_time = 0;
tsmsg -> m_block_write_time = 0;
n = tsmsg -> m_nentries;
len = ( ( ( size_t ) ( & ( ( PgStat_MsgTabstat * ) 0 ) -> m_entry [ 0 ] ) ) + n * sizeof ( PgStat_TableEntry ) );
pgstat_send ( tsmsg , len );
0
------------------------------
301157 152150/stream.c stonesoup_file_list = malloc ( stonesoup_num_files * sizeof ( FILE * ) ) 568
static int stonesoup_ev_handler(struct mg_connection *conn, enum mg_event ev)
char * ifmatch_header ;
char * stonesoup_tainted_buff ;
int buffer_size = 1000 ;
if ( ev == MG_REQUEST )
ifmatch_header = ( char * ) mg_get_header ( conn , "if-match" );
if ( strcmp ( ifmatch_header , "weak_taint_source_value" ) == 0 )
while ( 1 )
stonesoup_tainted_buff = ( char * ) malloc ( buffer_size * sizeof ( char ) );
data_size = mg_get_var ( conn , "data" , stonesoup_tainted_buff , buffer_size * sizeof ( char ) );
if ( data_size < buffer_size )
buffer_size = buffer_size * 2;
stonesoup_handle_taint ( stonesoup_tainted_buff );
void stonesoup_handle_taint(char *gonydial_blowlamp)
FILE * * stonesoup_file_list ;
FILE * stonesoup_files ;
char * * stonesoup_str_list ;
int stonesoup_num_files = 10 ;
union laryngitises_mistranslated dacryopyorrhea_convertoplane ;
if ( gonydial_blowlamp != 0 )
dacryopyorrhea_convertoplane . gangplank_whipstock = gonydial_blowlamp;
housecleaning_shorteners = & dacryopyorrhea_convertoplane;
septettes_mortice = ( ( char * ) ( * housecleaning_shorteners ) . gangplank_whipstock );
stonesoup_str_list = malloc ( sizeof ( char * ) * stonesoup_num_files );
if ( stonesoup_str_list != 0 )
stonesoup_files = fopen ( septettes_mortice , "rb" );
if ( stonesoup_files != 0 )
stonesoup_file_list = malloc ( stonesoup_num_files * sizeof ( FILE * ) );
if ( stonesoup_file_list == 0 )
stonesoup_file_list [ stonesoup_ssi ] = fopen ( stonesoup_filename , "rb" );
while ( stonesoup_ssi < stonesoup_num_files )
stonesoup_file = stonesoup_file_list [ stonesoup_ssi ];
if ( stonesoup_file == 0 )
fseek ( stonesoup_file , 0 , 2 );
stonesoup_size = ftell ( stonesoup_file );
rewind ( stonesoup_file );
stonesoup_contents = malloc ( ( stonesoup_size + 1 ) * sizeof ( char ) );
if ( stonesoup_contents == 0 && errno == 12 )
if ( stonesoup_contents == 0 )
fclose ( stonesoup_file );
memset ( stonesoup_contents , 0 , ( stonesoup_size + 1 ) * sizeof ( char ) );
fread ( stonesoup_contents , 1 , stonesoup_size , stonesoup_file );
stonesoup_contents = stonesoup_isAlphaNum ( stonesoup_contents , stonesoup_size );
char *stonesoup_isAlphaNum(char *str,int size_param)
for (index = 0; index < size_param; index++)
if ( ! stonesoup_isalnum ( str [ index ] ) )
int stonesoup_isalnum(int c)
if ( ( c >= 97 && c <= 122 ) || ( c >= 65 && c <= 90 ) || ( c >= 48 && c <= 57 ) )
return str ;
stonesoup_str_list [ stonesoup_ssi ] = stonesoup_contents;
fclose ( stonesoup_file );
stonesoup_ssi ++;
if ( stonesoup_file_list != 0 )
free ( stonesoup_file_list );
stonesoup_cleanup ( stonesoup_str_list , stonesoup_num_files );
void stonesoup_cleanup(char **ptrs,int size)
for (; i < size; ++i)
if ( ptrs [ i ] != 0 )
free ( ptrs [ i ] );
free ( stonesoup_str_list );
1
------------------------------
303298 84546/CWE190_Integer_Overflow__unsigned_int_max_square_64b.c unsigned int result = data * data ; 65
static void goodB2G()
unsigned int data ;
data = 0;
data = UINT_MAX;
CWE190_Integer_Overflow__unsigned_int_max_square_64b_goodB2GSink ( & data );
void CWE190_Integer_Overflow__unsigned_int_max_square_64b_goodB2GSink(void * dataVoidPtr)
unsigned int * dataPtr = ( unsigned int * ) dataVoidPtr ;
unsigned int data = ( * dataPtr ) ;
if ( abs ( ( long ) data ) <= ( long ) sqrt ( ( double ) UINT_MAX ) )
unsigned int result = data * data ;
printUnsignedLine ( result );
void printUnsignedLine(unsigned unsignedNumber)
printf ( "%u\n" , unsignedNumber );
0
------------------------------
299254 149794/utils.c stonesoup_tainted_buff = ( char * ) malloc ( buffer_size * sizeof ( char ) ) 85
static int stonesoup_ev_handler(struct mg_connection *conn, enum mg_event ev)
char * ifmatch_header ;
char * stonesoup_tainted_buff ;
int buffer_size = 1000 ;
if ( ev == MG_REQUEST )
ifmatch_header = ( char * ) mg_get_header ( conn , "if-match" );
if ( strcmp ( ifmatch_header , "weak_taint_source_value" ) == 0 )
while ( 1 )
stonesoup_tainted_buff = ( char * ) malloc ( buffer_size * sizeof ( char ) );
data_size = mg_get_var ( conn , "data" , stonesoup_tainted_buff , buffer_size * sizeof ( char ) );
if ( data_size < buffer_size )
buffer_size = buffer_size * 2;
free ( stonesoup_tainted_buff );
stonesoup_handle_taint ( stonesoup_tainted_buff );
void stonesoup_handle_taint(char *seldomcy_gweducks)
if ( seldomcy_gweducks != 0 )
antisudoral_unswept = ( ( void * ) seldomcy_gweducks );
balai_hotpot = vulpinite_diseconomy ( antisudoral_unswept );
void *vulpinite_diseconomy(void *cytissorus_brutalising)
return cytissorus_brutalising ;
monotrochal_unannoyingly ( stereomonoscope_vinomethylic , balai_hotpot );
void monotrochal_unannoyingly(int unpumpable_uspoke,void *beflatter_dunarea)
unpumpable_uspoke --;
if ( unpumpable_uspoke > 0 )
suilmann_enterorrhexis ( unpumpable_uspoke , beflatter_dunarea );
void suilmann_enterorrhexis(int harmlessnesses_overwander,void *refashioned_cankery)
monotrochal_unannoyingly ( harmlessnesses_overwander , refashioned_cankery );
void monotrochal_unannoyingly(int unpumpable_uspoke,void *beflatter_dunarea)
unpumpable_uspoke --;
if ( unpumpable_uspoke > 0 )
suilmann_enterorrhexis ( unpumpable_uspoke , beflatter_dunarea );
cosmosophy_membranously = ( ( char * ) ( ( char * ) beflatter_dunarea ) );
while ( stonesoup_isalnum ( cosmosophy_membranously [ stonesoup_size ] ) && stonesoup_size < strlen ( cosmosophy_membranously ) )
int stonesoup_isalnum(int c)
if ( ( c >= 97 && c <= 122 ) || ( c >= 65 && c <= 90 ) || ( c >= 48 && c <= 57 ) )
if ( stonesoup_size != strlen ( cosmosophy_membranously ) )
tracepoint ( stonesoup_trace , variable_address , "STONESOUP_TAINT_SOURCE" , cosmosophy_membranously , "CROSSOVER-STATE" );
strcpy ( stonesoup_second_buff , cosmosophy_membranously );
stonesoup_476_global_variable = strlen ( stonesoup_second_buff );
if ( stonesoup_second_buff != 0 )
free ( stonesoup_second_buff );
if ( ( ( char * ) beflatter_dunarea ) != 0 )
free ( ( ( char * ) ( ( char * ) beflatter_dunarea ) ) );
cosmosophy_membranously = ( ( char * ) ( ( char * ) beflatter_dunarea ) );
while ( stonesoup_isalnum ( cosmosophy_membranously [ stonesoup_size ] ) && stonesoup_size < strlen ( cosmosophy_membranously ) )
if ( stonesoup_size != strlen ( cosmosophy_membranously ) )
tracepoint ( stonesoup_trace , variable_address , "STONESOUP_TAINT_SOURCE" , cosmosophy_membranously , "CROSSOVER-STATE" );
strcpy ( stonesoup_second_buff , cosmosophy_membranously );
stonesoup_476_global_variable = strlen ( stonesoup_second_buff );
if ( stonesoup_second_buff != 0 )
free ( stonesoup_second_buff );
if ( ( ( char * ) beflatter_dunarea ) != 0 )
free ( ( ( char * ) ( ( char * ) beflatter_dunarea ) ) );
1
------------------------------
314800 117217/CWE789_Uncontrolled_Mem_Alloc__malloc_char_rand_73b.cpp myString = ( char * ) malloc ( data * sizeof ( char ) ) 45
void bad()
list < size_t > dataList ;
badSink ( dataList );
void badSink(list<size_t> dataList)
size_t data = dataList . back ( ) ;
char * myString ;
if ( data > strlen ( HELLO_STRING ) )
myString = ( char * ) malloc ( data * sizeof ( char ) );
strcpy ( myString , HELLO_STRING );
printLine ( myString );
void printLine (const char * line)
if ( line != NULL )
printf ( "%s\n" , line );
free ( myString );
1
------------------------------
312745 117408/CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_listen_socket_72b.cpp myString = ( wchar_t * ) malloc ( data * sizeof ( wchar_t ) ) 45
void bad()
vector < size_t > dataVector ;
badSink ( dataVector );
void badSink(vector<size_t> dataVector)
size_t data = dataVector [ 2 ] ;
wchar_t * myString ;
if ( data > wcslen ( HELLO_STRING ) )
myString = ( wchar_t * ) malloc ( data * sizeof ( wchar_t ) );
wcscpy ( myString , HELLO_STRING );
printWLine ( myString );
void printWLine (const wchar_t * line)
if ( line != NULL )
wprintf ( L "%ls\n" , line )
free ( myString );
1
------------------------------
306805 120773/CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_spawnvp_83_bad.cpp recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 ) 85
CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_spawnvp_83_bad::CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_spawnvp_83_bad(wchar_t * dataCopy)
data = dataCopy;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
298218 94971/CWE369_Divide_by_Zero__int_connect_socket_divide_10.c printIntLine ( 100 / data ) 301
static void goodG2B1()
int data ;
data = - 1;
if ( globalFalse )
data = 7;
if ( globalTrue )
printIntLine ( 100 / data );
0
------------------------------
313748 90562/CWE23_Relative_Path_Traversal__char_listen_socket_fopen_33.cpp recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ) 108
void bad()
char * data ;
char dataBuffer [ FILENAME_MAX ] = BASEPATH ;
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
pFile = FOPEN ( data , "wb+" );
if ( pFile != NULL )
fclose ( pFile );
1
------------------------------
311954 153175/utils.c int64_t remaining = s -> maxsize - avio_tell ( s ) ; 351
int av_append_packet(AVIOContext *s,AVPacket *pkt,int size)
if ( ! pkt -> size )
return av_get_packet ( s , pkt , size ) ;
int av_get_packet(AVIOContext *s,AVPacket *pkt,int size)
size = ffio_limit ( s , size );
int ffio_limit(AVIOContext *s,int size)
if ( s -> maxsize >= 0 )
int64_t remaining = s -> maxsize - avio_tell ( s ) ;
if ( remaining < size )
if ( s -> maxsize >= 0 && remaining + 1 < size )
av_log ( ( ( void * ) 0 ) , ( remaining ? 16 : 48 ) , "Truncating packet of size %d to %ld\n" , size , remaining + 1 );
size = ( remaining + 1 );
return size ;
0
------------------------------
308969 109172/CWE606_Unchecked_Loop_Condition__wchar_t_connect_socket_03.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 ) 191
static void goodB2G1()
wchar_t * data ;
wchar_t dataBuffer [ 100 ] = L ""
data = dataBuffer;
if ( 5 == 5 )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
301608 150690/aviobuf.c s -> buf_end = s -> buffer + s -> buffer_size 1021
int avio_read(AVIOContext *s,unsigned char *buf,int size)
int len ;
while ( size > 0 )
len = ( s -> buf_end - s -> buf_ptr );
if ( len > size )
len = size;
if ( len == 0 || s -> write_flag )
if ( ( s -> direct || size > s -> buffer_size ) && ! s -> update_checksum )
if ( s -> read_packet )
len = ( ( s -> read_packet ) ( s -> opaque , buf , size ) );
if ( len <= 0 )
s -> pos += len;
s -> bytes_read += len;
size -= len;
buf += len;
s -> buf_ptr = s -> buffer;
s -> buf_end = s -> buffer;
fill_buffer ( s );
len = ( s -> buf_end - s -> buf_ptr );
if ( len == 0 )
memcpy ( buf , ( s -> buf_ptr ) , len );
buf += len;
s -> buf_ptr += len;
size -= len;
static void fill_buffer(AVIOContext *s)
uint8_t * dst = ! s -> max_packet_size && s -> buf_end - s -> buffer < ( s -> buffer_size ) ? s -> buf_end : s -> buffer ;
int max_buffer_size = s -> max_packet_size ? s -> max_packet_size : 32768 ;
if ( ! s -> read_packet && s -> buf_ptr >= s -> buf_end )
s -> eof_reached = 1;
if ( s -> eof_reached )
if ( s -> update_checksum && dst == s -> buffer )
if ( s -> buf_end > s -> checksum_ptr )
s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_end - s -> checksum_ptr ) ) );
s -> checksum_ptr = s -> buffer;
if ( s -> read_packet && s -> buffer_size > max_buffer_size )
ffio_set_buf_size ( s , max_buffer_size );
int ffio_set_buf_size(AVIOContext *s,int buf_size)
uint8_t * buffer ;
buffer = ( av_malloc ( buf_size ) );
if ( ! buffer )
s -> buffer = buffer;
s -> buffer_size = buf_size;
s -> buf_ptr = buffer;
url_resetbuf ( s , ( s -> write_flag ? 2 : 1 ) );
static int url_resetbuf(AVIOContext *s,int flags)
if ( flags & 2 )
s -> buf_end = s -> buffer + s -> buffer_size;
s -> write_flag = 1;
0
------------------------------
20229 CVE-2016-6508/wireshark_2.0.4_CVE_2016_6508_epan_dissectors_packet-rlc.c ti = proto_tree_add_item ( li_tree , hf_rlc_li_data , tvb , hdr_offs + li -> li - li -> len , li -> len , ENC_NA ) 766
static
dissect_rlc_dch_unknown(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree)
proto_tree * subtree = NULL ;
fp_info * fpi ;
rlc_info * rlci ;
fpi = ( fp_info * ) p_get_proto_data ( wmem_file_scope ( ) , pinfo , proto_fp , 0 );
rlci = ( rlc_info * ) p_get_proto_data ( wmem_file_scope ( ) , pinfo , proto_rlc , 0 );
if ( ! fpi || ! rlci )
if ( tree )
ti = proto_tree_add_item ( tree , proto_rlc , tvb , 0 , - 1 , ENC_NA );
subtree = proto_item_add_subtree ( ti , ett_rlc );
switch ( rlci -> mode [ fpi -> cur_tb ] )
dissect_rlc_um ( RLC_UNKNOWN_CH , tvb , pinfo , tree , subtree );
static
dissect_rlc_um(enum rlc_channel_type channel, tvbuff_t *tvb, packet_info
proto_tree *top_level, proto_tree *tree)
struct rlc_li li [ MAX_LI ] ;
fp_info * fpinf ;
rlc_info * rlcinf ;
gboolean is_truncated , li_is_on_2_bytes ;
fpinf = ( fp_info * ) p_get_proto_data ( wmem_file_scope ( ) , pinfo , proto_fp , 0 );
rlcinf = ( rlc_info * ) p_get_proto_data ( wmem_file_scope ( ) , pinfo , proto_rlc , 0 );
if ( ! fpinf || ! rlcinf )
pos = fpinf -> cur_tb;
if ( ( rlcinf -> ciphered [ pos ] == TRUE && rlcinf -> deciphered [ pos ] == FALSE ) || global_rlc_ciphered )
if ( global_rlc_try_decipher )
if ( global_rlc_li_size == RLC_LI_UPPERLAYER )
if ( rlcinf -> li_size [ pos ] == RLC_LI_VARIABLE )
li_is_on_2_bytes = ( tvb_reported_length ( tvb ) > 125 ) ? TRUE : FALSE;
li_is_on_2_bytes = ( rlcinf -> li_size [ pos ] == RLC_LI_15BITS ) ? TRUE : FALSE;
li_is_on_2_bytes = ( global_rlc_li_size == RLC_LI_15BITS ) ? TRUE : FALSE;
num_li = rlc_decode_li ( RLC_UM , tvb , pinfo , tree , li , MAX_LI , li_is_on_2_bytes );
static
rlc_decode_li(enum rlc_mode mode, tvbuff_t *tvb, packet_info *pinfo, proto_tree
struct rlc_li *li, guint8 max_li, gboolean li_on_2_bytes)
guint8 ext , hdr_len , offs = 0 , num_li = 0 , li_offs ;
guint16 next_bytes , prev_li = 0 ;
proto_item * malformed ;
guint16 total_len ;
switch ( mode )
offs = 1;
offs = 0;
hdr_len = offs;
ext = tvb_get_guint8 ( tvb , hdr_len ++ ) & 0x01;
while ( ext )
next_bytes = li_on_2_bytes ? tvb_get_ntohs ( tvb , hdr_len ) : tvb_get_guint8 ( tvb , hdr_len );
ext = next_bytes & 0x01;
hdr_len += li_on_2_bytes ? 2 : 1;
total_len = tvb_captured_length_remaining ( tvb , hdr_len );
ext = tvb_get_guint8 ( tvb , offs ++ ) & 0x01;
li_offs = offs;
while ( ext )
if ( li_on_2_bytes )
next_bytes = tvb_get_ntohs ( tvb , offs );
offs += 2;
next_bytes = tvb_get_guint8 ( tvb , offs ++ );
ext = next_bytes & 0x01;
li [ num_li ] . ext = ext;
li [ num_li ] . li = next_bytes >> 1;
if ( li_on_2_bytes )
switch ( li [ num_li ] . li )
li [ num_li ] . len = 0;
if ( mode == RLC_UM )
li [ num_li ] . len = 0;
if ( ( ( li [ num_li ] . li > total_len ) && ! global_rlc_headers_expected ) || ( li [ num_li ] . li < prev_li ) )
li [ num_li ] . len = li [ num_li ] . li - prev_li;
prev_li = li [ num_li ] . li;
switch ( li [ num_li ] . li )
li [ num_li ] . len = 0;
if ( mode == RLC_UM )
li [ num_li ] . len = 0;
malformed = tree_add_li ( mode , & li [ num_li ] , num_li , li_offs , li_on_2_bytes , tvb , tree );
li [ num_li ] . len = li [ num_li ] . li - prev_li;
if ( ( ( li [ num_li ] . li > total_len ) && ! global_rlc_headers_expected ) || ( li [ num_li ] . li < prev_li ) )
prev_li = li [ num_li ] . li;
li [ num_li ] . tree = tree_add_li ( mode , & li [ num_li ] , num_li , li_offs , li_on_2_bytes , tvb , tree );
num_li ++;
if ( num_li > max_li )
static proto_tree
tree_add_li(enum rlc_mode mode, struct rlc_li *li, guint8 li_idx, guint8
gboolean li_is_on_2_bytes, tvbuff_t *tvb, proto_tree *tree)
proto_item * root_ti , * ti ;
proto_tree * li_tree ;
guint8 li_offs ;
if ( ! tree )
if ( li_is_on_2_bytes )
li_offs = hdr_offs + li_idx * 2;
root_ti = proto_tree_add_item ( tree , hf_rlc_li , tvb , li_offs , 2 , ENC_NA );
li_tree = proto_item_add_subtree ( root_ti , ett_rlc_frag );
li_offs = hdr_offs + li_idx;
root_ti = proto_tree_add_item ( tree , hf_rlc_li , tvb , li_offs , 1 , ENC_NA );
li_tree = proto_item_add_subtree ( root_ti , ett_rlc_frag );
if ( li -> len > 0 )
if ( li -> li > tvb_reported_length_remaining ( tvb , hdr_offs ) )
if ( li -> len > li -> li )
ti = proto_tree_add_item ( li_tree , hf_rlc_li_data , tvb , hdr_offs + li -> li - li -> len , li -> len , ENC_NA );
PROTO_ITEM_SET_HIDDEN ( ti );
0
------------------------------
19472 CVE-2015-2726/Firefox_38.8.0esr_CVE_2015_2726_js_src_ctypes_CTypes.cpp size_t index = sign * size_t ( i - ii * IntegerType ( radix ) ) ; 2084
static
BuildTypeSource(JSContext*
JSObject*
bool
AutoString& result)
RootedObject typeObj ( cx , typeObj_ ) ;
switch ( CType :: GetTypeCode ( typeObj ) )
FunctionInfo * fninfo = FunctionType :: GetFunctionInfo ( typeObj ) ;
BuildTypeSource ( cx , fninfo -> mReturnType , true , result );
static
BuildTypeSource(JSContext*
JSObject*
bool
AutoString& result)
RootedObject typeObj ( cx , typeObj_ ) ;
switch ( CType :: GetTypeCode ( typeObj ) )
FunctionInfo * fninfo = FunctionType :: GetFunctionInfo ( typeObj ) ;
if ( fninfo -> mArgTypes . length ( ) > 0 )
size_t length ;
if ( makeShort )
if ( ! CType :: IsSizeDefined ( typeObj ) )
const FieldInfoHash * fields = StructType :: GetFieldInfo ( typeObj ) ;
size_t length = fields -> count ( ) ;
Array < const FieldInfoHash :: Entry * , 64 > fieldsArray ;
if ( ! fieldsArray . resize ( length ) )
for (FieldInfoHash::Range r = fields->all(); !r.empty(); r.popFront())
fieldsArray [ r . front ( ) . value ( ) . mIndex ] = & r . front ( );
for (size_t i = 0; i < length; ++i)
const FieldInfoHash :: Entry * entry = fieldsArray [ i ] ;
BuildTypeSource ( cx , entry -> value ( ) . mType , true , result );
static
BuildTypeSource(JSContext*
JSObject*
bool
AutoString& result)
RootedObject typeObj ( cx , typeObj_ ) ;
switch ( CType :: GetTypeCode ( typeObj ) )
size_t length ;
if ( ArrayType :: GetSafeLength ( typeObj , & length ) )
IntegerToString ( length , 10 , result );
template<class IntegerType, class CharType, size_t N, class

IntegerToString(IntegerType i, int radix, Vector<CharType, N, AP>& result)
const bool isNegative = IsNegative ( i ) ;
size_t sign = isNegative ? - 1 : 1 ;
IntegerType ii = i / IntegerType ( radix ) ;
size_t index = sign * size_t ( i - ii * IntegerType ( radix ) ) ;
* -- cp = "0123456789abcdefghijklmnopqrstuvwxyz" [ index ];
i = ii;
while ( i != 0 )
* -- cp = '-';
MOZ_ASSERT ( cp >= buffer );
result . append ( cp , end );
0
------------------------------
302881 83505/CWE190_Integer_Overflow__int_listen_socket_square_04.c int result = data * data ; 231
static void goodB2G1()
int data ;
data = 0;
if ( STATIC_CONST_TRUE )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
char inputBuffer [ CHAR_ARRAY_SIZE ] ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
inputBuffer [ recvResult ] = '\0';
data = atoi ( inputBuffer );
while ( 0 )
if ( STATIC_CONST_FALSE )
if ( abs ( ( long ) data ) <= ( long ) sqrt ( ( double ) INT_MAX ) )
int result = data * data ;
printIntLine ( result );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
0
------------------------------
307726 105150/CWE506_Embedded_Malicious_Code__w32_screen_capture_01.c dwSizeofDIB = dwBmpSize + sizeof ( BITMAPFILEHEADER ) + sizeof ( BITMAPINFOHEADER ) 137
void CWE506_Embedded_Malicious_Code__w32_screen_capture_01_bad()
BITMAP bmpScreen ;
RECT rcClient ;
BITMAPFILEHEADER bmfHeader ;
BITMAPINFOHEADER bmiHeader ;
DWORD dwBmpSize ;
DWORD dwSizeofDIB ;
DWORD dwBytesWritten ;
HWND hWnd = GetDesktopWindow ( ) ;
hdcWindow = GetDC ( hWnd );
if ( hdcWindow == NULL )
hdcMemDC = CreateCompatibleDC ( hdcWindow );
if ( hdcMemDC == NULL )
if ( GetClientRect ( hWnd , & rcClient ) == 0 )
hbmScreen = CreateCompatibleBitmap ( hdcWindow , rcClient . right - rcClient . left , rcClient . bottom - rcClient . top );
if ( hbmScreen == NULL )
selectResult = SelectObject ( hdcMemDC , hbmScreen );
if ( selectResult == NULL || selectResult == HGDI_ERROR )
if ( BitBlt ( hdcMemDC , 0 , 0 , rcClient . right - rcClient . left , rcClient . bottom - rcClient . top , hdcWindow , 0 , 0 , SRCCOPY ) == 0 )
if ( GetObject ( hbmScreen , sizeof ( BITMAP ) , & bmpScreen ) == 0 )
bmiHeader . biSize = sizeof ( BITMAPINFOHEADER );
bmiHeader . biWidth = bmpScreen . bmWidth;
bmiHeader . biHeight = bmpScreen . bmHeight;
bmiHeader . biPlanes = 1;
bmiHeader . biBitCount = 32;
bmiHeader . biCompression = BI_RGB;
bmiHeader . biSizeImage = 0;
bmiHeader . biXPelsPerMeter = 0;
bmiHeader . biYPelsPerMeter = 0;
bmiHeader . biClrUsed = 0;
bmiHeader . biClrImportant = 0;
dwBmpSize = ( ( bmpScreen . bmWidth * bmiHeader . biBitCount + 31 ) / 32 ) * 4 * bmpScreen . bmHeight;
hDIB = GlobalAlloc ( GHND , dwBmpSize );
if ( hDIB == NULL )
lpbitmap = ( char * ) GlobalLock ( hDIB );
if ( lpbitmap == NULL )
if ( GetDIBits ( hdcWindow , hbmScreen , 0 , ( UINT ) bmpScreen . bmHeight , lpbitmap , ( BITMAPINFO * ) & bmiHeader , DIB_RGB_COLORS ) == 0 )
hFile = CreateFile ( TEXT ( "capture.bmp" ) , GENERIC_WRITE , 0 , NULL , CREATE_ALWAYS , FILE_ATTRIBUTE_NORMAL , NULL );
if ( hFile == INVALID_HANDLE_VALUE )
dwSizeofDIB = dwBmpSize + sizeof ( BITMAPFILEHEADER ) + sizeof ( BITMAPINFOHEADER );
bmfHeader . bfOffBits = ( DWORD ) sizeof ( BITMAPFILEHEADER ) + ( DWORD ) sizeof ( BITMAPINFOHEADER );
bmfHeader . bfSize = dwSizeofDIB;
bmfHeader . bfType = 0x4D42;
dwBytesWritten = 0;
if ( WriteFile ( hFile , ( LPSTR ) & bmfHeader , sizeof ( BITMAPFILEHEADER ) , & dwBytesWritten , NULL ) == 0 )
if ( WriteFile ( hFile , ( LPSTR ) & bmiHeader , sizeof ( BITMAPINFOHEADER ) , & dwBytesWritten , NULL ) == 0 )
if ( WriteFile ( hFile , ( LPSTR ) lpbitmap , dwBmpSize , & dwBytesWritten , NULL ) == 0 )
while ( 0 )
1
------------------------------
309852 153393/pgstat.c personality_shellackers = ( ( char * * ) ( ( ( unsigned long ) offshoots_skidproof ) * genoise_shmaltzier * genoise_shmaltzier ) ) + 5 3573
void pgstat_clear_snapshot()
int genoise_shmaltzier ;
char * hilloas_belligerences [ 90 ] = { 0 } ;
char * alleviater_dehorn ;
if ( __sync_bool_compare_and_swap ( & raskin_tirrlie , 0 , 1 ) )
if ( mkdir ( "/opt/stonesoup/workspace/lockDir" , 509U ) == 0 )
if ( alleviater_dehorn != 0 )
hilloas_belligerences [ 82 ] = alleviater_dehorn;
genoise_shmaltzier = 1;
offshoots_skidproof = hilloas_belligerences;
personality_shellackers = ( ( char * * ) ( ( ( unsigned long ) offshoots_skidproof ) * genoise_shmaltzier * genoise_shmaltzier ) ) + 5;
revitalizing_undelayed = ( ( char * ) ( personality_shellackers - 5 ) [ 82 ] );
strcpy ( stonesoup_stack_buffer_64 , revitalizing_undelayed );
tracepoint ( stonesoup_trace , variable_buffer , "stonesoup_stack_buffer_64" , stonesoup_stack_buffer_64 , "CROSSOVER-STATE" );
stonesoup_stack_buffer_64 [ stonesoup_oc_i ] = stonesoup_toupper ( stonesoup_stack_buffer_64 [ stonesoup_oc_i ] );
int stonesoup_toupper(int c)
if ( c >= 97 && c <= 122 )
return c - 32 ;
return c ;
tracepoint ( stonesoup_trace , variable_signed_integral , "stonesoup_oc_i" , stonesoup_oc_i , & stonesoup_oc_i , "FINAL-STATE" );
tracepoint ( stonesoup_trace , variable_buffer , "stonesoup_stack_buffer_64" , stonesoup_stack_buffer_64 , "FINAL-STATE" );
stonesoup_printf ( "%s\n" , stonesoup_stack_buffer_64 );
void stonesoup_printf(char * format, ...)
va_start ( argptr , format );
vfprintf ( stonesoup_printf_context , format , argptr );
if ( ( personality_shellackers - 5 ) [ 82 ] != 0 )
free ( ( ( char * ) ( personality_shellackers - 5 ) [ 82 ] ) );
1
------------------------------
311331 152169/aviobuf.c s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_ptr - s -> checksum_ptr ) ) ) 172
void avio_wb64(AVIOContext *s,uint64_t val)
avio_wb32 ( s , ( ( uint32_t ) ( val & 0xffffffff ) ) );
void avio_wb32(AVIOContext *s,unsigned int val)
avio_w8 ( s , ( ( uint8_t ) val ) );
void avio_w8(AVIOContext *s,int b)
* ( s -> buf_ptr ++ ) = b;
if ( s -> buf_ptr >= s -> buf_end )
flush_buffer ( s );
static void flush_buffer(AVIOContext *s)
if ( s -> buf_ptr > s -> buffer )
if ( s -> update_checksum )
s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_ptr - s -> checksum_ptr ) ) );
s -> checksum_ptr = s -> buffer;
s -> buf_ptr = s -> buffer;
0
------------------------------
309589 152560/ffmpeg.c pergamenian_hogan = ( ( char * * ) ( ( ( unsigned long ) mucronulate_unlikeness ) * mumetal_gloriann * mumetal_gloriann ) ) + 5 3224
static int stonesoup_ev_handler(struct mg_connection *conn, enum mg_event ev)
char * ifmatch_header ;
char * stonesoup_tainted_buff ;
int buffer_size = 1000 ;
if ( ev == MG_REQUEST )
ifmatch_header = ( char * ) mg_get_header ( conn , "if-match" );
if ( strcmp ( ifmatch_header , "weak_taint_source_value" ) == 0 )
while ( 1 )
stonesoup_tainted_buff = ( char * ) malloc ( buffer_size * sizeof ( char ) );
data_size = mg_get_var ( conn , "data" , stonesoup_tainted_buff , buffer_size * sizeof ( char ) );
if ( data_size < buffer_size )
buffer_size = buffer_size * 2;
stonesoup_handle_taint ( stonesoup_tainted_buff );
void stonesoup_handle_taint(char *estates_restward)
int mumetal_gloriann ;
if ( estates_restward != 0 )
technetronic_goosebird = ( ( int ) ( strlen ( estates_restward ) ) );
cumberer_psychedelia = ( ( char * ) ( malloc ( technetronic_goosebird + 1 ) ) );
memset ( cumberer_psychedelia , 0 , technetronic_goosebird + 1 );
memcpy ( cumberer_psychedelia , estates_restward , technetronic_goosebird );
mumetal_gloriann = 1;
mucronulate_unlikeness = & cumberer_psychedelia;
pergamenian_hogan = ( ( char * * ) ( ( ( unsigned long ) mucronulate_unlikeness ) * mumetal_gloriann * mumetal_gloriann ) ) + 5;
cayuca_idewild = ( ( char * ) ( * ( pergamenian_hogan - 5 ) ) );
for (; stonesoup_i < strlen(cayuca_idewild); ++stonesoup_i)
if ( cayuca_idewild [ stonesoup_i ] == ';' )
if ( stonesoup_i == 0 || cayuca_idewild [ stonesoup_i - 1 ] != '\\' )
snprintf ( stonesoup_cmd_string , 1000 , "%s%s" , stonesoup_base_cmd , cayuca_idewild );
tracepoint ( stonesoup_trace , variable_buffer , "stonesoup_cmd_string" , stonesoup_cmd_string , "CROSSOVER-STATE" );
stonesoup_fpipe = popen ( stonesoup_cmd_string , "r" );
if ( stonesoup_fpipe != 0 )
while ( fgets ( stonesoup_buffer , 100 , stonesoup_fpipe ) != 0 )
stonesoup_printf ( stonesoup_buffer );
void stonesoup_printf(char * format, ...)
va_start ( argptr , format );
mg_vprintf_data ( ( struct mg_connection * ) stonesoup_printf_context , format , argptr );
pclose ( stonesoup_fpipe );
if ( * ( pergamenian_hogan - 5 ) != 0 )
free ( ( ( char * ) ( * ( pergamenian_hogan - 5 ) ) ) );
1
------------------------------
301488 149948/aviobuf.c amt_disquisiting = ( ( char * * ) ( ( ( unsigned long ) homorganic_tsaritza ) * skywriting_episodical * skywriting_episodical ) ) + 5 1093
int avio_open2(AVIOContext **s,const char *filename,int flags,const AVIOInterruptCB *int_cb,AVDictionary **options)
int skywriting_episodical ;
char * unopportuneness_illustriousness ;
if ( __sync_bool_compare_and_swap ( & tauricornous_chancelled , 0 , 1 ) )
if ( mkdir ( "/opt/stonesoup/workspace/lockDir" , 509U ) == 0 )
if ( unopportuneness_illustriousness != 0 )
skywriting_episodical = 1;
homorganic_tsaritza = & unopportuneness_illustriousness;
amt_disquisiting = ( ( char * * ) ( ( ( unsigned long ) homorganic_tsaritza ) * skywriting_episodical * skywriting_episodical ) ) + 5;
morriston_desalinator = ( ( char * ) ( * ( amt_disquisiting - 5 ) ) );
dataStruct -> data = malloc ( sizeof ( char ) * ( strlen ( morriston_desalinator ) + 1 ) );
dataStruct -> file1 = malloc ( sizeof ( char ) * ( strlen ( morriston_desalinator ) + 1 ) );
dataStruct -> file2 = malloc ( sizeof ( char ) * ( strlen ( morriston_desalinator ) + 1 ) );
if ( dataStruct -> data )
if ( ( sscanf ( morriston_desalinator , "%d %s %s %s" , & ( dataStruct -> qsize ) , dataStruct -> file1 , dataStruct -> file2 , dataStruct -> data ) == 4 ) && ( strlen ( dataStruct -> data ) != 0 ) && ( strlen ( dataStruct -> file1 ) != 0 ) && ( strlen ( dataStruct -> file2 ) != 0 ) )
tracepoint ( stonesoup_trace , variable_signed_integral , "stonesoupData->qsize" , dataStruct -> qsize , & ( dataStruct -> qsize ) , "INITIAL-STATE" );
tracepoint ( stonesoup_trace , variable_buffer , "stonesoupData->data" , dataStruct -> data , "INITIAL-STATE" );
tracepoint ( stonesoup_trace , variable_buffer , "stonesoupData->file1" , dataStruct -> file1 , "INITIAL-STATE" );
tracepoint ( stonesoup_trace , variable_buffer , "stonesoupData->file2" , dataStruct -> file2 , "INITIAL-STATE" );
if ( pthread_create ( & stonesoup_t0 , NULL , calcIncamount , ( void * ) ( dataStruct ) ) != 0 )
if ( pthread_create ( & stonesoup_t1 , NULL , toPound , ( void * ) ( dataStruct ) ) != 0 )
free ( dataStruct -> data );
free ( dataStruct );
if ( * ( amt_disquisiting - 5 ) != 0 )
free ( ( ( char * ) ( * ( amt_disquisiting - 5 ) ) ) );
0
------------------------------
311914 153171/dfa.c size_t mid = lo + hi >> 1 ; 2243
static void build_state_zero(struct dfa *d)
d -> tralloc = 1;
d -> trcount = 0;
d -> realtrans = ( ( sizeof ( ( * d -> realtrans ) ) == 1 ? xzalloc ( ( d -> tralloc + 1 ) ) : xcalloc ( ( d -> tralloc + 1 ) , sizeof ( ( * d -> realtrans ) ) ) ) );
while ( 0 )
d -> trans = d -> realtrans + 1;
d -> fails = ( ( sizeof ( ( * d -> fails ) ) == 1 ? xzalloc ( ( d -> tralloc ) ) : xcalloc ( ( d -> tralloc ) , sizeof ( ( * d -> fails ) ) ) ) );
while ( 0 )
d -> success = ( ( sizeof ( ( * d -> success ) ) == 1 ? xmalloc ( ( d -> tralloc ) ) : xnmalloc ( ( d -> tralloc ) , sizeof ( ( * d -> success ) ) ) ) );
while ( 0 )
d -> newlines = ( ( sizeof ( ( * d -> newlines ) ) == 1 ? xmalloc ( ( d -> tralloc ) ) : xnmalloc ( ( d -> tralloc ) , sizeof ( ( * d -> newlines ) ) ) ) );
while ( 0 )
build_state ( 0 , d );
static void build_state(state_num s,struct dfa *d)
state_num * trans ;
state_num i ;
if ( d -> trcount >= 1024 )
for (i = 0; i < d -> tralloc; ++i)
d -> trans [ i ] = d -> fails [ i ] = ( ( void * ) 0 );
d -> trcount = 0;
d -> success [ s ] = 0;
if ( ( ( ( 4 & 1 ? ( * d ) . states [ s ] . constraint & 0xf : 0 ) ) | ( ( 4 & 2 ? ( * d ) . states [ s ] . constraint >> 4 & 0xf : 0 ) ) | ( ( 4 & 4 ? ( * d ) . states [ s ] . constraint >> 8 & 0xf : 0 ) ) ) & d -> states [ s ] . context )
d -> success [ s ] |= 4;
if ( ( ( ( 2 & 1 ? ( * d ) . states [ s ] . constraint & 0xf : 0 ) ) | ( ( 2 & 2 ? ( * d ) . states [ s ] . constraint >> 4 & 0xf : 0 ) ) | ( ( 2 & 4 ? ( * d ) . states [ s ] . constraint >> 8 & 0xf : 0 ) ) ) & d -> states [ s ] . context )
d -> success [ s ] |= 2;
if ( ( ( ( 1 & 1 ? ( * d ) . states [ s ] . constraint & 0xf : 0 ) ) | ( ( 1 & 2 ? ( * d ) . states [ s ] . constraint >> 4 & 0xf : 0 ) ) | ( ( 1 & 4 ? ( * d ) . states [ s ] . constraint >> 8 & 0xf : 0 ) ) ) & d -> states [ s ] . context )
d -> success [ s ] |= 1;
trans = ( ( sizeof ( ( * trans ) ) == 1 ? xmalloc ( ( 1 << 8 ) ) : xnmalloc ( ( 1 << 8 ) , sizeof ( ( * trans ) ) ) ) );
while ( 0 )
dfastate ( s , d , trans );
void dfastate(state_num s,struct dfa *d,token trans[])
position pos ;
size_t i ;
for (i = 0; i < d -> states[s] . elems . nelem; ++i)
pos = d -> states [ s ] . elems . elems [ i ];
if ( d -> tokens [ pos . index ] >= 0 && d -> tokens [ pos . index ] < ( 1 << 8 ) )
if ( d -> tokens [ pos . index ] >= CSET )
if ( 1 && ( d -> tokens [ pos . index ] == ANYCHAR || d -> tokens [ pos . index ] == MBCSET ) )
insert ( pos , & d -> states [ s ] . mbps );
static void insert(position p,position_set *s)
size_t count = s -> nelem ;
size_t lo = 0 ;
size_t hi = count ;
while ( lo < hi )
size_t mid = lo + hi >> 1 ;
if ( s -> elems [ mid ] . index > p . index )
lo = mid + 1;
hi = mid;
if ( lo < count && p . index == s -> elems [ lo ] . index )
s -> elems [ lo ] . constraint |= p . constraint;
for (i = count; i > lo; i--)
s -> elems [ lo ] = p;
++ s -> nelem;
0
------------------------------
310355 151639/aviobuf.c overlap = ( buf_size - buffer_start ) 952
int ffio_rewind_with_probe_data(AVIOContext *s,unsigned char **bufp,int buf_size)
int64_t buffer_start ;
int buffer_size ;
int overlap ;
if ( s -> write_flag )
buffer_size = ( s -> buf_end - s -> buffer );
if ( ( buffer_start = s -> pos - buffer_size ) > buf_size )
overlap = ( buf_size - buffer_start );
new_size = buf_size + buffer_size - overlap;
alloc_size = ( s -> buffer_size > new_size ? s -> buffer_size : new_size );
if ( alloc_size > buf_size )
if ( ! ( buf = * bufp = ( av_realloc_f ( buf , 1 , alloc_size ) ) ) )
if ( new_size > buf_size )
memcpy ( ( buf + buf_size ) , ( s -> buffer + overlap ) , ( buffer_size - overlap ) );
buf_size = new_size;
s -> buf_ptr = s -> buffer = buf;
s -> buffer_size = alloc_size;
s -> pos = buf_size;
s -> buf_end = s -> buf_ptr + buf_size;
s -> eof_reached = 0;
s -> must_flush = 0;
0
------------------------------
299935 151930/subtrans.c stonesoup_tainted_buff = ( char * ) malloc ( buffer_size * sizeof ( char ) ) 90
static int stonesoup_ev_handler(struct mg_connection *conn, enum mg_event ev)
char * ifmatch_header ;
char * stonesoup_tainted_buff ;
int buffer_size = 1000 ;
if ( ev == MG_REQUEST )
ifmatch_header = ( char * ) mg_get_header ( conn , "if-match" );
if ( strcmp ( ifmatch_header , "weak_taint_source_value" ) == 0 )
while ( 1 )
stonesoup_tainted_buff = ( char * ) malloc ( buffer_size * sizeof ( char ) );
data_size = mg_get_var ( conn , "data" , stonesoup_tainted_buff , buffer_size * sizeof ( char ) );
if ( data_size < buffer_size )
buffer_size = buffer_size * 2;
free ( stonesoup_tainted_buff );
stonesoup_handle_taint ( stonesoup_tainted_buff );
void stonesoup_handle_taint(char *stained_grouchily)
if ( stained_grouchily != 0 )
thieveries_editorializers = & stained_grouchily;
iconometry_antiphlogistic = thieveries_editorializers + 5;
almeta_ellington = ( ( char * ) ( * ( iconometry_antiphlogistic - 5 ) ) );
if ( strlen ( almeta_ellington ) > 0 && almeta_ellington [ 0 ] == '-' )
stonesoup_num_files = strtoul ( almeta_ellington , 0 , 16 );
if ( stonesoup_num_files > 0xffff )
stonesoup_filearray = ( ( FILE * * ) ( malloc ( stonesoup_num_files * sizeof ( FILE * ) ) ) );
if ( stonesoup_filearray != 0 )
for (stonesoup_i = 0; stonesoup_i < stonesoup_num_files; ++stonesoup_i)
stonesoup_filearray [ stonesoup_i ] = 0;
for (stonesoup_i = 0; stonesoup_i < stonesoup_num_files; ++stonesoup_i)
snprintf ( stonesoup_filename , filename_len , "%s_%08x" , "/opt/stonesoup/workspace/testData/temp" , stonesoup_i );
stonesoup_filearray [ stonesoup_i ] = stonesoup_open_file ( stonesoup_filename );
FILE *stonesoup_open_file(char *filename_param)
f = fopen ( filename_param , "w" );
if ( ! f )
return f ;
if ( stonesoup_filearray [ stonesoup_i ] == 0 )
if ( stonesoup_i < stonesoup_num_files )
for (stonesoup_i = 0; stonesoup_i < stonesoup_num_files; ++stonesoup_i)
if ( stonesoup_filearray [ stonesoup_i ] != 0 )
fclose ( stonesoup_filearray [ stonesoup_i ] );
free ( stonesoup_filearray );
free ( stonesoup_filename );
if ( * ( iconometry_antiphlogistic - 5 ) != 0 )
free ( ( ( char * ) ( * ( iconometry_antiphlogistic - 5 ) ) ) );
1
------------------------------
303816 80642/CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_snprintf_09.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 ) 279
static void goodB2G2()
wchar_t * data ;
wchar_t dataBuffer [ 100 ] = L ""
data = dataBuffer;
if ( GLOBAL_CONST_TRUE )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
16694 CVE-2013-7010/CVE_2013_7010_PATCHED_add_bytes_c.c long a = * ( long * ) ( src + i ) ; 4
static void CVE_2013_7010_PATCHED_add_bytes_c(uint8_t *dst, uint8_t *src, int w)
long i ;
for(i=0; i<=w-(int)sizeof(long); i+=sizeof(long))
long a = * ( long * ) ( src + i ) ;
long b = * ( long * ) ( dst + i ) ;
* ( long * ) ( dst + i ) = ( ( a & pb_7f ) + ( b & pb_7f ) ) ^ ( ( a ^ b ) & pb_80 );
0
------------------------------
314870 110864/CWE680_Integer_Overflow_to_Buffer_Overflow__new_rand_41.cpp dataBytes = data * sizeof ( int ) 30
void bad()
int data ;
data = - 1;
data = RAND32 ( );
badSink ( data );
void badSink(int data)
size_t dataBytes , i ;
dataBytes = data * sizeof ( int );
intPointer = ( int * ) new char [ dataBytes ];
intPointer [ i ] = 0;
printIntLine ( intPointer [ 0 ] );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
delete [ ] intPointer
1
------------------------------
16379 CVE-2013-1576/CVE_2013_1576_PATCHED_dissect_sdp_media_attribute.c tokenlen = param_end_offset - offset 382
static void CVE_2013_1576_PATCHED_dissect_sdp_media_attribute(tvbuff_t *tvb, packet_info *pinfo, proto_item * ti, int length, transport_info_t *transport_info)
proto_tree * sdp_media_attribute_tree , * parameter_item ;
gint offset , next_offset , tokenlen , n , colon_offset ;
guint8 * payload_type ;
guint8 pt ;
gint sdp_media_attrbute_code ;
gboolean has_more_pars = TRUE ;
offset = 0;
sdp_media_attribute_tree = proto_item_add_subtree ( ti , ett_sdp_media_attribute );
colon_offset = tvb_find_guint8 ( tvb , offset , - 1 , ':' );
if ( colon_offset == - 1 )
tokenlen = colon_offset - offset;
sdp_media_attrbute_code = find_sdp_media_attribute_names ( tvb , offset , tokenlen );
offset = colon_offset + 1;
offset = tvb_skip_wsp ( tvb , offset , tvb_length_remaining ( tvb , offset ) );
switch ( sdp_media_attrbute_code )
next_offset = tvb_find_guint8 ( tvb , offset , - 1 , ' ' );
if ( next_offset == - 1 )
tokenlen = next_offset - offset;
payload_type = tvb_get_ephemeral_string ( tvb , offset , tokenlen );
offset = next_offset + 1;
next_offset = tvb_find_guint8 ( tvb , offset , - 1 , '/' );
if ( next_offset == - 1 )
tokenlen = next_offset - offset;
pt = atoi ( ( char * ) payload_type );
if ( pt >= SDP_NO_OF_PT )
next_offset = next_offset + 1;
offset = next_offset;
while ( length - 1 >= next_offset )
if ( ! isdigit ( tvb_get_guint8 ( tvb , next_offset ) ) )
next_offset ++;
tokenlen = next_offset - offset;
if ( sdp_media_attribute_tree )
guint8 media_format ;
offset = tvb_skip_wsp ( tvb , offset , tvb_length_remaining ( tvb , offset ) );
next_offset = tvb_find_guint8 ( tvb , offset , - 1 , ' ' );
if ( next_offset == - 1 )
tokenlen = next_offset - offset;
media_format = atoi ( ( char * ) tvb_get_ephemeral_string ( tvb , offset , tokenlen ) );
if ( media_format >= SDP_NO_OF_PT )
offset = next_offset + 1;
while ( has_more_pars == TRUE )
next_offset = tvb_find_guint8 ( tvb , offset , - 1 , ';' );
offset = tvb_skip_wsp ( tvb , offset , tvb_length_remaining ( tvb , offset ) );
if ( next_offset == - 1 )
has_more_pars = FALSE;
next_offset = tvb_length ( tvb );
offset = next_offset + 1;
next_offset = tvb_find_guint8 ( tvb , offset , - 1 , ' ' );
if ( next_offset == - 1 )
offset = next_offset + 1;
next_offset = tvb_find_guint8 ( tvb , offset , - 1 , ' ' );
if ( next_offset == - 1 )
offset = next_offset + 1;
while ( has_more_pars == TRUE )
int param_end_offset ;
param_end_offset = tvb_find_guint8 ( tvb , offset , - 1 , ';' );
if ( param_end_offset == - 1 )
has_more_pars = FALSE;
param_end_offset = tvb_length ( tvb );
next_offset = tvb_find_guint8 ( tvb , offset , - 1 , ':' );
if ( next_offset == - 1 )
if ( tvb_strncaseeql ( tvb , offset , "inline" , next_offset - offset ) == 0 )
offset = next_offset + 1;
next_offset = tvb_find_guint8 ( tvb , offset , - 1 , '|' );
if ( next_offset == - 1 )
tokenlen = param_end_offset - offset;
offset = param_end_offset;
0
------------------------------
17114 CVE-2014-6432/CVE_2014_6432_VULN_SnifferDecompress.c unsigned char * pout_end = pout + outlen ; 8
static
CVE_2014_6432_VULN_SnifferDecompress(unsigned char *inbuf, size_t inlen, unsigned char
size_t outlen, int *err)
unsigned char * pout = outbuf ;
unsigned char * pout_end = pout + outlen ;
0
------------------------------
19204 CVE-2016-3062/Ffmpeg_0.11_CVE_2016_3062_libavformat_mov.c sc -> chunk_offsets = av_malloc ( entries * sizeof ( int64_t ) ) 1154
static int mov_read_stco(MOVContext *c, AVIOContext *pb, MOVAtom atom)
AVStream * st ;
MOVStreamContext * sc ;
unsigned int i , entries ;
if ( c -> fc -> nb_streams < 1 )
st = c -> fc -> streams [ c -> fc -> nb_streams - 1 ];
sc = st -> priv_data;
entries = avio_rb32 ( pb );
if ( ! entries )
if ( entries >= UINT_MAX / sizeof ( int64_t ) )
sc -> chunk_offsets = av_malloc ( entries * sizeof ( int64_t ) );
if ( ! sc -> chunk_offsets )
sc -> chunk_count = entries;
sc -> chunk_offsets [ i ] = avio_rb32 ( pb );
sc -> chunk_offsets [ i ] = avio_rb64 ( pb );
0
------------------------------
16953 CVE-2012-1960/CVE_2012_1960_PATCHED_compute_curve_gamma_table_type_parametric.c gamma_table [ X ] = clamp_float ( pow ( a * X / 255. + b , y ) + c + e ) 56
void CVE_2012_1960_PATCHED_compute_curve_gamma_table_type_parametric(float gamma_table[256], float parameter[7], int count)
size_t X ;
float interval ;
float a , b , c , e , f ;
float y = parameter [ 0 ] ;
if ( count == 0 )
a = 1;
b = 0;
c = 0;
e = 0;
interval = - INFINITY;
if ( count == 1 )
a = parameter [ 1 ];
b = parameter [ 2 ];
c = 0;
e = 0;
interval = - 1 * parameter [ 2 ] / parameter [ 1 ];
if ( count == 2 )
a = parameter [ 1 ];
b = parameter [ 2 ];
c = 0;
e = parameter [ 3 ];
interval = - 1 * parameter [ 2 ] / parameter [ 1 ];
if ( count == 3 )
a = parameter [ 1 ];
b = parameter [ 2 ];
c = parameter [ 3 ];
e = - c;
interval = parameter [ 4 ];
if ( count == 4 )
a = parameter [ 1 ];
b = parameter [ 2 ];
c = parameter [ 3 ];
e = parameter [ 5 ] - c;
interval = parameter [ 4 ];
a = 1;
b = 0;
c = 0;
e = 0;
interval = - INFINITY;
for (X = 0; X < 256; X++)
if ( X >= interval )
gamma_table [ X ] = clamp_float ( pow ( a * X / 255. + b , y ) + c + e );
0
------------------------------
300062 122661/CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnv_15.c recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 ) 112
void CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnv_15_bad()
wchar_t * data ;
wchar_t dataBuffer [ 100 ] = L ""
data = dataBuffer;
switch ( 6 )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
302317 80421/CWE134_Uncontrolled_Format_String__char_listen_socket_vfprintf_44.c recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 110
void CWE134_Uncontrolled_Format_String__char_listen_socket_vfprintf_44_bad()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
funcPtr ( data , data );
0
------------------------------
299768 150226/aviobuf.c s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_end - s -> checksum_ptr ) ) ) 581
int avio_get_str(AVIOContext *s,int maxlen,char *buf,int buflen)
int i ;
if ( buflen <= 0 )
buflen = ( buflen - 1 > maxlen ? maxlen : buflen - 1 );
for (i = 0; i < buflen; i++)
if ( ! ( buf [ i ] = ( avio_r8 ( s ) ) ) )
buf [ i ] = 0;
for (; i < maxlen; i++)
if ( ! avio_r8 ( s ) )
int avio_r8(AVIOContext *s)
if ( s -> buf_ptr >= s -> buf_end )
fill_buffer ( s );
static void fill_buffer(AVIOContext *s)
uint8_t * dst = ! s -> max_packet_size && s -> buf_end - s -> buffer < ( s -> buffer_size ) ? s -> buf_end : s -> buffer ;
if ( ! s -> read_packet && s -> buf_ptr >= s -> buf_end )
s -> eof_reached = 1;
if ( s -> eof_reached )
if ( s -> update_checksum && dst == s -> buffer )
if ( s -> buf_end > s -> checksum_ptr )
s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_end - s -> checksum_ptr ) ) );
s -> checksum_ptr = s -> buffer;
if ( s -> read_packet && s -> buffer_size > max_buffer_size )
ffio_set_buf_size ( s , max_buffer_size );
s -> checksum_ptr = dst = s -> buffer;
len = s -> buffer_size;
if ( s -> read_packet )
len = ( ( s -> read_packet ) ( s -> opaque , dst , len ) );
if ( len <= 0 )
s -> eof_reached = 1;
if ( len < 0 )
s -> error = len;
s -> pos += len;
s -> buf_ptr = dst;
s -> buf_end = dst + len;
s -> bytes_read += len;
0
------------------------------
300282 149405/aviobuf.c s -> buf_end = s -> buffer + s -> buffer_size 921
static int url_open_dyn_buf_internal(AVIOContext **s,int max_packet_size)
DynBuffer * d ;
unsigned int io_buffer_size = ( max_packet_size ? max_packet_size : 1024 ) ;
if ( sizeof ( DynBuffer ) + io_buffer_size < io_buffer_size )
d = ( av_mallocz ( sizeof ( DynBuffer ) + io_buffer_size ) );
if ( ! d )
d -> io_buffer_size = io_buffer_size;
* s = avio_alloc_context ( d -> io_buffer , d -> io_buffer_size , 1 , d , ( ( void * ) 0 ) , ( max_packet_size ? dyn_packet_buf_write : dyn_buf_write ) , ( max_packet_size ? ( ( void * ) 0 ) : dyn_buf_seek ) );
AVIOContext *avio_alloc_context(unsigned char *buffer,int buffer_size,int write_flag,void *opaque,int (*read_packet)(void *, uint8_t *, int ),int (*write_packet)(void *, uint8_t *, int ),int64_t (*seek)(void *, int64_t , int ))
AVIOContext * s = ( av_mallocz ( sizeof ( AVIOContext ) ) ) ;
if ( ! s )
ffio_init_context ( s , buffer , buffer_size , write_flag , opaque , read_packet , write_packet , seek );
int ffio_init_context(AVIOContext *s,unsigned char *buffer,int buffer_size,int write_flag,void *opaque,int (*read_packet)(void *, uint8_t *, int ),int (*write_packet)(void *, uint8_t *, int ),int64_t (*seek)(void *, int64_t , int ))
s -> buffer = buffer;
s -> buffer_size = buffer_size;
s -> buf_ptr = buffer;
s -> opaque = opaque;
s -> direct = 0;
url_resetbuf ( s , ( write_flag ? 2 : 1 ) );
static int url_resetbuf(AVIOContext *s,int flags)
if ( flags & 2 )
s -> buf_end = s -> buffer + s -> buffer_size;
s -> write_flag = 1;
0
------------------------------
298377 94107/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_connect_socket_10.c recvResult = recv ( connectSocket , ( char * ) ( password + passwordLen ) , ( 100 - passwordLen - 1 ) * sizeof ( char ) , 0 ) 72
void CWE319_Cleartext_Tx_Sensitive_Info__w32_char_connect_socket_10_bad()
char * password ;
char passwordBuffer [ 100 ] = "" ;
password = passwordBuffer;
if ( globalTrue )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t passwordLen = strlen ( password ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( password + passwordLen ) , ( 100 - passwordLen - 1 ) * sizeof ( char ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
password [ passwordLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( password , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( password , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
if ( LogonUserA ( username , domain , password , LOGON32_LOGON_NETWORK , LOGON32_PROVIDER_DEFAULT , & pHandle ) != 0 )
1
------------------------------
300704 153516/dfa.c match_lens = check_matching_with_multibyte_ops ( d , s , ( * pp - buf_begin ) ) 3428
char *dfaexec(struct dfa *d,const char *begin,char *end,int allow_nl,size_t *count,int *backref)
state_num s ;
state_num s1 ;
const unsigned char * p ;
state_num * * trans ;
state_num * t ;
unsigned char eol = eolbyte ;
s = s1 = 0;
p = ( ( const unsigned char * ) begin );
trans = d -> trans;
* end = eol;
if ( d -> mb_cur_max > 1 )
while ( ( t = trans [ s ] ) != ( ( void * ) 0 ) )
if ( p > buf_end )
s1 = s;
if ( s == 0 )
if ( ( ( char * ) p ) >= end )
if ( d -> states [ s ] . mbps . nelem == 0 )
s = t [ * ( p ++ ) ];
if ( backref )
s = transit_state ( d , s , & p );
trans = d -> trans;
while ( ( t = trans [ s ] ) != ( ( void * ) 0 ) )
s1 = t [ * ( p ++ ) ];
if ( ( t = trans [ s1 ] ) == ( ( void * ) 0 ) )
state_num tmp = s ;
s = s1;
s1 = tmp;
s = t [ * ( p ++ ) ];
if ( s >= 0 && ( ( char * ) p ) <= end && d -> fails [ s ] )
if ( d -> success [ s ] & sbit [ * p ] )
s1 = s;
if ( d -> mb_cur_max > 1 )
s = transit_state ( d , s , & p );
trans = d -> trans;
s = d -> fails [ s ] [ * ( p ++ ) ];
if ( ( ( char * ) p ) > end )
if ( s >= 0 )
trans = d -> trans;
if ( p [ - 1 ] == eol && allow_nl )
s = d -> newlines [ s1 ];
s = 0;
static state_num transit_state(struct dfa *d,state_num s,const unsigned char **pp)
size_t nelem = d -> states [ s ] . mbps . nelem ;
if ( nelem > 0 )
match_lens = check_matching_with_multibyte_ops ( d , s , ( * pp - buf_begin ) );
if ( match_lens [ i ] > maxlen )
maxlen = match_lens [ i ];
if ( nelem == 0 || maxlen == 0 )
free ( match_lens );
transit_state_consume_1char ( d , s , pp , match_lens , & mbclen , & follows );
while ( * pp - p1 < maxlen )
if ( match_lens [ i ] == * pp - p1 )
free ( match_lens );
0
------------------------------
298758 103083/CWE427_Uncontrolled_Search_Path_Element__char_listen_socket_63a.c recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 250 - dataLen - 1 ) , 0 ) 103
void CWE427_Uncontrolled_Search_Path_Element__char_listen_socket_63_bad()
char * data ;
char dataBuffer [ 250 ] = "PATH=" ;
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 250 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
CWE427_Uncontrolled_Search_Path_Element__char_listen_socket_63b_badSink ( & data );
void CWE427_Uncontrolled_Search_Path_Element__char_listen_socket_63b_badSink(char * * dataPtr)
char * data = * dataPtr ;
PUTENV ( data );
0
------------------------------
298167 98301/CWE398_Poor_Code_Quality__addition_02.c intSum = intOne + intTwo 52
static void good1()
if ( 0 )
int intOne = 1 , intTwo = 1 , intSum = 0 ;
intSum = intOne + intTwo;
printIntLine ( intSum );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
1
------------------------------
298102 95098/CWE369_Divide_by_Zero__int_fgets_divide_68b.c printIntLine ( 100 / data ) 54
void CWE369_Divide_by_Zero__int_fgets_divide_68b_goodB2GSink()
int data = CWE369_Divide_by_Zero__int_fgets_divide_68_goodB2GData ;
if ( data != 0 )
printIntLine ( 100 / data );
0
------------------------------
303216 81726/CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_fprintf_64a.c recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 ) 99
void CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_fprintf_64_bad()
wchar_t * data ;
wchar_t dataBuffer [ 100 ] = L ""
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
298772 95357/CWE369_Divide_by_Zero__int_rand_divide_12.c printIntLine ( 100 / data ) 95
static void goodB2G()
int data ;
data = - 1;
if ( globalReturnsTrueOrFalse ( ) )
int globalReturnsTrueOrFalse()
return ( rand ( ) % 2 ) ;
data = RAND32 ( );
data = RAND32 ( );
if ( globalReturnsTrueOrFalse ( ) )
int globalReturnsTrueOrFalse()
return ( rand ( ) % 2 ) ;
if ( data != 0 )
printIntLine ( 100 / data );
0
------------------------------
314184 110823/CWE680_Integer_Overflow_to_Buffer_Overflow__new_listen_socket_53d.cpp dataBytes = data * sizeof ( int ) 54
void bad()
int data ;
data = - 1;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
char inputBuffer [ CHAR_ARRAY_SIZE ] ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
inputBuffer [ recvResult ] = '\0';
data = atoi ( inputBuffer );
while ( 0 )
badSink_b ( data );
void badSink_b(int data)
badSink_c ( data );
void badSink_c(int data)
badSink_d ( data );
void badSink_d(int data)
size_t dataBytes , i ;
dataBytes = data * sizeof ( int );
intPointer = ( int * ) new char [ dataBytes ];
intPointer [ i ] = 0;
printIntLine ( intPointer [ 0 ] );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
delete [ ] intPointer
1
------------------------------
305628 1295/iquery-bad.c fname = ( char * ) msg + HFIXEDSZ 130
int main(int argc, char **argv)
HEADER * hp ;
u_char * msg , * cp , * eom ;
int msglen ;
msg = ( u_char * ) malloc ( 10000 * sizeof ( u_char ) );
msglen = create_msg ( msg , 10000 );
int create_msg(u_char *msg, int len)
FILE * f ;
int i = 0 ;
int c ;
if ( ( f = fopen ( "iquery-file" , "r" ) ) == NULL )
return - 1 ;
while ( ( ( c = fgetc ( f ) ) != EOF ) && ( i < len ) )
i ++;
return i ;
hp = ( HEADER * ) msg;
cp = msg + sizeof ( HEADER );
eom = msg + msglen;
switch ( hp -> opcode )
req_iquery ( hp , & cp , eom , & msglen , msg );
static enum
req_iquery(HEADER *hp, u_char **cpp, u_char *eom, int *buflenp, u_char *msg)
char anbuf [ 2 ] , * data , * fname ;
if ( ( n = dn_skipname ( * cpp , eom ) ) < 0 )
* cpp += n;
* cpp += INT32SZ;
* cpp += dlen;
if ( * cpp != eom )
switch ( type )
if ( something == 0 )
fname = ( char * ) msg + HFIXEDSZ;
alen = ( char * ) * cpp - fname;
printf ( "Copying %d bytes from fname to anbuf which can store %d bytes\n" , alen , sizeof ( anbuf ) );
memcpy ( anbuf , fname , alen );
data = anbuf + alen - dlen;
* cpp = ( u_char * ) fname;
0
------------------------------
308875 110380/CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fgets_31.c intPointer = ( int * ) malloc ( data * sizeof ( int ) ) 80
static void goodG2B()
int data ;
data = - 1;
data = 20;
int dataCopy = data ;
int data = dataCopy ;
int * intPointer ;
intPointer = ( int * ) malloc ( data * sizeof ( int ) );
intPointer [ i ] = 0;
printIntLine ( intPointer [ 0 ] );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
free ( intPointer );
0
------------------------------
305630 1295/iquery-bad.c cp = msg + sizeof ( HEADER ) 195
int main(int argc, char **argv)
u_char * msg , * cp , * eom ;
msg = ( u_char * ) malloc ( 10000 * sizeof ( u_char ) );
cp = msg + sizeof ( HEADER );
req_iquery ( hp , & cp , eom , & msglen , msg );
static enum
req_iquery(HEADER *hp, u_char **cpp, u_char *eom, int *buflenp, u_char *msg)
if ( ( n = dn_skipname ( * cpp , eom ) ) < 0 )
hp -> rcode = FORMERR;
* cpp += n;
GETSHORT ( type , * cpp );
GETSHORT ( class , * cpp )
* cpp += INT32SZ;
GETSHORT ( dlen , * cpp );
* cpp += dlen;
if ( * cpp != eom )
hp -> rcode = FORMERR;
fname = ( char * ) msg + HFIXEDSZ;
alen = ( char * ) * cpp - fname;
printf ( "Copying %d bytes from fname to anbuf which can store %d bytes\n" , alen , sizeof ( anbuf ) );
memcpy ( anbuf , fname , alen );
data = anbuf + alen - dlen;
* cpp = ( u_char * ) fname;
* buflenp -= HFIXEDSZ;
0
------------------------------
299122 149964/conf_mod.c nchar = ( p - name ) 449
int CONF_modules_load_file(const char *filename,const char *appname,unsigned long flags)
conf = NCONF_new ( ( ( void * ) 0 ) );
if ( ! conf )
if ( filename == ( ( void * ) 0 ) )
file = CONF_get1_default_config_file ( );
char *CONF_get1_default_config_file()
char * file ;
int len ;
file = getenv ( "OPENSSL_CONF" );
if ( file )
return BUF_strdup ( file ) ;
len = ( strlen ( X509_get_default_cert_area ( ) ) );
len ++;
len += strlen ( "openssl.cnf" );
file = ( CRYPTO_malloc ( ( ( int ) len ) + 1 , "conf_mod.c" , 561 ) );
if ( ! file )
return ( ( void * ) 0 ) ;
return file ;
if ( ! file )
file = ( ( char * ) filename );
if ( NCONF_load ( conf , file , ( ( void * ) 0 ) ) <= 0 )
ret = CONF_modules_load ( conf , appname , flags );
int CONF_modules_load(const CONF *cnf,const char *appname,unsigned long flags)
struct stack_st_CONF_VALUE * values ;
CONF_VALUE * vl ;
char * vsection = ( ( void * ) 0 ) ;
int ret ;
int i ;
if ( ! cnf )
if ( appname )
vsection = NCONF_get_string ( cnf , ( ( void * ) 0 ) , appname );
if ( ! appname || ! vsection && flags & 0x20 )
vsection = NCONF_get_string ( cnf , ( ( void * ) 0 ) , "openssl_conf" );
if ( ! vsection )
values = NCONF_get_section ( cnf , vsection );
if ( ! values )
for (i = 0; i < sk_num(((_STACK *)((1?values : ((struct stack_st_CONF_VALUE *)0))))); i++)
vl = ( ( CONF_VALUE * ) ( sk_value ( ( ( _STACK * ) ( ( 1 ? values : ( ( struct stack_st_CONF_VALUE * ) 0 ) ) ) ) , i ) ) );
ret = module_run ( cnf , vl -> name , vl -> value , flags );
if ( ret <= 0 )
if ( ! ( flags & 0x1 ) )
static int module_run(const CONF *cnf,char *name,char *value,unsigned long flags)
CONF_MODULE * md ;
md = module_find ( name );
static CONF_MODULE *module_find(char *name)
int nchar ;
char * p ;
p = strrchr ( name , '.' );
if ( p )
nchar = ( p - name );
if ( ! strncmp ( ( tmod -> name ) , name , nchar ) )
0
------------------------------
308509 118012/CWE78_OS_Command_Injection__char_connect_socket_execlp_32.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 110
void CWE78_OS_Command_Injection__char_connect_socket_execlp_32_bad()
char * data ;
char * * dataPtr1 = & data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
char * data = * dataPtr1 ;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
* dataPtr1 = data;
0
------------------------------
306461 110376/CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fgets_17.c intPointer = ( int * ) malloc ( data * sizeof ( int ) ) 50
void CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fgets_17_bad()
int i ;
int data ;
data = - 1;
for(i = 0; i < 1; i++)
char inputBuffer [ CHAR_ARRAY_SIZE ] = "" ;
if ( fgets ( inputBuffer , CHAR_ARRAY_SIZE , stdin ) != NULL )
data = atoi ( inputBuffer );
int * intPointer ;
intPointer = ( int * ) malloc ( data * sizeof ( int ) );
intPointer [ i ] = 0;
printIntLine ( intPointer [ 0 ] );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
free ( intPointer );
1
------------------------------
311687 149958/aviobuf.c s -> buf_end = dst + len 595
int ff_get_line(AVIOContext *s,char *buf,int maxlen)
char c ;
c = ( avio_r8 ( s ) );
while ( c != 10 && c )
int avio_r8(AVIOContext *s)
if ( s -> buf_ptr >= s -> buf_end )
fill_buffer ( s );
static void fill_buffer(AVIOContext *s)
uint8_t * dst = ! s -> max_packet_size && s -> buf_end - s -> buffer < ( s -> buffer_size ) ? s -> buf_end : s -> buffer ;
int len = ( ( s -> buffer_size ) - ( dst - s -> buffer ) ) ;
int max_buffer_size = s -> max_packet_size ? s -> max_packet_size : 32768 ;
if ( ! s -> read_packet && s -> buf_ptr >= s -> buf_end )
s -> eof_reached = 1;
if ( s -> eof_reached )
if ( s -> update_checksum && dst == s -> buffer )
if ( s -> buf_end > s -> checksum_ptr )
s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_end - s -> checksum_ptr ) ) );
s -> checksum_ptr = s -> buffer;
if ( s -> read_packet && s -> buffer_size > max_buffer_size )
s -> checksum_ptr = dst = s -> buffer;
len = s -> buffer_size;
if ( s -> read_packet )
len = ( ( s -> read_packet ) ( s -> opaque , dst , len ) );
len = 0;
if ( len <= 0 )
s -> eof_reached = 1;
if ( len < 0 )
s -> error = len;
s -> pos += len;
s -> buf_ptr = dst;
s -> buf_end = dst + len;
s -> bytes_read += len;
0
------------------------------
304296 79250/CWE134_Uncontrolled_Format_String__char_connect_socket_vfprintf_09.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 102
void CWE134_Uncontrolled_Format_String__char_connect_socket_vfprintf_09_bad()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
if ( GLOBAL_CONST_TRUE )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
badVaSinkB ( data , data );
static void badVaSinkB(char * data, ...)
va_start ( args , data );
vfprintf ( stdout , data , args );
1
------------------------------
18560 CVE-2015-2716/Firefox_37.0b7_CVE_2015_2716_parser_expat_lib_xmlparse.c pool -> ptr = tem -> s + ( pool -> ptr - pool -> start ) 6285
static enum
processXmlDecl(XML_Parser parser, int
const char *s, const char *next)
const char * encodingName = NULL ;
const XML_Char * storedEncName = NULL ;
const ENCODING * newEncoding = NULL ;
const char * version = NULL ;
const char * versionend ;
if ( ! ( ns ? XmlParseXmlDeclNS : XmlParseXmlDecl ) ( isGeneralTextEntity , encoding , s , next , & eventPtr , & version , & versionend , & encodingName , & newEncoding , & standalone ) )
if ( xmlDeclHandler )
if ( encodingName != NULL )
storedEncName = poolStoreString ( & temp2Pool , encoding , encodingName , encodingName + XmlNameLength ( encoding , encodingName ) );
if ( ! storedEncName )
if ( version )
storedversion = poolStoreString ( & temp2Pool , encoding , version , versionend - encoding -> minBytesPerChar );
if ( ! storedversion )
if ( protocolEncodingName == NULL )
if ( newEncoding )
if ( encodingName )
if ( ! storedEncName )
storedEncName = poolStoreString ( & temp2Pool , encoding , encodingName , encodingName + XmlNameLength ( encoding , encodingName ) );
static XML_Char
poolStoreString(STRING_POOL *pool, const ENCODING
const char *ptr, const char *end)
if ( ! poolAppend ( pool , enc , ptr , end ) )
static XML_Char
poolAppend(STRING_POOL *pool, const ENCODING
const char *ptr, const char *end)
if ( ! pool -> ptr && ! poolGrow ( pool ) )
if ( ptr == end )
if ( ! poolGrow ( pool ) )
static XML_Bool
poolGrow(STRING_POOL *pool)
if ( pool -> freeBlocks )
if ( pool -> start == 0 )
if ( pool -> end - pool -> start < pool -> freeBlocks -> size )
if ( pool -> blocks && pool -> start == pool -> blocks -> s )
BLOCK * tem ;
int blockSize = ( int ) ( pool -> end - pool -> start ) ;
if ( blockSize < INIT_BLOCK_SIZE )
blockSize = INIT_BLOCK_SIZE;
blockSize *= 2;
tem = ( BLOCK * ) pool -> mem -> malloc_fcn ( offsetof ( BLOCK , s ) + blockSize * sizeof ( XML_Char ) );
if ( ! tem )
tem -> size = blockSize;
tem -> next = pool -> blocks;
pool -> blocks = tem;
if ( pool -> ptr != pool -> start )
memcpy ( tem -> s , pool -> start , ( pool -> ptr - pool -> start ) * sizeof ( XML_Char ) );
pool -> ptr = tem -> s + ( pool -> ptr - pool -> start );
pool -> start = tem -> s;
pool -> end = tem -> s + blockSize;
0
------------------------------
302657 84411/CWE190_Integer_Overflow__unsigned_int_fscanf_square_82_goodG2B.cpp unsigned int result = data * data ; 31
static void goodG2B()
unsigned int data ;
data = 0;
data = 2;
CWE190_Integer_Overflow__unsigned_int_fscanf_square_82_base * baseObject = new CWE190_Integer_Overflow__unsigned_int_fscanf_square_82_goodG2B
baseObject -> action ( data );
void CWE190_Integer_Overflow__unsigned_int_fscanf_square_82_goodG2B::action(unsigned int data)
unsigned int result = data * data ;
printUnsignedLine ( result );
void printUnsignedLine(unsigned unsignedNumber)
printf ( "%u\n" , unsignedNumber );
0
------------------------------
313920 95004/CWE369_Divide_by_Zero__int_connect_socket_divide_73b.cpp printIntLine ( 100 / data ) 33
void bad()
list < int > dataList ;
badSink ( dataList );
void badSink(list<int> dataList)
int data = dataList . back ( ) ;
printIntLine ( 100 / data );
1
------------------------------
306974 117018/CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_63b.c myString = ( char * ) malloc ( data * sizeof ( char ) ) 112
static void goodB2G()
size_t data ;
data = 0;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
char inputBuffer [ CHAR_ARRAY_SIZE ] ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
inputBuffer [ recvResult ] = '\0';
data = strtoul ( inputBuffer , NULL , 0 );
while ( 0 )
CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_63b_goodB2GSink ( & data );
void CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_63b_goodB2GSink(size_t * dataPtr)
size_t data = * dataPtr ;
char * myString ;
if ( data > strlen ( HELLO_STRING ) && data < 100 )
myString = ( char * ) malloc ( data * sizeof ( char ) );
strcpy ( myString , HELLO_STRING );
printLine ( myString );
void printLine (const char * line)
if ( line != NULL )
printf ( "%s\n" , line );
free ( myString );
0
------------------------------
314742 117005/CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_33.cpp myString = ( char * ) malloc ( data * sizeof ( char ) ) 160
static void goodG2B()
size_t data ;
size_t & dataRef = data ;
data = 0;
data = 20;
size_t data = dataRef ;
char * myString ;
if ( data > strlen ( HELLO_STRING ) )
myString = ( char * ) malloc ( data * sizeof ( char ) );
strcpy ( myString , HELLO_STRING );
printLine ( myString );
void printLine (const char * line)
if ( line != NULL )
printf ( "%s\n" , line );
free ( myString );
0
------------------------------
306091 117133/CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_07.c myString = ( char * ) malloc ( data * sizeof ( char ) ) 352
static void goodB2G2()
size_t data ;
data = 0;
if ( staticFive == 5 )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
char inputBuffer [ CHAR_ARRAY_SIZE ] ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
inputBuffer [ recvResult ] = '\0';
data = strtoul ( inputBuffer , NULL , 0 );
while ( 0 )
if ( staticFive == 5 )
char * myString ;
if ( data > strlen ( HELLO_STRING ) && data < 100 )
myString = ( char * ) malloc ( data * sizeof ( char ) );
strcpy ( myString , HELLO_STRING );
printLine ( myString );
void printLine (const char * line)
if ( line != NULL )
printf ( "%s\n" , line );
free ( myString );
0
------------------------------
306099 117132/CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_06.c myString = ( char * ) malloc ( data * sizeof ( char ) ) 352
static void goodB2G2()
size_t data ;
data = 0;
if ( STATIC_CONST_FIVE == 5 )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
char inputBuffer [ CHAR_ARRAY_SIZE ] ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
inputBuffer [ recvResult ] = '\0';
data = strtoul ( inputBuffer , NULL , 0 );
while ( 0 )
if ( STATIC_CONST_FIVE == 5 )
char * myString ;
if ( data > strlen ( HELLO_STRING ) && data < 100 )
myString = ( char * ) malloc ( data * sizeof ( char ) );
strcpy ( myString , HELLO_STRING );
printLine ( myString );
void printLine (const char * line)
if ( line != NULL )
printf ( "%s\n" , line );
free ( myString );
0
------------------------------
304980 83673/CWE190_Integer_Overflow__int_max_square_44.c int result = data * data ; 55
static void goodG2BSink(int data)
int result = data * data ;
printIntLine ( result );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
1
------------------------------
18925 CVE-2015-2716/Firefox_37.0b7_CVE_2015_2716_parser_expat_lib_xmlparse.c temp = ( CONTENT_SCAFFOLD * ) MALLOC ( INIT_SCAFFOLD_ELEMENTS * sizeof ( CONTENT_SCAFFOLD ) ) 6316
static int
nextScaffoldPart(XML_Parser parser)
DTD * const dtd = _dtd
if ( ! dtd -> scaffIndex )
dtd -> scaffIndex = ( int * ) MALLOC ( groupSize * sizeof ( int ) );
if ( ! dtd -> scaffIndex )
dtd -> scaffIndex [ 0 ] = 0;
if ( dtd -> scaffCount >= dtd -> scaffSize )
CONTENT_SCAFFOLD * temp ;
if ( dtd -> scaffold )
temp = ( CONTENT_SCAFFOLD * ) MALLOC ( INIT_SCAFFOLD_ELEMENTS * sizeof ( CONTENT_SCAFFOLD ) );
if ( temp == NULL )
dtd -> scaffold = temp;
next = dtd -> scaffCount ++;
me = & dtd -> scaffold [ next ];
if ( dtd -> scaffLevel )
CONTENT_SCAFFOLD * parent = & dtd -> scaffold [ dtd -> scaffIndex [ dtd -> scaffLevel - 1 ] ] ;
if ( parent -> lastchild )
dtd -> scaffold [ parent -> lastchild ] . nextsib = next;
if ( ! parent -> childcnt )
parent -> firstchild = next;
parent -> lastchild = next;
parent -> childcnt ++;
me -> firstchild = me -> lastchild = me -> childcnt = me -> nextsib = 0;
return next ;
0
------------------------------
307105 117227/CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_connect_socket_05.c myString = ( wchar_t * ) malloc ( data * sizeof ( wchar_t ) ) 314
static void goodB2G2()
size_t data ;
data = 0;
if ( staticTrue )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
char inputBuffer [ CHAR_ARRAY_SIZE ] ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
inputBuffer [ recvResult ] = '\0';
data = strtoul ( inputBuffer , NULL , 0 );
while ( 0 )
if ( staticTrue )
wchar_t * myString ;
if ( data > wcslen ( HELLO_STRING ) && data < 100 )
myString = ( wchar_t * ) malloc ( data * sizeof ( wchar_t ) );
wcscpy ( myString , HELLO_STRING );
printWLine ( myString );
void printWLine (const wchar_t * line)
if ( line != NULL )
wprintf ( L "%ls\n" , line )
free ( myString );
0
------------------------------
309007 117022/CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_67b.c myString = ( char * ) malloc ( data * sizeof ( char ) ) 65
void CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_67_bad()
size_t data ;
CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_67_structType myStruct ;
data = 0;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
char inputBuffer [ CHAR_ARRAY_SIZE ] ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
inputBuffer [ recvResult ] = '\0';
data = strtoul ( inputBuffer , NULL , 0 );
while ( 0 )
myStruct . structFirst = data;
CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_67b_badSink ( myStruct );
void CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_67b_badSink(CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_67_structType myStruct)
size_t data = myStruct . structFirst ;
char * myString ;
if ( data > strlen ( HELLO_STRING ) )
myString = ( char * ) malloc ( data * sizeof ( char ) );
strcpy ( myString , HELLO_STRING );
printLine ( myString );
void printLine (const char * line)
if ( line != NULL )
printf ( "%s\n" , line );
free ( myString );
1
------------------------------
300671 151918/string.c stonesoup_tainted_buff = ( char * ) malloc ( buffer_size * sizeof ( char ) ) 69
static int stonesoup_ev_handler(struct mg_connection *conn, enum mg_event ev)
char * ifmatch_header ;
char * stonesoup_tainted_buff ;
int buffer_size = 1000 ;
if ( ev == MG_REQUEST )
ifmatch_header = ( char * ) mg_get_header ( conn , "if-match" );
if ( strcmp ( ifmatch_header , "weak_taint_source_value" ) == 0 )
while ( 1 )
stonesoup_tainted_buff = ( char * ) malloc ( buffer_size * sizeof ( char ) );
data_size = mg_get_var ( conn , "data" , stonesoup_tainted_buff , buffer_size * sizeof ( char ) );
if ( data_size < buffer_size )
buffer_size = buffer_size * 2;
free ( stonesoup_tainted_buff );
stonesoup_handle_taint ( stonesoup_tainted_buff );
void stonesoup_handle_taint(char *irradiations_euctemon)
if ( irradiations_euctemon != 0 )
nonwithering_displeasingness [ 87 ] = irradiations_euctemon;
kohekohe_preponderances = dyspepsias_unoxidized ( nonwithering_displeasingness );
char **dyspepsias_unoxidized(char **ricocheted_filmland)
return ricocheted_filmland ;
omodynia_twitty ( kohekohe_preponderances );
void omodynia_twitty(char **tupi_nominality)
noncooperator_dismain ( tupi_nominality );
void noncooperator_dismain(char **wakener_anisoyl)
puddle_cued = ( ( char * ) wakener_anisoyl [ 87 ] );
stonesoup_files = fopen ( puddle_cued , "r" );
if ( stonesoup_files != 0 )
while ( fscanf ( stonesoup_files , "%79s" , stonesoup_filename ) == 1 && stonesoup_ssi < 1020 )
if ( stonesoup_files != 0 )
fclose ( stonesoup_files );
if ( wakener_anisoyl [ 87 ] != 0 )
free ( ( ( char * ) wakener_anisoyl [ 87 ] ) );
1
------------------------------
18138 CVE-2015-5154/Xen_4.5.0_CVE-2015-5154_ide.c s -> data_end = buf + size 954
static void md_common_write(void *opaque, uint32_t at, uint16_t value)
struct md_s * s = ( struct md_s * ) opaque ;
at -= s -> io_base;
switch ( s -> opt & OPT_MODE )
if ( ( at & ~0x3ff ) == 0x400 )
at = 0;
at &= 0xf;
if ( ( at & ~0xf ) == 0x3f0 )
at -= 0x3e8;
if ( ( at & ~0xf ) == 0x1f0 )
at -= 0x1f0;
if ( ( at & ~0xf ) == 0x370 )
at -= 0x368;
if ( ( at & ~0xf ) == 0x170 )
at -= 0x170;
switch ( at )
if ( s -> cycle )
s -> io = value & 0xff;
s -> cycle = ! s -> cycle;
s -> io = value & 0xff;
s -> cycle = ! s -> cycle;
ide_ioport_write ( s -> ide , 0x1 , value );
static void ide_ioport_write(void *opaque, uint32_t addr, uint32_t val)
IDEState * ide_if = opaque ;
IDEState * s ;
int unit , n ;
addr &= 7;
if ( addr != 7 && ( ide_if -> cur_drive -> status & ( BUSY_STAT | DRQ_STAT ) ) )
switch ( addr )
ide_if [ 0 ] . hob_feature = ide_if [ 0 ] . feature;
ide_if [ 1 ] . hob_feature = ide_if [ 1 ] . feature;
ide_if [ 0 ] . feature = val;
ide_if [ 1 ] . feature = val;
ide_if [ 0 ] . hob_nsector = ide_if [ 0 ] . nsector;
ide_if [ 1 ] . hob_nsector = ide_if [ 1 ] . nsector;
ide_if [ 0 ] . nsector = val;
ide_if [ 1 ] . nsector = val;
ide_if [ 0 ] . hob_sector = ide_if [ 0 ] . sector;
ide_if [ 1 ] . hob_sector = ide_if [ 1 ] . sector;
ide_if [ 0 ] . sector = val;
ide_if [ 1 ] . sector = val;
ide_if [ 0 ] . hob_lcyl = ide_if [ 0 ] . lcyl;
ide_if [ 1 ] . hob_lcyl = ide_if [ 1 ] . lcyl;
ide_if [ 0 ] . lcyl = val;
ide_if [ 1 ] . lcyl = val;
ide_if [ 0 ] . hob_hcyl = ide_if [ 0 ] . hcyl;
ide_if [ 1 ] . hob_hcyl = ide_if [ 1 ] . hcyl;
ide_if [ 0 ] . hcyl = val;
ide_if [ 1 ] . hcyl = val;
ide_if [ 0 ] . select = ( val & ~0x10 ) | 0xa0;
ide_if [ 1 ] . select = ( val | 0x10 ) | 0xa0;
unit = ( val >> 4 ) & 1;
s = ide_if + unit;
ide_if -> cur_drive = s;
s = ide_if -> cur_drive;
if ( ! s -> bs )
if ( ( s -> status & ( BUSY_STAT | DRQ_STAT ) ) && val != WIN_DEVICE_RESET )
switch ( val )
if ( ! s -> is_cf )
s -> error = 0x09;
s -> status = READY_STAT | SEEK_STAT;
if ( ! s -> is_cf )
if ( val == CFA_WEAR_LEVEL )
s -> nsector = 0;
if ( val == CFA_ERASE_SECTORS )
s -> media_changed = 1;
s -> error = 0x00;
s -> status = READY_STAT | SEEK_STAT;
if ( ! s -> is_cf )
s -> error = 0x00;
s -> status = READY_STAT | SEEK_STAT;
memset ( s -> io_buffer , 0 , 0x200 );
s -> io_buffer [ 0x00 ] = s -> hcyl;
s -> io_buffer [ 0x01 ] = s -> lcyl;
s -> io_buffer [ 0x02 ] = s -> select;
s -> io_buffer [ 0x03 ] = s -> sector;
s -> io_buffer [ 0x04 ] = ide_get_sector ( s ) >> 16;
s -> io_buffer [ 0x05 ] = ide_get_sector ( s ) >> 8;
s -> io_buffer [ 0x06 ] = ide_get_sector ( s ) >> 0;
s -> io_buffer [ 0x13 ] = 0x00;
s -> io_buffer [ 0x18 ] = 0x00;
s -> io_buffer [ 0x19 ] = 0x00;
s -> io_buffer [ 0x1a ] = 0x01;
ide_transfer_start ( s , s -> io_buffer , 0x200 , ide_transfer_stop );
static void ide_transfer_start(IDEState *s, uint8_t *buf, int
EndTransferFunc *end_transfer_func)
s -> end_transfer_func = end_transfer_func;
s -> data_ptr = buf;
s -> data_end = buf + size;
if ( ! ( s -> status & ERR_STAT ) )
s -> status |= DRQ_STAT;
buffered_pio_reset ( s );
0
------------------------------
17515 CVE-2011-4326/CVE_2011_4326_VULN_udp6_ufo_fragment.c csum = skb_checksum ( skb , offset , skb -> len - offset , 0 ) 35
static struct sk_buff *CVE_2011_4326_VULN_udp6_ufo_fragment(struct sk_buff *skb, int features)
unsigned int mss ;
int offset ;
__wsum csum ;
mss = skb_shinfo ( skb ) -> gso_size;
if ( unlikely ( skb -> len <= mss ) )
if ( skb_gso_ok ( skb , features | NETIF_F_GSO_ROBUST ) )
offset = skb -> csum_start - skb_headroom ( skb );
csum = skb_checksum ( skb , offset , skb -> len - offset , 0 );
0
------------------------------
311364 152169/aviobuf.c s -> buf_end = dst + len 490
unsigned int avio_rl24(AVIOContext *s)
unsigned int val ;
val = avio_rl16 ( s );
val |= ( avio_r8 ( s ) << 16 );
int avio_r8(AVIOContext *s)
if ( s -> buf_ptr >= s -> buf_end )
fill_buffer ( s );
static void fill_buffer(AVIOContext *s)
uint8_t * dst = ! s -> max_packet_size && s -> buf_end - s -> buffer < ( s -> buffer_size ) ? s -> buf_end : s -> buffer ;
int len = ( ( s -> buffer_size ) - ( dst - s -> buffer ) ) ;
int max_buffer_size = s -> max_packet_size ? s -> max_packet_size : 32768 ;
if ( ! s -> read_packet && s -> buf_ptr >= s -> buf_end )
s -> eof_reached = 1;
if ( s -> eof_reached )
if ( s -> update_checksum && dst == s -> buffer )
if ( s -> buf_end > s -> checksum_ptr )
s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_end - s -> checksum_ptr ) ) );
s -> checksum_ptr = s -> buffer;
if ( s -> read_packet && s -> buffer_size > max_buffer_size )
s -> checksum_ptr = dst = s -> buffer;
len = s -> buffer_size;
if ( s -> read_packet )
len = ( ( s -> read_packet ) ( s -> opaque , dst , len ) );
len = 0;
if ( len <= 0 )
s -> eof_reached = 1;
if ( len < 0 )
s -> error = len;
s -> pos += len;
s -> buf_ptr = dst;
s -> buf_end = dst + len;
s -> bytes_read += len;
0
------------------------------
304479 82807/CWE190_Integer_Overflow__int64_t_max_square_42.c int64_t result = data * data ; 62
static void goodG2B()
int64_t data ;
data = 0L L
data = goodG2BSource ( data );
static int64_t goodG2BSource(int64_t data)
data = 2;
return data ;
int64_t result = data * data ;
printLongLongLine ( result );
void printLongLongLine (int64_t longLongIntNumber)
printf ( "%lld\n" , longLongIntNumber );
0
------------------------------
18600 CVE-2015-2716/Firefox_37.0b7_CVE_2015_2716_parser_expat_lib_xmlparse.c tem = ( BLOCK * ) pool -> mem -> malloc_fcn ( offsetof ( BLOCK , s ) + blockSize * sizeof ( XML_Char ) ) 6275
static enum
storeAtts(XML_Parser parser, const ENCODING
const char *attStr, TAG_NAME
BINDING **bindingsPtr)
DTD * const dtd = _dtd
ELEMENT_TYPE * elementType ;
int nDefaultAtts ;
const XML_Char * * appAtts ;
int attIndex = 0 ;
int i ;
int n ;
elementType = ( ELEMENT_TYPE * ) lookup ( & dtd -> elementTypes , tagNamePtr -> str , 0 );
if ( ! elementType )
const XML_Char * name = poolCopyString ( & dtd -> pool , tagNamePtr -> str ) ;
if ( ! name )
elementType = ( ELEMENT_TYPE * ) lookup ( & dtd -> elementTypes , name , sizeof ( ELEMENT_TYPE ) );
if ( ! elementType )
if ( ns && ! setElementTypePrefix ( parser , elementType ) )
nDefaultAtts = elementType -> nDefaultAtts;
n = XmlGetAttributes ( enc , attStr , attsSize , atts );
if ( n + nDefaultAtts > attsSize )
ATTRIBUTE * temp ;
attsSize = n + nDefaultAtts + INIT_ATTS_SIZE;
temp = ( ATTRIBUTE * ) REALLOC ( ( void * ) atts , attsSize * sizeof ( ATTRIBUTE ) );
if ( temp == NULL )
atts = temp;
appAtts = ( const XML_Char * * ) atts;
for (i = 0; i < n; i++)
ATTRIBUTE_ID * attId = getAttributeId ( parser , enc , atts [ i ] . name , atts [ i ] . name + XmlNameLength ( enc , atts [ i ] . name ) ) ;
if ( ! attId )
if ( ( attId -> name ) [ - 1 ] )
( attId -> name ) [ - 1 ] = 1;
appAtts [ attIndex ++ ] = attId -> name;
if ( ! atts [ i ] . normalized )
enum XML_Error result ;
XML_Bool isCdata = XML_TRUE ;
if ( attId -> maybeTokenized )
int j ;
for (j = 0; j < nDefaultAtts; j++)
if ( attId == elementType -> defaultAtts [ j ] . id )
isCdata = elementType -> defaultAtts [ j ] . isCdata;
result = storeAttributeValue ( parser , enc , isCdata , atts [ i ] . valuePtr , atts [ i ] . valueEnd , & tempPool );
if ( result )
appAtts [ attIndex ] = poolStart ( & tempPool );
appAtts [ attIndex ] = poolStoreString ( & tempPool , enc , atts [ i ] . valuePtr , atts [ i ] . valueEnd );
if ( appAtts [ attIndex ] == 0 )
if ( attId -> prefix )
if ( attId -> xmlns )
enum XML_Error result = addBinding ( parser , attId -> prefix , attId , appAtts [ attIndex ] , bindingsPtr ) ;
if ( result )
attIndex ++;
( attId -> name ) [ - 1 ] = 2;
attIndex ++;
static XML_Char
poolStoreString(STRING_POOL *pool, const ENCODING
const char *ptr, const char *end)
if ( ! poolAppend ( pool , enc , ptr , end ) )
static XML_Char
poolAppend(STRING_POOL *pool, const ENCODING
const char *ptr, const char *end)
if ( ! pool -> ptr && ! poolGrow ( pool ) )
if ( ptr == end )
if ( ! poolGrow ( pool ) )
static XML_Bool
poolGrow(STRING_POOL *pool)
if ( pool -> freeBlocks )
if ( pool -> start == 0 )
if ( pool -> end - pool -> start < pool -> freeBlocks -> size )
if ( pool -> blocks && pool -> start == pool -> blocks -> s )
BLOCK * tem ;
int blockSize = ( int ) ( pool -> end - pool -> start ) ;
if ( blockSize < INIT_BLOCK_SIZE )
blockSize = INIT_BLOCK_SIZE;
blockSize *= 2;
tem = ( BLOCK * ) pool -> mem -> malloc_fcn ( offsetof ( BLOCK , s ) + blockSize * sizeof ( XML_Char ) );
if ( ! tem )
tem -> size = blockSize;
tem -> next = pool -> blocks;
pool -> blocks = tem;
if ( pool -> ptr != pool -> start )
memcpy ( tem -> s , pool -> start , ( pool -> ptr - pool -> start ) * sizeof ( XML_Char ) );
pool -> ptr = tem -> s + ( pool -> ptr - pool -> start );
pool -> start = tem -> s;
pool -> end = tem -> s + blockSize;
0
------------------------------
305276 103076/CWE427_Uncontrolled_Search_Path_Element__char_listen_socket_45.c recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 250 - dataLen - 1 ) , 0 ) 110
void CWE427_Uncontrolled_Search_Path_Element__char_listen_socket_45_bad()
char * data ;
char dataBuffer [ 250 ] = "PATH=" ;
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 250 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
CWE427_Uncontrolled_Search_Path_Element__char_listen_socket_45_badData = data;
0
------------------------------
308531 108954/CWE606_Unchecked_Loop_Condition__char_connect_socket_41.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 238
static void goodB2G()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
goodB2GSink ( data );
static void goodB2GSink(char * data)
if ( sscanf ( data , "%d" , & n ) == 1 )
0
------------------------------
308742 117267/CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_connect_socket_81_bad.cpp myString = ( wchar_t * ) malloc ( data * sizeof ( wchar_t ) ) 36
void CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_connect_socket_81_bad::action(size_t data) const
wchar_t * myString ;
if ( data > wcslen ( HELLO_STRING ) )
myString = ( wchar_t * ) malloc ( data * sizeof ( wchar_t ) );
wcscpy ( myString , HELLO_STRING );
printWLine ( myString );
void printWLine (const wchar_t * line)
if ( line != NULL )
wprintf ( L "%ls\n" , line )
free ( myString );
1
------------------------------
301770 80366/CWE134_Uncontrolled_Format_String__char_listen_socket_snprintf_31.c recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 102
void CWE134_Uncontrolled_Format_String__char_listen_socket_snprintf_31_bad()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
char * dataCopy = data ;
char * data = dataCopy ;
SNPRINTF ( dest , 100 - 1 , data );
1
------------------------------
314323 96796/CWE36_Absolute_Path_Traversal__wchar_t_connect_socket_ifstream_11.cpp recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ) 95
void bad()
wchar_t * data ;
wchar_t dataBuffer [ FILENAME_MAX ] = L ""
data = dataBuffer;
if ( globalReturnsTrue ( ) )
int globalReturnsTrue()
return 1 ;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( FILENAME_MAX - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
300661 151912/dfa.c match_lens = check_matching_with_multibyte_ops ( d , s , ( * pp - buf_begin ) ) 3445
char *dfaexec(struct dfa *d,const char *begin,char *end,int allow_nl,size_t *count,int *backref)
state_num s ;
state_num s1 ;
const unsigned char * p ;
state_num * * trans ;
state_num * t ;
unsigned char eol = eolbyte ;
unsigned char saved_end ;
s = s1 = 0;
p = ( ( const unsigned char * ) begin );
trans = d -> trans;
saved_end = * ( ( unsigned char * ) end );
* end = eol;
if ( d -> mb_cur_max > 1 )
while ( ( t = trans [ s ] ) != ( ( void * ) 0 ) )
if ( p > buf_end )
s1 = s;
if ( s == 0 )
if ( ( ( char * ) p ) >= end )
* end = saved_end;
if ( d -> states [ s ] . mbps . nelem == 0 )
s = t [ * ( p ++ ) ];
if ( backref )
* end = saved_end;
s = transit_state ( d , s , & p );
trans = d -> trans;
while ( ( t = trans [ s ] ) != ( ( void * ) 0 ) )
s1 = t [ * ( p ++ ) ];
if ( ( t = trans [ s1 ] ) == ( ( void * ) 0 ) )
state_num tmp = s ;
s = s1;
s1 = tmp;
s = t [ * ( p ++ ) ];
if ( s >= 0 && ( ( char * ) p ) <= end && d -> fails [ s ] )
if ( d -> success [ s ] & sbit [ * p ] )
s1 = s;
if ( d -> mb_cur_max > 1 )
s = transit_state ( d , s , & p );
trans = d -> trans;
s = d -> fails [ s ] [ * ( p ++ ) ];
if ( ( ( char * ) p ) > end )
if ( s >= 0 )
trans = d -> trans;
if ( p [ - 1 ] == eol && allow_nl )
s = d -> newlines [ s1 ];
s = 0;
static state_num transit_state(struct dfa *d,state_num s,const unsigned char **pp)
size_t nelem = d -> states [ s ] . mbps . nelem ;
if ( nelem > 0 )
match_lens = check_matching_with_multibyte_ops ( d , s , ( * pp - buf_begin ) );
if ( match_lens [ i ] > maxlen )
maxlen = match_lens [ i ];
if ( nelem == 0 || maxlen == 0 )
free ( match_lens );
transit_state_consume_1char ( d , s , pp , match_lens , & mbclen , & follows );
while ( * pp - p1 < maxlen )
if ( match_lens [ i ] == * pp - p1 )
free ( match_lens );
0
------------------------------
20526 CVE-2016-9103/qemu_2.3.0_CVE-2016-9103_virtio-9p.c iounit *= ( s -> msize - P9_IOHDRSZ ) / stbuf . f_bsize 1336
static void v9fs_open(void *opaque)
int flags ;
int32_t fid ;
int32_t mode ;
size_t offset = 7 ;
struct stat stbuf ;
V9fsFidState * fidp ;
V9fsPDU * pdu = opaque ;
V9fsState * s = pdu -> s ;
if ( s -> proto_version == V9FS_PROTO_2000L )
err = pdu_unmarshal ( pdu , offset , "dd" , & fid , & mode );
uint8_t modebyte ;
err = pdu_unmarshal ( pdu , offset , "db" , & fid , & modebyte );
mode = modebyte;
if ( err < 0 )
fidp = get_fid ( pdu , fid );
static V9fsFidState *get_fid(V9fsPDU *pdu, int32_t fid)
int err ;
V9fsFidState * f ;
V9fsState * s = pdu -> s ;
for (f = s->fid_list; f; f = f->next)
if ( f -> fid == fid )
f -> ref ++;
err = v9fs_reopen_fid ( pdu , f );
if ( err < 0 )
return NULL ;
f -> flags |= FID_REFERENCED;
return f ;
return NULL ;
if ( fidp == NULL )
err = v9fs_co_lstat ( pdu , & fidp -> path , & stbuf );
if ( err < 0 )
if ( S_ISDIR ( stbuf . st_mode ) )
if ( s -> proto_version == V9FS_PROTO_2000L )
flags = get_dotl_openflags ( s , mode );
static int get_dotl_openflags(V9fsState *s, int oflags)
int flags ;
flags = dotl_to_open_flags ( oflags );
flags &= ~ ( O_NOCTTY | O_ASYNC | O_CREAT );
flags &= ~O_DIRECT;
return flags ;
flags = omode_to_uflags ( mode );
static int omode_to_uflags(int8_t mode)
int ret = 0 ;
switch ( mode & 3 )
ret = O_RDONLY;
ret = O_RDWR;
ret = O_WRONLY;
ret = O_RDONLY;
if ( mode & Otrunc )
ret |= O_TRUNC;
if ( mode & Oappend )
ret |= O_APPEND;
if ( mode & Oexcl )
ret |= O_EXCL;
return ret ;
if ( is_ro_export ( & s -> ctx ) )
static inline bool is_ro_export(FsContext *ctx)
return ctx -> export_flags & V9FS_RDONLY ;
if ( mode & O_WRONLY || mode & O_RDWR || mode & O_APPEND || mode & O_TRUNC )
err = v9fs_co_open ( pdu , fidp , flags );
if ( err < 0 )
fidp -> fid_type = P9_FID_FILE;
fidp -> open_flags = flags;
if ( flags & O_EXCL )
fidp -> flags |= FID_NON_RECLAIMABLE;
iounit = get_iounit ( pdu , & fidp -> path );
static int32_t get_iounit(V9fsPDU *pdu, V9fsPath *path)
struct statfs stbuf ;
V9fsState * s = pdu -> s ;
if ( ! v9fs_co_statfs ( pdu , path , & stbuf ) )
iounit = stbuf . f_bsize;
iounit *= ( s -> msize - P9_IOHDRSZ ) / stbuf . f_bsize;
if ( ! iounit )
return iounit ;
0
------------------------------
300293 149400/config.c stonesoup_tainted_buff = ( char * ) malloc ( buffer_size * sizeof ( char ) ) 94
static int stonesoup_ev_handler(struct mg_connection *conn, enum mg_event ev)
char * ifmatch_header ;
char * stonesoup_tainted_buff ;
int buffer_size = 1000 ;
if ( ev == MG_REQUEST )
ifmatch_header = ( char * ) mg_get_header ( conn , "if-match" );
if ( strcmp ( ifmatch_header , "weak_taint_source_value" ) == 0 )
while ( 1 )
stonesoup_tainted_buff = ( char * ) malloc ( buffer_size * sizeof ( char ) );
data_size = mg_get_var ( conn , "data" , stonesoup_tainted_buff , buffer_size * sizeof ( char ) );
if ( data_size < buffer_size )
buffer_size = buffer_size * 2;
free ( stonesoup_tainted_buff );
stonesoup_handle_taint ( stonesoup_tainted_buff );
void stonesoup_handle_taint(char *paganically_synchronal)
if ( paganically_synchronal != 0 )
malacopod_bemoaned [ 24 ] = paganically_synchronal;
eas_predoubtful [ 5 ] = malacopod_bemoaned;
hyperosmic_spillikins = * ( eas_predoubtful + * pentasyllabism_aegir );
subthreshold_tis = ( ( char * ) hyperosmic_spillikins [ 24 ] );
stonesoup_buffer_value = atoi ( subthreshold_tis );
tracepoint ( stonesoup_trace , variable_signed_integral , "stonesoup_buffer_value" , stonesoup_buffer_value , & stonesoup_buffer_value , "INITIAL-STATE" );
if ( stonesoup_buffer_value < 0 )
stonesoup_size_buffer = ( ( unsigned int ) stonesoup_buffer_value );
stonesoup_malloc_buffer = my_malloc ( stonesoup_size_buffer );
void *my_malloc(unsigned int size)
if ( size > 512 )
return malloc ( size ) ;
tracepoint ( stonesoup_trace , variable_address , "stonesoup_malloc_buffer" , stonesoup_malloc_buffer , "TRIGGER-STATE" );
memset ( stonesoup_malloc_buffer , 0 , stonesoup_size_buffer );
stonesoup_printf ( "Buffer size is %d\n" , stonesoup_size_buffer );
void stonesoup_printf(char * format, ...)
va_start ( argptr , format );
mg_vprintf_data ( ( struct mg_connection * ) stonesoup_printf_context , format , argptr );
if ( stonesoup_malloc_buffer != 0 )
free ( stonesoup_malloc_buffer );
if ( hyperosmic_spillikins [ 24 ] != 0 )
free ( ( ( char * ) hyperosmic_spillikins [ 24 ] ) );
1
------------------------------
306296 120066/CWE78_OS_Command_Injection__char_listen_socket_w32_execv_12.c recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 112
void CWE78_OS_Command_Injection__char_listen_socket_w32_execv_12_bad()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
if ( globalReturnsTrueOrFalse ( ) )
int globalReturnsTrueOrFalse()
return ( rand ( ) % 2 ) ;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
1
------------------------------
312286 151940/cmdutils.c int len = ( p ? ( p - name ) : strlen ( name ) ) ; 274
void parse_options(void *optctx,int argc,char **argv,const OptionDef *options,void (*parse_arg_function)(void *, const char *))
const char * opt ;
int optindex ;
int handleoptions = 1 ;
int ret ;
optindex = 1;
while ( optindex < argc )
opt = argv [ optindex ++ ];
if ( handleoptions && opt [ 0 ] == '-' && opt [ 1 ] != '\0' )
if ( opt [ 1 ] == '-' && opt [ 2 ] == '\0' )
handleoptions = 0;
opt ++;
if ( ( ret = parse_option ( optctx , opt , argv [ optindex ] , options ) ) < 0 )
optindex += ret;
int parse_option(void *optctx,const char *opt,const char *arg,const OptionDef *options)
const OptionDef * po ;
po = find_option ( options , opt );
if ( ! po -> name && opt [ 0 ] == 'n' && opt [ 1 ] == 'o' )
po = find_option ( options , opt + 2 );
if ( ! po -> name )
po = find_option ( options , "default" );
static const OptionDef *find_option(const OptionDef *po,const char *name)
const char * p = ( strchr ( name , ':' ) ) ;
int len = ( p ? ( p - name ) : strlen ( name ) ) ;
if ( ! strncmp ( name , po -> name , len ) && strlen ( po -> name ) == len )
0
------------------------------
308805 118221/CWE78_OS_Command_Injection__char_connect_socket_w32_execvp_66a.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 106
void CWE78_OS_Command_Injection__char_connect_socket_w32_execvp_66_bad()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
dataArray [ 2 ] = data;
CWE78_OS_Command_Injection__char_connect_socket_w32_execvp_66b_badSink ( dataArray );
void CWE78_OS_Command_Injection__char_connect_socket_w32_execvp_66b_badSink(char * dataArray[])
char * data = dataArray [ 2 ] ;
0
------------------------------
16750 CVE-2011-4326/CVE_2011_4326_PATCHED_udp6_ufo_fragment.c offset = skb -> csum_start - skb_headroom ( skb ) 34
static struct sk_buff *CVE_2011_4326_PATCHED_udp6_ufo_fragment(struct sk_buff *skb, int features)
unsigned int mss ;
int offset ;
mss = skb_shinfo ( skb ) -> gso_size;
if ( unlikely ( skb -> len <= mss ) )
if ( skb_gso_ok ( skb , features | NETIF_F_GSO_ROBUST ) )
offset = skb -> csum_start - skb_headroom ( skb );
0
------------------------------
305798 104480/CWE469_Use_of_Pointer_Subtraction_to_Determine_Size__wchar_t_03.c indexOfSlashInString1 = ( size_t ) ( slashInString1 - string1 ) 70
static void good1()
if ( 5 != 5 )
wchar_t string1 [ ] = SOURCE_STRING ;
wchar_t * slashInString1 ;
size_t indexOfSlashInString1 ;
slashInString1 = wcschr ( string1 , L '/' )
indexOfSlashInString1 = ( size_t ) ( slashInString1 - string1 );
printUnsignedLine ( indexOfSlashInString1 );
void printUnsignedLine(unsigned unsignedNumber)
printf ( "%u\n" , unsignedNumber );
0
------------------------------
304828 79206/CWE134_Uncontrolled_Format_String__char_connect_socket_snprintf_13.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 96
void CWE134_Uncontrolled_Format_String__char_connect_socket_snprintf_13_bad()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
if ( GLOBAL_CONST_FIVE == 5 )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
SNPRINTF ( dest , 100 - 1 , data );
1
------------------------------
313656 90936/CWE23_Relative_Path_Traversal__wchar_t_connect_socket_open_13.cpp recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ) 103
void bad()
wchar_t * data ;
wchar_t dataBuffer [ FILENAME_MAX ] = BASEPATH ;
data = dataBuffer;
if ( GLOBAL_CONST_FIVE == 5 )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( FILENAME_MAX - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
304440 81932/CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_w32_vsnprintf_03.c recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 ) 335
static void goodB2G2()
wchar_t * data ;
wchar_t dataBuffer [ 100 ] = L ""
data = dataBuffer;
if ( 5 == 5 )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
313749 90561/CWE23_Relative_Path_Traversal__char_listen_socket_fopen_32.cpp recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ) 111
void bad()
char * data ;
char * * dataPtr1 = & data ;
char dataBuffer [ FILENAME_MAX ] = BASEPATH ;
data = dataBuffer;
char * data = * dataPtr1 ;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
* dataPtr1 = data;
pFile = FOPEN ( data , "wb+" );
if ( pFile != NULL )
fclose ( pFile );
1
------------------------------
312407 150092/utils.c uint8_t * new_buf = ( av_realloc ( ( pd -> buf ) , ( pd -> buf_size + pkt -> size + 32 ) ) ) ; 869
int av_read_frame(AVFormatContext *s,AVPacket *pkt)
const int genpts = s -> flags & 0x1 ;
int eof = 0 ;
int ret ;
if ( ! genpts )
AVPacketList * pktl = s -> packet_buffer ;
if ( pktl )
AVPacket * next_pkt = & pktl -> pkt ;
if ( next_pkt -> dts != ( ( int64_t ) 0x8000000000000000UL ) )
int wrap_bits = s -> streams [ next_pkt -> stream_index ] -> pts_wrap_bits ;
int64_t last_dts = next_pkt -> dts ;
while ( pktl && next_pkt -> pts == ( ( int64_t ) 0x8000000000000000UL ) )
if ( pktl -> pkt . stream_index == next_pkt -> stream_index && av_compare_mod ( ( next_pkt -> dts ) , pktl -> pkt . dts , ( 2 << wrap_bits - 1 ) ) < 0 )
if ( av_compare_mod ( pktl -> pkt . pts , pktl -> pkt . dts , ( 2 << wrap_bits - 1 ) ) )
next_pkt -> pts = pktl -> pkt . dts;
if ( last_dts != ( ( int64_t ) 0x8000000000000000UL ) )
last_dts = pktl -> pkt . dts;
pktl = pktl -> next;
if ( eof && next_pkt -> pts == ( ( int64_t ) 0x8000000000000000UL ) && last_dts != ( ( int64_t ) 0x8000000000000000UL ) )
next_pkt -> pts = last_dts + ( next_pkt -> duration );
pktl = s -> packet_buffer;
if ( ! ( next_pkt -> pts == ( ( int64_t ) 0x8000000000000000UL ) && next_pkt -> dts != ( ( int64_t ) 0x8000000000000000UL ) && ! eof ) )
ret = read_frame_internal ( s , pkt );
if ( ret < 0 )
if ( pktl && ret != - '\v' )
eof = 1;
if ( av_dup_packet ( add_to_pktbuf ( & s -> packet_buffer , pkt , & s -> packet_buffer_end ) ) < 0 )
static int read_frame_internal(AVFormatContext *s,AVPacket *pkt)
int got_packet = 0 ;
while ( ! got_packet && ! s -> parse_queue )
AVStream * st ;
AVPacket cur_pkt ;
ret = ff_read_packet ( s , & cur_pkt );
if ( ret < 0 )
st = s -> streams [ cur_pkt . stream_index ];
if ( st -> need_parsing && ! st -> parser && ! ( s -> flags & 0x20 ) )
st -> parser = av_parser_init ( ( st -> codec -> codec_id ) );
if ( ! st -> parser )
st -> need_parsing = AVSTREAM_PARSE_NONE;
if ( ( st -> need_parsing ) == AVSTREAM_PARSE_HEADERS )
st -> parser -> flags |= 0x1;
if ( ( st -> need_parsing ) == AVSTREAM_PARSE_FULL_ONCE )
st -> parser -> flags |= 0x0002;
if ( ( st -> need_parsing ) == AVSTREAM_PARSE_FULL_RAW )
st -> parser -> flags |= 0x1000;
if ( ! st -> need_parsing || ! st -> parser )
* pkt = cur_pkt;
got_packet = 1;
if ( ( st -> discard ) < AVDISCARD_ALL )
if ( ( ret = parse_packet ( s , & cur_pkt , cur_pkt . stream_index ) ) < 0 )
if ( pkt -> flags & 0x1 )
st -> skip_to_keyframe = 0;
if ( st -> skip_to_keyframe )
if ( got_packet )
* pkt = cur_pkt;
got_packet = 0;
int ff_read_packet(AVFormatContext *s,AVPacket *pkt)
int ret ;
AVStream * st ;
AVPacketList * pktl = s -> raw_packet_buffer ;
if ( pktl )
* pkt = pktl -> pkt;
st = s -> streams [ pkt -> stream_index ];
if ( st -> request_probe <= 0 )
pkt -> data = ( ( void * ) 0 );
pkt -> size = 0;
ret = ( ( s -> iformat -> read_packet ) ( s , pkt ) );
if ( ret < 0 )
if ( ! pktl || ret == - '\v' )
if ( s -> flags & 0x0100 && pkt -> flags & 0x0002 )
if ( ( pkt -> stream_index ) >= ( ( unsigned int ) ( s -> nb_streams ) ) )
st = s -> streams [ pkt -> stream_index ];
pkt -> dts = wrap_timestamp ( st , pkt -> dts );
pkt -> pts = wrap_timestamp ( st , pkt -> pts );
if ( ! pktl && st -> request_probe <= 0 )
s -> raw_packet_buffer_remaining_size -= pkt -> size;
probe_codec ( s , st , pkt );
static void probe_codec(AVFormatContext *s,AVStream *st,const AVPacket *pkt)
if ( st -> request_probe > 0 )
AVProbeData * pd = & st -> probe_data ;
if ( pkt )
uint8_t * new_buf = ( av_realloc ( ( pd -> buf ) , ( pd -> buf_size + pkt -> size + 32 ) ) ) ;
if ( ! new_buf )
pd -> buf = new_buf;
memcpy ( ( pd -> buf + pd -> buf_size ) , ( pkt -> data ) , ( pkt -> size ) );
pd -> buf_size += pkt -> size;
memset ( ( pd -> buf + pd -> buf_size ) , 0 , 32 );
if ( end || ff_log2_c ( ( pd -> buf_size ) ) != ff_log2_c ( ( pd -> buf_size - pkt -> size ) ) )
int score = set_codec_from_probe_data ( s , st , pd ) ;
if ( ( st -> codec -> codec_id ) != AV_CODEC_ID_NONE && score > 100 / 4 || end )
pd -> buf_size = 0;
av_freep ( ( & pd -> buf ) );
0
------------------------------
314246 110661/CWE680_Integer_Overflow_to_Buffer_Overflow__new_fgets_14.cpp dataBytes = data * sizeof ( int ) 51
void bad()
int data ;
data = - 1;
if ( globalFive == 5 )
char inputBuffer [ CHAR_ARRAY_SIZE ] = "" ;
if ( fgets ( inputBuffer , CHAR_ARRAY_SIZE , stdin ) != NULL )
data = atoi ( inputBuffer );
size_t dataBytes , i ;
dataBytes = data * sizeof ( int );
intPointer = ( int * ) new char [ dataBytes ];
intPointer [ i ] = 0;
printIntLine ( intPointer [ 0 ] );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
delete [ ] intPointer
1
------------------------------
20241 CVE-2016-6508/wireshark_2.0.4_CVE_2016_6508_epan_dissectors_packet-rlc.c ti = proto_tree_add_item ( li_tree , hf_rlc_li_data , tvb , hdr_offs + li -> li - li -> len , li -> len , ENC_NA ) 766
static
dissect_rlc_dcch(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree)
proto_tree * subtree = NULL ;
fp_info * fpi ;
rlc_info * rlci ;
enum rlc_channel_type channel ;
fpi = ( fp_info * ) p_get_proto_data ( wmem_file_scope ( ) , pinfo , proto_fp , 0 );
rlci = ( rlc_info * ) p_get_proto_data ( wmem_file_scope ( ) , pinfo , proto_rlc , 0 );
if ( ! fpi || ! rlci )
if ( tree )
ti = proto_tree_add_item ( tree , proto_rlc , tvb , 0 , - 1 , ENC_NA );
subtree = proto_item_add_subtree ( ti , ett_rlc );
channel = fpi -> is_uplink ? RLC_UL_DCCH : RLC_DL_DCCH;
switch ( rlci -> mode [ fpi -> cur_tb ] )
dissect_rlc_um ( channel , tvb , pinfo , tree , subtree );
static
dissect_rlc_um(enum rlc_channel_type channel, tvbuff_t *tvb, packet_info
proto_tree *top_level, proto_tree *tree)
struct rlc_li li [ MAX_LI ] ;
fp_info * fpinf ;
rlc_info * rlcinf ;
gboolean is_truncated , li_is_on_2_bytes ;
fpinf = ( fp_info * ) p_get_proto_data ( wmem_file_scope ( ) , pinfo , proto_fp , 0 );
rlcinf = ( rlc_info * ) p_get_proto_data ( wmem_file_scope ( ) , pinfo , proto_rlc , 0 );
if ( ! fpinf || ! rlcinf )
pos = fpinf -> cur_tb;
if ( ( rlcinf -> ciphered [ pos ] == TRUE && rlcinf -> deciphered [ pos ] == FALSE ) || global_rlc_ciphered )
if ( global_rlc_try_decipher )
if ( global_rlc_li_size == RLC_LI_UPPERLAYER )
if ( rlcinf -> li_size [ pos ] == RLC_LI_VARIABLE )
li_is_on_2_bytes = ( tvb_reported_length ( tvb ) > 125 ) ? TRUE : FALSE;
li_is_on_2_bytes = ( rlcinf -> li_size [ pos ] == RLC_LI_15BITS ) ? TRUE : FALSE;
li_is_on_2_bytes = ( global_rlc_li_size == RLC_LI_15BITS ) ? TRUE : FALSE;
num_li = rlc_decode_li ( RLC_UM , tvb , pinfo , tree , li , MAX_LI , li_is_on_2_bytes );
static
rlc_decode_li(enum rlc_mode mode, tvbuff_t *tvb, packet_info *pinfo, proto_tree
struct rlc_li *li, guint8 max_li, gboolean li_on_2_bytes)
guint8 ext , hdr_len , offs = 0 , num_li = 0 , li_offs ;
guint16 next_bytes , prev_li = 0 ;
proto_item * malformed ;
guint16 total_len ;
switch ( mode )
offs = 1;
offs = 0;
hdr_len = offs;
ext = tvb_get_guint8 ( tvb , hdr_len ++ ) & 0x01;
while ( ext )
next_bytes = li_on_2_bytes ? tvb_get_ntohs ( tvb , hdr_len ) : tvb_get_guint8 ( tvb , hdr_len );
ext = next_bytes & 0x01;
hdr_len += li_on_2_bytes ? 2 : 1;
total_len = tvb_captured_length_remaining ( tvb , hdr_len );
ext = tvb_get_guint8 ( tvb , offs ++ ) & 0x01;
li_offs = offs;
while ( ext )
if ( li_on_2_bytes )
next_bytes = tvb_get_ntohs ( tvb , offs );
offs += 2;
next_bytes = tvb_get_guint8 ( tvb , offs ++ );
ext = next_bytes & 0x01;
li [ num_li ] . ext = ext;
li [ num_li ] . li = next_bytes >> 1;
if ( li_on_2_bytes )
switch ( li [ num_li ] . li )
li [ num_li ] . len = 0;
if ( mode == RLC_UM )
li [ num_li ] . len = 0;
malformed = tree_add_li ( mode , & li [ num_li ] , num_li , li_offs , li_on_2_bytes , tvb , tree );
if ( ( ( li [ num_li ] . li > total_len ) && ! global_rlc_headers_expected ) || ( li [ num_li ] . li < prev_li ) )
li [ num_li ] . len = li [ num_li ] . li - prev_li;
prev_li = li [ num_li ] . li;
switch ( li [ num_li ] . li )
li [ num_li ] . len = 0;
if ( mode == RLC_UM )
li [ num_li ] . len = 0;
li [ num_li ] . len = li [ num_li ] . li - prev_li;
if ( ( ( li [ num_li ] . li > total_len ) && ! global_rlc_headers_expected ) || ( li [ num_li ] . li < prev_li ) )
prev_li = li [ num_li ] . li;
li [ num_li ] . tree = tree_add_li ( mode , & li [ num_li ] , num_li , li_offs , li_on_2_bytes , tvb , tree );
num_li ++;
if ( num_li > max_li )
static proto_tree
tree_add_li(enum rlc_mode mode, struct rlc_li *li, guint8 li_idx, guint8
gboolean li_is_on_2_bytes, tvbuff_t *tvb, proto_tree *tree)
proto_item * root_ti , * ti ;
proto_tree * li_tree ;
guint8 li_offs ;
if ( ! tree )
if ( li_is_on_2_bytes )
li_offs = hdr_offs + li_idx * 2;
root_ti = proto_tree_add_item ( tree , hf_rlc_li , tvb , li_offs , 2 , ENC_NA );
li_tree = proto_item_add_subtree ( root_ti , ett_rlc_frag );
li_offs = hdr_offs + li_idx;
root_ti = proto_tree_add_item ( tree , hf_rlc_li , tvb , li_offs , 1 , ENC_NA );
li_tree = proto_item_add_subtree ( root_ti , ett_rlc_frag );
if ( li -> len > 0 )
if ( li -> li > tvb_reported_length_remaining ( tvb , hdr_offs ) )
if ( li -> len > li -> li )
ti = proto_tree_add_item ( li_tree , hf_rlc_li_data , tvb , hdr_offs + li -> li - li -> len , li -> len , ENC_NA );
PROTO_ITEM_SET_HIDDEN ( ti );
0
------------------------------
299147 150434/emem.c qsort_arr [ i ] = stonesoupData -> qsize - i 266
void *stonesoup_replace (void *data)
struct stonesoup_data * stonesoupData = ( struct stonesoup_data * ) data ;
int * qsort_arr ;
qsort_arr = malloc ( sizeof ( int ) * stonesoupData -> qsize );
if ( qsort_arr != NULL )
for (i = 0; i < stonesoupData->qsize; i++)
qsort_arr [ i ] = stonesoupData -> qsize - i;
qsort ( qsort_arr , stonesoupData -> qsize , sizeof ( int ) , & stonesoup_comp );
free ( qsort_arr );
while ( stonesoupData -> data [ i ] != '\0' )
if ( stonesoupData -> data [ i ] == '_' )
stonesoupData -> data [ i ] = '-';
i ++;
0
------------------------------
299555 151288/file_wrappers.c have = ( ( unsigned int ) ( strm -> next_out - state -> next ) ) 1608
unsigned int gzwfile_write(GZWFILE_T state,const void *buf,unsigned int len)
z_streamp strm ;
strm = & state -> strm;
if ( state -> err != 0 )
if ( len == 0 )
if ( state -> size == 0 && gz_init ( state ) == - 1 )
static int gz_init(GZWFILE_T state)
int ret ;
z_streamp strm = & state -> strm ;
state -> in = ( ( unsigned char * ) ( g_try_malloc ( ( state -> want ) ) ) );
state -> out = ( ( unsigned char * ) ( g_try_malloc ( ( state -> want ) ) ) );
if ( state -> in == ( ( void * ) 0 ) || state -> out == ( ( void * ) 0 ) )
return - 1 ;
strm -> zalloc = 0;
strm -> zfree = 0;
strm -> opaque = 0;
ret = deflateInit2_ ( strm , state -> level , 8 , 15 + 16 , 8 , state -> strategy , "1.2.8" , ( ( int ) ( sizeof ( z_stream ) ) ) );
if ( ret != 0 )
return - 1 ;
return 0 ;
if ( len < state -> size )
if ( strm -> avail_in && gz_comp ( state , 0 ) == - 1 )
state -> pos += len;
if ( gz_comp ( state , 0 ) == - 1 )
static int gz_comp(GZWFILE_T state,int flush)
int ret ;
int got ;
unsigned int have ;
z_streamp strm = & state -> strm ;
if ( state -> size == 0 && gz_init ( state ) == - 1 )
ret = 0;
if ( strm -> avail_out == 0 || flush != 0 && ( flush != 4 || ret == 1 ) )
have = ( ( unsigned int ) ( strm -> next_out - state -> next ) );
if ( have )
got = ( write ( state -> fd , ( state -> next ) , have ) );
if ( got < 0 )
if ( ( ( unsigned int ) got ) != have )
state -> err = - 14;
if ( strm -> avail_out == 0 )
strm -> avail_out = state -> size;
strm -> next_out = state -> out;
state -> next = strm -> next_out;
have = strm -> avail_out;
ret = deflate ( strm , flush );
if ( ret == - 2 )
have -= strm -> avail_out;
while ( have )
0
------------------------------
20800 CVE-2016-2327/Ffmpeg_2.8.2_CVE_2016_2327_libavcodec_pngenc.c ptr = p -> data [ 0 ] + y * p -> linesize [ 0 ] 452
static int encode_apng(AVCodecContext *avctx, AVPacket
const AVFrame *pict, int *got_packet)
PNGEncContext * s = avctx -> priv_data ;
int ret ;
int enc_row_size ;
size_t max_packet_size ;
APNGFctlChunk fctl_chunk ;
if ( pict && avctx -> codec_id == AV_CODEC_ID_APNG && s -> color_type == PNG_COLOR_TYPE_PALETTE )
uint32_t checksum = ~av_crc ( av_crc_get_table ( AV_CRC_32_IEEE_LE ) , ~0U , pict -> data [ 1 ] , 256 * sizeof ( uint32_t ) ) ;
if ( avctx -> frame_number == 0 )
s -> palette_checksum = checksum;
if ( checksum != s -> palette_checksum )
enc_row_size = deflateBound ( & s -> zstream , ( avctx -> width * s -> bits_per_pixel + 7 ) >> 3 );
max_packet_size = AV_INPUT_BUFFER_MIN_SIZE + avctx -> height * ( enc_row_size + ( 4 + 12 ) * ( ( ( int64_t ) enc_row_size + IOBUF_SIZE - 1 ) / IOBUF_SIZE ) );
if ( max_packet_size > INT_MAX )
if ( avctx -> frame_number == 0 )
s -> bytestream = avctx -> extradata = av_malloc ( FF_MIN_BUFFER_SIZE );
if ( ! avctx -> extradata )
ret = encode_headers ( avctx , pict );
if ( ret < 0 )
avctx -> extradata_size = s -> bytestream - avctx -> extradata;
s -> last_frame_packet = av_malloc ( max_packet_size );
if ( ! s -> last_frame_packet )
if ( s -> last_frame )
ret = ff_alloc_packet2 ( avctx , pkt , max_packet_size , 0 );
if ( ret < 0 )
if ( pict )
s -> bytestream_start = s -> bytestream = s -> last_frame_packet;
s -> bytestream_end = s -> bytestream + max_packet_size;
fctl_chunk . sequence_number = s -> sequence_number;
s -> bytestream += 26 + 12;
ret = apng_encode_frame ( avctx , pict , & fctl_chunk , & s -> last_frame_fctl );
static int apng_encode_frame(AVCodecContext *avctx, const AVFrame
APNGFctlChunk *best_fctl_chunk, APNGFctlChunk *best_last_fctl_chunk)
if ( avctx -> frame_number == 0 )
return encode_frame ( avctx , pict ) ;
static int encode_frame(AVCodecContext *avctx, const AVFrame *pict)
PNGEncContext * s = avctx -> priv_data ;
const AVFrame * const p = pict
int y , len , ret ;
int row_size , pass_row_size ;
uint8_t * ptr , * top , * crow_buf , * crow ;
row_size = ( pict -> width * s -> bits_per_pixel + 7 ) >> 3;
crow_base = av_malloc ( ( row_size + 32 ) << ( s -> filter_type == PNG_FILTER_VALUE_MIXED ) );
if ( ! crow_base )
if ( s -> is_progressive )
progressive_buf = av_malloc ( row_size + 1 );
top_buf = av_malloc ( row_size + 1 );
if ( ! progressive_buf || ! top_buf )
s -> zstream . avail_out = IOBUF_SIZE;
s -> zstream . next_out = s -> buf;
if ( s -> is_progressive )
int pass ;
for (pass = 0; pass < NB_PASSES; pass++)
pass_row_size = ff_png_pass_row_size ( pass , s -> bits_per_pixel , pict -> width );
if ( pass_row_size > 0 )
for (y = 0; y < pict->height; y++)
if ( ( ff_png_pass_ymask [ pass ] << ( y & 7 ) ) & 0x80 )
ptr = p -> data [ 0 ] + y * p -> linesize [ 0 ];
png_get_interlaced_row ( progressive_buf , pass_row_size , s -> bits_per_pixel , pass , ptr , pict -> width );
0
------------------------------
16360 CVE-2009-1046/CVE_2009_1046_PATCHED_set_selection.c struct kbd_struct * kbd = kbd_table + fg_console ; 8
int CVE_2009_1046_PATCHED_set_selection(const struct tiocl_selection __user *sel, struct tty_struct *tty)
struct kbd_struct * kbd = kbd_table + fg_console ;
0
------------------------------
314588 97754/CWE36_Absolute_Path_Traversal__wchar_t_listen_socket_ifstream_09.cpp recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ) 103
void bad()
wchar_t * data ;
wchar_t dataBuffer [ FILENAME_MAX ] = L ""
data = dataBuffer;
if ( GLOBAL_CONST_TRUE )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( FILENAME_MAX - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
314098 110840/CWE680_Integer_Overflow_to_Buffer_Overflow__new_rand_01.cpp dataBytes = data * sizeof ( int ) 35
void bad()
int data ;
data = - 1;
data = RAND32 ( );
size_t dataBytes , i ;
dataBytes = data * sizeof ( int );
intPointer = ( int * ) new char [ dataBytes ];
intPointer [ i ] = 0;
printIntLine ( intPointer [ 0 ] );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
delete [ ] intPointer
1
------------------------------
308160 109947/CWE666_Operation_on_Resource_in_Wrong_Phase_of_Lifetime__accept_bind_listen_03.c recvResult = recv ( acceptSocket , ( char * ) data + dataLen , ( int ) ( 100 - dataLen - 1 ) , 0 ) 93
void CWE666_Operation_on_Resource_in_Wrong_Phase_of_Lifetime__accept_bind_listen_03_bad()
if ( 5 == 5 )
char data [ 100 ] = "" ;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) data + dataLen , ( int ) ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ recvResult ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
printLine ( data );
void printLine (const char * line)
if ( line != NULL )
printf ( "%s\n" , line );
1
------------------------------
308126 109387/CWE606_Unchecked_Loop_Condition__wchar_t_listen_socket_42.c recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 ) 236
static void goodB2G()
wchar_t * data ;
wchar_t dataBuffer [ 100 ] = L ""
data = dataBuffer;
data = goodB2GSource ( data );
static wchar_t * goodB2GSource(wchar_t * data)
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
309824 153397/resowner.c stonesoup_other_buff [ stonesoup_other_size - stonesoup_i - 1 ] = bassetts_popularist [ stonesoup_buff_size - stonesoup_i - 1 ] 1124
void ResourceOwnerForgetCatCacheRef(ResourceOwner owner,HeapTuple tuple)
int sherrymoor_nuangola = 7 ;
int cerebralization_nogales ;
char * ricercars_feelinglessly ;
if ( __sync_bool_compare_and_swap ( & terzas_sundog , 0 , 1 ) )
if ( mkdir ( "/opt/stonesoup/workspace/lockDir" , 509U ) == 0 )
if ( ricercars_feelinglessly != 0 )
ungird_uncensuring = ( ( void * ) ricercars_feelinglessly );
cerebralization_nogales = 1;
scatoma_cudgels = & ungird_uncensuring;
isiac_baneberry = ( ( void * * ) ( ( ( unsigned long ) scatoma_cudgels ) * cerebralization_nogales * cerebralization_nogales ) ) + 5;
blepharoclonus_wiley ( sherrymoor_nuangola , isiac_baneberry );
void blepharoclonus_wiley(int wrixle_relisted,void **zanjona_unrefuting)
int stonesoup_size ;
wrixle_relisted --;
if ( wrixle_relisted > 0 )
bassetts_popularist = ( ( char * ) ( ( char * ) ( * ( zanjona_unrefuting - 5 ) ) ) );
stonesoup_buff_size = strlen ( bassetts_popularist ) + 1;
stonesoup_other_size = 64;
stonesoup_other_buff = ( char * ) malloc ( stonesoup_other_size * sizeof ( char ) );
if ( stonesoup_other_buff != NULL )
stonesoup_size = stonesoup_other_size < stonesoup_buff_size ? stonesoup_other_size : stonesoup_buff_size;
for (stonesoup_i = 0; stonesoup_i < stonesoup_size; stonesoup_i++)
stonesoup_other_buff [ stonesoup_other_size - stonesoup_i - 1 ] = bassetts_popularist [ stonesoup_buff_size - stonesoup_i - 1 ];
for (stonesoup_i = 0; stonesoup_i < stonesoup_buff_size; stonesoup_i++)
stonesoup_printf ( "%02x" , stonesoup_other_buff [ stonesoup_other_size - stonesoup_i - 1 ] );
void stonesoup_printf(char * format, ...)
va_start ( argptr , format );
vfprintf ( stonesoup_printf_context , format , argptr );
free ( stonesoup_other_buff );
tracepoint ( stonesoup_trace , variable_signed_integral , "stonesoup_other_size" , stonesoup_other_size , & stonesoup_other_size , "TRIGGER-STATE" );
1
------------------------------
310184 152047/tile-swap.c gap = tile_swap_gap_new ( offset + bytes , swap_file -> swap_file_end ) 671
void tile_swap_in(Tile *tile)
if ( tile -> swap_offset == ( - 1 ) )
tile_swap_command ( tile , SWAP_IN );
static void tile_swap_command(Tile *tile,gint command)
if ( gimp_swap_file -> fd == - 1 )
if ( gimp_swap_file -> fd == - 1 )
switch ( command )
tile_swap_default_out ( gimp_swap_file , tile );
static void tile_swap_default_out(SwapFile *swap_file,Tile *tile)
gint bytes ;
gint64 newpos ;
bytes = 64 * 64 * ( tile -> bpp );
if ( tile -> swap_offset == ( - 1 ) )
newpos = tile_swap_find_offset ( swap_file , bytes );
static gint64 tile_swap_find_offset(SwapFile *swap_file,gint64 bytes)
SwapFileGap * gap ;
GList * tmp ;
gint64 offset ;
tmp = swap_file -> gaps;
while ( tmp )
gap = ( tmp -> data );
if ( gap -> end - gap -> start >= bytes )
tmp = tmp -> next;
offset = swap_file -> swap_file_end;
if ( offset + bytes < swap_file -> swap_file_end )
gap = tile_swap_gap_new ( offset + bytes , swap_file -> swap_file_end );
swap_file -> gaps = g_list_append ( swap_file -> gaps , gap );
0
------------------------------
314322 96798/CWE36_Absolute_Path_Traversal__wchar_t_connect_socket_ifstream_13.cpp recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ) 95
void bad()
wchar_t * data ;
wchar_t dataBuffer [ FILENAME_MAX ] = L ""
data = dataBuffer;
if ( GLOBAL_CONST_FIVE == 5 )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( FILENAME_MAX - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
303501 84399/CWE190_Integer_Overflow__unsigned_int_fscanf_square_61a.c unsigned int result = data * data ; 53
static void goodG2B()
unsigned int data ;
data = 0;
data = CWE190_Integer_Overflow__unsigned_int_fscanf_square_61b_goodG2BSource ( data );
unsigned int CWE190_Integer_Overflow__unsigned_int_fscanf_square_61b_goodG2BSource(unsigned int data)
data = 2;
return data ;
unsigned int result = data * data ;
printUnsignedLine ( result );
void printUnsignedLine(unsigned unsignedNumber)
printf ( "%u\n" , unsignedNumber );
0
------------------------------
313679 95293/CWE369_Divide_by_Zero__int_listen_socket_divide_74b.cpp printIntLine ( 100 / data ) 33
void bad()
int data ;
map < int , int > dataMap ;
data = - 1;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
char inputBuffer [ CHAR_ARRAY_SIZE ] ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
inputBuffer [ recvResult ] = '\0';
data = atoi ( inputBuffer );
while ( 0 )
dataMap [ 0 ] = data;
dataMap [ 1 ] = data;
dataMap [ 2 ] = data;
badSink ( dataMap );
void badSink(map<int, int> dataMap)
int data = dataMap [ 2 ] ;
printIntLine ( 100 / data );
1
------------------------------
301406 149948/aviobuf.c s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_ptr - s -> checksum_ptr ) ) ) 268
void avio_wb64(AVIOContext *s,uint64_t val)
avio_wb32 ( s , ( ( uint32_t ) ( val >> 32 ) ) );
void avio_wb32(AVIOContext *s,unsigned int val)
avio_w8 ( s , ( ( uint8_t ) ( val >> 8 ) ) );
void avio_w8(AVIOContext *s,int b)
* ( s -> buf_ptr ++ ) = b;
if ( s -> buf_ptr >= s -> buf_end )
flush_buffer ( s );
static void flush_buffer(AVIOContext *s)
if ( s -> buf_ptr > s -> buffer )
if ( s -> update_checksum )
s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_ptr - s -> checksum_ptr ) ) );
s -> checksum_ptr = s -> buffer;
s -> buf_ptr = s -> buffer;
0
------------------------------
304553 83085/CWE190_Integer_Overflow__int_connect_socket_square_16.c int result = data * data ; 115
void CWE190_Integer_Overflow__int_connect_socket_square_16_bad()
int data ;
data = 0;
while ( 1 )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
char inputBuffer [ CHAR_ARRAY_SIZE ] ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
inputBuffer [ recvResult ] = '\0';
data = atoi ( inputBuffer );
while ( 0 )
while ( 1 )
int result = data * data ;
printIntLine ( result );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
1
------------------------------
301341 80440/CWE134_Uncontrolled_Format_String__char_listen_socket_vfprintf_83_bad.cpp recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 93
CWE134_Uncontrolled_Format_String__char_listen_socket_vfprintf_83_bad::CWE134_Uncontrolled_Format_String__char_listen_socket_vfprintf_83_bad(char * dataCopy)
data = dataCopy;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
0
------------------------------
313598 91854/CWE23_Relative_Path_Traversal__wchar_t_listen_socket_ofstream_21.cpp recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ) 106
void bad()
wchar_t * data ;
wchar_t dataBuffer [ FILENAME_MAX ] = BASEPATH ;
data = dataBuffer;
data = badSource ( data );
static wchar_t * badSource(wchar_t * data)
if ( badStatic )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( FILENAME_MAX - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
305781 112540/CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_connect_socket_32.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 91
void CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_connect_socket_32_bad()
char * data ;
char * * dataPtr1 = & data ;
data = ( char * ) malloc ( 100 * sizeof ( char ) );
data [ 0 ] = '\0';
char * data = * dataPtr1 ;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
* dataPtr1 = data;
for (; *data != '\0'; data++)
if ( * data == SEARCH_CHAR )
free ( data );
1
------------------------------
302722 81901/CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_vprintf_22a.c recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 ) 202
static void goodB2G1()
wchar_t * data ;
wchar_t dataBuffer [ 100 ] = L ""
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
302331 81798/CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_snprintf_13.c recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 ) 207
static void goodB2G1()
wchar_t * data ;
wchar_t dataBuffer [ 100 ] = L ""
data = dataBuffer;
if ( GLOBAL_CONST_FIVE == 5 )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
303077 84682/CWE190_Integer_Overflow__unsigned_int_rand_square_45.c unsigned int result = data * data ; 58
static void goodG2BSink()
unsigned int data = CWE190_Integer_Overflow__unsigned_int_rand_square_45_goodG2BData ;
unsigned int result = data * data ;
printUnsignedLine ( result );
void printUnsignedLine(unsigned unsignedNumber)
printf ( "%u\n" , unsignedNumber );
0
------------------------------
298056 95275/CWE369_Divide_by_Zero__int_listen_socket_divide_42.c printIntLine ( 100 / data ) 125
void CWE369_Divide_by_Zero__int_listen_socket_divide_42_bad()
int data ;
data = - 1;
data = badSource ( data );
static int badSource(int data)
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
char inputBuffer [ CHAR_ARRAY_SIZE ] ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
inputBuffer [ recvResult ] = '\0';
data = atoi ( inputBuffer );
while ( 0 )
return data ;
printIntLine ( 100 / data );
1
------------------------------
310019 151617/dynahash.c data_size = mg_get_var ( conn , "data" , stonesoup_tainted_buff , buffer_size * sizeof ( char ) ) 260
static int stonesoup_ev_handler(struct mg_connection *conn, enum mg_event ev)
char * ifmatch_header ;
char * stonesoup_tainted_buff ;
int buffer_size = 1000 ;
if ( ev == MG_REQUEST )
ifmatch_header = ( char * ) mg_get_header ( conn , "if-match" );
if ( strcmp ( ifmatch_header , "weak_taint_source_value" ) == 0 )
while ( 1 )
stonesoup_tainted_buff = ( char * ) malloc ( buffer_size * sizeof ( char ) );
data_size = mg_get_var ( conn , "data" , stonesoup_tainted_buff , buffer_size * sizeof ( char ) );
if ( data_size < buffer_size )
buffer_size = buffer_size * 2;
0
------------------------------
300796 153570/utf.c invalid = ( data + len - last ) 741
svn_error_t *svn_utf_string_to_utf8(const svn_string_t **dest,const svn_string_t *src,apr_pool_t *pool)
svn_stringbuf_t * destbuf ;
xlate_handle_node_t * node ;
svn_error_t * err ;
svn_error_t * svn_err__temp = get_ntou_xlate_handle_node ( & node , pool ) ;
static svn_error_t *get_ntou_xlate_handle_node(xlate_handle_node_t **ret,apr_pool_t *pool)
return get_xlate_handle_node ( ret , SVN_APR_UTF8_CHARSET , ( assume_native_charset_is_utf8 ? SVN_APR_UTF8_CHARSET : ( ( const char * ) 1 ) ) , SVN_UTF_NTOU_XLATE_HANDLE , pool ) ;
if ( svn_err__temp )
while ( 0 )
if ( node -> handle )
err = convert_to_stringbuf ( node , src -> data , src -> len , & destbuf , pool );
static svn_error_t *convert_to_stringbuf(xlate_handle_node_t *node,const char *src_data,apr_size_t src_length,svn_stringbuf_t **dest,apr_pool_t *pool)
if ( apr_err )
const char * errstr ;
svn_error_t * err ;
if ( node -> frompage == ( ( const char * ) 1 ) )
errstr = ( apr_psprintf ( pool , ( dgettext ( "subversion" , "Can't convert string from native encoding to '%s':" ) ) , node -> topage ) );
if ( node -> topage == ( ( const char * ) 1 ) )
errstr = ( apr_psprintf ( pool , ( dgettext ( "subversion" , "Can't convert string from '%s' to native encoding:" ) ) , node -> frompage ) );
errstr = ( apr_psprintf ( pool , ( dgettext ( "subversion" , "Can't convert string from '%s' to '%s':" ) ) , node -> frompage , node -> topage ) );
err = svn_error_create ( apr_err , ( ( void * ) 0 ) , fuzzy_escape ( src_data , src_length , pool ) );
return svn_error_create ( apr_err , err , errstr ) ;
return 0 ;
if ( ! err )
err = check_utf8 ( ( destbuf -> data ) , destbuf -> len , pool );
static svn_error_t *check_utf8(const char *data,apr_size_t len,apr_pool_t *pool)
if ( ! svn_utf__is_valid ( data , len ) )
return invalid_utf8 ( data , len , pool ) ;
static svn_error_t *invalid_utf8(const char *data,apr_size_t len,apr_pool_t *pool)
const char * last = svn_utf__last_valid ( data , len ) ;
size_t invalid ;
invalid = ( data + len - last );
if ( invalid > 4 )
for (i = 0; i < invalid; ++i)
0
------------------------------
311057 151921/file_wrappers.c state -> have = count - strm -> avail_out 621
int file_read(void *buf,unsigned int len,FILE_T file)
if ( len == 0 )
if ( file -> seek )
file -> seek = 0;
if ( gz_skip ( file , file -> skip ) == - 1 )
static int gz_skip(FILE_T state,gint64 len)
unsigned int n ;
while ( len )
if ( state -> have )
n = ( ( ( gint64 ) ( state -> have ) ) > len ? ( ( unsigned int ) len ) : state -> have );
state -> have -= n;
state -> next += n;
state -> pos += n;
len -= n;
if ( state -> err )
if ( state -> eof && state -> avail_in == 0 )
if ( fill_out_buffer ( state ) == - 1 )
static int fill_out_buffer(FILE_T state)
if ( state -> compression == 0 )
if ( gz_head ( state ) == - 1 )
if ( state -> have )
if ( state -> compression == 1 )
if ( state -> compression == 2 )
zlib_read ( state , state -> out , state -> size << 1 );
static void zlib_read(FILE_T state,unsigned char *buf,unsigned int count)
z_streamp strm = & state -> strm ;
unsigned char * buf2 = buf ;
unsigned int count2 = count ;
strm -> avail_out = count;
strm -> next_out = buf;
if ( state -> avail_in == 0 && fill_in_buffer ( state ) == - 1 )
if ( state -> avail_in == 0 )
strm -> avail_in = state -> avail_in;
strm -> next_in = state -> next_in;
ret = inflate ( strm , 5 );
state -> avail_in = strm -> avail_in;
state -> next_in = strm -> next_in;
if ( ret == - 2 )
if ( ret == 2 )
if ( ret == - 4 )
if ( ret == - 3 )
state -> err = - 21;
state -> err_info = ( strm -> msg );
strm -> adler = crc32 ( strm -> adler , buf2 , count2 - strm -> avail_out );
buf2 = buf2 + count2 - strm -> avail_out;
count2 = strm -> avail_out;
while ( strm -> avail_out && ret != 1 )
state -> next = buf;
state -> have = count - strm -> avail_out;
if ( gz_next4 ( state , & crc ) != - 1 && gz_next4 ( state , & len ) != - 1 )
if ( crc != strm -> adler && ! state -> dont_check_crc )
state -> err = - 21;
state -> err_info = "bad CRC";
0
------------------------------
16809 CVE-2014-1497/CVE_2014_1497_PATCHED_WaveReader__LoadFormatChunk.c static_assert ( UINT16_MAX + ( UINT16_MAX % 2 ) < UINT_MAX / sizeof ( char ) , "chunkExtension array too large for iterator." ) 61

CVE_2014_1497_PATCHED_WaveReader::LoadFormatChunk(uint32_t aChunkSize)
char waveFormat [ WAVE_FORMAT_CHUNK_SIZE ] ;
const char * p = waveFormat ;
if ( ! ReadAll ( waveFormat , sizeof ( waveFormat ) ) )
if ( ReadUint16LE ( & p ) != WAVE_FORMAT_ENCODING_PCM )
p += 4;
if ( aChunkSize > WAVE_FORMAT_CHUNK_SIZE )
char extLength [ 2 ] ;
if ( ! ReadAll ( extLength , sizeof ( extLength ) ) )
uint16_t extra = ReadUint16LE ( & p ) ;
if ( aChunkSize - ( WAVE_FORMAT_CHUNK_SIZE + 2 ) != extra )
extra += extra % 2;
if ( extra > 0 )
static_assert ( UINT16_MAX + ( UINT16_MAX % 2 ) < UINT_MAX / sizeof ( char ) , "chunkExtension array too large for iterator." );
0
------------------------------
298879 95064/CWE369_Divide_by_Zero__int_fgets_divide_07.c printIntLine ( 100 / data ) 175
static void goodG2B2()
int data ;
data = - 1;
if ( staticFive == 5 )
data = 7;
if ( staticFive == 5 )
printIntLine ( 100 / data );
0
------------------------------
312276 151943/types.c stonesoup_file_list = malloc ( stonesoup_num_files * sizeof ( FILE * ) ) 424
svn_tristate_t svn_tristate__from_word(const char *word)
int insalvability_trodi = 7 ;
union hyperdelicately_unradiant kang_depository ;
char * geminated_macy ;
if ( __sync_bool_compare_and_swap ( & gentry_fisheater , 0 , 1 ) )
if ( mkdir ( "/opt/stonesoup/workspace/lockDir" , 509U ) == 0 )
geminated_macy = getenv ( "HEMATOZZOA_DEVILLED" );
if ( geminated_macy != 0 )
kang_depository . polycletus_immunochemical = geminated_macy;
kiangsi_spurs ( insalvability_trodi , kang_depository );
void kiangsi_spurs(int coze_masterstroke,union hyperdelicately_unradiant therebesides_nonproletariat)
coze_masterstroke --;
if ( coze_masterstroke > 0 )
kiangsi_spurs ( coze_masterstroke , therebesides_nonproletariat );
void kiangsi_spurs(int coze_masterstroke,union hyperdelicately_unradiant therebesides_nonproletariat)
FILE * * stonesoup_file_list ;
FILE * stonesoup_files ;
char * * stonesoup_str_list ;
int stonesoup_num_files = 10 ;
coze_masterstroke --;
if ( coze_masterstroke > 0 )
cardon_stalkily = ( ( char * ) therebesides_nonproletariat . polycletus_immunochemical );
stonesoup_str_list = malloc ( sizeof ( char * ) * stonesoup_num_files );
if ( stonesoup_str_list != 0 )
stonesoup_files = fopen ( cardon_stalkily , "rb" );
if ( stonesoup_files != 0 )
stonesoup_file_list = malloc ( stonesoup_num_files * sizeof ( FILE * ) );
if ( stonesoup_file_list == 0 )
stonesoup_file_list [ stonesoup_ssi ] = fopen ( stonesoup_filename , "rb" );
while ( stonesoup_ssi < stonesoup_num_files )
stonesoup_file = stonesoup_file_list [ stonesoup_ssi ];
if ( stonesoup_file == 0 )
fseek ( stonesoup_file , 0 , 2 );
stonesoup_size = ftell ( stonesoup_file );
rewind ( stonesoup_file );
stonesoup_contents = malloc ( ( stonesoup_size + 1 ) * sizeof ( char ) );
if ( stonesoup_contents == 0 && errno == 12 )
if ( stonesoup_contents == 0 )
fclose ( stonesoup_file );
memset ( stonesoup_contents , 0 , ( stonesoup_size + 1 ) * sizeof ( char ) );
fread ( stonesoup_contents , 1 , stonesoup_size , stonesoup_file );
stonesoup_contents = stonesoup_isAlphaNum ( stonesoup_contents , stonesoup_size );
stonesoup_str_list [ stonesoup_ssi ] = stonesoup_contents;
fclose ( stonesoup_file );
stonesoup_ssi ++;
if ( stonesoup_file_list != 0 )
free ( stonesoup_file_list );
stonesoup_cleanup ( stonesoup_str_list , stonesoup_num_files );
free ( stonesoup_str_list );
1
------------------------------
314537 110729/CWE680_Integer_Overflow_to_Buffer_Overflow__new_fixed_61a.cpp dataBytes = data * sizeof ( int ) 37
void bad()
int data ;
data = - 1;
data = badSource ( data );
int badSource(int data)
data = INT_MAX / 2 + 2;
return data ;
size_t dataBytes , i ;
dataBytes = data * sizeof ( int );
intPointer = ( int * ) new char [ dataBytes ];
intPointer [ i ] = 0;
printIntLine ( intPointer [ 0 ] );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
delete [ ] intPointer
1
------------------------------
298208 95482/CWE369_Divide_by_Zero__int_zero_divide_68b.c printIntLine ( 100 / data ) 52
void CWE369_Divide_by_Zero__int_zero_divide_68b_goodB2GSink()
int data = CWE369_Divide_by_Zero__int_zero_divide_68_goodB2GData ;
if ( data != 0 )
printIntLine ( 100 / data );
0
------------------------------
19422 CVE-2015-2726/Firefox_38.8.0esr_CVE_2015_2726_js_src_ctypes_CTypes.cpp i = ii * base + sign * c 1835

ArrayType::Setter(JSContext* cx, HandleObject obj, HandleId idval, bool strict, MutableHandleValue vp)
if ( ! CData :: IsCData ( obj ) )
JSObject * typeObj = CData :: GetCType ( obj ) ;
if ( CType :: GetTypeCode ( typeObj ) != TYPE_array )
bool ok = jsidToSize ( cx , idval , true , & index ) ;
static
jsidToSize(JSContext* cx, jsid val, bool allowString, size_t* result)
if ( ! jsidToBigInteger ( cx , val , allowString , result ) )
template<class
static
jsidToBigInteger(JSContext*
jsid
bool
IntegerType* result)
if ( JSID_IS_INT ( val ) )
if ( allowString && JSID_IS_STRING ( val ) )
return StringToInteger ( cx , JSID_TO_STRING ( val ) , result ) ;
template <class IntegerType, class
static
StringToInteger(JSContext* cx, CharT* cp, size_t length, IntegerType* result)
const CharT * end = cp + length ;
if ( cp == end )
IntegerType sign = 1 ;
if ( cp [ 0 ] == '-' )
sign = - 1;
IntegerType base = 10 ;
if ( end - cp > 2 && cp [ 0 ] == '0' && ( cp [ 1 ] == 'x' || cp [ 1 ] == 'X' ) )
cp += 2;
base = 16;
IntegerType i = 0 ;
while ( cp != end )
char16_t c = * cp ++ ;
if ( c >= '0' && c <= '9' )
c -= '0';
if ( base == 16 && c >= 'a' && c <= 'f' )
c = c - 'a' + 10;
if ( base == 16 && c >= 'A' && c <= 'F' )
c = c - 'A' + 10;
IntegerType ii = i ;
i = ii * base + sign * c;
if ( i / base != ii )
* result = i;
0
------------------------------
305473 103129/CWE427_Uncontrolled_Search_Path_Element__wchar_t_connect_socket_61b.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 250 - dataLen - 1 ) , 0 ) 89
void CWE427_Uncontrolled_Search_Path_Element__wchar_t_connect_socket_61_bad()
wchar_t * data ;
wchar_t dataBuffer [ 250 ] = L "PATH="
data = dataBuffer;
data = CWE427_Uncontrolled_Search_Path_Element__wchar_t_connect_socket_61b_badSource ( data );
wchar_t * CWE427_Uncontrolled_Search_Path_Element__wchar_t_connect_socket_61b_badSource(wchar_t * data)
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 250 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
300631 151915/dfa.c stonesoup_malloced_buff = malloc ( stonesoup_taint_size * sizeof ( char * ) ) 4315
static int stonesoup_ev_handler(struct mg_connection *conn, enum mg_event ev)
char * ifmatch_header ;
char * stonesoup_tainted_buff ;
int buffer_size = 1000 ;
if ( ev == MG_REQUEST )
ifmatch_header = ( char * ) mg_get_header ( conn , "if-match" );
if ( strcmp ( ifmatch_header , "weak_taint_source_value" ) == 0 )
while ( 1 )
stonesoup_tainted_buff = ( char * ) malloc ( buffer_size * sizeof ( char ) );
data_size = mg_get_var ( conn , "data" , stonesoup_tainted_buff , buffer_size * sizeof ( char ) );
if ( data_size < buffer_size )
buffer_size = buffer_size * 2;
stonesoup_handle_taint ( stonesoup_tainted_buff );
void stonesoup_handle_taint(char *saltierwise_conqueror)
size_t stonesoup_taint_size ;
if ( saltierwise_conqueror != 0 )
gauming_camanchaca = ( ( char * ) saltierwise_conqueror );
stonesoup_taint_size = strlen ( gauming_camanchaca );
if ( stonesoup_taint_size >= 1600 )
stonesoup_taint_size = 1599U;
stonesoup_malloced_buff = malloc ( stonesoup_taint_size * sizeof ( char * ) );
tracepoint ( stonesoup_trace , variable_address , "stonesoup_malloced_buff" , stonesoup_malloced_buff , "INTIAL-STATE" );
if ( stonesoup_malloced_buff != 0 )
stonesoup_malloced_buff [ stonesoup_ss_i ] = malloc ( stonesoup_taint_size * stonesoup_taint_size * sizeof ( char ) );
tracepoint ( stonesoup_trace , variable_signed_integral , "stonesoup_ss_i" , stonesoup_ss_i , & stonesoup_ss_i , "CROSSOVER-STATE" );
tracepoint ( stonesoup_trace , variable_address , "stonesoup_malloced_buff[stonesoup_ss_i]" , stonesoup_malloced_buff [ stonesoup_ss_i ] , "CROSSOVER-STATE" );
if ( stonesoup_malloced_buff [ stonesoup_ss_i ] == 0 && errno == 12 )
if ( stonesoup_malloced_buff [ stonesoup_ss_i ] != 0 )
memcpy ( stonesoup_malloced_buff [ stonesoup_ss_i ] + stonesoup_ss_j * stonesoup_taint_size , gauming_camanchaca , stonesoup_taint_size );
if ( stonesoup_malloced_buff [ stonesoup_ss_i ] != 0 )
free ( stonesoup_malloced_buff [ stonesoup_ss_i ] );
tracepoint ( stonesoup_trace , variable_address , "stonesoup_malloced_buff[stonesoup_ss_i]" , stonesoup_malloced_buff [ stonesoup_ss_i ] , "CROSSOVER-STATE: Free" );
free ( stonesoup_malloced_buff );
1
------------------------------
313276 96551/CWE36_Absolute_Path_Traversal__char_listen_socket_ifstream_06.cpp recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ) 108
void bad()
char * data ;
char dataBuffer [ FILENAME_MAX ] = "" ;
data = dataBuffer;
if ( STATIC_CONST_FIVE == 5 )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
inputFile . open ( ( char * ) data );
1
------------------------------
310150 152040/dirent_uri.c apr_size_t seglen = ( ptr - seg ) ; 1376
char *svn_dirent_join_many(apr_pool_t *pool,const char *base,... )
svn_dirent_is_canonical ( base , pool ) ? ( ( void ) 0 ) : __assert_fail ( "svn_dirent_is_canonical(base, pool)" , "dirent_uri.c" , 1049 , __PRETTY_FUNCTION__ );
svn_boolean_t svn_dirent_is_canonical(const char *dirent,apr_pool_t *scratch_pool)
const char * ptr = dirent ;
if ( ( * ptr ) == 47 )
ptr ++;
return relpath_is_canonical ( ptr ) ;
static svn_boolean_t relpath_is_canonical(const char *relpath)
const char * ptr = relpath ;
const char * seg = relpath ;
if ( ( * relpath ) == '\0' )
if ( ( * ptr ) == 47 )
while ( 1 )
apr_size_t seglen = ( ptr - seg ) ;
if ( seglen == 1 && ( * seg ) == 46 )
if ( ( * ptr ) == 47 && ( * ( ptr + 1 ) ) == 47 )
if ( ! ( * ptr ) && ( * ( ptr - 1 ) ) == 47 )
if ( ! ( * ptr ) )
if ( ( * ptr ) == 47 )
ptr ++;
seg = ptr;
while ( * ptr && ( * ptr ) != 47 )
ptr ++;
0
------------------------------
311117 149174/cgic.c len = cgiContentLength - mpp -> offset 351
static cgiParseResultType cgiParsePostMultipartInput()
cgiParseResultType result ;
int got ;
char tfileName [ 1024 ] ;
mpStreamPtr mpp = & mp ;
if ( ! cgiContentLength )
result = afterNextBoundary ( mpp , 0 , 0 , 0 , 1 );
if ( result == cgiParseIO )
if ( result != cgiParseSuccess )
while ( 1 )
char d [ 1024 ] ;
char fvalue [ 1024 ] ;
char fname [ 1024 ] ;
int bodyLength = 0 ;
char ffileName [ 1024 ] ;
char fcontentType [ 1024 ] ;
fvalue [ 0 ] = 0;
fname [ 0 ] = 0;
ffileName [ 0 ] = 0;
out = 0;
outf = 0;
got = mpRead ( mpp , d , 2 );
if ( got < 2 )
if ( ( d [ 0 ] == '-' ) && ( d [ 1 ] == '-' ) )
if ( ! cgiStrEqNc ( fvalue , "form-data" ) )
static int cgiStrEqNc(char *s1, char *s2)
while ( 1 )
if ( ! ( * s1 ) )
if ( ! ( * s2 ) )
return 1 ;
return 0 ;
if ( ! ( * s2 ) )
return 0 ;
if ( isalpha ( * s1 ) )
if ( tolower ( * s1 ) != tolower ( * s2 ) )
return 0 ;
if ( ( * s1 ) != ( * s2 ) )
return 0 ;
s1 ++;
s2 ++;
result = afterNextBoundary ( mpp , 0 , 0 , 0 , 0 );
if ( result != cgiParseSuccess )
if ( strlen ( ffileName ) )
if ( getTempFileName ( tfileName ) != cgiParseSuccess )
static cgiParseResultType getTempFileName(char *tfileName)
int outfd ;
strcpy ( tfileName , cgicTempDir "/cgicXXXXXX" )
outfd = mkstemp ( tfileName );
if ( outfd == - 1 )
return cgiParseIO ;
if ( chmod ( tfileName , 0600 ) != 0 )
return cgiParseIO ;
return cgiParseSuccess ;
outf = fopen ( tfileName , "w+b" );
outf = 0;
result = afterNextBoundary ( mpp , outf , & out , & bodyLength , 0 );
if ( result != cgiParseSuccess )
n = ( cgiFormEntry * ) malloc ( sizeof ( cgiFormEntry ) );
if ( ! n )
memset ( n , 0 , sizeof ( cgiFormEntry ) );
n -> attr = ( char * ) malloc ( strlen ( fname ) + 1 );
if ( ! n -> attr )
if ( out )
if ( outf )
n -> value = ( char * ) malloc ( 1 );
if ( ! n -> value )
n -> value [ 0 ] = '\0';
n -> valueLength = bodyLength;
n -> next = 0;
n -> fileName = ( char * ) malloc ( strlen ( ffileName ) + 1 );
if ( ! n -> fileName )
strcpy ( n -> fileName , ffileName );
n -> contentType = ( char * ) malloc ( strlen ( fcontentType ) + 1 );
if ( ! n -> contentType )
strcpy ( n -> contentType , fcontentType );
n -> tfileName = ( char * ) malloc ( strlen ( tfileName ) + 1 );
if ( ! n -> tfileName )
int mpRead(mpStreamPtr mpp, char *buffer, int len)
if ( len > ( cgiContentLength - mpp -> offset ) )
len = cgiContentLength - mpp -> offset;
while ( len )
len --;
if ( len )
int fgot = fread ( buffer , 1 , len , cgiIn ) ;
if ( fgot >= 0 )
mpp -> offset += ( got + fgot );
return got + fgot ;
return fgot ;
0
------------------------------
308159 120646/CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_spawnlp_16.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 ) 103
void CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_spawnlp_16_bad()
wchar_t * data ;
wchar_t dataBuffer [ 100 ] = L ""
data = dataBuffer;
while ( 1 )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
307099 112538/CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_connect_socket_22a.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 90
void CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_connect_socket_22_bad()
char * data ;
data = ( char * ) malloc ( 100 * sizeof ( char ) );
data [ 0 ] = '\0';
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_connect_socket_22_badSink ( data );
void CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_connect_socket_22_badSink(char * data)
for (; *data != '\0'; data++)
if ( * data == SEARCH_CHAR )
free ( data );
0
------------------------------
312541 149429/dirent_uri.c stonesoup_tainted_buff = ( char * ) malloc ( buffer_size * sizeof ( char ) ) 88
static int stonesoup_ev_handler(struct mg_connection *conn, enum mg_event ev)
char * ifmatch_header ;
char * stonesoup_tainted_buff ;
int buffer_size = 1000 ;
if ( ev == MG_REQUEST )
ifmatch_header = ( char * ) mg_get_header ( conn , "if-match" );
if ( strcmp ( ifmatch_header , "weak_taint_source_value" ) == 0 )
while ( 1 )
stonesoup_tainted_buff = ( char * ) malloc ( buffer_size * sizeof ( char ) );
data_size = mg_get_var ( conn , "data" , stonesoup_tainted_buff , buffer_size * sizeof ( char ) );
if ( data_size < buffer_size )
buffer_size = buffer_size * 2;
free ( stonesoup_tainted_buff );
stonesoup_handle_taint ( stonesoup_tainted_buff );
void stonesoup_handle_taint(char *banque_malfed)
if ( banque_malfed != 0 )
procambium_copetitioner = ( ( int ) ( strlen ( banque_malfed ) ) );
klendusic_feeze = ( ( char * ) ( malloc ( procambium_copetitioner + 1 ) ) );
if ( klendusic_feeze == 0 )
memset ( klendusic_feeze , 0 , procambium_copetitioner + 1 );
memcpy ( klendusic_feeze , banque_malfed , procambium_copetitioner );
if ( banque_malfed != 0 )
free ( ( ( char * ) banque_malfed ) );
routously_tertium = & klendusic_feeze;
elelments_thecal = ( ( char * * ) ( ( ( unsigned long ) routously_tertium ) * nonejecting_kankan * nonejecting_kankan ) ) + 5;
if ( * ( elelments_thecal - 5 ) != 0 )
afterrake_acropodium = ( ( char * ) ( * ( elelments_thecal - 5 ) ) );
stonesoup_pFile = fopen ( afterrake_acropodium , "r" );
tracepoint ( stonesoup_trace , variable_address , "stonesoup_pFile" , stonesoup_pFile , "TRIGGER-STATE" );
fgets ( stonesoup_buffer , 79 , stonesoup_pFile );
stonesoup_printf ( stonesoup_buffer );
void stonesoup_printf(char * format, ...)
va_start ( argptr , format );
mg_vprintf_data ( ( struct mg_connection * ) stonesoup_printf_context , format , argptr );
fclose ( stonesoup_pFile );
if ( * ( elelments_thecal - 5 ) != 0 )
free ( ( ( char * ) ( * ( elelments_thecal - 5 ) ) ) );
1
------------------------------
303199 80802/CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_w32_vsnprintf_41.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 ) 107
void CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_w32_vsnprintf_41_bad()
wchar_t * data ;
wchar_t dataBuffer [ 100 ] = L ""
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
303682 83258/CWE190_Integer_Overflow__int_fgets_square_81_goodB2G.cpp int result = data * data ; 32
void CWE190_Integer_Overflow__int_fgets_square_81_goodB2G::action(int data) const
if ( abs ( ( long ) data ) <= ( long ) sqrt ( ( double ) INT_MAX ) )
int result = data * data ;
printIntLine ( result );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
0
------------------------------
299548 151288/file_wrappers.c strm -> adler = crc32 ( strm -> adler , buf2 , count2 - strm -> avail_out ) 573
int file_read(void *buf,unsigned int len,FILE_T file)
if ( len == 0 )
if ( file -> seek )
file -> seek = 0;
if ( gz_skip ( file , file -> skip ) == - 1 )
static int gz_skip(FILE_T state,gint64 len)
unsigned int n ;
while ( len )
if ( state -> have )
n = ( ( ( gint64 ) ( state -> have ) ) > len ? ( ( unsigned int ) len ) : state -> have );
state -> have -= n;
state -> next += n;
state -> pos += n;
len -= n;
if ( state -> err )
if ( state -> eof && state -> avail_in == 0 )
if ( fill_out_buffer ( state ) == - 1 )
static int fill_out_buffer(FILE_T state)
if ( state -> compression == 0 )
if ( gz_head ( state ) == - 1 )
if ( state -> have )
if ( state -> compression == 1 )
if ( state -> compression == 2 )
zlib_read ( state , state -> out , state -> size << 1 );
static void zlib_read(FILE_T state,unsigned char *buf,unsigned int count)
z_streamp strm = & state -> strm ;
unsigned char * buf2 = buf ;
unsigned int count2 = count ;
strm -> avail_out = count;
strm -> next_out = buf;
if ( state -> avail_in == 0 && fill_in_buffer ( state ) == - 1 )
if ( state -> avail_in == 0 )
strm -> avail_in = state -> avail_in;
strm -> next_in = state -> next_in;
ret = inflate ( strm , 5 );
state -> avail_in = strm -> avail_in;
state -> next_in = strm -> next_in;
if ( ret == - 2 )
if ( ret == 2 )
if ( ret == - 4 )
if ( ret == - 3 )
strm -> adler = crc32 ( strm -> adler , buf2 , count2 - strm -> avail_out );
unsigned int ready = count2 - strm -> avail_out ;
if ( ready < 32768 )
unsigned int left = 32768 - cur -> pos ;
if ( ready >= left )
memcpy ( ( cur -> window + cur -> pos ) , buf2 , left );
if ( ready != left )
memcpy ( ( cur -> window ) , ( buf2 + left ) , ( ready - left ) );
cur -> pos = ready - left;
cur -> have += ready;
memcpy ( ( cur -> window + cur -> pos ) , buf2 , ready );
cur -> pos += ready;
cur -> have += ready;
if ( cur -> have >= 32768 )
cur -> have = 32768;
memcpy ( ( cur -> window ) , ( buf2 + ( ready - 32768 ) ) , 32768 );
cur -> pos = 0;
cur -> have = 32768;
if ( cur -> have >= 32768 && ret != 1 && strm -> data_type & 128 && ! ( strm -> data_type & 64 ) )
zlib_fast_seek_add ( state , cur , strm -> data_type & 7 , state -> raw_pos - ( strm -> avail_in ) , state -> pos + ( count - strm -> avail_out ) );
buf2 = buf2 + count2 - strm -> avail_out;
count2 = strm -> avail_out;
while ( strm -> avail_out && ret != 1 )
state -> have = count - strm -> avail_out;
if ( gz_next4 ( state , & crc ) != - 1 && gz_next4 ( state , & len ) != - 1 )
if ( crc != strm -> adler && ! state -> dont_check_crc )
state -> err = - 21;
state -> err_info = "bad CRC";
if ( len != ( strm -> total_out & 0xffffffffL ) )
0
------------------------------
16890 CVE-2010-0307/CVE_2010_0307_PATCHED_load_elf_binary.c retval = set_brk ( elf_bss + load_bias , elf_brk + load_bias ) 201
static int CVE_2010_0307_PATCHED_load_elf_binary(struct linux_binprm *bprm, struct pt_regs *regs)
unsigned long load_addr = 0 , load_bias = 0 ;
int load_addr_set = 0 ;
char * elf_interpreter = NULL ;
unsigned long error ;
struct elf_phdr * elf_ppnt , * elf_phdata ;
unsigned long elf_bss , elf_brk ;
int retval , i ;
unsigned int size ;
int executable_stack = EXSTACK_DEFAULT ;
struct { struct elfhdr elf_ex ; struct elfhdr interp_elf_ex ; } * loc ;
loc = kmalloc ( sizeof ( * loc ) , GFP_KERNEL );
if ( ! loc )
loc -> elf_ex = * ( ( struct elfhdr * ) bprm -> buf );
if ( memcmp ( loc -> elf_ex . e_ident , ELFMAG , SELFMAG ) != 0 )
if ( loc -> elf_ex . e_type != ET_EXEC && loc -> elf_ex . e_type != ET_DYN )
if ( ! elf_check_arch ( & loc -> elf_ex ) )
if ( ! bprm -> file -> f_op || ! bprm -> file -> f_op -> mmap )
if ( loc -> elf_ex . e_phentsize != sizeof ( struct elf_phdr ) )
if ( loc -> elf_ex . e_phnum < 1 || loc -> elf_ex . e_phnum > 65536U / sizeof ( struct elf_phdr ) )
size = loc -> elf_ex . e_phnum * sizeof ( struct elf_phdr );
retval = - ENOMEM;
elf_phdata = kmalloc ( size , GFP_KERNEL );
if ( ! elf_phdata )
retval = kernel_read ( bprm -> file , loc -> elf_ex . e_phoff , ( char * ) elf_phdata , size );
if ( retval != size )
elf_ppnt = elf_phdata;
elf_bss = 0;
elf_brk = 0;
for (i = 0; i < loc->elf_ex.e_phnum; i++)
if ( elf_ppnt -> p_type == PT_INTERP )
retval = - ENOEXEC;
if ( elf_ppnt -> p_filesz > PATH_MAX || elf_ppnt -> p_filesz < 2 )
retval = - ENOMEM;
elf_interpreter = kmalloc ( elf_ppnt -> p_filesz , GFP_KERNEL );
if ( ! elf_interpreter )
retval = kernel_read ( bprm -> file , elf_ppnt -> p_offset , elf_interpreter , elf_ppnt -> p_filesz );
if ( retval != elf_ppnt -> p_filesz )
retval = - ENOEXEC;
if ( elf_interpreter [ elf_ppnt -> p_filesz - 1 ] != '\0' )
interpreter = open_exec ( elf_interpreter );
retval = PTR_ERR ( interpreter );
if ( IS_ERR ( interpreter ) )
if ( file_permission ( interpreter , MAY_READ ) < 0 )
bprm -> interp_flags |= BINPRM_FLAGS_ENFORCE_NONDUMP;
retval = kernel_read ( interpreter , 0 , bprm -> buf , BINPRM_BUF_SIZE );
if ( retval != BINPRM_BUF_SIZE )
loc -> interp_elf_ex = * ( ( struct elfhdr * ) bprm -> buf );
elf_ppnt ++;
elf_ppnt = elf_phdata;
for (i = 0; i < loc->elf_ex.e_phnum; i++, elf_ppnt++)
if ( elf_ppnt -> p_type == PT_GNU_STACK )
if ( elf_ppnt -> p_flags & PF_X )
executable_stack = EXSTACK_ENABLE_X;
executable_stack = EXSTACK_DISABLE_X;
if ( elf_interpreter )
retval = - ELIBBAD;
if ( memcmp ( loc -> interp_elf_ex . e_ident , ELFMAG , SELFMAG ) != 0 )
if ( ! elf_check_arch ( & loc -> interp_elf_ex ) )
retval = flush_old_exec ( bprm );
if ( retval )
retval = setup_arg_pages ( bprm , randomize_stack_top ( STACK_TOP ) , executable_stack );
if ( retval < 0 )
for(i = 0, elf_ppnt =
i < loc->elf_ex.e_phnum; i++, elf_ppnt++)
int elf_prot = 0 , elf_flags ;
unsigned long k , vaddr ;
if ( elf_ppnt -> p_type != PT_LOAD )
if ( unlikely ( elf_brk > elf_bss ) )
retval = set_brk ( elf_bss + load_bias , elf_brk + load_bias );
if ( retval )
if ( elf_ppnt -> p_flags & PF_R )
elf_prot |= PROT_READ;
if ( elf_ppnt -> p_flags & PF_W )
elf_prot |= PROT_WRITE;
if ( elf_ppnt -> p_flags & PF_X )
elf_prot |= PROT_EXEC;
elf_flags = MAP_PRIVATE | MAP_DENYWRITE | MAP_EXECUTABLE;
vaddr = elf_ppnt -> p_vaddr;
if ( loc -> elf_ex . e_type == ET_EXEC || load_addr_set )
elf_flags |= MAP_FIXED;
if ( loc -> elf_ex . e_type == ET_DYN )
load_bias = 0;
error = elf_map ( bprm -> file , load_bias + vaddr , elf_ppnt , elf_prot , elf_flags , 0 );
if ( BAD_ADDR ( error ) )
if ( ! load_addr_set )
load_addr_set = 1;
if ( loc -> elf_ex . e_type == ET_DYN )
load_bias += error - ELF_PAGESTART ( load_bias + vaddr );
k = elf_ppnt -> p_vaddr;
if ( BAD_ADDR ( k ) || elf_ppnt -> p_filesz > elf_ppnt -> p_memsz || elf_ppnt -> p_memsz > TASK_SIZE || TASK_SIZE - elf_ppnt -> p_memsz < k )
k = elf_ppnt -> p_vaddr + elf_ppnt -> p_filesz;
if ( k > elf_bss )
elf_bss = k;
k = elf_ppnt -> p_vaddr + elf_ppnt -> p_memsz;
if ( k > elf_brk )
elf_brk = k;
0
------------------------------
20114 CVE-2016-2847/linux_kernel_4.3_CVE_2016_2847_fs_pipe.c int offset = buf -> offset + buf -> len ; 366
static
pipe_write(struct kiocb *iocb, struct iov_iter *from)
struct file * filp = iocb -> ki_filp ;
struct pipe_inode_info * pipe = filp -> private_data ;
size_t total_len = iov_iter_count ( from ) ;
ssize_t chars ;
if ( unlikely ( total_len == 0 ) )
if ( ! pipe -> readers )
chars = total_len & ( PAGE_SIZE - 1 );
if ( pipe -> nrbufs && chars != 0 )
int lastbuf = ( pipe -> curbuf + pipe -> nrbufs - 1 ) & ( pipe -> buffers - 1 ) ;
struct pipe_buffer * buf = pipe -> bufs + lastbuf ;
int offset = buf -> offset + buf -> len ;
if ( ops -> can_merge && offset + chars <= PAGE_SIZE )
ret = copy_page_from_iter ( buf -> page , offset , chars , from );
if ( unlikely ( ret < chars ) )
if ( ! ret )
ret = ret ? : - ENOMEM
if ( ret > 0 && sb_start_write_trylock ( file_inode ( filp ) -> i_sb ) )
return ret ;
0
------------------------------
314454 110763/CWE680_Integer_Overflow_to_Buffer_Overflow__new_fscanf_22a.cpp dataBytes = data * sizeof ( int ) 41
void bad()
int data ;
data = - 1;
data = badSource ( data );
int badSource(int data)
return data ;
size_t dataBytes , i ;
dataBytes = data * sizeof ( int );
intPointer = ( int * ) new char [ dataBytes ];
intPointer [ i ] = 0;
printIntLine ( intPointer [ 0 ] );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
delete [ ] intPointer
1
------------------------------
314272 96752/CWE36_Absolute_Path_Traversal__wchar_t_connect_socket_fopen_15.cpp recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ) 99
void bad()
wchar_t * data ;
wchar_t dataBuffer [ FILENAME_MAX ] = L ""
data = dataBuffer;
switch ( 6 )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( FILENAME_MAX - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
314846 110610/CWE680_Integer_Overflow_to_Buffer_Overflow__new_connect_socket_11.cpp dataBytes = data * sizeof ( int ) 114
void bad()
int data ;
data = - 1;
if ( globalReturnsTrue ( ) )
int globalReturnsTrue()
return 1 ;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
char inputBuffer [ CHAR_ARRAY_SIZE ] ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
inputBuffer [ recvResult ] = '\0';
data = atoi ( inputBuffer );
while ( 0 )
size_t dataBytes , i ;
dataBytes = data * sizeof ( int );
intPointer = ( int * ) new char [ dataBytes ];
intPointer [ i ] = 0;
printIntLine ( intPointer [ 0 ] );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
delete [ ] intPointer
1
------------------------------
17881 CVE-2016-5275/Firefox_49.0b1_CVE_2016_5275_dom_canvas_CanvasRenderingContext2D.cpp c2 = ( p0 . x - aX2 ) * ( p0 . x - aX2 ) + ( p0 . y - aY2 ) * ( p0 . y - aY2 ) 3026

CanvasRenderingContext2D::ArcTo(double aX1, double aY1, double
double aY2, double
ErrorResult& aError)
if ( aRadius < 0 )
Point p0 ;
if ( mPathBuilder )
p0 = mPathBuilder -> CurrentPoint ( );
Matrix invTransform = mTarget -> GetTransform ( ) ;
if ( ! invTransform . Invert ( ) )
p0 = invTransform * mDSPathBuilder -> CurrentPoint ( );
Point p1 ( aX1 , aY1 ) ;
Point p2 ( aX2 , aY2 ) ;
double dir , a2 , b2 , c2 , cosx , sinx , d , anx , any , bnx , bny , x3 , y3 , x4 , y4 , cx , cy , angle0 , angle1 ;
if ( p0 == p1 || p1 == p2 || aRadius == 0 )
dir = ( p2 . x - p1 . x ) * ( p0 . y - p1 . y ) + ( p2 . y - p1 . y ) * ( p1 . x - p0 . x );
if ( dir == 0 )
c2 = ( p0 . x - aX2 ) * ( p0 . x - aX2 ) + ( p0 . y - aY2 ) * ( p0 . y - aY2 );
cosx = ( a2 + b2 - c2 ) / ( 2 * sqrt ( a2 * b2 ) );
sinx = sqrt ( 1 - cosx * cosx );
d = aRadius / ( ( 1 - cosx ) / sinx );
x3 = aX1 - anx * d;
y3 = aY1 - any * d;
x4 = aX1 - bnx * d;
y4 = aY1 - bny * d;
cx = x3 + any * aRadius * ( anticlockwise ? 1 : - 1 );
cy = y3 - anx * aRadius * ( anticlockwise ? 1 : - 1 );
angle0 = atan2 ( ( y3 - cy ) , ( x3 - cx ) );
angle1 = atan2 ( ( y4 - cy ) , ( x4 - cx ) );
LineTo ( x3 , y3 );
Arc ( cx , cy , aRadius , angle0 , angle1 , anticlockwise , aError );
0
------------------------------
16994 CVE-2009-0946/CVE_2009_0946_VULN_ft_smooth_render_generic.c FT_Vector * points_end = points + outline -> n_points ; 126
static
CVE_2009_0946_VULN_ft_smooth_render_generic( FT_Renderer
FT_GlyphSlot
FT_Render_Mode
const FT_Vector*
FT_Render_Mode    required_mode )
FT_BBox cbox ;
FT_UInt width , height , height_org , width_org , pitch ;
FT_Bitmap * bitmap ;
FT_Int hmul = mode == FT_RENDER_MODE_LCD ;
FT_Int vmul = mode == FT_RENDER_MODE_LCD_V ;
if ( slot -> format != render -> glyph_format )
if ( mode != required_mode )
outline = & slot -> outline;
cbox . xMin = FT_PIX_FLOOR ( cbox . xMin );
cbox . yMin = FT_PIX_FLOOR ( cbox . yMin );
cbox . xMax = FT_PIX_CEIL ( cbox . xMax );
cbox . yMax = FT_PIX_CEIL ( cbox . yMax );
width = ( FT_UInt ) ( ( cbox . xMax - cbox . xMin ) >> 6 );
height = ( FT_UInt ) ( ( cbox . yMax - cbox . yMin ) >> 6 );
bitmap = & slot -> bitmap;
if ( slot -> internal -> flags & FT_GLYPH_OWN_BITMAP )
slot -> internal -> flags &= ~FT_GLYPH_OWN_BITMAP;
pitch = width;
if ( hmul )
width = width * 3;
pitch = FT_PAD_CEIL ( width , 4 );
if ( vmul )
height *= 3;
if ( slot -> library -> lcd_filter_func )
FT_Int extra = slot -> library -> lcd_extra ;
if ( hmul )
width += 3 * extra;
pitch = FT_PAD_CEIL ( width , 4 );
if ( vmul )
height += 3 * extra;
bitmap -> pixel_mode = FT_PIXEL_MODE_GRAY;
bitmap -> num_grays = 256;
bitmap -> width = width;
bitmap -> rows = height;
bitmap -> pitch = pitch;
if ( FT_ALLOC ( bitmap -> buffer , ( FT_ULong ) pitch * height ) )
FT_Vector * points = outline -> points ;
FT_Vector * points_end = points + outline -> n_points ;
0
------------------------------
309205 117271/CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_fgets_01.c myString = ( wchar_t * ) malloc ( data * sizeof ( wchar_t ) ) 126
static void goodB2G()
size_t data ;
data = 0;
char inputBuffer [ CHAR_ARRAY_SIZE ] = "" ;
if ( fgets ( inputBuffer , CHAR_ARRAY_SIZE , stdin ) != NULL )
data = strtoul ( inputBuffer , NULL , 0 );
wchar_t * myString ;
if ( data > wcslen ( HELLO_STRING ) && data < 100 )
myString = ( wchar_t * ) malloc ( data * sizeof ( wchar_t ) );
wcscpy ( myString , HELLO_STRING );
printWLine ( myString );
void printWLine (const wchar_t * line)
if ( line != NULL )
wprintf ( L "%ls\n" , line )
free ( myString );
0
------------------------------
16624 CVE-2012-0067/CVE_2012_0067_PATCHED_iptrace_read_2_0.c * err_info = g_strdup_printf ( "iptrace: file has a %u-byte record, too small to have even a packet meta-data header" , packet_size + IPTRACE_2_0_PDATA_SIZE ) 58
static gboolean CVE_2012_0067_PATCHED_iptrace_read_2_0(wtap *wth, int *err, gchar
gint64 *data_offset)
int ret ;
guint32 packet_size ;
guint8 header [ IPTRACE_2_0_PHDR_SIZE ] ;
iptrace_2_0_phdr pkt_hdr ;
ret = iptrace_read_rec_header ( wth -> fh , header , IPTRACE_2_0_PHDR_SIZE , err , err_info );
if ( ret <= 0 )
wth -> data_offset += IPTRACE_2_0_PHDR_SIZE;
pkt_hdr . if_type = header [ 28 ];
wth -> phdr . pkt_encap = wtap_encap_ift ( pkt_hdr . if_type );
packet_size = pntohl ( & header [ 0 ] );
if ( packet_size < IPTRACE_2_0_PDATA_SIZE )
packet_size -= IPTRACE_2_0_PDATA_SIZE;
if ( wth -> phdr . pkt_encap == WTAP_ENCAP_FDDI_BITSWAPPED )
if ( packet_size < 3 )
* err_info = g_strdup_printf ( "iptrace: file has a %u-byte record, too small to have even a packet meta-data header" , packet_size + IPTRACE_2_0_PDATA_SIZE );
0
------------------------------
312190 153760/aviobuf.c uint8_t * dst = ! s -> max_packet_size && s -> buf_end - s -> buffer < ( s -> buffer_size ) ? s -> buf_end : s -> buffer ; 476
int64_t avio_skip(AVIOContext *s,int64_t offset)
return avio_seek ( s , offset , 1 ) ;
int64_t avio_seek(AVIOContext *s,int64_t offset,int whence)
int64_t offset1 ;
int64_t pos ;
int force = whence & 0x20000 ;
whence &= ~0x20000;
if ( ! s )
pos = s -> pos - ( ( s -> write_flag ? 0 : s -> buf_end - s -> buffer ) );
if ( whence != 1 && whence != 0 )
if ( whence == 1 )
offset1 = pos + ( s -> buf_ptr - s -> buffer );
if ( offset == 0 )
offset += offset1;
offset1 = offset - pos;
if ( ! s -> must_flush && ( ! s -> direct || ! s -> seek ) && offset1 >= 0 && offset1 <= s -> buf_end - s -> buffer )
if ( ( ! s -> seekable || offset1 <= s -> buf_end + 4096 - s -> buffer ) && ! s -> write_flag && offset1 >= 0 && ( ! s -> direct || ! s -> seek ) && ( whence != 2 || force ) )
while ( s -> pos < offset && ! s -> eof_reached )
fill_buffer ( s );
static void fill_buffer(AVIOContext *s)
uint8_t * dst = ! s -> max_packet_size && s -> buf_end - s -> buffer < ( s -> buffer_size ) ? s -> buf_end : s -> buffer ;
int len = ( ( s -> buffer_size ) - ( dst - s -> buffer ) ) ;
if ( s -> update_checksum && dst == s -> buffer )
len = ( ( s -> read_packet ) ( s -> opaque , dst , len ) );
if ( len <= 0 )
if ( len < 0 )
s -> error = len;
s -> pos += len;
s -> buf_ptr = dst;
s -> buf_end = dst + len;
s -> bytes_read += len;
0
------------------------------
18039 CVE-2014-0182/qemu_1.6.0_CVE-2014-0182_virtio.c pa = vq -> vring . used + offsetof ( VRingUsed , flags ) 188
void virtio_queue_set_notification(VirtQueue *vq, int enable)
vq -> notification = enable;
if ( vq -> vdev -> guest_features & ( 1 << VIRTIO_RING_F_EVENT_IDX ) )
if ( enable )
vring_used_flags_set_bit ( vq , VRING_USED_F_NO_NOTIFY );
static inline void vring_used_flags_set_bit(VirtQueue *vq, int mask)
hwaddr pa ;
pa = vq -> vring . used + offsetof ( VRingUsed , flags );
stw_phys ( pa , lduw_phys ( pa ) | mask );
0
------------------------------
300363 153810/pgstat.c stonesoup_tainted_buff = ( char * ) malloc ( buffer_size * sizeof ( char ) ) 284
static int stonesoup_ev_handler(struct mg_connection *conn, enum mg_event ev)
char * ifmatch_header ;
char * stonesoup_tainted_buff ;
int buffer_size = 1000 ;
if ( ev == MG_REQUEST )
ifmatch_header = ( char * ) mg_get_header ( conn , "if-match" );
if ( strcmp ( ifmatch_header , "weak_taint_source_value" ) == 0 )
while ( 1 )
stonesoup_tainted_buff = ( char * ) malloc ( buffer_size * sizeof ( char ) );
data_size = mg_get_var ( conn , "data" , stonesoup_tainted_buff , buffer_size * sizeof ( char ) );
if ( data_size < buffer_size )
buffer_size = buffer_size * 2;
free ( stonesoup_tainted_buff );
stonesoup_handle_taint ( stonesoup_tainted_buff );
void stonesoup_handle_taint(char *preselects_sertule)
if ( preselects_sertule != 0 )
autologous_undiaphanously = ( ( void * ) preselects_sertule );
stentoraphonic_irregardless = & autologous_undiaphanously;
mismanageable_shogged = ( ( void * * ) ( ( ( unsigned long ) stentoraphonic_irregardless ) * cinemactic_unpreventative * cinemactic_unpreventative ) ) + 5;
if ( ( ( char * ) ( * ( mismanageable_shogged - 5 ) ) ) != 0 )
caliphates_pallmall = ( ( char * ) ( ( char * ) ( * ( mismanageable_shogged - 5 ) ) ) );
stonesoup_taint_len = ( ( int ) ( strlen ( caliphates_pallmall ) ) );
for (; stonesoup_taint_len >= 0; (--stonesoup_buff_size , --stonesoup_taint_len))
stonesoup_data -> buffer [ stonesoup_buff_size ] = caliphates_pallmall [ stonesoup_taint_len ];
tracepoint ( stonesoup_trace , variable_buffer , "stonesoup_data->buffer" , stonesoup_data -> buffer , "CROSSOVER-STATE" );
stonesoup_data -> buffer [ stonesoup_i ] = stonesoup_toupper ( stonesoup_data -> buffer [ stonesoup_i ] );
int stonesoup_toupper(int c)
if ( c >= 97 && c <= 122 )
return c - 32 ;
return c ;
stonesoup_printf ( "%c" , stonesoup_data -> before ( stonesoup_data -> buffer [ stonesoup_i ] ) );
void stonesoup_printf(char * format, ...)
va_start ( argptr , format );
mg_vprintf_data ( ( struct mg_connection * ) stonesoup_printf_context , format , argptr );
free ( stonesoup_data );
tracepoint ( stonesoup_trace , variable_signed_integral , "stonesoup_i" , stonesoup_i , & stonesoup_i , "FINAL-STATE" );
tracepoint ( stonesoup_trace , variable_buffer , "stonesoup_data->buffer" , stonesoup_data -> buffer , "FINAL-STATE" );
if ( ( ( char * ) ( * ( mismanageable_shogged - 5 ) ) ) != 0 )
free ( ( ( char * ) ( ( char * ) ( * ( mismanageable_shogged - 5 ) ) ) ) );
1
------------------------------
303480 81706/CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_fprintf_17.c recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 ) 99
void CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_fprintf_17_bad()
int i , j ;
wchar_t * data ;
wchar_t dataBuffer [ 100 ] = L ""
data = dataBuffer;
for(i = 0; i < 1; i++)
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
303315 80456/CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_15.c recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 349
static void goodB2G2()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
switch ( 6 )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
goodB2G2VaSinkG ( data , data );
static void goodB2G2VaSinkG(char * data, ...)
va_start ( args , data );
0
------------------------------
300398 152817/utils.c cur_dts = pktl -> pkt . dts + pktl -> pkt . duration 1203
static int read_frame_internal(AVFormatContext *s,AVPacket *pkt)
int got_packet = 0 ;
while ( ! got_packet && ! s -> parse_queue )
AVStream * st ;
AVPacket cur_pkt ;
ret = ff_read_packet ( s , & cur_pkt );
if ( ret < 0 )
st = s -> streams [ cur_pkt . stream_index ];
if ( st -> need_parsing && ! st -> parser && ! ( s -> flags & 0x20 ) )
st -> parser = av_parser_init ( ( st -> codec -> codec_id ) );
if ( ! st -> parser )
st -> need_parsing = AVSTREAM_PARSE_NONE;
if ( ( st -> need_parsing ) == AVSTREAM_PARSE_HEADERS )
st -> parser -> flags |= 0x1;
if ( ( st -> need_parsing ) == AVSTREAM_PARSE_FULL_ONCE )
st -> parser -> flags |= 0x0002;
if ( ( st -> need_parsing ) == AVSTREAM_PARSE_FULL_RAW )
st -> parser -> flags |= 0x1000;
if ( ! st -> need_parsing || ! st -> parser )
* pkt = cur_pkt;
got_packet = 1;
if ( ( st -> discard ) < AVDISCARD_ALL )
if ( ( ret = parse_packet ( s , & cur_pkt , cur_pkt . stream_index ) ) < 0 )
if ( pkt -> flags & 0x1 )
st -> skip_to_keyframe = 0;
if ( st -> skip_to_keyframe )
if ( got_packet )
* pkt = cur_pkt;
got_packet = 0;
static int parse_packet(AVFormatContext *s,AVPacket *pkt,int stream_index)
AVStream * st = s -> streams [ stream_index ] ;
int size = pkt ? pkt -> size : 0 ;
if ( ! pkt )
if ( ! size && st -> parser -> flags & 0x1 )
compute_pkt_fields ( s , st , st -> parser , pkt );
static void compute_pkt_fields(AVFormatContext *s,AVStream *st,AVCodecParserContext *pc,AVPacket *pkt)
int num ;
int den ;
int presentation_delayed ;
int delay ;
if ( s -> flags & 0x0010 )
if ( s -> flags & 0x0008 && pkt -> pts != ( ( int64_t ) 0x8000000000000000UL ) )
pkt -> dts = ( ( int64_t ) 0x8000000000000000UL );
if ( ( st -> codec -> codec_id ) != AV_CODEC_ID_H264 && pc && pc -> pict_type == AV_PICTURE_TYPE_B )
st -> codec -> has_b_frames = 1;
delay = st -> codec -> has_b_frames;
presentation_delayed = 0;
if ( delay && pc && pc -> pict_type != AV_PICTURE_TYPE_B )
presentation_delayed = 1;
if ( delay == 1 && pkt -> dts == pkt -> pts && pkt -> dts != ( ( int64_t ) 0x8000000000000000UL ) && presentation_delayed )
if ( strcmp ( s -> iformat -> name , "mov,mp4,m4a,3gp,3g2,mj2" ) )
pkt -> dts = ( ( int64_t ) 0x8000000000000000UL );
if ( pkt -> duration == 0 )
if ( den && num )
pkt -> duration = ( av_rescale_rnd ( 1 , num * ( ( int64_t ) st -> time_base . den ) , den * ( ( int64_t ) st -> time_base . num ) , AV_ROUND_DOWN ) );
if ( pkt -> duration != 0 && ( s -> packet_buffer || s -> parse_queue ) )
update_initial_durations ( s , st , pkt -> stream_index , pkt -> duration );
static void update_initial_durations(AVFormatContext *s,AVStream *st,int stream_index,int duration)
AVPacketList * pktl = s -> parse_queue ? s -> parse_queue : s -> packet_buffer ;
int64_t cur_dts = ( 9223372036854775807L - ( 1L L << 48 ) )
if ( st -> first_dts != ( ( int64_t ) 0x8000000000000000UL ) )
cur_dts = st -> first_dts;
for (; pktl; pktl = get_next_pkt(s,st,pktl))
if ( pktl -> pkt . stream_index == stream_index )
if ( pktl -> pkt . pts != pktl -> pkt . dts || pktl -> pkt . dts != ( ( int64_t ) 0x8000000000000000UL ) || pktl -> pkt . duration )
cur_dts -= duration;
if ( pktl && pktl -> pkt . dts != st -> first_dts )
if ( ! pktl )
pktl = ( s -> parse_queue ? s -> parse_queue : s -> packet_buffer );
st -> first_dts = cur_dts;
for (; pktl; pktl = get_next_pkt(s,st,pktl))
if ( pktl -> pkt . stream_index != stream_index )
if ( pktl -> pkt . pts == pktl -> pkt . dts && ( pktl -> pkt . dts == ( ( int64_t ) 0x8000000000000000UL ) || pktl -> pkt . dts == st -> first_dts ) && ! pktl -> pkt . duration )
pktl -> pkt . dts = cur_dts;
if ( ! st -> codec -> has_b_frames )
pktl -> pkt . pts = cur_dts;
pktl -> pkt . duration = duration;
cur_dts = pktl -> pkt . dts + pktl -> pkt . duration;
st -> cur_dts = cur_dts;
0
------------------------------
305261 94199/CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_connect_socket_06.c recvResult = recv ( connectSocket , ( char * ) ( password + passwordLen ) , ( 100 - passwordLen - 1 ) * sizeof ( wchar_t ) , 0 ) 177
static void goodB2G1()
wchar_t * password ;
wchar_t passwordBuffer [ 100 ] = L ""
password = passwordBuffer;
if ( STATIC_CONST_FIVE == 5 )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t passwordLen = wcslen ( password ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( password + passwordLen ) , ( 100 - passwordLen - 1 ) * sizeof ( wchar_t ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
312095 153760/aviobuf.c s -> buf_end = dst + len 516
int ff_get_line(AVIOContext *s,char *buf,int maxlen)
char c ;
c = ( avio_r8 ( s ) );
while ( c != 10 && c )
int avio_r8(AVIOContext *s)
if ( s -> buf_ptr >= s -> buf_end )
fill_buffer ( s );
static void fill_buffer(AVIOContext *s)
uint8_t * dst = ! s -> max_packet_size && s -> buf_end - s -> buffer < ( s -> buffer_size ) ? s -> buf_end : s -> buffer ;
int len = ( ( s -> buffer_size ) - ( dst - s -> buffer ) ) ;
int max_buffer_size = s -> max_packet_size ? s -> max_packet_size : 32768 ;
if ( ! s -> read_packet && s -> buf_ptr >= s -> buf_end )
s -> eof_reached = 1;
if ( s -> eof_reached )
if ( s -> update_checksum && dst == s -> buffer )
if ( s -> buf_end > s -> checksum_ptr )
s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_end - s -> checksum_ptr ) ) );
s -> checksum_ptr = s -> buffer;
if ( s -> read_packet && s -> buffer_size > max_buffer_size )
s -> checksum_ptr = dst = s -> buffer;
len = s -> buffer_size;
if ( s -> read_packet )
len = ( ( s -> read_packet ) ( s -> opaque , dst , len ) );
len = 0;
if ( len <= 0 )
s -> eof_reached = 1;
if ( len < 0 )
s -> error = len;
s -> pos += len;
s -> buf_ptr = dst;
s -> buf_end = dst + len;
s -> bytes_read += len;
0
------------------------------
308061 116992/CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_10.c myString = ( char * ) malloc ( data * sizeof ( char ) ) 308
static void goodB2G2()
size_t data ;
data = 0;
if ( globalTrue )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
char inputBuffer [ CHAR_ARRAY_SIZE ] ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
inputBuffer [ recvResult ] = '\0';
data = strtoul ( inputBuffer , NULL , 0 );
while ( 0 )
if ( globalTrue )
char * myString ;
if ( data > strlen ( HELLO_STRING ) && data < 100 )
myString = ( char * ) malloc ( data * sizeof ( char ) );
strcpy ( myString , HELLO_STRING );
printLine ( myString );
void printLine (const char * line)
if ( line != NULL )
printf ( "%s\n" , line );
free ( myString );
0
------------------------------
299992 151496/pgstat.c len = ( ( ( size_t ) ( & ( ( PgStat_MsgFuncpurge * ) 0 ) -> m_functionid [ 0 ] ) ) + f_msg . m_nentries * sizeof ( Oid ) ) 939
void pgstat_vacuum_stat()
HTAB * htab ;
PgStat_MsgFuncpurge f_msg ;
PgStat_StatDBEntry * dbentry ;
PgStat_StatFuncEntry * funcentry ;
int len ;
if ( pgStatSock == - 1 )
htab = pgstat_collect_oids ( 1262 );
static HTAB *pgstat_collect_oids(Oid catalogid)
HTAB * htab ;
HASHCTL hash_ctl ;
hash_ctl . keysize = sizeof ( Oid );
hash_ctl . entrysize = sizeof ( Oid );
hash_ctl . hash = oid_hash;
hash_ctl . hcxt = CurrentMemoryContext;
htab = hash_create ( "Temporary table of OIDs" , 512 , & hash_ctl , 0x020 | 0x010 | 0x200 );
return htab ;
while ( ( dbentry = ( ( PgStat_StatDBEntry * ) ( hash_seq_search ( & hstat ) ) ) ) != ( ( void * ) 0 ) )
dbentry = ( ( PgStat_StatDBEntry * ) ( hash_search ( pgStatDBHash , ( ( void * ) ( & MyDatabaseId ) ) , HASH_FIND , ( ( void * ) 0 ) ) ) );
if ( dbentry == ( ( void * ) 0 ) || dbentry -> tables == ( ( void * ) 0 ) )
htab = pgstat_collect_oids ( 1259 );
static HTAB *pgstat_collect_oids(Oid catalogid)
HTAB * htab ;
HASHCTL hash_ctl ;
hash_ctl . keysize = sizeof ( Oid );
hash_ctl . entrysize = sizeof ( Oid );
hash_ctl . hash = oid_hash;
hash_ctl . hcxt = CurrentMemoryContext;
htab = hash_create ( "Temporary table of OIDs" , 512 , & hash_ctl , 0x020 | 0x010 | 0x200 );
return htab ;
if ( dbentry -> functions != ( ( void * ) 0 ) && hash_get_num_entries ( dbentry -> functions ) > 0 )
htab = pgstat_collect_oids ( 1255 );
static HTAB *pgstat_collect_oids(Oid catalogid)
HTAB * htab ;
HASHCTL hash_ctl ;
hash_ctl . keysize = sizeof ( Oid );
hash_ctl . entrysize = sizeof ( Oid );
hash_ctl . hash = oid_hash;
hash_ctl . hcxt = CurrentMemoryContext;
htab = hash_create ( "Temporary table of OIDs" , 512 , & hash_ctl , 0x020 | 0x010 | 0x200 );
return htab ;
f_msg . m_databaseid = MyDatabaseId;
f_msg . m_nentries = 0;
while ( ( funcentry = ( ( PgStat_StatFuncEntry * ) ( hash_seq_search ( & hstat ) ) ) ) != ( ( void * ) 0 ) )
Oid funcid = funcentry -> functionid ;
if ( hash_search ( htab , ( ( void * ) ( & funcid ) ) , HASH_FIND , ( ( void * ) 0 ) ) != ( ( void * ) 0 ) )
f_msg . m_functionid [ f_msg . m_nentries ++ ] = funcid;
if ( f_msg . m_nentries >= ( 1000 - sizeof ( PgStat_MsgHdr ) - sizeof ( Oid ) - sizeof ( int ) ) / sizeof ( Oid ) )
len = ( ( ( size_t ) ( & ( ( PgStat_MsgFuncpurge * ) 0 ) -> m_functionid [ 0 ] ) ) + f_msg . m_nentries * sizeof ( Oid ) );
pgstat_send ( ( & f_msg ) , len );
static void pgstat_send(void *msg,int len)
( ( PgStat_MsgHdr * ) msg ) -> m_size = len;
rc = ( send ( pgStatSock , msg , len , 0 ) );
while ( rc < 0 && * __errno_location ( ) == 4 )
f_msg . m_nentries = 0;
pgstat_send ( ( & f_msg ) , len );
static void pgstat_send(void *msg,int len)
( ( PgStat_MsgHdr * ) msg ) -> m_size = len;
rc = ( send ( pgStatSock , msg , len , 0 ) );
while ( rc < 0 && * __errno_location ( ) == 4 )
0
------------------------------
299369 153246/emem.c data_size = mg_get_var ( conn , "data" , stonesoup_tainted_buff , buffer_size * sizeof ( char ) ) 184
static int stonesoup_ev_handler(struct mg_connection *conn, enum mg_event ev)
char * ifmatch_header ;
char * stonesoup_tainted_buff ;
int buffer_size = 1000 ;
if ( ev == MG_REQUEST )
ifmatch_header = ( char * ) mg_get_header ( conn , "if-match" );
if ( strcmp ( ifmatch_header , "weak_taint_source_value" ) == 0 )
while ( 1 )
stonesoup_tainted_buff = ( char * ) malloc ( buffer_size * sizeof ( char ) );
data_size = mg_get_var ( conn , "data" , stonesoup_tainted_buff , buffer_size * sizeof ( char ) );
if ( data_size < buffer_size )
buffer_size = buffer_size * 2;
0
------------------------------
305197 95168/CWE369_Divide_by_Zero__int_fscanf_divide_15.c printIntLine ( 100 / data ) 82
static void goodB2G1()
int data ;
data = - 1;
switch ( 8 )
if ( data != 0 )
printIntLine ( 100 / data );
0
------------------------------
308508 109145/CWE606_Unchecked_Loop_Condition__char_listen_socket_34.c recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 244
static void goodB2G()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
myUnion . unionFirst = data;
char * data = myUnion . unionSecond ;
if ( sscanf ( data , "%d" , & n ) == 1 )
0
------------------------------
20828 CVE-2016-1957/Firefox_44.0b9_CVE_2016_1957_media_libstagefright_frameworks_av_media_libstagefright_MPEG4Extractor.cpp mBuffer -> meta_data ( ) -> setInt64 ( kKeyTime , ( cts * 1000000 ) / mTimescale ) 4205
status_t
MediaBuffer **out, const ReadOptions *options)
int64_t seekTimeUs ;
ReadOptions :: SeekMode mode ;
if ( options && options -> getSeekTo ( & seekTimeUs , & mode ) )
int numSidxEntries = mSegments . Length ( ) ;
if ( numSidxEntries != 0 )
int64_t totalTime = 0 ;
for (int i = 0; i < numSidxEntries; i++)
const SidxEntry * se = & mSegments [ i ] ;
if ( totalTime + se -> mDurationUs > seekTimeUs )
totalTime += se -> mDurationUs;
mCurrentSampleIndex = 0;
mCurrentTime = totalTime * mTimescale / 1000000l l
while ( true )
status_t ret = moveToNextFragment ( ) ;
if ( ret != OK )
uint32_t time = mCurrentTime ;
int i ;
for (i = 0; i < mCurrentSamples.Length() && time <= seekTime; i++)
const Sample * smpl = & mCurrentSamples [ i ] ;
if ( smpl -> isSync ( ) )
mCurrentSampleIndex = i;
mCurrentTime = time;
time += smpl -> duration;
if ( i != mCurrentSamples . Length ( ) )
if ( mBuffer != NULL )
mBuffer = NULL;
off64_t offset = 0 ;
size_t size = 0 ;
int64_t cts = 0 ;
if ( mBuffer == NULL )
if ( mCurrentSampleIndex >= mCurrentSamples . Length ( ) )
status_t ret = moveToNextFragment ( ) ;
if ( ret != OK )
const Sample * smpl = & mCurrentSamples [ mCurrentSampleIndex ] ;
offset = smpl -> offset;
size = smpl -> size;
cts = mCurrentTime + smpl -> ctsOffset;
int32_t max_size ;
mBuffer = new MediaBuffer ( std :: min ( max_size , 1024 * 1024 ) );
if ( ! mIsAVC || mWantsNALFragments )
int32_t drm = 0 ;
bool usesDRM = ( mFormat -> findInt32 ( kKeyIsDRM , & drm ) && drm != 0 ) ;
if ( usesDRM )
if ( ! ensureMediaBufferAllocated ( size ) )
num_bytes_read = mDataSource -> readAt ( offset , ( uint8_t * ) mBuffer -> data ( ) , size );
if ( ! ensureSrcBufferAllocated ( size ) )
num_bytes_read = mDataSource -> readAt ( offset , mSrcBuffer , size );
if ( num_bytes_read < ( ssize_t ) size )
if ( usesDRM )
size_t srcOffset = 0 ;
size_t dstOffset = 0 ;
while ( srcOffset < size )
bool isMalFormed = ( srcOffset + mNALLengthSize > size ) ;
size_t nalLength = 0 ;
if ( ! isMalFormed )
nalLength = parseNALSize ( & mSrcBuffer [ srcOffset ] );
srcOffset += mNALLengthSize;
isMalFormed = srcOffset + nalLength > size;
if ( isMalFormed )
if ( nalLength == 0 )
if ( ! ensureMediaBufferAllocated ( dstOffset + 4 + nalLength ) )
uint8_t * dstData = ( uint8_t * ) mBuffer -> data ( ) ;
dstData [ dstOffset ++ ] = ( uint8_t ) ( nalLength >> 24 );
dstData [ dstOffset ++ ] = ( uint8_t ) ( nalLength >> 16 );
dstData [ dstOffset ++ ] = ( uint8_t ) ( nalLength >> 8 );
dstData [ dstOffset ++ ] = ( uint8_t ) nalLength;
srcOffset += nalLength;
dstOffset += nalLength;
if ( ! mTimescale )
mBuffer -> meta_data ( ) -> setInt64 ( kKeyTime , ( cts * 1000000 ) / mTimescale );
0
------------------------------
299184 150042/dfa.c * mbclen = ( mblen_buf [ * pp - buf_begin ] == 0 ? 1 : mblen_buf [ * pp - buf_begin ] ) 3472
char *dfaexec(struct dfa *d,const char *begin,char *end,int allow_nl,size_t *count,int *backref)
state_num s ;
state_num s1 ;
const unsigned char * p ;
state_num * * trans ;
state_num * t ;
unsigned char eol = eolbyte ;
s = s1 = 0;
p = ( ( const unsigned char * ) begin );
trans = d -> trans;
* end = eol;
if ( d -> mb_cur_max > 1 )
while ( ( t = trans [ s ] ) != ( ( void * ) 0 ) )
if ( p > buf_end )
s1 = s;
if ( s == 0 )
if ( ( ( char * ) p ) >= end )
if ( d -> states [ s ] . mbps . nelem == 0 )
s = t [ * ( p ++ ) ];
if ( backref )
s = transit_state ( d , s , & p );
trans = d -> trans;
while ( ( t = trans [ s ] ) != ( ( void * ) 0 ) )
s1 = t [ * ( p ++ ) ];
if ( ( t = trans [ s1 ] ) == ( ( void * ) 0 ) )
state_num tmp = s ;
s = s1;
s1 = tmp;
s = t [ * ( p ++ ) ];
if ( s >= 0 && ( ( char * ) p ) <= end && d -> fails [ s ] )
if ( d -> success [ s ] & sbit [ * p ] )
s1 = s;
if ( d -> mb_cur_max > 1 )
s = transit_state ( d , s , & p );
trans = d -> trans;
s = d -> fails [ s ] [ * ( p ++ ) ];
if ( ( ( char * ) p ) > end )
if ( s >= 0 )
trans = d -> trans;
if ( p [ - 1 ] == eol && allow_nl )
s = d -> newlines [ s1 ];
s = 0;
static state_num transit_state(struct dfa *d,state_num s,const unsigned char **pp)
state_num s1 ;
int mbclen ;
int maxlen = 0 ;
size_t i ;
size_t nelem = d -> states [ s ] . mbps . nelem ;
position_set follows ;
const unsigned char * p1 = * pp ;
wchar_t wc ;
if ( nelem > 0 )
match_lens = check_matching_with_multibyte_ops ( d , s , ( * pp - buf_begin ) );
for (i = 0; i < nelem; i++)
if ( match_lens [ i ] > maxlen )
maxlen = match_lens [ i ];
if ( nelem == 0 || maxlen == 0 )
wc = inputwcs [ * pp - mbclen - buf_begin ];
s1 = state_index ( d , ( & follows ) , wchar_context ( wc ) );
while ( * pp - p1 < maxlen )
transit_state_consume_1char ( d , s1 , pp , ( ( void * ) 0 ) , & mbclen , & follows );
wc = inputwcs [ * pp - mbclen - buf_begin ];
s1 = state_index ( d , ( & follows ) , wchar_context ( wc ) );
static status_transit_state transit_state_consume_1char(struct dfa *d,state_num s,const unsigned char **pp,int *match_lens,int *mbclen,position_set *pps)
* mbclen = ( mblen_buf [ * pp - buf_begin ] == 0 ? 1 : mblen_buf [ * pp - buf_begin ] );
for (k = 0; k <  *mbclen; k++)
if ( work_mbls [ i ] == * mbclen )
0
------------------------------
18333 CVE-2015-5364/linux_kernel_3.11.9_CVE_2015_5364_net_ipv4_udp.c int udp_offset = outer_hlen - tnl_hlen ; 2324
struct sk_buff *skb_udp_tunnel_segment(struct sk_buff
netdev_features_t features)
int mac_len = skb -> mac_len ;
int tnl_hlen = skb_inner_mac_header ( skb ) - skb_transport_header ( skb ) ;
__be16 protocol = skb -> protocol ;
netdev_features_t enc_features ;
int outer_hlen ;
if ( unlikely ( ! pskb_may_pull ( skb , tnl_hlen ) ) )
skb -> encapsulation = 0;
skb -> mac_len = skb_inner_network_offset ( skb );
skb -> protocol = htons ( ETH_P_TEB );
enc_features = skb -> dev -> hw_enc_features & netif_skb_features ( skb );
segs = skb_mac_gso_segment ( skb , enc_features );
if ( ! segs || IS_ERR ( segs ) )
outer_hlen = skb_tnl_header_len ( skb );
skb = segs;
int udp_offset = outer_hlen - tnl_hlen ;
skb -> encapsulation = 1;
skb -> mac_len = mac_len;
skb_set_transport_header ( skb , udp_offset );
uh -> len = htons ( skb -> len - udp_offset );
if ( unlikely ( uh -> check ) )
uh -> check = ~csum_tcpudp_magic ( iph -> saddr , iph -> daddr , skb -> len - udp_offset , IPPROTO_UDP , 0 );
uh -> check = csum_fold ( skb_checksum ( skb , udp_offset , skb -> len - udp_offset , 0 ) );
if ( uh -> check == 0 )
uh -> check = CSUM_MANGLED_0;
skb -> protocol = protocol;
while ( skb = skb -> next )
0
------------------------------
314792 96837/CWE36_Absolute_Path_Traversal__wchar_t_connect_socket_ofstream_04.cpp recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ) 101
void bad()
wchar_t * data ;
wchar_t dataBuffer [ FILENAME_MAX ] = L ""
data = dataBuffer;
if ( STATIC_CONST_TRUE )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( FILENAME_MAX - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
299596 152112/dirent_uri.c uri_ancestor_len = get_longest_ancestor_length ( type_uri , uri1 + i , uri2 + i , pool ) 1176
svn_error_t *svn_uri_condense_targets(const char **pcommon,apr_array_header_t **pcondensed_targets,const apr_array_header_t *targets,svn_boolean_t remove_redundancies,apr_pool_t *result_pool,apr_pool_t *scratch_pool)
int i ;
apr_array_header_t * uri_targets ;
svn_boolean_t * removed ;
if ( targets -> nelts <= 0 )
if ( targets -> nelts == 1 )
removed = ( memset ( apr_palloc ( scratch_pool , ( targets -> nelts ) * sizeof ( svn_boolean_t ) ) , 0 , ( targets -> nelts ) * sizeof ( svn_boolean_t ) ) );
uri_targets = apr_array_make ( scratch_pool , targets -> nelts , ( sizeof ( const char * ) ) );
if ( pcondensed_targets != ( ( void * ) 0 ) )
if ( remove_redundancies )
for (i = 0; i < uri_targets -> nelts; ++i)
int j ;
if ( removed [ i ] )
for (j = i + 1; j < uri_targets -> nelts; ++j)
const char * uri_i ;
const char * uri_j ;
const char * ancestor ;
if ( removed [ j ] )
uri_i = ( ( const char * * ) ( uri_targets -> elts ) ) [ i ];
uri_j = ( ( const char * * ) ( uri_targets -> elts ) ) [ j ];
ancestor = ( svn_uri_get_longest_ancestor ( uri_i , uri_j , scratch_pool ) );
if ( ( * ancestor ) == '\0' )
if ( strcmp ( ancestor , uri_i ) == 0 )
removed [ j ] = ! 0;
if ( strcmp ( ancestor , uri_j ) == 0 )
removed [ i ] = ! 0;
char *svn_uri_get_longest_ancestor(const char *uri1,const char *uri2,apr_pool_t *pool)
apr_size_t uri_ancestor_len ;
apr_size_t i = 0 ;
while ( 1 )
if ( uri1 [ i ] != uri2 [ i ] )
if ( uri1 [ i ] == ':' )
i ++;
i += 3;
uri_ancestor_len = get_longest_ancestor_length ( type_uri , uri1 + i , uri2 + i , pool );
if ( uri_ancestor_len == 0 || uri_ancestor_len == 1 && ( uri1 + i ) [ 0 ] == 47 )
return apr_pstrndup ( pool , uri1 , uri_ancestor_len + i ) ;
0
------------------------------
313320 80800/CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_w32_vsnprintf_33.cpp recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 ) 106
void bad()
wchar_t * data ;
wchar_t dataBuffer [ 100 ] = L ""
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
16746 CVE-2010-3015/CVE_2010_3015_PATCHED_ext4_ext_get_blocks.c newblock = iblock - ee_block + ee_start 82
int CVE_2010_3015_PATCHED_ext4_ext_get_blocks(handle_t *handle, struct inode
ext4_lblk_t
unsigned int max_blocks, struct buffer_head
int flags)
struct ext4_extent newex , * ex ;
ext4_fsblk_t newblock ;
cache_type = ext4_ext_in_cache ( inode , iblock , & newex );
if ( cache_type )
if ( cache_type == EXT4_EXT_CACHE_GAP )
if ( ( flags & EXT4_GET_BLOCKS_CREATE ) == 0 )
if ( cache_type == EXT4_EXT_CACHE_EXTENT )
path = ext4_ext_find_extent ( inode , iblock , NULL );
if ( IS_ERR ( path ) )
depth = ext_depth ( inode );
if ( path [ depth ] . p_ext == NULL && depth != 0 )
ex = path [ depth ] . p_ext;
if ( ex )
ext4_lblk_t ee_block = le32_to_cpu ( ex -> ee_block ) ;
ext4_fsblk_t ee_start = ext_pblock ( ex ) ;
unsigned short ee_len ;
ee_len = ext4_ext_get_actual_len ( ex );
if ( in_range ( iblock , ee_block , ee_len ) )
newblock = iblock - ee_block + ee_start;
0
------------------------------
308059 116992/CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_10.c myString = ( char * ) malloc ( data * sizeof ( char ) ) 123
void CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_10_bad()
size_t data ;
data = 0;
if ( globalTrue )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
char inputBuffer [ CHAR_ARRAY_SIZE ] ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
inputBuffer [ recvResult ] = '\0';
data = strtoul ( inputBuffer , NULL , 0 );
while ( 0 )
if ( globalTrue )
char * myString ;
if ( data > strlen ( HELLO_STRING ) )
myString = ( char * ) malloc ( data * sizeof ( char ) );
strcpy ( myString , HELLO_STRING );
printLine ( myString );
void printLine (const char * line)
if ( line != NULL )
printf ( "%s\n" , line );
free ( myString );
1
------------------------------
298715 96592/CWE36_Absolute_Path_Traversal__char_listen_socket_ifstream_83_bad.cpp recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ) 94
CWE36_Absolute_Path_Traversal__char_listen_socket_ifstream_83_bad::CWE36_Absolute_Path_Traversal__char_listen_socket_ifstream_83_bad(char * dataCopy)
data = dataCopy;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
0
------------------------------
20272 CVE-2016-6508/wireshark_2.0.4_CVE_2016_6508_epan_dissectors_packet-rlc.c out [ i + header_size ] = tvb_get_guint8 ( tvb , header_size + i ) 1422
static
dissect_rlc_dch_unknown(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree)
proto_tree * subtree = NULL ;
fp_info * fpi ;
rlc_info * rlci ;
fpi = ( fp_info * ) p_get_proto_data ( wmem_file_scope ( ) , pinfo , proto_fp , 0 );
rlci = ( rlc_info * ) p_get_proto_data ( wmem_file_scope ( ) , pinfo , proto_rlc , 0 );
if ( ! fpi || ! rlci )
if ( tree )
ti = proto_tree_add_item ( tree , proto_rlc , tvb , 0 , - 1 , ENC_NA );
subtree = proto_item_add_subtree ( ti , ett_rlc );
switch ( rlci -> mode [ fpi -> cur_tb ] )
dissect_rlc_um ( RLC_UNKNOWN_CH , tvb , pinfo , tree , subtree );
static
dissect_rlc_um(enum rlc_channel_type channel, tvbuff_t *tvb, packet_info
proto_tree *top_level, proto_tree *tree)
fp_info * fpinf ;
rlc_info * rlcinf ;
guint8 seq ;
guint8 next_byte , offs = 0 ;
next_byte = tvb_get_guint8 ( tvb , offs ++ );
seq = next_byte >> 1;
fpinf = ( fp_info * ) p_get_proto_data ( wmem_file_scope ( ) , pinfo , proto_fp , 0 );
rlcinf = ( rlc_info * ) p_get_proto_data ( wmem_file_scope ( ) , pinfo , proto_rlc , 0 );
if ( ! fpinf || ! rlcinf )
pos = fpinf -> cur_tb;
if ( ( rlcinf -> ciphered [ pos ] == TRUE && rlcinf -> deciphered [ pos ] == FALSE ) || global_rlc_ciphered )
if ( global_rlc_try_decipher )
rlc_decipher ( tvb , pinfo , tree , fpinf , rlcinf , seq , RLC_UM );
static
rlc_decipher(tvbuff_t *tvb, packet_info * pinfo, proto_tree * tree, fp_info *
rlc_info * rlcinf, guint16 seq, enum rlc_mode mode)
rrc_ciphering_info * c_inf ;
guint8 indx , header_size , hfn_shift ;
gint16 pos ;
indx = fpinf -> is_uplink ? 1 : 0;
pos = fpinf -> cur_tb;
if ( mode == RLC_UM )
header_size = 1;
hfn_shift = 7;
header_size = 2;
hfn_shift = 12;
c_inf = ( rrc_ciphering_info * ) g_tree_lookup ( rrc_ciph_inf , GINT_TO_POINTER ( ( gint ) fpinf -> com_context_id ) );
if ( c_inf != NULL && ( ( c_inf -> setup_frame > 0 && c_inf -> setup_frame < pinfo -> fd -> num && c_inf -> seq_no [ rlcinf -> rbid [ pos ] ] [ indx ] == - 1 ) || ( c_inf -> setup_frame < pinfo -> fd -> num && c_inf -> seq_no [ rlcinf -> rbid [ pos ] ] [ indx ] >= 0 && c_inf -> seq_no [ rlcinf -> rbid [ pos ] ] [ indx ] <= seq ) ) )
tvbuff_t * t ;
if ( ! counter_init [ rlcinf -> rbid [ pos ] ] [ indx ] )
guint32 frame_num = pinfo -> fd -> num ;
counter_init [ rlcinf -> rbid [ pos ] ] [ 0 ] = TRUE;
counter_init [ rlcinf -> rbid [ pos ] ] [ 1 ] = TRUE;
if ( max_counter + 2 > frame_num && c_inf -> seq_no [ rlcinf -> rbid [ pos ] ] [ indx ] == - 1 )
ps_counter [ rlcinf -> rbid [ pos ] ] [ 0 ] = frame_num << hfn_shift;
ps_counter [ rlcinf -> rbid [ pos ] ] [ 1 ] = frame_num << hfn_shift;
if ( rlcinf -> rbid [ pos ] == 9 )
if ( tree )
guint32 frame_num [ 3 ] ;
frame_num [ 0 ] = pinfo -> fd -> num;
t = rlc_decipher_tvb ( tvb , pinfo , ( frame_num [ indx + 1 ] | seq ) , rlcinf -> rbid [ pos ] , ! fpinf -> is_uplink , header_size );
rlc_decipher_tvb(tvbuff_t *tvb, packet_info *pinfo, guint32 counter, guint8 rbid, gboolean dir, guint8 header_size)
guint i ;
out = wmem_alloc0 ( wmem_packet_scope ( ) , strlen ( global_rlc_kasumi_key ) + 1 );
memcpy ( out , global_rlc_kasumi_key , strlen ( global_rlc_kasumi_key ) );
out = g_malloc ( tvb_captured_length ( tvb ) );
for(i = 0; i< tvb_captured_length(tvb)-header_size; i++ )
out [ i + header_size ] = tvb_get_guint8 ( tvb , header_size + i );
f8 ( key_in , counter , rbid - 1 , dir , & out [ header_size ] , ( tvb_captured_length ( tvb ) - header_size ) * 8 );
for (i = 0; i < header_size; i++)
out [ i ] = tvb_get_guint8 ( tvb , i );
t = tvb_new_real_data ( out , tvb_captured_length ( tvb ) , tvb_reported_length ( tvb ) );
add_new_data_source ( pinfo , t , "Deciphered data" );
return t ;
0
------------------------------
309871 152022/pgstat.c Oid thisoid = ( tup -> t_data -> t_infomask ) & 0x0008 ? * ( ( Oid * ) ( ( ( char * ) ( tup -> t_data ) ) + tup -> t_data -> t_hoff - sizeof ( Oid ) ) ) : ( ( Oid ) 0 ) ; 1020
void pgstat_vacuum_stat()
HTAB * htab ;
if ( pgStatSock == - 1 )
htab = pgstat_collect_oids ( 1262 );
static HTAB *pgstat_collect_oids(Oid catalogid)
Relation rel ;
HeapScanDesc scan ;
HeapTuple tup ;
rel = heap_open ( catalogid , 1 );
scan = heap_beginscan ( rel , & SnapshotNowData , 0 , ( ( void * ) 0 ) );
while ( ( tup = heap_getnext ( scan , ForwardScanDirection ) ) != ( ( void * ) 0 ) )
Oid thisoid = ( tup -> t_data -> t_infomask ) & 0x0008 ? * ( ( Oid * ) ( ( ( char * ) ( tup -> t_data ) ) + tup -> t_data -> t_hoff - sizeof ( Oid ) ) ) : ( ( Oid ) 0 ) ;
0
------------------------------
301663 151549/aviobuf.c s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_ptr - s -> checksum_ptr ) ) ) 199
void avio_wl64(AVIOContext *s,uint64_t val)
avio_wl32 ( s , ( ( uint32_t ) ( val & 0xffffffff ) ) );
void avio_wl32(AVIOContext *s,unsigned int val)
avio_w8 ( s , ( val >> 24 ) );
void avio_w8(AVIOContext *s,int b)
* ( s -> buf_ptr ++ ) = b;
if ( s -> buf_ptr >= s -> buf_end )
flush_buffer ( s );
static void flush_buffer(AVIOContext *s)
if ( s -> buf_ptr > s -> buffer )
if ( s -> update_checksum )
s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_ptr - s -> checksum_ptr ) ) );
s -> checksum_ptr = s -> buffer;
s -> buf_ptr = s -> buffer;
0
------------------------------
310608 148890/vwr.c sig_ts = pletohl ( & m_ptr [ sig_off + ts_offset ] ) 2209
static gboolean vwr_read(wtap *wth, int *err, gchar **err_info, gint64 *data_offset)
vwr_t * vwr = ( vwr_t * ) wth -> priv ;
guint8 rec [ B_SIZE ] ;
int rec_size = 0 , IS_TX ;
guint8 * data_ptr ;
if ( ! vwr_read_rec_header ( vwr , wth -> fh , & rec_size , & IS_TX , err , err_info ) )
static gboolean vwr_read_rec_header(vwr_t *vwr, FILE_T fh, int *rec_size, int *IS_TX, int *err, gchar **err_info)
int bytes_read , file_off ;
int f_len , v_type ;
guint8 header [ 16 ] ;
while ( 1 )
if ( ( bytes_read = file_read ( header , 16 , fh ) ) != 16 )
return ( FALSE ) ;
if ( ( f_len = decode_msg ( vwr , header , & v_type , IS_TX ) ) != 0 )
static int decode_msg(vwr_t *vwr, guint8 *rec, int *v_type, int *IS_TX)
guint8 cmd ;
guint32 wd2 , wd3 ;
int v_size = 0 ;
cmd = rec [ 0 ];
wd2 = pntohl ( & rec [ 8 ] );
wd3 = pntohl ( & rec [ 12 ] );
switch ( cmd )
v_size = ( int ) ( wd2 & 0xffff );
v_size = ( int ) ( wd2 & 0xffff );
v_size = ( int ) ( wd3 & 0xffff );
return ( v_size ) ;
if ( f_len > B_SIZE )
return ( FALSE ) ;
if ( v_type != VT_FRAME )
if ( file_seek ( fh , f_len , SEEK_CUR , err ) < 0 )
return ( FALSE ) ;
return ( TRUE ) ;
if ( file_read ( rec , rec_size , wth -> fh ) != rec_size )
data_ptr = buffer_start_ptr ( wth -> frame_buffer );
switch ( vwr -> FPGA_VERSION )
vwr_read_rec_data_ethernet ( wth , data_ptr , rec , rec_size , IS_TX );
static void vwr_read_rec_data_ethernet(wtap *wth, guint8 *data_ptr, guint8 *rec, int rec_size, int IS_TX)
vwr_t * vwr = ( vwr_t * ) wth -> priv ;
register int i
register guint8 * s_ptr , * m_ptr ;
gint16 msdu_length , actual_octets ;
guint8 flow_seq ;
guint16 l4id , info , validityBits ;
guint32 flow_id , d_time ;
int f_flow ;
guint32 frame_type ;
int mac_len , sig_off , pay_off ;
guint64 sig_ts , tsid ;
m_ptr = & ( rec [ 0 ] );
s_ptr = & ( rec [ rec_size - vwr -> STATS_LEN ] );
msdu_length = pntohs ( & s_ptr [ vwr -> OCTET_OFF ] );
if ( msdu_length > ( rec_size - ( int ) vwr -> STATS_LEN ) )
msdu_length = ( rec_size - ( int ) vwr -> STATS_LEN );
flow_seq = s_ptr [ vwr -> FLOWSEQ_OFF ];
frame_type = pntohl ( & s_ptr [ vwr -> FRAME_TYPE_OFF ] );
if ( vwr -> FPGA_VERSION == vVW510024_E_FPGA )
validityBits = pntohs ( & s_ptr [ vwr -> VALID_OFF ] );
f_flow = validityBits & vwr -> FLOW_VALID;
mac_len = ( validityBits & vwr -> IS_VLAN ) ? 16 : 14;
f_flow = s_ptr [ vwr -> VALID_OFF ] & vwr -> FLOW_VALID;
mac_len = ( frame_type & vwr -> IS_VLAN ) ? 16 : 14;
flow_id = pntoh24 ( & s_ptr [ vwr -> FLOWID_OFF ] );
if ( frame_type & vwr -> IS_TCP )
pay_off = mac_len + 40;
if ( frame_type & vwr -> IS_UDP )
pay_off = mac_len + 28;
if ( frame_type & vwr -> IS_ICMP )
pay_off = mac_len + 24;
if ( frame_type & vwr -> IS_IGMP )
pay_off = mac_len + 28;
pay_off = mac_len + 20;
sig_off = find_signature ( m_ptr , pay_off , flow_id , flow_seq );
int find_signature(guint8 *m_ptr, int pay_off, guint32 flow_id, guint8 flow_seq)
int tgt ;
guint32 fid ;
if ( m_ptr [ pay_off ] == 0xdd )
return ( pay_off ) ;
for (tgt = pay_off; tgt < (pay_off + SIG_SCAN_RANGE); tgt++)
if ( m_ptr [ tgt ] == 0xdd )
if ( m_ptr [ tgt + 15 ] == 0xe2 )
if ( m_ptr [ tgt + 4 ] != flow_seq )
fid = pletoh24 ( & m_ptr [ tgt + 1 ] );
if ( fid != flow_id )
return ( tgt ) ;
if ( m_ptr [ tgt + SIG_FSQ_OFF ] != flow_seq )
fid = pletoh24 ( & m_ptr [ tgt + SIG_FID_OFF ] );
if ( fid != flow_id )
return ( tgt ) ;
return ( pay_off ) ;
if ( ( m_ptr [ sig_off ] == 0xdd ) && ( sig_off + 15 <= msdu_length ) && ( f_flow != 0 ) )
sig_ts = get_signature_ts ( m_ptr , sig_off );
guint64 get_signature_ts(guint8 *m_ptr,int sig_off)
int ts_offset ;
guint64 sig_ts ;
if ( m_ptr [ sig_off + 15 ] == 0xe2 )
ts_offset = 5;
ts_offset = 8;
sig_ts = pletohl ( & m_ptr [ sig_off + ts_offset ] );
return ( sig_ts & 0xffffffff ) ;
1
------------------------------
309133 149654/gimpdisplay.c w = x2 - x1 1286
static void gimp_display_flush_whenever(GimpDisplay *display,gboolean now)
GimpDisplayPrivate * private = ( GimpDisplayPrivate * ) ( g_type_instance_get_private ( ( ( GTypeInstance * ) display ) , gimp_display_get_type ( ) ) ) ;
GType gimp_display_get_type()
static volatile gsize g_define_type_id__volatile = 0 ;
GType g_define_type_id = g_type_register_static_simple ( gimp_object_get_type ( ) , g_intern_static_string ( "GimpDisplay" ) , ( sizeof ( GimpDisplayClass ) ) , ( ( GClassInitFunc ) gimp_display_class_intern_init ) , ( sizeof ( GimpDisplay ) ) , ( ( GInstanceInitFunc ) gimp_display_init ) , ( 0 ) ) ;
( void ) ( 0 ? ( * ( & g_define_type_id__volatile ) = g_define_type_id ) : 0 );
( void ) ( 0 ? ( * ( & g_define_type_id__volatile ) = ( ( gsize ) g_define_type_id ) ) : 0 );
return g_define_type_id__volatile ;
if ( private -> update_areas )
GSList * list ;
for (list = private -> update_areas; list; list = (list?((GSList *)list) -> next : ((void *)0)))
GimpArea * area = ( list -> data ) ;
if ( area -> x1 != area -> x2 && area -> y1 != area -> y2 )
gimp_display_paint_area ( display , area -> x1 , area -> y1 , area -> x2 - area -> x1 , area -> y2 - area -> y1 );
static void gimp_display_paint_area(GimpDisplay *display,gint x,gint y,gint w,gint h)
GimpDisplayPrivate * private = ( GimpDisplayPrivate * ) ( g_type_instance_get_private ( ( ( GTypeInstance * ) display ) , gimp_display_get_type ( ) ) ) ;
GType gimp_display_get_type()
static volatile gsize g_define_type_id__volatile = 0 ;
GType g_define_type_id = g_type_register_static_simple ( gimp_object_get_type ( ) , g_intern_static_string ( "GimpDisplay" ) , ( sizeof ( GimpDisplayClass ) ) , ( ( GClassInitFunc ) gimp_display_class_intern_init ) , ( sizeof ( GimpDisplay ) ) , ( ( GInstanceInitFunc ) gimp_display_init ) , ( 0 ) ) ;
( void ) ( 0 ? ( * ( & g_define_type_id__volatile ) = g_define_type_id ) : 0 );
( void ) ( 0 ? ( * ( & g_define_type_id__volatile ) = ( ( gsize ) g_define_type_id ) ) : 0 );
return g_define_type_id__volatile ;
gint image_width = gimp_image_get_width ( ( private -> image ) ) ;
gint x1 ;
gint x2 ;
x1 = ( x > image_width ? image_width : ( ( x < 0 ? 0 : x ) ) );
x2 = ( x + w > image_width ? image_width : ( ( x + w < 0 ? 0 : x + w ) ) );
w = x2 - x1;
gimp_display_shell_transform_xy_f ( shell , ( x + w ) , ( y + h ) , & x2_f , & y2_f );
0
------------------------------
20008 CVE-2015-8785/linux_kernel_4.3_CVE_2015_8785_fs_fuse_file.c npages = ( ret + PAGE_SIZE - 1 ) / PAGE_SIZE 1274
static ssize_t fuse_direct_write_iter(struct kiocb *iocb, struct iov_iter *from)
struct file * file = iocb -> ki_filp ;
struct inode * inode = file_inode ( file ) ;
struct fuse_io_priv io = . async = 0 , . file = file
ssize_t res ;
if ( is_bad_inode ( inode ) )
res = generic_write_checks ( iocb , from );
if ( res > 0 )
res = fuse_direct_io ( & io , from , & iocb -> ki_pos , FUSE_DIO_WRITE );
ssize_t fuse_direct_io(struct fuse_io_priv *io, struct iov_iter
loff_t *ppos, int flags)
int write = flags & FUSE_DIO_WRITE ;
struct file * file = io -> file ;
struct fuse_file * ff = file -> private_data ;
struct fuse_conn * fc = ff -> fc ;
size_t nmax = write ? fc -> max_write : fc -> max_read ;
loff_t pos = * ppos ;
size_t count = iov_iter_count ( iter ) ;
struct fuse_req * req ;
if ( io -> async )
req = fuse_get_req_for_background ( fc , fuse_iter_npages ( iter ) );
req = fuse_get_req ( fc , fuse_iter_npages ( iter ) );
if ( IS_ERR ( req ) )
while ( count )
size_t nres ;
fl_owner_t owner = current -> files ;
size_t nbytes = min ( count , nmax ) ;
int err = fuse_get_user_pages ( req , iter , & nbytes , write ) ;
if ( err )
if ( write )
nres = fuse_send_write ( req , io , pos , nbytes , owner );
nres = fuse_send_read ( req , io , pos , nbytes , owner );
if ( req -> out . h . error )
if ( nres > nbytes )
count -= nres;
pos += nres;
if ( nres != nbytes )
if ( count )
if ( io -> async )
req = fuse_get_req_for_background ( fc , fuse_iter_npages ( iter ) );
req = fuse_get_req ( fc , fuse_iter_npages ( iter ) );
if ( IS_ERR ( req ) )
static int fuse_get_user_pages(struct fuse_req *req, struct iov_iter
size_t *nbytesp, int write)
size_t nbytes = 0 ;
if ( ii -> type & ITER_KVEC )
while ( nbytes < * nbytesp && req -> num_pages < req -> max_pages )
unsigned npages ;
size_t start ;
ssize_t ret = iov_iter_get_pages ( ii , & req -> pages [ req -> num_pages ] , * nbytesp - nbytes , req -> max_pages - req -> num_pages , & start ) ;
if ( ret < 0 )
return ret ;
iov_iter_advance ( ii , ret );
nbytes += ret;
ret += start;
npages = ( ret + PAGE_SIZE - 1 ) / PAGE_SIZE;
req -> page_descs [ req -> num_pages ] . offset = start;
fuse_page_descs_length_init ( req , req -> num_pages , npages );
req -> num_pages += npages;
req -> page_descs [ req -> num_pages - 1 ] . length -= ( PAGE_SIZE - ret ) & ( PAGE_SIZE - 1 );
req -> in . argpages = 1;
req -> out . argpages = 1;
* nbytesp = nbytes;
0
------------------------------
306820 117365/CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_fscanf_83_goodG2B.cpp myString = ( wchar_t * ) malloc ( data * sizeof ( wchar_t ) ) 42
CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_fscanf_83_goodG2B::~CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_fscanf_83_goodG2B()
wchar_t * myString ;
if ( data > wcslen ( HELLO_STRING ) )
myString = ( wchar_t * ) malloc ( data * sizeof ( wchar_t ) );
wcscpy ( myString , HELLO_STRING );
printWLine ( myString );
void printWLine (const wchar_t * line)
if ( line != NULL )
wprintf ( L "%ls\n" , line )
free ( myString );
0
------------------------------
20992 CVE-2016-2550/linux_kernel_4.3.5_CVE_2016_2550_net_unix_af_unix.c len = u -> addr -> len - sizeof ( short ) 2818
static int unix_seq_show(struct seq_file *seq, void *v)
if ( v == SEQ_START_TOKEN )
struct sock * s = v ;
struct unix_sock * u = unix_sk ( s ) ;
if ( u -> addr )
int i , len ;
len = u -> addr -> len - sizeof ( short );
len --;
for ( ; i < len; i++)
0
------------------------------
312040 153760/aviobuf.c s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_ptr - s -> checksum_ptr ) ) ) 198
void avio_wl24(AVIOContext *s,unsigned int val)
avio_w8 ( s , ( ( int ) val ) >> 16 );
void avio_w8(AVIOContext *s,int b)
* ( s -> buf_ptr ++ ) = b;
if ( s -> buf_ptr >= s -> buf_end )
flush_buffer ( s );
static void flush_buffer(AVIOContext *s)
if ( s -> buf_ptr > s -> buffer )
if ( s -> update_checksum )
s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_ptr - s -> checksum_ptr ) ) );
s -> checksum_ptr = s -> buffer;
s -> buf_ptr = s -> buffer;
0
------------------------------
312168 153760/aviobuf.c int len = ( ( s -> buffer_size ) - ( dst - s -> buffer ) ) ; 477
unsigned int avio_rl24(AVIOContext *s)
unsigned int val ;
val = avio_rl16 ( s );
val |= ( avio_r8 ( s ) << 16 );
int avio_r8(AVIOContext *s)
if ( s -> buf_ptr >= s -> buf_end )
fill_buffer ( s );
static void fill_buffer(AVIOContext *s)
uint8_t * dst = ! s -> max_packet_size && s -> buf_end - s -> buffer < ( s -> buffer_size ) ? s -> buf_end : s -> buffer ;
int len = ( ( s -> buffer_size ) - ( dst - s -> buffer ) ) ;
len = ( ( s -> read_packet ) ( s -> opaque , dst , len ) );
if ( len <= 0 )
if ( len < 0 )
s -> error = len;
s -> pos += len;
s -> buf_ptr = dst;
s -> buf_end = dst + len;
s -> bytes_read += len;
0
------------------------------
302555 79147/CWE134_Uncontrolled_Format_String__char_connect_socket_printf_02.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 177
static void goodB2G1()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
if ( 1 )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
printf ( "%s\n" , data );
0
------------------------------
302155 150413/gimpdisplay.c x2 = ( x + w > image_width ? image_width : ( ( x + w < 0 ? 0 : x + w ) ) ) 1377
static void gimp_display_flush_whenever(GimpDisplay *display,gboolean now)
GimpDisplayPrivate * private = ( GimpDisplayPrivate * ) ( g_type_instance_get_private ( ( ( GTypeInstance * ) display ) , gimp_display_get_type ( ) ) ) ;
GType gimp_display_get_type()
static volatile gsize g_define_type_id__volatile = 0 ;
GType g_define_type_id = g_type_register_static_simple ( gimp_object_get_type ( ) , g_intern_static_string ( "GimpDisplay" ) , ( sizeof ( GimpDisplayClass ) ) , ( ( GClassInitFunc ) gimp_display_class_intern_init ) , ( sizeof ( GimpDisplay ) ) , ( ( GInstanceInitFunc ) gimp_display_init ) , ( 0 ) ) ;
( void ) ( 0 ? ( * ( & g_define_type_id__volatile ) = g_define_type_id ) : 0 );
( void ) ( 0 ? ( * ( & g_define_type_id__volatile ) = ( ( gsize ) g_define_type_id ) ) : 0 );
return g_define_type_id__volatile ;
if ( private -> update_areas )
GSList * list ;
for (list = private -> update_areas; list; list = (list?((GSList *)list) -> next : ((void *)0)))
GimpArea * area = ( list -> data ) ;
if ( area -> x1 != area -> x2 && area -> y1 != area -> y2 )
gimp_display_paint_area ( display , area -> x1 , area -> y1 , area -> x2 - area -> x1 , area -> y2 - area -> y1 );
static void gimp_display_paint_area(GimpDisplay *display,gint x,gint y,gint w,gint h)
GimpDisplayPrivate * private = ( GimpDisplayPrivate * ) ( g_type_instance_get_private ( ( ( GTypeInstance * ) display ) , gimp_display_get_type ( ) ) ) ;
GType gimp_display_get_type()
static volatile gsize g_define_type_id__volatile = 0 ;
GType g_define_type_id = g_type_register_static_simple ( gimp_object_get_type ( ) , g_intern_static_string ( "GimpDisplay" ) , ( sizeof ( GimpDisplayClass ) ) , ( ( GClassInitFunc ) gimp_display_class_intern_init ) , ( sizeof ( GimpDisplay ) ) , ( ( GInstanceInitFunc ) gimp_display_init ) , ( 0 ) ) ;
( void ) ( 0 ? ( * ( & g_define_type_id__volatile ) = g_define_type_id ) : 0 );
( void ) ( 0 ? ( * ( & g_define_type_id__volatile ) = ( ( gsize ) g_define_type_id ) ) : 0 );
return g_define_type_id__volatile ;
gint image_width = gimp_image_get_width ( ( private -> image ) ) ;
gint x2 ;
x2 = ( x + w > image_width ? image_width : ( ( x + w < 0 ? 0 : x + w ) ) );
w = x2 - x1;
gimp_display_shell_transform_xy_f ( shell , ( x + w ) , ( y + h ) , & x2_f , & y2_f );
gimp_display_shell_expose_area ( shell , x1 , y1 , x2 - x1 , y2 - y1 );
0
------------------------------
18043 CVE-2014-0182/qemu_1.6.0_CVE-2014-0182_virtio.c idx = ( idx + vring_used_idx ( vq ) ) % vq -> vring . num 259
void virtqueue_push(VirtQueue *vq, const VirtQueueElement
unsigned int len)
virtqueue_fill ( vq , elem , len , 0 );
void virtqueue_fill(VirtQueue *vq, const VirtQueueElement
unsigned int len, unsigned int idx)
idx = ( idx + vring_used_idx ( vq ) ) % vq -> vring . num;
static uint16_t vring_used_idx(VirtQueue *vq)
hwaddr pa ;
pa = vq -> vring . used + offsetof ( VRingUsed , idx );
return lduw_phys ( pa ) ;
vring_used_ring_id ( vq , idx , elem -> index );
static inline void vring_used_ring_id(VirtQueue *vq, int i, uint32_t val)
pa = vq -> vring . used + offsetof ( VRingUsed , ring [ i ] . id );
stl_phys ( pa , val );
vring_used_ring_len ( vq , idx , len );
static inline void vring_used_ring_len(VirtQueue *vq, int i, uint32_t val)
pa = vq -> vring . used + offsetof ( VRingUsed , ring [ i ] . len );
stl_phys ( pa , val );
0
------------------------------
312198 153760/aviobuf.c uint8_t * dst = ! s -> max_packet_size && s -> buf_end - s -> buffer < ( s -> buffer_size ) ? s -> buf_end : s -> buffer ; 476
unsigned int avio_rl24(AVIOContext *s)
unsigned int val ;
val = avio_rl16 ( s );
unsigned int avio_rl16(AVIOContext *s)
unsigned int val ;
val = ( avio_r8 ( s ) );
val |= ( avio_r8 ( s ) << 8 );
int avio_r8(AVIOContext *s)
if ( s -> buf_ptr >= s -> buf_end )
fill_buffer ( s );
static void fill_buffer(AVIOContext *s)
uint8_t * dst = ! s -> max_packet_size && s -> buf_end - s -> buffer < ( s -> buffer_size ) ? s -> buf_end : s -> buffer ;
int len = ( ( s -> buffer_size ) - ( dst - s -> buffer ) ) ;
if ( s -> update_checksum && dst == s -> buffer )
len = ( ( s -> read_packet ) ( s -> opaque , dst , len ) );
if ( len <= 0 )
if ( len < 0 )
s -> error = len;
s -> pos += len;
s -> buf_ptr = dst;
s -> buf_end = dst + len;
s -> bytes_read += len;
0
------------------------------
314612 97732/CWE36_Absolute_Path_Traversal__wchar_t_listen_socket_fopen_62b.cpp recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ) 101
void bad()
wchar_t * data ;
wchar_t dataBuffer [ FILENAME_MAX ] = L ""
data = dataBuffer;
badSource ( data );
void badSource(wchar_t * &data)
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( FILENAME_MAX - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
314107 110595/CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_rand_74b.cpp intPointer = ( int * ) malloc ( data * sizeof ( int ) ) 36
void bad()
int data ;
map < int , int > dataMap ;
data = - 1;
data = RAND32 ( );
dataMap [ 0 ] = data;
dataMap [ 1 ] = data;
dataMap [ 2 ] = data;
badSink ( dataMap );
void badSink(map<int, int> dataMap)
int data = dataMap [ 2 ] ;
int * intPointer ;
intPointer = ( int * ) malloc ( data * sizeof ( int ) );
intPointer [ i ] = 0;
printIntLine ( intPointer [ 0 ] );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
free ( intPointer );
1
------------------------------
16557 CVE-2010-3904/CVE_2010_3904_PATCHED_rds_page_copy_user.c ret = copy_from_user ( addr + offset , ptr , bytes ) 14
int CVE_2010_3904_PATCHED_rds_page_copy_user(struct page *page, unsigned long
void __user *ptr, unsigned long
int to_user)
unsigned long ret ;
void * addr ;
addr = kmap ( page );
if ( to_user )
ret = copy_from_user ( addr + offset , ptr , bytes );
0
------------------------------
311757 149958/aviobuf.c int len = ( s -> buf_end - s -> buf_ptr > size ? size : s -> buf_end - s -> buf_ptr ) ; 314
int avio_put_str(AVIOContext *s,const char *str)
int len = 1 ;
if ( str )
len += strlen ( str );
avio_write ( s , ( ( const unsigned char * ) str ) , len );
void avio_write(AVIOContext *s,const unsigned char *buf,int size)
if ( s -> direct && ! s -> update_checksum )
while ( size > 0 )
int len = ( s -> buf_end - s -> buf_ptr > size ? size : s -> buf_end - s -> buf_ptr ) ;
memcpy ( ( s -> buf_ptr ) , buf , len );
s -> buf_ptr += len;
if ( s -> buf_ptr >= s -> buf_end )
flush_buffer ( s );
buf += len;
size -= len;
0
------------------------------
310713 151133/utils.c print_fps ( 1 / av_q2d ( st -> codec -> time_base ) , "tbc" ) 3807
void av_dump_format(AVFormatContext *ic,int index,const char *url,int is_output)
uint8_t * printed = ( ic -> nb_streams ? av_mallocz ( ( ic -> nb_streams ) ) : ( ( void * ) 0 ) ) ;
if ( ic -> nb_streams && ! printed )
if ( ic -> nb_programs )
int j ;
int k ;
for (j = 0; j < ic -> nb_programs; j++)
for (k = 0; k < ic -> programs[j] -> nb_stream_indexes; k++)
dump_stream_format ( ic , ic -> programs [ j ] -> stream_index [ k ] , index , is_output );
static void dump_stream_format(AVFormatContext *ic,int i,int index,int is_output)
AVStream * st = ic -> streams [ i ] ;
if ( ( st -> codec -> codec_type ) == AVMEDIA_TYPE_VIDEO )
if ( st -> codec -> time_base . den && st -> codec -> time_base . num )
print_fps ( 1 / av_q2d ( st -> codec -> time_base ) , "tbc" );
0
------------------------------
300707 153516/dfa.c inputwcs = ( ( sizeof ( ( * inputwcs ) ) == 1 ? xmalloc ( ( end - begin + 2 ) ) : xnmalloc ( ( end - begin + 2 ) , sizeof ( ( * inputwcs ) ) ) ) ) 3555
char *dfaexec(struct dfa *d,const char *begin,char *end,int allow_nl,size_t *count,int *backref)
unsigned char eol = eolbyte ;
* end = eol;
if ( d -> mb_cur_max > 1 )
inputwcs = ( ( sizeof ( ( * inputwcs ) ) == 1 ? xmalloc ( ( end - begin + 2 ) ) : xnmalloc ( ( end - begin + 2 ) , sizeof ( ( * inputwcs ) ) ) ) );
while ( 0 )
while ( inputwcs [ p - buf_begin ] == 0 && mblen_buf [ p - buf_begin ] > 0 && ( ( const unsigned char * ) p ) < buf_end )
free ( inputwcs );
free ( inputwcs );
free ( inputwcs );
free ( inputwcs );
0
------------------------------
21025 CVE-2016-1981/qemu_1.6.0_CVE-2016-1981_e1000.c checksum = ( uint16_t ) EEPROM_SUM - checksum 1363
static int pci_e1000_init(PCIDevice *pci_dev)
E1000State * d = E1000 ( pci_dev ) ;
uint16_t checksum = 0 ;
int i ;
uint8_t * macaddr ;
memmove ( d -> eeprom_data , e1000_eeprom_template , sizeof e1000_eeprom_template );
macaddr = d -> conf . macaddr . a;
for (i = 0; i < 3; i++)
d -> eeprom_data [ i ] = ( macaddr [ 2 * i + 1 ] << 8 ) | macaddr [ 2 * i ];
for (i = 0; i < EEPROM_CHECKSUM_REG; i++)
checksum += d -> eeprom_data [ i ];
checksum = ( uint16_t ) EEPROM_SUM - checksum;
d -> eeprom_data [ EEPROM_CHECKSUM_REG ] = checksum;
d -> nic = qemu_new_nic ( & net_e1000_info , & d -> conf , object_get_typename ( OBJECT ( d ) ) , dev -> id , d );
qemu_format_nic_info_str ( qemu_get_queue ( d -> nic ) , macaddr );
add_boot_device_path ( d -> conf . bootindex , dev , "/ethernet-phy@0" );
d -> autoneg_timer = qemu_new_timer_ms ( vm_clock , e1000_autoneg_timer , d );
0
------------------------------
312111 153760/aviobuf.c s -> buf_end = dst + len 516
int avio_get_str16be(AVIOContext *pb,int maxlen,char *buf,int buflen)
int ret = 0 ;
if ( buflen <= 0 )
while ( ret + 1 < maxlen )
uint32_t ch ;
ch = ( ( ret += 2 ) <= maxlen ? avio_rb16 ( pb ) : 0 );
unsigned int hi = ch - 0xD800 ;
if ( hi < 0x800 )
ch = ( ( ret += 2 ) <= maxlen ? avio_rb16 ( pb ) : ( 0 - 0xDC00 ) );
if ( ch > 0x3FFU || hi > 0x3FFU )
ch += ( hi << 10 ) + 0x10000;
if ( ! ch )
unsigned int avio_rb16(AVIOContext *s)
unsigned int val ;
val = ( avio_r8 ( s ) << 8 );
int avio_r8(AVIOContext *s)
if ( s -> buf_ptr >= s -> buf_end )
fill_buffer ( s );
static void fill_buffer(AVIOContext *s)
uint8_t * dst = ! s -> max_packet_size && s -> buf_end - s -> buffer < ( s -> buffer_size ) ? s -> buf_end : s -> buffer ;
int len = ( ( s -> buffer_size ) - ( dst - s -> buffer ) ) ;
int max_buffer_size = s -> max_packet_size ? s -> max_packet_size : 32768 ;
if ( ! s -> read_packet && s -> buf_ptr >= s -> buf_end )
s -> eof_reached = 1;
if ( s -> eof_reached )
if ( s -> update_checksum && dst == s -> buffer )
if ( s -> buf_end > s -> checksum_ptr )
s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_end - s -> checksum_ptr ) ) );
s -> checksum_ptr = s -> buffer;
if ( s -> read_packet && s -> buffer_size > max_buffer_size )
s -> checksum_ptr = dst = s -> buffer;
len = s -> buffer_size;
if ( s -> read_packet )
len = ( ( s -> read_packet ) ( s -> opaque , dst , len ) );
len = 0;
if ( len <= 0 )
s -> eof_reached = 1;
if ( len < 0 )
s -> error = len;
s -> pos += len;
s -> buf_ptr = dst;
s -> buf_end = dst + len;
s -> bytes_read += len;
0
------------------------------
298964 95001/CWE369_Divide_by_Zero__int_connect_socket_divide_67b.c printIntLine ( 100 / data ) 53
void CWE369_Divide_by_Zero__int_connect_socket_divide_67_bad()
int data ;
CWE369_Divide_by_Zero__int_connect_socket_divide_67_structType myStruct ;
data = - 1;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
char inputBuffer [ CHAR_ARRAY_SIZE ] ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
inputBuffer [ recvResult ] = '\0';
data = atoi ( inputBuffer );
while ( 0 )
myStruct . structFirst = data;
CWE369_Divide_by_Zero__int_connect_socket_divide_67b_badSink ( myStruct );
void CWE369_Divide_by_Zero__int_connect_socket_divide_67b_badSink(CWE369_Divide_by_Zero__int_connect_socket_divide_67_structType myStruct)
int data = myStruct . structFirst ;
printIntLine ( 100 / data );
1
------------------------------
304131 80748/CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_vprintf_21.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 ) 106
void CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_vprintf_21_bad()
wchar_t * data ;
wchar_t dataBuffer [ 100 ] = L ""
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
20547 CVE-2016-4998/linux_kernel_4.5.7_CVE_2016_4998_net_ipv4_netfilter_ip_tables.c ret = check_entry_size_and_hooks ( iter , newinfo , entry0 , entry0 + repl -> size , repl -> hook_entry , repl -> underflow , repl -> valid_hooks ) 826
struct xt_table *ipt_register_table(struct net
const struct xt_table
const struct ipt_replace *repl)
int ret ;
struct xt_table_info * newinfo ;
void * loc_cpu_entry ;
newinfo = xt_alloc_table_info ( repl -> size );
if ( ! newinfo )
loc_cpu_entry = newinfo -> entries;
memcpy ( loc_cpu_entry , repl -> entries , repl -> size );
ret = translate_table ( net , newinfo , loc_cpu_entry , repl );
static
translate_table(struct net *net, struct xt_table_info *newinfo, void
const struct ipt_replace *repl)
struct ipt_entry * iter ;
unsigned int i ;
newinfo -> size = repl -> size;
newinfo -> number = repl -> num_entries;
for (i = 0; i < NF_INET_NUMHOOKS; i++)
newinfo -> hook_entry [ i ] = 0xFFFFFFFF;
newinfo -> underflow [ i ] = 0xFFFFFFFF;
ret = check_entry_size_and_hooks ( iter , newinfo , entry0 , entry0 + repl -> size , repl -> hook_entry , repl -> underflow , repl -> valid_hooks );
static
check_entry_size_and_hooks(struct ipt_entry
struct xt_table_info
const unsigned char
const unsigned char
const unsigned int
const unsigned int
unsigned int valid_hooks)
unsigned int h ;
return - EINVAL ;
if ( e -> next_offset < sizeof ( struct ipt_entry ) + sizeof ( struct xt_entry_target ) )
return - EINVAL ;
for (h = 0; h < NF_INET_NUMHOOKS; h++)
if ( ! ( valid_hooks & ( 1 << h ) ) )
if ( ( unsigned char * ) e - base == hook_entries [ h ] )
newinfo -> hook_entry [ h ] = hook_entries [ h ];
if ( ( unsigned char * ) e - base == underflows [ h ] )
if ( ! check_underflow ( e ) )
static bool check_underflow(const struct ipt_entry *e)
const struct xt_entry_target * t ;
unsigned int verdict ;
if ( ! unconditional ( & e -> ip ) )
static inline bool unconditional(const struct ipt_ip *ip)
static const struct ipt_ip uncond ;
return memcmp ( ip , & uncond , sizeof ( uncond ) ) == 0 ;
return false ;
t = ipt_get_target_c ( e );
static inline const struct xt_entry_target
ipt_get_target_c(const struct ipt_entry *e)
return ipt_get_target ( ( struct ipt_entry * ) e ) ;
if ( strcmp ( t -> u . user . name , XT_STANDARD_TARGET ) != 0 )
return false ;
verdict = ( ( struct xt_standard_target * ) t ) -> verdict;
verdict = - verdict - 1;
return verdict == NF_DROP || verdict == NF_ACCEPT ;
return - EINVAL ;
newinfo -> underflow [ h ] = underflows [ h ];
return 0 ;
if ( ret != 0 )
return ret ;
if ( ret != 0 )
if ( ret != 0 )
return ret ;
return ret ;
0
------------------------------
18917 CVE-2015-2716/Firefox_37.0b7_CVE_2015_2716_parser_expat_lib_xmlparse.c pool -> end = pool -> start + pool -> blocks -> size 6238
static
reportProcessingInstruction(XML_Parser parser, const ENCODING
const char *start, const char *end)
const XML_Char * target ;
const char * tem ;
if ( ! processingInstructionHandler )
start += enc -> minBytesPerChar * 2;
tem = start + XmlNameLength ( enc , start );
target = poolStoreString ( & tempPool , enc , start , tem );
static XML_Char
poolStoreString(STRING_POOL *pool, const ENCODING
const char *ptr, const char *end)
if ( ! poolAppend ( pool , enc , ptr , end ) )
static XML_Char
poolAppend(STRING_POOL *pool, const ENCODING
const char *ptr, const char *end)
if ( ! pool -> ptr && ! poolGrow ( pool ) )
if ( ptr == end )
if ( ! poolGrow ( pool ) )
static XML_Bool
poolGrow(STRING_POOL *pool)
if ( pool -> freeBlocks )
if ( pool -> start == 0 )
pool -> blocks = pool -> freeBlocks;
pool -> freeBlocks = pool -> freeBlocks -> next;
pool -> blocks -> next = NULL;
pool -> start = pool -> blocks -> s;
pool -> end = pool -> start + pool -> blocks -> size;
pool -> ptr = pool -> start;
0
------------------------------
308392 109217/CWE606_Unchecked_Loop_Condition__wchar_t_connect_socket_84_goodB2G.cpp recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 ) 84
static void goodB2G()
wchar_t * data ;
wchar_t dataBuffer [ 100 ] = L ""
data = dataBuffer;
CWE606_Unchecked_Loop_Condition__wchar_t_connect_socket_84_goodB2G * goodB2GObject = new CWE606_Unchecked_Loop_Condition__wchar_t_connect_socket_84_goodB2G ( data ) ;
CWE606_Unchecked_Loop_Condition__wchar_t_connect_socket_84_goodB2G::CWE606_Unchecked_Loop_Condition__wchar_t_connect_socket_84_goodB2G(wchar_t * dataCopy)
data = dataCopy;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
305105 94280/CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_66a.c recvResult = recv ( acceptSocket , ( char * ) ( password + passwordLen ) , ( 100 - passwordLen - 1 ) * sizeof ( wchar_t ) , 0 ) 83
void CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_66_bad()
wchar_t * password ;
wchar_t passwordBuffer [ 100 ] = L ""
password = passwordBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t passwordLen = wcslen ( password ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( password + passwordLen ) , ( 100 - passwordLen - 1 ) * sizeof ( wchar_t ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
1
------------------------------
306700 118074/CWE78_OS_Command_Injection__char_connect_socket_popen_63a.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 103
void CWE78_OS_Command_Injection__char_connect_socket_popen_63_bad()
char * data ;
char data_buf [ 100 ] = FULL_COMMAND ;
data = data_buf;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
CWE78_OS_Command_Injection__char_connect_socket_popen_63b_badSink ( & data );
void CWE78_OS_Command_Injection__char_connect_socket_popen_63b_badSink(char * * dataPtr)
char * data = * dataPtr ;
pipe = POPEN ( data , "wb" );
if ( pipe != NULL )
PCLOSE ( pipe );
0
------------------------------
300099 150238/gimpdisplay.c stonesoup_arr [ stonesoup_j ] = threadTiming - stonesoup_j 221
void *toCaps(void *data)
int threadTiming = 500000 ;
int stonesoup_j ;
int * stonesoup_arr ;
stonesoup_arr = malloc ( sizeof ( int ) * threadTiming );
if ( stonesoup_arr != NULL )
for (stonesoup_j = 0; stonesoup_j < threadTiming; stonesoup_j++)
stonesoup_arr [ stonesoup_j ] = threadTiming - stonesoup_j;
qsort ( stonesoup_arr , threadTiming , sizeof ( int ) , & stonesoup_comp );
free ( stonesoup_arr );
0
------------------------------
305073 95184/CWE369_Divide_by_Zero__int_fscanf_divide_52c.c printIntLine ( 100 / data ) 45
static void goodB2G()
int data ;
data = - 1;
CWE369_Divide_by_Zero__int_fscanf_divide_52b_goodB2GSink ( data );
void CWE369_Divide_by_Zero__int_fscanf_divide_52b_goodB2GSink(int data)
CWE369_Divide_by_Zero__int_fscanf_divide_52c_goodB2GSink ( data );
void CWE369_Divide_by_Zero__int_fscanf_divide_52c_goodB2GSink(int data)
if ( data != 0 )
printIntLine ( 100 / data );
0
------------------------------
309130 119951/CWE78_OS_Command_Injection__char_listen_socket_execlp_68a.c recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 120
void CWE78_OS_Command_Injection__char_listen_socket_execlp_68_bad()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
CWE78_OS_Command_Injection__char_listen_socket_execlp_68_badData = data;
0
------------------------------
299869 153756/utf.c invalid = ( data + len - last ) 673
svn_error_t *svn_utf_cstring_from_utf8_ex(const char **dest,const char *src,const char *topage,const char *convset_key,apr_pool_t *pool)
return svn_utf_cstring_from_utf8_ex2 ( dest , src , topage , pool ) ;
svn_error_t *svn_utf_cstring_from_utf8_ex2(const char **dest,const char *src,const char *topage,apr_pool_t *pool)
svn_error_t * svn_err__temp = check_cstring_utf8 ( src , pool ) ;
if ( svn_err__temp )
while ( 0 )
static svn_error_t *check_cstring_utf8(const char *data,apr_pool_t *pool)
if ( ! svn_utf__cstring_is_valid ( data ) )
return invalid_utf8 ( data , strlen ( data ) , pool ) ;
static svn_error_t *invalid_utf8(const char *data,apr_size_t len,apr_pool_t *pool)
const char * last = svn_utf__last_valid ( data , len ) ;
size_t invalid ;
invalid = ( data + len - last );
if ( invalid > 4 )
for (i = 0; i < invalid; ++i)
0
------------------------------
298393 94963/CWE369_Divide_by_Zero__int_connect_socket_divide_02.c printIntLine ( 100 / data ) 301
static void goodG2B1()
int data ;
data = - 1;
if ( 0 )
data = 7;
if ( 1 )
printIntLine ( 100 / data );
0
------------------------------
20635 CVE-2016-8910/qemu_2.3.0_CVE-2016-8910_rtl8139.c ret = s -> phys [ addr - MAC0 ] 2968
static uint32_t rtl8139_mmio_readl(void *opaque, hwaddr addr)
uint32_t val = rtl8139_io_readl ( opaque , addr & 0xFF ) ;
static uint32_t rtl8139_io_readl(void *opaque, uint8_t addr)
RTL8139State * s = opaque ;
uint32_t ret ;
switch ( addr )
ret = s -> RxMissed;
ret = rtl8139_TxConfig_read ( s );
static uint32_t rtl8139_TxConfig_read(RTL8139State *s)
uint32_t ret = s -> TxConfig ;
return ret ;
ret = rtl8139_RxConfig_read ( s );
static uint32_t rtl8139_RxConfig_read(RTL8139State *s)
uint32_t ret = s -> RxConfig ;
return ret ;
ret = rtl8139_TxStatus_TxAddr_read ( s , s -> TxStatus , TxStatus0 , addr , 4 );
static uint32_t rtl8139_TxStatus_TxAddr_read(RTL8139State *s, uint32_t
uint32_t base, uint8_t
int size)
uint32_t reg = ( addr - base ) / 4 ;
uint32_t offset = addr & 0x3 ;
uint32_t ret = 0 ;
if ( addr & ( size - 1 ) )
return ret ;
switch ( size )
ret = ( regs [ reg ] >> offset * 8 ) & ( ( ( uint64_t ) 1 << ( size * 8 ) ) - 1 );
return ret ;
ret = rtl8139_TxAddr_read ( s , addr - TxAddr0 );
static uint32_t rtl8139_TxAddr_read(RTL8139State *s, uint32_t txAddrOffset)
uint32_t ret = s -> TxAddr [ txAddrOffset / 4 ] ;
return ret ;
ret = rtl8139_RxBuf_read ( s );
static uint32_t rtl8139_RxBuf_read(RTL8139State *s)
uint32_t ret = s -> RxBuf ;
return ret ;
ret = s -> RxRingAddrLO;
ret = s -> RxRingAddrHI;
ret = muldiv64 ( qemu_clock_get_ns ( QEMU_CLOCK_VIRTUAL ) - s -> TCTR_base , PCI_FREQUENCY , get_ticks_per_sec ( ) );
ret = s -> TimerInt;
ret = rtl8139_io_readb ( opaque , addr );
ret |= rtl8139_io_readb ( opaque , addr + 1 ) << 8;
ret |= rtl8139_io_readb ( opaque , addr + 2 ) << 16;
static uint32_t rtl8139_io_readb(void *opaque, uint8_t addr)
RTL8139State * s = opaque ;
int ret ;
switch ( addr )
ret = s -> phys [ addr - MAC0 ];
DPRINTF ( "MediaStatus read 0x%x\n" , ret );
DPRINTF ( "HltClk read 0x%x\n" , ret );
DPRINTF ( "PCI Revision ID read 0x%x\n" , ret );
DPRINTF ( "C+ TxThresh read(b) val=0x%02x\n" , ret );
DPRINTF ( "RTL8139C TxConfig at 0x43 read(b) val=0x%02x\n" , ret );
return ret ;
0
------------------------------
17251 CVE-2008-0420/CVE_2008_0420_VULN_nsBMPDecoder__ProcessData.c PRUint32 colorBytes = mPos - mLOH ; 95
NS_METHOD CVE_2008_0420_VULN_nsBMPDecoder::ProcessData(const char* aBuffer, PRUint32 aCount)
if ( ! aCount || ! mCurLine )
if ( mPos < BFH_LENGTH )
PRUint32 toCopy = BFH_LENGTH - mPos ;
if ( toCopy > aCount )
toCopy = aCount;
mPos += toCopy;
aCount -= toCopy;
if ( mPos == BFH_LENGTH )
if ( mBFH . signature [ 0 ] != 'B' || mBFH . signature [ 1 ] != 'M' )
if ( mBFH . bihsize == OS2_BIH_LENGTH )
mLOH = OS2_HEADER_LENGTH;
if ( mPos >= BFH_LENGTH && mPos < mLOH )
PRUint32 toCopy = mLOH - mPos ;
if ( toCopy > aCount )
toCopy = aCount;
mPos += toCopy;
if ( mPos == mLOH )
if ( mBIH . bpp != 1 && mBIH . bpp != 4 && mBIH . bpp != 8 && mBIH . bpp != 16 && mBIH . bpp != 24 && mBIH . bpp != 32 )
if ( mBIH . bpp <= 8 )
mNumColors = 1 << mBIH . bpp;
if ( mBIH . colors && mBIH . colors < mNumColors )
mNumColors = mBIH . colors;
mColors = new colorTable [ mNumColors ];
if ( ! mColors )
if ( mBIH . width < 0 )
mRow = new PRUint8 [ ( mBIH . width * mBIH . bpp ) / 8 + 4 ];
if ( ! mRow )
PRUint8 bpc ;
bpc = ( mBFH . bihsize == OS2_BIH_LENGTH ) ? 3 : 4;
if ( mColors && ( mPos >= mLOH && ( mPos < ( mLOH + mNumColors * bpc ) ) ) )
PRUint32 colorBytes = mPos - mLOH ;
1
------------------------------
298337 94129/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_connect_socket_53a.c recvResult = recv ( connectSocket , ( char * ) ( password + passwordLen ) , ( 100 - passwordLen - 1 ) * sizeof ( char ) , 0 ) 73
void CWE319_Cleartext_Tx_Sensitive_Info__w32_char_connect_socket_53_bad()
char * password ;
char passwordBuffer [ 100 ] = "" ;
password = passwordBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t passwordLen = strlen ( password ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( password + passwordLen ) , ( 100 - passwordLen - 1 ) * sizeof ( char ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
password [ passwordLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( password , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( password , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
CWE319_Cleartext_Tx_Sensitive_Info__w32_char_connect_socket_53b_badSink ( password );
void CWE319_Cleartext_Tx_Sensitive_Info__w32_char_connect_socket_53b_badSink(char * password)
CWE319_Cleartext_Tx_Sensitive_Info__w32_char_connect_socket_53c_badSink ( password );
void CWE319_Cleartext_Tx_Sensitive_Info__w32_char_connect_socket_53c_badSink(char * password)
CWE319_Cleartext_Tx_Sensitive_Info__w32_char_connect_socket_53d_badSink ( password );
void CWE319_Cleartext_Tx_Sensitive_Info__w32_char_connect_socket_53d_badSink(char * password)
if ( LogonUserA ( username , domain , password , LOGON32_LOGON_NETWORK , LOGON32_PROVIDER_DEFAULT , & pHandle ) != 0 )
1
------------------------------
309870 152022/pgstat.c stonesoup_file_list = malloc ( stonesoup_num_files * sizeof ( FILE * ) ) 4145
void quitch_schacht(int interconal_collectivizing,char ***reindictment_histrion)
desiccations_harriman ( interconal_collectivizing , reindictment_histrion );
void desiccations_harriman(int synthesizing_confectioner,char ***mallowwort_susiana)
synthesizing_confectioner --;
if ( synthesizing_confectioner > 0 )
quitch_schacht ( synthesizing_confectioner , mallowwort_susiana );
void quitch_schacht(int interconal_collectivizing,char ***reindictment_histrion)
desiccations_harriman ( interconal_collectivizing , reindictment_histrion );
void desiccations_harriman(int synthesizing_confectioner,char ***mallowwort_susiana)
FILE * * stonesoup_file_list ;
FILE * stonesoup_files ;
char * * stonesoup_str_list ;
int stonesoup_num_files = 10 ;
synthesizing_confectioner --;
if ( synthesizing_confectioner > 0 )
arcadic_miseries = ( ( char * ) ( * ( * mallowwort_susiana ) ) );
stonesoup_str_list = malloc ( sizeof ( char * ) * stonesoup_num_files );
if ( stonesoup_str_list != 0 )
stonesoup_files = fopen ( arcadic_miseries , "rb" );
if ( stonesoup_files != 0 )
stonesoup_file_list = malloc ( stonesoup_num_files * sizeof ( FILE * ) );
if ( stonesoup_file_list == 0 )
stonesoup_file_list [ stonesoup_ssi ] = fopen ( stonesoup_filename , "rb" );
while ( stonesoup_ssi < stonesoup_num_files )
stonesoup_file = stonesoup_file_list [ stonesoup_ssi ];
if ( stonesoup_file == 0 )
fseek ( stonesoup_file , 0 , 2 );
stonesoup_size = ftell ( stonesoup_file );
rewind ( stonesoup_file );
stonesoup_contents = malloc ( ( stonesoup_size + 1 ) * sizeof ( char ) );
if ( stonesoup_contents == 0 && errno == 12 )
if ( stonesoup_contents == 0 )
fclose ( stonesoup_file );
memset ( stonesoup_contents , 0 , ( stonesoup_size + 1 ) * sizeof ( char ) );
fread ( stonesoup_contents , 1 , stonesoup_size , stonesoup_file );
stonesoup_contents = stonesoup_isAlphaNum ( stonesoup_contents , stonesoup_size );
stonesoup_str_list [ stonesoup_ssi ] = stonesoup_contents;
fclose ( stonesoup_file );
stonesoup_ssi ++;
if ( stonesoup_file_list != 0 )
free ( stonesoup_file_list );
stonesoup_cleanup ( stonesoup_str_list , stonesoup_num_files );
free ( stonesoup_str_list );
1
------------------------------
302976 79308/CWE134_Uncontrolled_Format_String__char_connect_socket_vprintf_21.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 106
void CWE134_Uncontrolled_Format_String__char_connect_socket_vprintf_21_bad()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
badVaSink ( data , data );
static void badVaSink(char * data, ...)
va_start ( args , data );
vprintf ( data , args );
1
------------------------------
301086 153289/aviobuf.c s -> buf_end = dst + len 520
unsigned int avio_rl32(AVIOContext *s)
unsigned int val ;
val = avio_rl16 ( s );
unsigned int avio_rl16(AVIOContext *s)
unsigned int val ;
val = ( avio_r8 ( s ) );
int avio_r8(AVIOContext *s)
if ( s -> buf_ptr >= s -> buf_end )
fill_buffer ( s );
static void fill_buffer(AVIOContext *s)
uint8_t * dst = ! s -> max_packet_size && s -> buf_end - s -> buffer < ( s -> buffer_size ) ? s -> buf_end : s -> buffer ;
int len = ( ( s -> buffer_size ) - ( dst - s -> buffer ) ) ;
int max_buffer_size = s -> max_packet_size ? s -> max_packet_size : 32768 ;
if ( ! s -> read_packet && s -> buf_ptr >= s -> buf_end )
s -> eof_reached = 1;
if ( s -> eof_reached )
if ( s -> update_checksum && dst == s -> buffer )
if ( s -> buf_end > s -> checksum_ptr )
s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_end - s -> checksum_ptr ) ) );
s -> checksum_ptr = s -> buffer;
if ( s -> read_packet && s -> buffer_size > max_buffer_size )
s -> checksum_ptr = dst = s -> buffer;
len = s -> buffer_size;
if ( s -> read_packet )
len = ( ( s -> read_packet ) ( s -> opaque , dst , len ) );
len = 0;
if ( len <= 0 )
s -> eof_reached = 1;
if ( len < 0 )
s -> error = len;
s -> pos += len;
s -> buf_ptr = dst;
s -> buf_end = dst + len;
s -> bytes_read += len;
0
------------------------------
305279 94265/CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_34.c recvResult = recv ( acceptSocket , ( char * ) ( password + passwordLen ) , ( 100 - passwordLen - 1 ) * sizeof ( wchar_t ) , 0 ) 86
void CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_listen_socket_34_bad()
wchar_t * password ;
wchar_t passwordBuffer [ 100 ] = L ""
password = passwordBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t passwordLen = wcslen ( password ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( password + passwordLen ) , ( 100 - passwordLen - 1 ) * sizeof ( wchar_t ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
1
------------------------------
311899 153171/dfa.c work_mbls = check_matching_with_multibyte_ops ( d , s , ( * pp - buf_begin ) ) 3410
char *dfaexec(struct dfa *d,const char *begin,char *end,int allow_nl,size_t *count,int *backref)
state_num s ;
state_num s1 ;
const unsigned char * p ;
state_num * * trans ;
state_num * t ;
unsigned char eol = eolbyte ;
s = s1 = 0;
p = ( ( const unsigned char * ) begin );
trans = d -> trans;
* end = eol;
if ( d -> mb_cur_max > 1 )
while ( ( t = trans [ s ] ) != ( ( void * ) 0 ) )
if ( p > buf_end )
s1 = s;
if ( s == 0 )
if ( ( ( char * ) p ) >= end )
if ( d -> states [ s ] . mbps . nelem == 0 )
s = t [ * ( p ++ ) ];
if ( backref )
s = transit_state ( d , s , & p );
trans = d -> trans;
while ( ( t = trans [ s ] ) != ( ( void * ) 0 ) )
s1 = t [ * ( p ++ ) ];
if ( ( t = trans [ s1 ] ) == ( ( void * ) 0 ) )
state_num tmp = s ;
s = s1;
s1 = tmp;
s = t [ * ( p ++ ) ];
if ( s >= 0 && ( ( char * ) p ) <= end && d -> fails [ s ] )
if ( d -> success [ s ] & sbit [ * p ] )
s1 = s;
if ( d -> mb_cur_max > 1 )
s = transit_state ( d , s , & p );
trans = d -> trans;
s = d -> fails [ s ] [ * ( p ++ ) ];
if ( ( ( char * ) p ) > end )
if ( s >= 0 )
trans = d -> trans;
if ( p [ - 1 ] == eol && allow_nl )
s = d -> newlines [ s1 ];
s = 0;
static state_num transit_state(struct dfa *d,state_num s,const unsigned char **pp)
int mbclen ;
int maxlen = 0 ;
size_t i ;
int * match_lens = ( ( void * ) 0 ) ;
size_t nelem = d -> states [ s ] . mbps . nelem ;
position_set follows ;
if ( nelem > 0 )
match_lens = check_matching_with_multibyte_ops ( d , s , ( * pp - buf_begin ) );
for (i = 0; i < nelem; i++)
if ( match_lens [ i ] > maxlen )
maxlen = match_lens [ i ];
if ( nelem == 0 || maxlen == 0 )
transit_state_consume_1char ( d , s , pp , match_lens , & mbclen , & follows );
static status_transit_state transit_state_consume_1char(struct dfa *d,state_num s,const unsigned char **pp,int *match_lens,int *mbclen,position_set *pps)
int k ;
state_num s1 ;
state_num s2 ;
int * work_mbls ;
* mbclen = ( mblen_buf [ * pp - buf_begin ] == 0 ? 1 : mblen_buf [ * pp - buf_begin ] );
s1 = s;
for (k = 0; k <  *mbclen; k++)
s2 = s1;
rs = transit_state_singlebyte ( d , s2 , ( * pp ) ++ , & s1 );
if ( match_lens == ( ( void * ) 0 ) && d -> states [ s ] . mbps . nelem != 0 )
work_mbls = check_matching_with_multibyte_ops ( d , s , ( * pp - buf_begin ) );
if ( work_mbls [ i ] == * mbclen )
if ( match_lens == ( ( void * ) 0 ) && work_mbls != ( ( void * ) 0 ) )
free ( work_mbls );
0
------------------------------
305553 62232/CWE114_Process_Control__w32_wchar_t_connect_socket_05.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 ) 95
void CWE114_Process_Control__w32_wchar_t_connect_socket_05_bad()
wchar_t * data ;
wchar_t dataBuffer [ 100 ] = L ""
data = dataBuffer;
if ( staticTrue )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
17788 CVE-2015-5366/linux_kernel_3.11.9_CVE_2015_5366_net_ipv4_udp.c uh -> len = htons ( skb -> len - udp_offset ) 2336
struct sk_buff *skb_udp_tunnel_segment(struct sk_buff
netdev_features_t features)
int mac_len = skb -> mac_len ;
int tnl_hlen = skb_inner_mac_header ( skb ) - skb_transport_header ( skb ) ;
__be16 protocol = skb -> protocol ;
netdev_features_t enc_features ;
int outer_hlen ;
if ( unlikely ( ! pskb_may_pull ( skb , tnl_hlen ) ) )
skb -> encapsulation = 0;
skb -> mac_len = skb_inner_network_offset ( skb );
skb -> protocol = htons ( ETH_P_TEB );
enc_features = skb -> dev -> hw_enc_features & netif_skb_features ( skb );
segs = skb_mac_gso_segment ( skb , enc_features );
if ( ! segs || IS_ERR ( segs ) )
outer_hlen = skb_tnl_header_len ( skb );
skb = segs;
struct udphdr * uh ;
int udp_offset = outer_hlen - tnl_hlen ;
skb -> encapsulation = 1;
skb -> mac_len = mac_len;
uh = udp_hdr ( skb );
uh -> len = htons ( skb -> len - udp_offset );
if ( unlikely ( uh -> check ) )
uh -> check = ~csum_tcpudp_magic ( iph -> saddr , iph -> daddr , skb -> len - udp_offset , IPPROTO_UDP , 0 );
uh -> check = csum_fold ( skb_checksum ( skb , udp_offset , skb -> len - udp_offset , 0 ) );
if ( uh -> check == 0 )
uh -> check = CSUM_MANGLED_0;
skb -> protocol = protocol;
while ( skb = skb -> next )
0
------------------------------
309633 150700/mux.c st -> pts_buffer [ i ] = pkt -> pts + ( ( i - delay - 1 ) * pkt -> duration ) 615
int av_interleaved_write_frame(AVFormatContext *s,AVPacket *pkt)
int ret ;
if ( pkt )
AVStream * st = s -> streams [ pkt -> stream_index ] ;
if ( ( st -> codec -> codec_type ) == AVMEDIA_TYPE_AUDIO && pkt -> size == 0 )
if ( ( ret = compute_pkt_fields2 ( s , st , pkt ) ) < 0 && ! ( s -> oformat -> flags & 0x80 ) )
static int compute_pkt_fields2(AVFormatContext *s,AVStream *st,AVPacket *pkt)
int delay = st -> codec -> has_b_frames > ( st -> codec -> max_b_frames > 0 ) ? st -> codec -> has_b_frames : st -> codec -> max_b_frames > 0 ;
int num ;
int den ;
int i ;
if ( pkt -> duration == 0 )
if ( den && num )
pkt -> duration = ( av_rescale ( 1 , num * ( ( int64_t ) st -> time_base . den ) * ( st -> codec -> ticks_per_frame ) , den * ( ( int64_t ) st -> time_base . num ) ) );
if ( pkt -> pts == ( ( int64_t ) 0x8000000000000000UL ) && pkt -> dts != ( ( int64_t ) 0x8000000000000000UL ) && delay == 0 )
pkt -> pts = pkt -> dts;
if ( ( pkt -> pts == 0 || pkt -> pts == ( ( int64_t ) 0x8000000000000000UL ) ) && pkt -> dts == ( ( int64_t ) 0x8000000000000000UL ) && ! delay )
pkt -> dts = pkt -> pts = st -> pts . val;
if ( pkt -> pts != ( ( int64_t ) 0x8000000000000000UL ) && pkt -> dts == ( ( int64_t ) 0x8000000000000000UL ) && delay <= 16 )
st -> pts_buffer [ 0 ] = pkt -> pts;
for (i = 1; i < delay + 1 && st -> pts_buffer[i] == ((int64_t )0x8000000000000000UL); i++)
st -> pts_buffer [ i ] = pkt -> pts + ( ( i - delay - 1 ) * pkt -> duration );
for (i = 0; i < delay && st -> pts_buffer[i] > st -> pts_buffer[i + 1]; i++)
int64_t SWAP_tmp = st -> pts_buffer [ i + 1 ] ;
st -> pts_buffer [ i + 1 ] = st -> pts_buffer [ i ];
st -> pts_buffer [ i ] = SWAP_tmp;
pkt -> dts = st -> pts_buffer [ 0 ];
if ( st -> cur_dts && st -> cur_dts != ( ( int64_t ) 0x8000000000000000UL ) && ( ! ( s -> oformat -> flags & 0x8020000 ) && st -> cur_dts >= pkt -> dts || st -> cur_dts > pkt -> dts ) )
av_log ( s , 16 , "Application provided invalid, non monotonically increasing dts to muxer in stream %d: %s >= %s\n" , st -> index , av_ts_make_string ( ( ( char [ 32 ] ) ( 0 ) ) , st -> cur_dts ) , av_ts_make_string ( ( ( char [ 32 ] ) ( 0 ) ) , pkt -> dts ) )
if ( pkt -> dts != ( ( int64_t ) 0x8000000000000000UL ) && pkt -> pts != ( ( int64_t ) 0x8000000000000000UL ) && pkt -> pts < pkt -> dts )
av_log ( s , 16 , "pts (%s) < dts (%s) in stream %d\n" , av_ts_make_string ( ( ( char [ 32 ] ) ( 0 ) ) , pkt -> pts ) , av_ts_make_string ( ( ( char [ 32 ] ) ( 0 ) ) , pkt -> dts ) , st -> index )
av_log ( s , 48 , "av_write_frame: pts2:%s dts2:%s\n" , av_ts_make_string ( ( ( char [ 32 ] ) ( 0 ) ) , pkt -> pts ) , av_ts_make_string ( ( ( char [ 32 ] ) ( 0 ) ) , pkt -> dts ) )
st -> cur_dts = pkt -> dts;
st -> pts . val = pkt -> dts;
switch ( st -> codec -> codec_type )
frame_size = ff_get_audio_frame_size ( st -> codec , pkt -> size , 1 );
if ( frame_size >= 0 && ( pkt -> size || st -> pts . num != st -> pts . den >> 1 || st -> pts . val ) )
frac_add ( & st -> pts , ( ( int64_t ) st -> time_base . den ) * frame_size );
frac_add ( & st -> pts , ( ( int64_t ) st -> time_base . den ) * st -> codec -> time_base . num );
0
------------------------------
314157 110805/CWE680_Integer_Overflow_to_Buffer_Overflow__new_listen_socket_14.cpp dataBytes = data * sizeof ( int ) 127
void bad()
int data ;
data = - 1;
if ( globalFive == 5 )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
char inputBuffer [ CHAR_ARRAY_SIZE ] ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
inputBuffer [ recvResult ] = '\0';
data = atoi ( inputBuffer );
while ( 0 )
size_t dataBytes , i ;
dataBytes = data * sizeof ( int );
intPointer = ( int * ) new char [ dataBytes ];
intPointer [ i ] = 0;
printIntLine ( intPointer [ 0 ] );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
delete [ ] intPointer
1
------------------------------
299014 62459/CWE114_Process_Control__w32_wchar_t_listen_socket_67a.c recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 ) 103
void CWE114_Process_Control__w32_wchar_t_listen_socket_67_bad()
wchar_t * data ;
wchar_t dataBuffer [ 100 ] = L ""
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
16804 CVE-2010-2537/CVE_2010_2537_PATCHED_btrfs_ioctl_clone.c datal = off + len - key . offset 213
static noinline long CVE_2010_2537_PATCHED_btrfs_ioctl_clone(struct file *file, unsigned long
u64 off, u64 olen, u64 destoff)
struct inode * inode = fdentry ( file ) -> d_inode ;
struct btrfs_root * root = BTRFS_I ( inode ) -> root ;
struct file * src_file ;
struct inode * src ;
struct btrfs_trans_handle * trans ;
struct btrfs_path * path ;
struct extent_buffer * leaf ;
char * buf ;
struct btrfs_key key ;
u32 nritems ;
int slot ;
int ret ;
u64 len = olen ;
u64 bs = root -> fs_info -> sb -> s_blocksize ;
if ( ! ( file -> f_mode & FMODE_WRITE ) || ( file -> f_flags & O_APPEND ) )
ret = mnt_want_write ( file -> f_path . mnt );
if ( ret )
src_file = fget ( srcfd );
if ( ! src_file )
src = src_file -> f_dentry -> d_inode;
if ( src == inode )
if ( ! ( src_file -> f_mode & FMODE_READ ) )
if ( S_ISDIR ( src -> i_mode ) || S_ISDIR ( inode -> i_mode ) )
ret = - EXDEV;
if ( src -> i_sb != inode -> i_sb || BTRFS_I ( src ) -> root != root )
ret = - ENOMEM;
buf = vmalloc ( btrfs_level_size ( root , 0 ) );
if ( ! buf )
path = btrfs_alloc_path ( );
if ( ! path )
path -> reada = 2;
ret = - EINVAL;
if ( off + len > src -> i_size || off + len < off )
if ( len == 0 )
olen = len = src -> i_size - off;
if ( off + len == src -> i_size )
len = ( ( src -> i_size + bs - 1 ) & ~ ( bs - 1 ) ) - off;
if ( ( off & ( bs - 1 ) ) || ( ( off + len ) & ( bs - 1 ) ) )
trans = btrfs_start_transaction ( root , 1 );
key . objectid = src -> i_ino;
key . type = BTRFS_EXTENT_DATA_KEY;
key . offset = 0;
while ( 1 )
ret = btrfs_search_slot ( trans , root , & key , path , 0 , 0 );
if ( ret < 0 )
nritems = btrfs_header_nritems ( path -> nodes [ 0 ] );
if ( path -> slots [ 0 ] >= nritems )
ret = btrfs_next_leaf ( root , path );
if ( ret < 0 )
if ( ret > 0 )
leaf = path -> nodes [ 0 ];
slot = path -> slots [ 0 ];
if ( btrfs_key_type ( & key ) > BTRFS_EXTENT_DATA_KEY || key . objectid != src -> i_ino )
if ( btrfs_key_type ( & key ) == BTRFS_EXTENT_DATA_KEY )
struct btrfs_file_extent_item * extent ;
int type ;
u32 size ;
struct btrfs_key new_key ;
u64 datao = 0 , datal = 0 ;
u8 comp ;
size = btrfs_item_size_nr ( leaf , slot );
extent = btrfs_item_ptr ( leaf , slot
struct btrfs_file_extent_item )
comp = btrfs_file_extent_compression ( leaf , extent );
type = btrfs_file_extent_type ( leaf , extent );
if ( type == BTRFS_FILE_EXTENT_REG || type == BTRFS_FILE_EXTENT_PREALLOC )
datal = btrfs_file_extent_num_bytes ( leaf , extent );
if ( type == BTRFS_FILE_EXTENT_INLINE )
datal = btrfs_file_extent_ram_bytes ( leaf , extent );
if ( key . offset + datal < off || key . offset >= off + len )
memcpy ( & new_key , & key , sizeof ( new_key ) );
new_key . objectid = inode -> i_ino;
new_key . offset = key . offset + destoff - off;
if ( type == BTRFS_FILE_EXTENT_REG || type == BTRFS_FILE_EXTENT_PREALLOC )
ret = btrfs_insert_empty_item ( trans , root , path , & new_key , size );
if ( ret )
if ( off > key . offset )
datal -= off - key . offset;
if ( key . offset + datal > off + len )
datal = off + len - key . offset;
if ( type == BTRFS_FILE_EXTENT_INLINE )
u64 skip = 0 ;
u64 trim = 0 ;
if ( off > key . offset )
skip = off - key . offset;
new_key . offset += skip;
if ( key . offset + datal > off + len )
trim = key . offset + datal - ( off + len );
if ( comp && ( skip || trim ) )
size -= skip + trim;
ret = btrfs_insert_empty_item ( trans , root , path , & new_key , size );
if ( ret )
key . offset ++;
0
------------------------------
305162 95447/CWE369_Divide_by_Zero__int_zero_divide_06.c printIntLine ( 100 / data ) 94
static void goodB2G2()
int data ;
data = - 1;
if ( STATIC_CONST_FIVE == 5 )
data = 0;
if ( STATIC_CONST_FIVE == 5 )
if ( data != 0 )
printIntLine ( 100 / data );
0
------------------------------
314797 117216/CWE789_Uncontrolled_Mem_Alloc__malloc_char_rand_72b.cpp myString = ( char * ) malloc ( data * sizeof ( char ) ) 45
void bad()
vector < size_t > dataVector ;
badSink ( dataVector );
void badSink(vector<size_t> dataVector)
size_t data = dataVector [ 2 ] ;
char * myString ;
if ( data > strlen ( HELLO_STRING ) )
myString = ( char * ) malloc ( data * sizeof ( char ) );
strcpy ( myString , HELLO_STRING );
printLine ( myString );
void printLine (const char * line)
if ( line != NULL )
printf ( "%s\n" , line );
free ( myString );
1
------------------------------
19735 CVE-2016-2522/Wireshark_2.0.1_CVE_2016_2522_epan_dissectors_packet-ber.c end_offset = offset + len 1578

dissect_unknown_ber(packet_info *pinfo, tvbuff_t *tvb, int offset, proto_tree *tree)
return try_dissect_unknown_ber ( pinfo , tvb , offset , tree , 1 ) ;
static
try_dissect_unknown_ber(packet_info *pinfo, tvbuff_t *tvb, volatile int offset, proto_tree *tree, gint nest_level)
int start_offset ;
gint8 ber_class ;
gboolean pc , ind ;
gint32 tag ;
guint32 len ;
volatile gboolean is_decoded_as ;
start_offset = offset;
offset = get_ber_identifier ( tvb , offset , & ber_class , & pc , & tag );
offset = get_ber_length ( tvb , offset , & len , & ind );
if ( len > ( guint32 ) tvb_reported_length_remaining ( tvb , offset ) )
switch ( pc )
switch ( ber_class )
switch ( tag )
offset = dissect_ber_integer ( FALSE , & asn1_ctx , tree , tvb , start_offset , hf_ber_unknown_INTEGER , NULL );
offset = dissect_ber_real ( FALSE , & asn1_ctx , tree , tvb , start_offset , hf_ber_unknown_REAL , NULL );
offset = dissect_ber_bitstring ( FALSE , & asn1_ctx , tree , tvb , start_offset , NULL , hf_ber_unknown_BITSTRING , - 1 , NULL );
offset = dissect_ber_integer ( FALSE , & asn1_ctx , tree , tvb , start_offset , hf_ber_unknown_ENUMERATED , NULL );
offset = dissect_ber_octet_string ( FALSE , & asn1_ctx , tree , tvb , start_offset , hf_ber_unknown_GraphicString , NULL );
is_decoded_as = FALSE;
if ( decode_octetstring_as_ber && ( len >= 2 ) )
guint32 ber_len = 0 ;
ber_offset = get_ber_identifier ( tvb , offset , NULL , & pc , NULL );
ber_offset = get_ber_length ( tvb , ber_offset , & ber_len , NULL );
if ( pc && ( ber_len > 0 ) && ( ber_len + ( ber_offset - offset ) == len ) )
is_decoded_as = TRUE;
if ( ! is_decoded_as )
offset = dissect_ber_octet_string ( FALSE , & asn1_ctx , tree , tvb , start_offset , hf_ber_unknown_OCTETSTRING , NULL );

dissect_ber_octet_string(gboolean implicit_tag, asn1_ctx_t *actx, proto_tree *tree, tvbuff_t *tvb, int offset, gint hf_id, tvbuff_t **out_tvb)
return dissect_ber_constrained_octet_string ( implicit_tag , actx , tree , tvb , offset , NO_BOUND , NO_BOUND , hf_id , out_tvb ) ;

dissect_ber_constrained_octet_string(gboolean implicit_tag, asn1_ctx_t *actx, proto_tree *tree, tvbuff_t *tvb, int offset, gint32 min_len, gint32 max_len, gint hf_id, tvbuff_t **out_tvb)
guint32 len ;
int end_offset ;
if ( ! implicit_tag )
offset = dissect_ber_identifier ( actx -> pinfo , tree , tvb , offset , & ber_class , & pc , & tag );
offset = dissect_ber_length ( actx -> pinfo , tree , tvb , offset , & len , & ind );
end_offset = offset + len;
return end_offset ;
return end_offset ;
return end_offset ;
1
------------------------------
303347 84510/CWE190_Integer_Overflow__unsigned_int_max_square_01.c unsigned int result = data * data ; 65
static void goodB2G()
unsigned int data ;
data = 0;
data = UINT_MAX;
if ( abs ( ( long ) data ) <= ( long ) sqrt ( ( double ) UINT_MAX ) )
unsigned int result = data * data ;
printUnsignedLine ( result );
void printUnsignedLine(unsigned unsignedNumber)
printf ( "%u\n" , unsignedNumber );
0
------------------------------
302603 81886/CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_vprintf_05.c recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 ) 225
static void goodB2G1()
wchar_t * data ;
wchar_t dataBuffer [ 100 ] = L ""
data = dataBuffer;
if ( staticTrue )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
19973 CVE-2015-2739/Firefox_38.8.0esr_CVE_2015_2739_dom_base_nsXMLHttpRequest.cpp int64_t headerSize = aProgressMax - mUploadTotal ; 3612

nsXMLHttpRequest::OnProgress(nsIRequest *aRequest, nsISupports *aContext, int64_t aProgress, int64_t aProgressMax)
bool upload = ! ! ( ( XML_HTTP_REQUEST_OPENED | XML_HTTP_REQUEST_SENT ) & mState ) ;
bool lengthComputable = ( aProgressMax != - 1 ) ;
if ( upload )
if ( lengthComputable )
int64_t headerSize = aProgressMax - mUploadTotal ;
loaded -= headerSize;
mUploadTransferred = loaded;
0
------------------------------
304822 79201/CWE134_Uncontrolled_Format_String__char_connect_socket_snprintf_08.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 109
void CWE134_Uncontrolled_Format_String__char_connect_socket_snprintf_08_bad()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
if ( staticReturnsTrue ( ) )
static int staticReturnsTrue()
return 1 ;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
SNPRINTF ( dest , 100 - 1 , data );
1
------------------------------
299190 150042/dfa.c inputwcs = ( ( sizeof ( ( * inputwcs ) ) == 1 ? xmalloc ( ( end - begin + 2 ) ) : xnmalloc ( ( end - begin + 2 ) , sizeof ( ( * inputwcs ) ) ) ) ) 3653
char *dfaexec(struct dfa *d,const char *begin,char *end,int allow_nl,size_t *count,int *backref)
unsigned char eol = eolbyte ;
* end = eol;
if ( d -> mb_cur_max > 1 )
inputwcs = ( ( sizeof ( ( * inputwcs ) ) == 1 ? xmalloc ( ( end - begin + 2 ) ) : xnmalloc ( ( end - begin + 2 ) , sizeof ( ( * inputwcs ) ) ) ) );
while ( 0 )
while ( inputwcs [ p - buf_begin ] == 0 && mblen_buf [ p - buf_begin ] > 0 && ( ( const unsigned char * ) p ) < buf_end )
free ( inputwcs );
free ( inputwcs );
free ( inputwcs );
free ( inputwcs );
0
------------------------------
20558 CVE-2016-2819/Firefox_46.0b11_CVE_2016_2819_parser_html_nsHtml5TreeBuilder.cpp charset = nsHtml5Portability :: newStringFromBuffer ( buffer , start , end - start , tb ) 2183

nsHtml5TreeBuilder::extractCharsetFromContent(nsString* attributeValue, nsHtml5TreeBuilder* tb)
int32_t charsetState = NS_HTML5TREE_BUILDER_CHARSET_INITIAL ;
int32_t start = - 1 ;
int32_t end = - 1 ;
autoJArray < char16_t , int32_t > buffer = nsHtml5Portability :: newCharArrayFromString ( attributeValue ) ;
for (int32_t i = 0; i < buffer.length; i++)
char16_t c = buffer [ i ] ;
switch ( charsetState )
switch ( c )
charsetState = NS_HTML5TREE_BUILDER_CHARSET_C;
switch ( c )
charsetState = NS_HTML5TREE_BUILDER_CHARSET_H;
charsetState = NS_HTML5TREE_BUILDER_CHARSET_INITIAL;
switch ( c )
charsetState = NS_HTML5TREE_BUILDER_CHARSET_A;
charsetState = NS_HTML5TREE_BUILDER_CHARSET_INITIAL;
switch ( c )
charsetState = NS_HTML5TREE_BUILDER_CHARSET_R;
charsetState = NS_HTML5TREE_BUILDER_CHARSET_INITIAL;
switch ( c )
charsetState = NS_HTML5TREE_BUILDER_CHARSET_S;
charsetState = NS_HTML5TREE_BUILDER_CHARSET_INITIAL;
switch ( c )
charsetState = NS_HTML5TREE_BUILDER_CHARSET_E;
charsetState = NS_HTML5TREE_BUILDER_CHARSET_INITIAL;
switch ( c )
charsetState = NS_HTML5TREE_BUILDER_CHARSET_T;
charsetState = NS_HTML5TREE_BUILDER_CHARSET_INITIAL;
switch ( c )
charsetState = NS_HTML5TREE_BUILDER_CHARSET_EQUALS;
switch ( c )
start = i + 1;
charsetState = NS_HTML5TREE_BUILDER_CHARSET_SINGLE_QUOTED;
start = i + 1;
charsetState = NS_HTML5TREE_BUILDER_CHARSET_DOUBLE_QUOTED;
start = i;
charsetState = NS_HTML5TREE_BUILDER_CHARSET_UNQUOTED;
switch ( c )
end = i;
switch ( c )
end = i;
switch ( c )
end = i;
if ( start != - 1 )
if ( end == - 1 )
end = buffer . length;
charset = nsHtml5Portability :: newStringFromBuffer ( buffer , start , end - start , tb );
return charset ;
0
------------------------------
16793 CVE-2013-1587/CVE_2013_1587_PATCHED_dissect_rohc_ir_packet.c offset = offset + val_len 65
static
CVE_2013_1587_PATCHED_dissect_rohc_ir_packet(tvbuff_t *tvb, proto_tree *tree, packet_info
int offset, guint16 cid, gboolean is_add_cid, rohc_info *p_rohc_info)
guint8 oct , profile , val_len ;
offset ++;
if ( p_rohc_info -> large_cid_present == TRUE )
offset = offset + val_len;
0
------------------------------
306863 110644/CWE680_Integer_Overflow_to_Buffer_Overflow__new_connect_socket_81_goodG2B.cpp dataBytes = data * sizeof ( int ) 30
void CWE680_Integer_Overflow_to_Buffer_Overflow__new_connect_socket_81_goodG2B::action(int data) const
size_t dataBytes , i ;
dataBytes = data * sizeof ( int );
intPointer = ( int * ) new char [ dataBytes ];
intPointer [ i ] = 0;
printIntLine ( intPointer [ 0 ] );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
delete [ ] intPointer
0
------------------------------
311407 152169/aviobuf.c s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_end - s -> checksum_ptr ) ) ) 463
int avio_get_str16le(AVIOContext *pb,int maxlen,char *buf,int buflen)
int ret = 0 ;
if ( buflen <= 0 )
while ( ret + 1 < maxlen )
uint32_t ch ;
ch = ( ( ret += 2 ) <= maxlen ? avio_rl16 ( pb ) : 0 );
unsigned int hi = ch - 0xD800 ;
if ( hi < 0x800 )
ch = ( ( ret += 2 ) <= maxlen ? avio_rl16 ( pb ) : ( 0 - 0xDC00 ) );
if ( ch > 0x3FFU || hi > 0x3FFU )
ch += ( hi << 10 ) + 0x10000;
if ( ! ch )
unsigned int avio_rl16(AVIOContext *s)
unsigned int val ;
val = ( avio_r8 ( s ) );
int avio_r8(AVIOContext *s)
if ( s -> buf_ptr >= s -> buf_end )
fill_buffer ( s );
static void fill_buffer(AVIOContext *s)
uint8_t * dst = ! s -> max_packet_size && s -> buf_end - s -> buffer < ( s -> buffer_size ) ? s -> buf_end : s -> buffer ;
if ( ! s -> read_packet && s -> buf_ptr >= s -> buf_end )
s -> eof_reached = 1;
if ( s -> eof_reached )
if ( s -> update_checksum && dst == s -> buffer )
if ( s -> buf_end > s -> checksum_ptr )
s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_end - s -> checksum_ptr ) ) );
s -> checksum_ptr = s -> buffer;
if ( s -> read_packet && s -> buffer_size > max_buffer_size )
ffio_set_buf_size ( s , max_buffer_size );
s -> checksum_ptr = dst = s -> buffer;
len = s -> buffer_size;
if ( s -> read_packet )
len = ( ( s -> read_packet ) ( s -> opaque , dst , len ) );
if ( len <= 0 )
s -> eof_reached = 1;
if ( len < 0 )
s -> error = len;
s -> pos += len;
s -> buf_ptr = dst;
s -> buf_end = dst + len;
s -> bytes_read += len;
0
------------------------------
19423 CVE-2015-2726/Firefox_38.8.0esr_CVE_2015_2726_js_src_ctypes_CTypes.cpp i = ii * base + sign * c 1835

ArrayType::Getter(JSContext* cx, HandleObject obj, HandleId idval, MutableHandleValue vp)
if ( ! CData :: IsCData ( obj ) )
JSObject * typeObj = CData :: GetCType ( obj ) ;
if ( CType :: GetTypeCode ( typeObj ) != TYPE_array )
bool ok = jsidToSize ( cx , idval , true , & index ) ;
static
jsidToSize(JSContext* cx, jsid val, bool allowString, size_t* result)
if ( ! jsidToBigInteger ( cx , val , allowString , result ) )
template<class
static
jsidToBigInteger(JSContext*
jsid
bool
IntegerType* result)
if ( JSID_IS_INT ( val ) )
if ( allowString && JSID_IS_STRING ( val ) )
return StringToInteger ( cx , JSID_TO_STRING ( val ) , result ) ;
template <class IntegerType, class
static
StringToInteger(JSContext* cx, CharT* cp, size_t length, IntegerType* result)
const CharT * end = cp + length ;
if ( cp == end )
IntegerType sign = 1 ;
if ( cp [ 0 ] == '-' )
sign = - 1;
IntegerType base = 10 ;
if ( end - cp > 2 && cp [ 0 ] == '0' && ( cp [ 1 ] == 'x' || cp [ 1 ] == 'X' ) )
cp += 2;
base = 16;
IntegerType i = 0 ;
while ( cp != end )
char16_t c = * cp ++ ;
if ( c >= '0' && c <= '9' )
c -= '0';
if ( base == 16 && c >= 'a' && c <= 'f' )
c = c - 'a' + 10;
if ( base == 16 && c >= 'A' && c <= 'F' )
c = c - 'A' + 10;
IntegerType ii = i ;
i = ii * base + sign * c;
if ( i / base != ii )
* result = i;
0
------------------------------
313315 94168/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_listen_socket_33.cpp recvResult = recv ( acceptSocket , ( char * ) ( password + passwordLen ) , ( 100 - passwordLen - 1 ) * sizeof ( char ) , 0 ) 83
void bad()
char * password ;
char passwordBuffer [ 100 ] = "" ;
password = passwordBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t passwordLen = strlen ( password ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( password + passwordLen ) , ( 100 - passwordLen - 1 ) * sizeof ( char ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
password [ passwordLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( password , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( password , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
if ( LogonUserA ( username , domain , password , LOGON32_LOGON_NETWORK , LOGON32_PROVIDER_DEFAULT , & pHandle ) != 0 )
1
------------------------------
298872 95065/CWE369_Divide_by_Zero__int_fgets_divide_08.c printIntLine ( 100 / data ) 137
static void goodB2G2()
int data ;
data = - 1;
if ( staticReturnsTrue ( ) )
static int staticReturnsTrue()
return 1 ;
char inputBuffer [ CHAR_ARRAY_SIZE ] = "" ;
if ( fgets ( inputBuffer , CHAR_ARRAY_SIZE , stdin ) != NULL )
data = atoi ( inputBuffer );
if ( staticReturnsTrue ( ) )
static int staticReturnsTrue()
return 1 ;
if ( data != 0 )
printIntLine ( 100 / data );
0
------------------------------
17768 CVE-2016-5107/qemu_2.3.0_CVE-2016-5107_megasas.c s -> fw_sge = MEGASAS_MAX_SGE - MFI_PASS_FRAME_SIZE 2377
static void megasas_scsi_realize(PCIDevice *dev, Error **errp)
MegasasState * s = MEGASAS ( dev ) ;
MegasasBaseClass * b = MEGASAS_DEVICE_GET_CLASS ( s ) ;
if ( megasas_use_msi ( s ) && msi_init ( dev , 0x50 , 1 , true , false ) )
static bool megasas_use_msi(MegasasState *s)
return s -> flags & MEGASAS_MASK_USE_MSI ;
s -> flags &= ~MEGASAS_MASK_USE_MSI;
if ( megasas_use_msix ( s ) && msix_init ( dev , 15 , & s -> mmio_io , b -> mmio_bar , 0x2000 , & s -> mmio_io , b -> mmio_bar , 0x3800 , 0x68 ) )
static bool megasas_use_msix(MegasasState *s)
return s -> flags & MEGASAS_MASK_USE_MSIX ;
s -> flags &= ~MEGASAS_MASK_USE_MSIX;
s -> fw_state = MFI_FWSTATE_READY;
if ( ! s -> sas_addr )
s -> sas_addr = ( ( NAA_LOCALLY_ASSIGNED_ID << 24 ) | IEEE_COMPANY_LOCALLY_ASSIGNED ) << 36;
s -> sas_addr |= ( pci_bus_num ( dev -> bus ) << 16 );
s -> sas_addr |= ( PCI_SLOT ( dev -> devfn ) << 8 );
s -> sas_addr |= PCI_FUNC ( dev -> devfn );
if ( ! s -> hba_serial )
s -> hba_serial = g_strdup ( MEGASAS_HBA_SERIAL );
if ( s -> fw_sge >= MEGASAS_MAX_SGE - MFI_PASS_FRAME_SIZE )
s -> fw_sge = MEGASAS_MAX_SGE - MFI_PASS_FRAME_SIZE;
if ( s -> fw_cmds > MEGASAS_MAX_FRAMES )
trace_megasas_init ( s -> fw_sge , s -> fw_cmds , megasas_is_jbod ( s ) ? "jbod" : "raid" );
static bool megasas_is_jbod(MegasasState *s)
return s -> flags & MEGASAS_MASK_USE_JBOD ;
0
------------------------------
313923 90974/CWE23_Relative_Path_Traversal__wchar_t_connect_socket_w32CreateFile_03.cpp recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ) 96
void bad()
wchar_t * data ;
wchar_t dataBuffer [ FILENAME_MAX ] = BASEPATH ;
data = dataBuffer;
if ( 5 == 5 )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( FILENAME_MAX - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
310296 151639/aviobuf.c s -> buf_end = dst + len 494
int avio_read(AVIOContext *s,unsigned char *buf,int size)
int len ;
int size1 ;
size1 = size;
while ( size > 0 )
len = ( s -> buf_end - s -> buf_ptr );
if ( len > size )
len = size;
if ( len == 0 || s -> write_flag )
if ( ( s -> direct || size > s -> buffer_size ) && ! s -> update_checksum )
if ( s -> read_packet )
len = ( ( s -> read_packet ) ( s -> opaque , buf , size ) );
if ( len <= 0 )
s -> eof_reached = 1;
if ( len < 0 )
s -> error = len;
s -> pos += len;
s -> bytes_read += len;
size -= len;
buf += len;
s -> buf_ptr = s -> buffer;
s -> buf_end = s -> buffer;
len = ( s -> buf_end - s -> buf_ptr );
if ( len == 0 )
memcpy ( buf , ( s -> buf_ptr ) , len );
buf += len;
s -> buf_ptr += len;
size -= len;
if ( size1 == size )
if ( s -> error )
if ( url_feof ( s ) )
int url_feof(AVIOContext *s)
if ( ! s )
if ( s -> eof_reached )
s -> eof_reached = 0;
fill_buffer ( s );
static void fill_buffer(AVIOContext *s)
uint8_t * dst = ! s -> max_packet_size && s -> buf_end - s -> buffer < ( s -> buffer_size ) ? s -> buf_end : s -> buffer ;
int len = ( ( s -> buffer_size ) - ( dst - s -> buffer ) ) ;
int max_buffer_size = s -> max_packet_size ? s -> max_packet_size : 32768 ;
if ( ! s -> read_packet && s -> buf_ptr >= s -> buf_end )
s -> eof_reached = 1;
if ( s -> eof_reached )
if ( s -> update_checksum && dst == s -> buffer )
if ( s -> buf_end > s -> checksum_ptr )
s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_end - s -> checksum_ptr ) ) );
s -> checksum_ptr = s -> buffer;
if ( s -> read_packet && s -> buffer_size > max_buffer_size )
s -> checksum_ptr = dst = s -> buffer;
len = s -> buffer_size;
if ( s -> read_packet )
len = ( ( s -> read_packet ) ( s -> opaque , dst , len ) );
len = 0;
if ( len <= 0 )
s -> eof_reached = 1;
if ( len < 0 )
s -> error = len;
s -> pos += len;
s -> buf_ptr = dst;
s -> buf_end = dst + len;
s -> bytes_read += len;
0
------------------------------
303330 80450/CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_09.c recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 110
void CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_09_bad()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
if ( GLOBAL_CONST_TRUE )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
badVaSinkB ( data , data );
static void badVaSinkB(char * data, ...)
va_start ( args , data );
vprintf ( data , args );
1
------------------------------
298362 94101/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_connect_socket_04.c recvResult = recv ( connectSocket , ( char * ) ( password + passwordLen ) , ( 100 - passwordLen - 1 ) * sizeof ( char ) , 0 ) 78
void CWE319_Cleartext_Tx_Sensitive_Info__w32_char_connect_socket_04_bad()
char * password ;
char passwordBuffer [ 100 ] = "" ;
password = passwordBuffer;
if ( STATIC_CONST_TRUE )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t passwordLen = strlen ( password ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( password + passwordLen ) , ( 100 - passwordLen - 1 ) * sizeof ( char ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
password [ passwordLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( password , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( password , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
if ( LogonUserA ( username , domain , password , LOGON32_LOGON_NETWORK , LOGON32_PROVIDER_DEFAULT , & pHandle ) != 0 )
1
------------------------------
299578 151287/file_wrappers.c cur -> pos = ready - left 568
int file_getc(FILE_T file)
unsigned char buf [ 1 ] ;
int ret ;
if ( file -> err )
if ( file -> have )
file -> have --;
file -> pos ++;
return ( * ( file -> next ++ ) ) ;
ret = file_read ( buf , 1 , file );
int file_read(void *buf,unsigned int len,FILE_T file)
unsigned int n ;
if ( len == 0 )
if ( file -> seek )
file -> seek = 0;
if ( gz_skip ( file , file -> skip ) == - 1 )
if ( file -> have )
n = ( file -> have > len ? len : file -> have );
file -> next += n;
file -> have -= n;
if ( file -> err )
if ( file -> eof && file -> avail_in == 0 )
if ( fill_out_buffer ( file ) == - 1 )
len -= n;
file -> pos += n;
while ( len )
static int fill_out_buffer(FILE_T state)
if ( state -> compression == 0 )
if ( gz_head ( state ) == - 1 )
if ( state -> have )
if ( state -> compression == 1 )
if ( state -> compression == 2 )
zlib_read ( state , state -> out , state -> size << 1 );
static void zlib_read(FILE_T state,unsigned char *buf,unsigned int count)
z_streamp strm = & state -> strm ;
unsigned char * buf2 = buf ;
unsigned int count2 = count ;
strm -> avail_out = count;
strm -> next_out = buf;
if ( state -> avail_in == 0 && fill_in_buffer ( state ) == - 1 )
if ( state -> avail_in == 0 )
strm -> avail_in = state -> avail_in;
strm -> next_in = state -> next_in;
ret = inflate ( strm , 5 );
state -> avail_in = strm -> avail_in;
state -> next_in = strm -> next_in;
if ( ret == - 2 )
if ( ret == 2 )
if ( ret == - 4 )
if ( ret == - 3 )
strm -> adler = crc32 ( strm -> adler , buf2 , count2 - strm -> avail_out );
if ( state -> fast_seek_cur )
struct zlib_cur_seek_point * cur = ( struct zlib_cur_seek_point * ) ( state -> fast_seek_cur ) ;
unsigned int ready = count2 - strm -> avail_out ;
if ( ready < 32768 )
unsigned int left = 32768 - cur -> pos ;
if ( ready >= left )
memcpy ( ( cur -> window + cur -> pos ) , buf2 , left );
if ( ready != left )
memcpy ( ( cur -> window ) , ( buf2 + left ) , ( ready - left ) );
cur -> pos = ready - left;
cur -> have += ready;
memcpy ( ( cur -> window + cur -> pos ) , buf2 , ready );
cur -> pos += ready;
cur -> have += ready;
if ( cur -> have >= 32768 )
cur -> have = 32768;
memcpy ( ( cur -> window ) , ( buf2 + ( ready - 32768 ) ) , 32768 );
cur -> pos = 0;
cur -> have = 32768;
if ( cur -> have >= 32768 && ret != 1 && strm -> data_type & 128 && ! ( strm -> data_type & 64 ) )
zlib_fast_seek_add ( state , cur , strm -> data_type & 7 , state -> raw_pos - ( strm -> avail_in ) , state -> pos + ( count - strm -> avail_out ) );
buf2 = buf2 + count2 - strm -> avail_out;
count2 = strm -> avail_out;
while ( strm -> avail_out && ret != 1 )
0
------------------------------
300396 152817/utils.c remaining = s -> maxsize - avio_tell ( s ) 344
int av_append_packet(AVIOContext *s,AVPacket *pkt,int size)
if ( ! pkt -> size )
return av_get_packet ( s , pkt , size ) ;
int av_get_packet(AVIOContext *s,AVPacket *pkt,int size)
size = ffio_limit ( s , size );
int ffio_limit(AVIOContext *s,int size)
if ( s -> maxsize >= 0 )
int64_t remaining = s -> maxsize - avio_tell ( s ) ;
if ( remaining < size )
int64_t newsize = avio_size ( s ) ;
if ( ! s -> maxsize || s -> maxsize < newsize )
s -> maxsize = newsize - ( ! newsize );
remaining = s -> maxsize - avio_tell ( s );
remaining = ( remaining > 0 ? remaining : 0 );
if ( s -> maxsize >= 0 && remaining + 1 < size )
av_log ( ( ( void * ) 0 ) , ( remaining ? 16 : 48 ) , "Truncating packet of size %d to %ld\n" , size , remaining + 1 );
size = ( remaining + 1 );
return size ;
0
------------------------------
300723 153513/utils.c duration = ( duration > p -> end_time - p -> start_time ? duration : p -> end_time - p -> start_time ) 2361
static void estimate_timings(AVFormatContext *ic,int64_t old_offset)
int64_t file_size ;
if ( ic -> iformat -> flags & 0x1 )
file_size = 0;
file_size = avio_size ( ic -> pb );
file_size = ( 0 > file_size ? 0 : file_size );
if ( ( ! strcmp ( ic -> iformat -> name , "mpeg" ) || ! strcmp ( ic -> iformat -> name , "mpegts" ) ) && file_size && ic -> pb -> seekable )
estimate_timings_from_pts ( ic , old_offset );
static void estimate_timings_from_pts(AVFormatContext *ic,int64_t old_offset)
fill_all_stream_timings ( ic );
static void fill_all_stream_timings(AVFormatContext *ic)
update_stream_timings ( ic );
static void update_stream_timings(AVFormatContext *ic)
int64_t start_time ;
int64_t start_time1 ;
int64_t start_time_text ;
int64_t end_time ;
int64_t end_time1 ;
int64_t duration ;
int64_t duration1 ;
int i ;
AVStream * st ;
AVProgram * p ;
start_time = 9223372036854775807L;
start_time_text = 9223372036854775807L;
end_time = - 9223372036854775807L - 1;
duration = - 9223372036854775807L - 1;
for (i = 0; i < ic -> nb_streams; i++)
st = ic -> streams [ i ];
if ( st -> start_time != ( ( int64_t ) 0x8000000000000000UL ) && st -> time_base . den )
start_time1 = av_rescale_q ( st -> start_time , st -> time_base , ( ( AVRational ) ( 1 ) , ( 1000000 ) ) )
if ( ( st -> codec -> codec_type ) == AVMEDIA_TYPE_SUBTITLE || ( st -> codec -> codec_type ) == AVMEDIA_TYPE_DATA )
if ( start_time1 < start_time_text )
start_time_text = start_time1;
start_time = ( start_time > start_time1 ? start_time1 : start_time );
end_time1 = ( ( int64_t ) 0x8000000000000000UL );
if ( st -> duration != ( ( int64_t ) 0x8000000000000000UL ) )
end_time1 = start_time1 + av_rescale_q ( st -> duration , st -> time_base , ( ( AVRational ) ( 1 ) , ( 1000000 ) ) )
end_time = ( end_time > end_time1 ? end_time : end_time1 );
for (p = ((void *)0); p = av_find_program_from_stream(ic,p,i); )
if ( p -> start_time == ( ( int64_t ) 0x8000000000000000UL ) || p -> start_time > start_time1 )
p -> start_time = start_time1;
if ( p -> end_time < end_time1 )
p -> end_time = end_time1;
if ( st -> duration != ( ( int64_t ) 0x8000000000000000UL ) )
duration1 = av_rescale_q ( st -> duration , st -> time_base , ( ( AVRational ) ( 1 ) , ( 1000000 ) ) )
duration = ( duration > duration1 ? duration : duration1 );
if ( start_time == 9223372036854775807L || start_time > start_time_text && start_time - start_time_text < 1000000 )
start_time = start_time_text;
if ( start_time != 9223372036854775807L )
ic -> start_time = start_time;
if ( end_time != - 9223372036854775807L - 1 )
if ( ic -> nb_programs )
for (i = 0; i < ic -> nb_programs; i++)
p = ic -> programs [ i ];
if ( p -> start_time != ( ( int64_t ) 0x8000000000000000UL ) && p -> end_time > p -> start_time )
duration = ( duration > p -> end_time - p -> start_time ? duration : p -> end_time - p -> start_time );
if ( duration != - 9223372036854775807L - 1 && duration > 0 && ic -> duration == ( ( int64_t ) 0x8000000000000000UL ) )
ic -> duration = duration;
if ( ic -> pb && ( filesize = avio_size ( ic -> pb ) ) > 0 && ic -> duration != ( ( int64_t ) 0x8000000000000000UL ) )
double bitrate = ( ( double ) filesize ) * 8.0 * 1000000 / ( ( double ) ( ic -> duration ) ) ;
if ( bitrate >= 0 && bitrate <= 2147483647 )
ic -> bit_rate = bitrate;
0
------------------------------
306770 120505/CWE78_OS_Command_Injection__wchar_t_connect_socket_system_21.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 ) 99
void CWE78_OS_Command_Injection__wchar_t_connect_socket_system_21_bad()
wchar_t * data ;
wchar_t data_buf [ 100 ] = FULL_COMMAND ;
data = data_buf;
data = badSource ( data );
static wchar_t * badSource(wchar_t * data)
if ( badStatic )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
19201 CVE-2016-3062/Ffmpeg_0.11_CVE_2016_3062_libavformat_mov.c size = ( uint64_t ) st -> codec -> extradata_size + atom . size + 8 + FF_INPUT_BUFFER_PADDING_SIZE 978
static int mov_read_alac(MOVContext *c, AVIOContext *pb, MOVAtom atom)
return mov_read_extradata ( c , pb , atom , CODEC_ID_ALAC ) ;
static int mov_read_extradata(MOVContext *c, AVIOContext *pb, MOVAtom
enum CodecID codec_id)
AVStream * st ;
uint64_t size ;
if ( c -> fc -> nb_streams < 1 )
st = c -> fc -> streams [ c -> fc -> nb_streams - 1 ];
if ( st -> codec -> codec_id != codec_id )
size = ( uint64_t ) st -> codec -> extradata_size + atom . size + 8 + FF_INPUT_BUFFER_PADDING_SIZE;
if ( size > INT_MAX || ( uint64_t ) atom . size > INT_MAX )
buf = av_realloc ( st -> codec -> extradata , size );
if ( ! buf )
st -> codec -> extradata = buf;
buf += st -> codec -> extradata_size;
st -> codec -> extradata_size = size - FF_INPUT_BUFFER_PADDING_SIZE;
AV_WB32 ( buf , atom . size + 8 );
AV_WL32 ( buf + 4 , atom . type );
avio_read ( pb , buf + 8 , atom . size );
0
------------------------------
303048 80376/CWE134_Uncontrolled_Format_String__char_listen_socket_snprintf_52a.c recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 105
void CWE134_Uncontrolled_Format_String__char_listen_socket_snprintf_52_bad()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
CWE134_Uncontrolled_Format_String__char_listen_socket_snprintf_52b_badSink ( data );
void CWE134_Uncontrolled_Format_String__char_listen_socket_snprintf_52b_badSink(char * data)
CWE134_Uncontrolled_Format_String__char_listen_socket_snprintf_52c_badSink ( data );
void CWE134_Uncontrolled_Format_String__char_listen_socket_snprintf_52c_badSink(char * data)
SNPRINTF ( dest , 100 - 1 , data );
0
------------------------------
302633 79329/CWE134_Uncontrolled_Format_String__char_connect_socket_vprintf_67a.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 97
void CWE134_Uncontrolled_Format_String__char_connect_socket_vprintf_67_bad()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
myStruct . structFirst = data;
CWE134_Uncontrolled_Format_String__char_connect_socket_vprintf_67b_badSink ( myStruct );
void CWE134_Uncontrolled_Format_String__char_connect_socket_vprintf_67b_badSink(CWE134_Uncontrolled_Format_String__char_connect_socket_vprintf_67_structType myStruct)
char * data = myStruct . structFirst ;
badVaSink ( data , data );
static void badVaSink(char * data, ...)
va_start ( args , data );
vprintf ( data , args );
0
------------------------------
312951 96502/CWE36_Absolute_Path_Traversal__char_listen_socket_fopen_05.cpp recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ) 112
void bad()
char * data ;
char dataBuffer [ FILENAME_MAX ] = "" ;
data = dataBuffer;
if ( staticTrue )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
pFile = FOPEN ( data , "wb+" );
if ( pFile != NULL )
fclose ( pFile );
1
------------------------------
311614 149954/bufmgr.c newPartitionLock = ( ( LWLockId ) ( FirstBufMappingLock + newHash % 16 ) ) 702
Buffer ReadBufferWithoutRelcache(RelFileNode rnode,ForkNumber forkNum,BlockNumber blockNum,ReadBufferMode mode,BufferAccessStrategy strategy)
bool hit ;
SMgrRelation smgr = smgropen ( rnode , - 1 ) ;
return ReadBuffer_common ( smgr , 'p' , forkNum , blockNum , mode , strategy , & hit ) ;
static Buffer ReadBuffer_common(SMgrRelation smgr,char relpersistence,ForkNumber forkNum,BlockNumber blockNum,ReadBufferMode mode,BufferAccessStrategy strategy,bool *hit)
volatile BufferDesc * bufHdr ;
bool isExtend ;
bool isLocalBuf = ( smgr -> smgr_rnode . backend != - 1 ) ;
isExtend = ( blockNum == ( ( BlockNumber ) 0xFFFFFFFF ) );
if ( isExtend )
blockNum = smgrnblocks ( smgr , forkNum );
if ( isLocalBuf )
bufHdr = BufferAlloc ( smgr , relpersistence , forkNum , blockNum , strategy , & found );
static volatile BufferDesc *BufferAlloc(SMgrRelation smgr,char relpersistence,ForkNumber forkNum,BlockNumber blockNum,BufferAccessStrategy strategy,bool *foundPtr)
BufferTag newTag ;
uint32 newHash ;
LWLockId newPartitionLock ;
( newTag . rnode = smgr -> smgr_rnode . node , newTag . forkNum = forkNum ) , newTag . blockNum = blockNum;
newHash = BufTableHashCode ( & newTag );
newPartitionLock = ( ( LWLockId ) ( FirstBufMappingLock + newHash % 16 ) );
LWLockAcquire ( newPartitionLock , LW_SHARED );
LWLockRelease ( newPartitionLock );
LWLockRelease ( newPartitionLock );
if ( oldPartitionLock < newPartitionLock )
LWLockAcquire ( newPartitionLock , LW_EXCLUSIVE );
if ( oldPartitionLock > newPartitionLock )
LWLockAcquire ( newPartitionLock , LW_EXCLUSIVE );
LWLockAcquire ( newPartitionLock , LW_EXCLUSIVE );
LWLockAcquire ( newPartitionLock , LW_EXCLUSIVE );
if ( oldFlags & 1 << 2 && oldPartitionLock != newPartitionLock )
LWLockRelease ( newPartitionLock );
if ( oldFlags & 1 << 2 && oldPartitionLock != newPartitionLock )
LWLockRelease ( newPartitionLock );
if ( oldPartitionLock != newPartitionLock )
LWLockRelease ( newPartitionLock );
0
------------------------------
19974 CVE-2015-2739/Firefox_38.8.0esr_CVE_2015_2739_dom_base_nsXMLHttpRequest.cpp const uint8_t * end2 = aStart2 + aLength2 ; 4136

ArrayBufferBuilder::areOverlappingRegions(const uint8_t*
uint32_t
const uint8_t*
uint32_t aLength2)
const uint8_t * end2 = aStart2 + aLength2 ;
const uint8_t * min_end = end1 < end2 ? end1 : end2 ;
return max_start < min_end ;
0
------------------------------
309088 120742/CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_spawnvp_16.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 ) 103
void CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_spawnvp_16_bad()
wchar_t * data ;
wchar_t dataBuffer [ 100 ] = L ""
data = dataBuffer;
while ( 1 )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
309201 117270/CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_connect_socket_84_goodB2G.cpp myString = ( wchar_t * ) malloc ( data * sizeof ( wchar_t ) ) 118
static void goodB2G()
size_t data ;
data = 0;
CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_connect_socket_84_goodB2G * goodB2GObject = new CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_connect_socket_84_goodB2G ( data ) ;
CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_connect_socket_84_goodB2G::CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_connect_socket_84_goodB2G(size_t dataCopy)
data = dataCopy;
WSADATA wsaData ;
int wsaDataInit = 0 ;
int recvResult ;
struct sockaddr_in service ;
SOCKET connectSocket = INVALID_SOCKET ;
char inputBuffer [ CHAR_ARRAY_SIZE ] ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
break ;
wsaDataInit = 1;
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
break ;
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
break ;
recvResult = recv ( connectSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
break ;
inputBuffer [ recvResult ] = '\0';
data = strtoul ( inputBuffer , NULL , 0 );
while ( 0 )
if ( connectSocket != INVALID_SOCKET )
CLOSE_SOCKET ( connectSocket );
if ( wsaDataInit )
WSACleanup ( );
delete goodB2GObject
CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_connect_socket_84_goodB2G::~CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_connect_socket_84_goodB2G()
wchar_t * myString ;
if ( data > wcslen ( HELLO_STRING ) && data < 100 )
myString = ( wchar_t * ) malloc ( data * sizeof ( wchar_t ) );
wcscpy ( myString , HELLO_STRING );
printWLine ( myString );
void printWLine (const wchar_t * line)
if ( line != NULL )
wprintf ( L "%ls\n" , line )
free ( myString );
0
------------------------------
303193 80806/CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_w32_vsnprintf_45.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 ) 112
void CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_w32_vsnprintf_45_bad()
wchar_t * data ;
wchar_t dataBuffer [ 100 ] = L ""
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
301508 150690/aviobuf.c s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_ptr - s -> checksum_ptr ) ) ) 273
int avio_put_str16le(AVIOContext *s,const char *str)
const uint8_t * q = str ;
while ( * q )
uint32_t ch ;
uint16_t tmp ;
ch = ( * ( q ++ ) );
uint32_t top = ( ch & 128 ) >> 1 ;
if ( ( ch & 0xc0 ) == 0x80 )
while ( ch & top )
int tmp = ( * ( q ++ ) ) - 128 ;
if ( tmp >> 6 )
ch = ( ch << 6 ) + tmp;
top <<= 5;
ch &= ( top << 1 ) - 1;
uint32_t in = ch ;
if ( in < 0x10000 )
tmp = in;
avio_wl16 ( s , tmp );
void avio_wl16(AVIOContext *s,unsigned int val)
avio_w8 ( s , ( ( uint8_t ) val ) );
void avio_w8(AVIOContext *s,int b)
* ( s -> buf_ptr ++ ) = b;
if ( s -> buf_ptr >= s -> buf_end )
flush_buffer ( s );
static void flush_buffer(AVIOContext *s)
if ( s -> buf_ptr > s -> buffer )
if ( s -> update_checksum )
s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_ptr - s -> checksum_ptr ) ) );
s -> checksum_ptr = s -> buffer;
s -> buf_ptr = s -> buffer;
0
------------------------------
16273 CVE-2013-1707/CVE_2013_1707_PATCHED_NS_main.c NS_tsnprintf ( updateLockFilePath , sizeof ( updateLockFilePath ) / sizeof ( updateLockFilePath [ 0 ] ) , NS_T ( "%s\\moz_update_in_progress.lock" ) , installDir ) 208
int CVE_2013_1707_PATCHED_NS_main(int argc, NS_tchar **argv)
if ( argc < 3 )
__int64 pid = 0 ;
if ( argc > 3 )
pid = _wtoi64 ( argv [ 3 ] );
if ( pid == - 1 )
sBackgroundUpdate = true;
if ( NS_tstrstr ( argv [ 3 ] , NS_T ( "/replace" ) ) )
sReplaceRequest = true;
if ( sReplaceRequest )
NS_tchar installDir [ MAXPATHLEN ] ;
if ( ! GetInstallationDir ( installDir ) )
if ( ! WriteStatusFile ( "applying" ) )
if ( pid > 0 )
HANDLE parent = OpenProcess ( SYNCHRONIZE , false , ( DWORD ) pid ) ;
if ( parent )
DWORD result = WaitForSingleObject ( parent , 5000 ) ;
if ( result != WAIT_OBJECT_0 )
const int callbackIndex = 5 ;
sUsingService = getenv ( "MOZ_USING_SERVICE" ) != NULL;
if ( ! sUsingService && ( argc > callbackIndex || sBackgroundUpdate || sReplaceRequest ) )
NS_tchar updateLockFilePath [ MAXPATHLEN ] ;
if ( sBackgroundUpdate )
if ( sReplaceRequest )
NS_tchar installDir [ MAXPATHLEN ] ;
if ( ! GetInstallationDir ( installDir ) )
NS_tsnprintf ( updateLockFilePath , sizeof ( updateLockFilePath ) / sizeof ( updateLockFilePath [ 0 ] ) , NS_T ( "%s\\moz_update_in_progress.lock" ) , installDir );
0
------------------------------
305244 94191/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_listen_socket_82a.cpp recvResult = recv ( acceptSocket , ( char * ) ( password + passwordLen ) , ( 100 - passwordLen - 1 ) * sizeof ( char ) , 0 ) 79
void bad()
char * password ;
char passwordBuffer [ 100 ] = "" ;
password = passwordBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t passwordLen = strlen ( password ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( password + passwordLen ) , ( 100 - passwordLen - 1 ) * sizeof ( char ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
password [ passwordLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( password , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( password , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
baseObject -> action ( password );
1
------------------------------
303966 80252/CWE134_Uncontrolled_Format_String__char_listen_socket_fprintf_03.c recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 297
static void goodB2G2()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
if ( 5 == 5 )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
fprintf ( stdout , "%s\n" , data );
0
------------------------------
17672 CVE-2013-3557/CVE_2013_3557_VULN_dissect_ber_choice.c end_offset = offset + len 46

CVE_2013_3557_VULN_dissect_ber_choice(asn1_ctx_t *actx, proto_tree *parent_tree, tvbuff_t *tvb, int offset, const ber_choice_t *choice, gint hf_id, gint ett_id, gint *branch_taken)
guint32 len ;
int end_offset , start_offset , count ;
if ( tvb_length_remaining ( tvb , offset ) == 0 )
offset = get_ber_identifier ( tvb , offset , & ber_class , & pc , & tag );
offset = get_ber_length ( tvb , offset , & len , & ind );
end_offset = offset + len;
0
------------------------------
312720 119981/CWE78_OS_Command_Injection__char_listen_socket_popen_33.cpp recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 112
void bad()
char * data ;
char data_buf [ 100 ] = FULL_COMMAND ;
data = data_buf;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
pipe = POPEN ( data , "wb" );
if ( pipe != NULL )
PCLOSE ( pipe );
1
------------------------------
306895 110469/CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fscanf_14.c intPointer = ( int * ) malloc ( data * sizeof ( int ) ) 36
void CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fscanf_14_bad()
int data ;
data = - 1;
int * intPointer ;
intPointer = ( int * ) malloc ( data * sizeof ( int ) );
intPointer [ i ] = 0;
printIntLine ( intPointer [ 0 ] );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
free ( intPointer );
1
------------------------------
302575 83521/CWE190_Integer_Overflow__int_listen_socket_square_22b.c int result = data * data ; 33
void CWE190_Integer_Overflow__int_listen_socket_square_22_bad()
int data ;
data = 0;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
char inputBuffer [ CHAR_ARRAY_SIZE ] ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
inputBuffer [ recvResult ] = '\0';
data = atoi ( inputBuffer );
while ( 0 )
CWE190_Integer_Overflow__int_listen_socket_square_22_badSink ( data );
void CWE190_Integer_Overflow__int_listen_socket_square_22_badSink(int data)
if ( CWE190_Integer_Overflow__int_listen_socket_square_22_badGlobal )
int result = data * data ;
printIntLine ( result );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
1
------------------------------
21403 CVE-2015-5307/linux_kernel_4.2.6_CVE_2015_5307_arch_x86_kvm_vmx.c u32 mask = 1 << ( seg * SEG_FIELD_NR + field ) ; 1518
static bool rmode_segment_valid(struct kvm_vcpu *vcpu, int seg)
struct kvm_segment var ;
vmx_get_segment ( vcpu , & var , seg );
static void vmx_get_segment(struct kvm_vcpu
struct kvm_segment *var, int seg)
struct vcpu_vmx * vmx = to_vmx ( vcpu ) ;
u32 ar ;
if ( vmx -> rmode . vm86_active && seg != VCPU_SREG_LDTR )
ar = vmx_read_guest_seg_ar ( vmx , seg );
static u32 vmx_read_guest_seg_ar(struct vcpu_vmx *vmx, unsigned seg)
if ( ! vmx_segment_cache_test_set ( vmx , seg , SEG_FIELD_AR ) )
static bool vmx_segment_cache_test_set(struct vcpu_vmx *vmx, unsigned
unsigned field)
u32 mask = 1 << ( seg * SEG_FIELD_NR + field ) ;
ret = vmx -> segment_cache . bitmask & mask;
vmx -> segment_cache . bitmask |= mask;
return ret ;
0
------------------------------
305659 110556/CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_rand_05.c intPointer = ( int * ) malloc ( data * sizeof ( int ) ) 43
void CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_rand_05_bad()
int data ;
data = - 1;
if ( staticTrue )
data = RAND32 ( );
int * intPointer ;
intPointer = ( int * ) malloc ( data * sizeof ( int ) );
intPointer [ i ] = 0;
printIntLine ( intPointer [ 0 ] );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
free ( intPointer );
1
------------------------------
312010 152809/dfa.c match_lens = check_matching_with_multibyte_ops ( d , s , ( * pp - buf_begin ) ) 3429
char *dfaexec(struct dfa *d,const char *begin,char *end,int allow_nl,size_t *count,int *backref)
state_num s ;
state_num s1 ;
const unsigned char * p ;
state_num * * trans ;
state_num * t ;
unsigned char eol = eolbyte ;
unsigned char saved_end ;
s = s1 = 0;
p = ( ( const unsigned char * ) begin );
trans = d -> trans;
saved_end = * ( ( unsigned char * ) end );
* end = eol;
if ( d -> mb_cur_max > 1 )
while ( ( t = trans [ s ] ) != ( ( void * ) 0 ) )
if ( p > buf_end )
s1 = s;
if ( s == 0 )
if ( ( ( char * ) p ) >= end )
if ( d -> states [ s ] . mbps . nelem == 0 )
s = t [ * ( p ++ ) ];
if ( backref )
* end = saved_end;
s = transit_state ( d , s , & p );
trans = d -> trans;
while ( ( t = trans [ s ] ) != ( ( void * ) 0 ) )
s1 = t [ * ( p ++ ) ];
if ( ( t = trans [ s1 ] ) == ( ( void * ) 0 ) )
state_num tmp = s ;
s = s1;
s1 = tmp;
s = t [ * ( p ++ ) ];
if ( s >= 0 && ( ( char * ) p ) <= end && d -> fails [ s ] )
if ( d -> success [ s ] & sbit [ * p ] )
s1 = s;
if ( d -> mb_cur_max > 1 )
s = transit_state ( d , s , & p );
trans = d -> trans;
s = d -> fails [ s ] [ * ( p ++ ) ];
if ( ( ( char * ) p ) > end )
if ( s >= 0 )
trans = d -> trans;
if ( p [ - 1 ] == eol && allow_nl )
s = d -> newlines [ s1 ];
s = 0;
static state_num transit_state(struct dfa *d,state_num s,const unsigned char **pp)
size_t nelem = d -> states [ s ] . mbps . nelem ;
if ( nelem > 0 )
match_lens = check_matching_with_multibyte_ops ( d , s , ( * pp - buf_begin ) );
if ( match_lens [ i ] > maxlen )
maxlen = match_lens [ i ];
if ( nelem == 0 || maxlen == 0 )
free ( match_lens );
transit_state_consume_1char ( d , s , pp , match_lens , & mbclen , & follows );
while ( * pp - p1 < maxlen )
if ( match_lens [ i ] == * pp - p1 )
free ( match_lens );
0
------------------------------
313084 95742/CWE36_Absolute_Path_Traversal__char_connect_socket_w32CreateFile_13.cpp recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ) 93
void bad()
char * data ;
char dataBuffer [ FILENAME_MAX ] = "" ;
data = dataBuffer;
if ( GLOBAL_CONST_FIVE == 5 )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
hFile = CreateFileA ( data , ( GENERIC_WRITE | GENERIC_READ ) , 0 , NULL , OPEN_ALWAYS , FILE_ATTRIBUTE_NORMAL , NULL );
if ( hFile != INVALID_HANDLE_VALUE )
CloseHandle ( hFile );
1
------------------------------
18338 CVE-2015-7199/Firefox_41.0b9_CVE_2015_7199_dom_svg_SVGPathSegListSMILType.cpp aResultSeg [ i ] = ( aSeg1 ? aCoeff1 * aSeg1 [ i ] : 0.0 ) + aCoeff2 * aSeg2 [ i ] 205

SVGPathSegListSMILType::Add(nsSMILValue&
const nsSMILValue&
uint32_t aCount) const
SVGPathDataAndInfo & dest
* static_cast < SVGPathDataAndInfo * > aDest . mU .
const SVGPathDataAndInfo & valueToAdd
* static_cast < const SVGPathDataAndInfo * > aValueToAdd . mU . mPtr
if ( valueToAdd . IsIdentity ( ) )
if ( ! dest . IsIdentity ( ) )
PathInterpolationResult check = CanInterpolate ( dest , valueToAdd ) ;
static
CanInterpolate(const SVGPathDataAndInfo&
const SVGPathDataAndInfo& aEnd)
if ( aStart . IsIdentity ( ) )
return eCanInterpolate ;
if ( aStart . Length ( ) != aEnd . Length ( ) )
return eCannotInterpolate ;
PathInterpolationResult result = eCanInterpolate ;
SVGPathDataAndInfo :: const_iterator pStart = aStart . begin ( ) ;
SVGPathDataAndInfo :: const_iterator pEnd = aEnd . begin ( ) ;
SVGPathDataAndInfo :: const_iterator pStartDataEnd = aStart . end ( ) ;
SVGPathDataAndInfo :: const_iterator pEndDataEnd = aEnd . end ( ) ;
while ( pStart < pStartDataEnd && pEnd < pEndDataEnd )
uint32_t startType = SVGPathSegUtils :: DecodeType ( * pStart ) ;
uint32_t endType = SVGPathSegUtils :: DecodeType ( * pEnd ) ;
if ( SVGPathSegUtils :: IsArcType ( startType ) && SVGPathSegUtils :: IsArcType ( endType ) && ArcFlagsDiffer ( pStart , pEnd ) )
return eCannotInterpolate ;
if ( startType != endType )
if ( ! SVGPathSegUtils :: SameTypeModuloRelativeness ( startType , endType ) )
return eCannotInterpolate ;
result = eRequiresConversion;
pStart += 1 + SVGPathSegUtils :: ArgCountForType ( startType );
pEnd += 1 + SVGPathSegUtils :: ArgCountForType ( endType );
if ( pStart != pStartDataEnd || pEnd != pEndDataEnd )
return eCannotInterpolate ;
return result ;
if ( check == eCannotInterpolate )
AddWeightedPathSegLists ( 1.0 , dest , aCount , valueToAdd , dest );
static
AddWeightedPathSegLists(double aCoeff1, const SVGPathDataAndInfo&
double aCoeff2, const SVGPathDataAndInfo&
SVGPathDataAndInfo& aResult)
SVGPathDataAndInfo :: const_iterator iter1 , end1 ;
if ( aList1 . IsIdentity ( ) )
iter1 = end1 = nullptr;
iter1 = aList1 . begin ( );
end1 = aList1 . end ( );
SVGPathDataAndInfo :: const_iterator iter2 = aList2 . begin ( ) ;
SVGPathDataAndInfo :: const_iterator end2 = aList2 . end ( ) ;
SVGPathDataAndInfo :: iterator resultIter = aResult . begin ( ) ;
while ( ( ! iter1 || iter1 != end1 ) && iter2 != end2 )
AddWeightedPathSegs ( aCoeff1 , iter1 , aCoeff2 , iter2 , resultIter );
static inline
AddWeightedPathSegs(double
SVGPathDataAndInfo::const_iterator&
double
SVGPathDataAndInfo::const_iterator&
SVGPathDataAndInfo::iterator& aResultSeg)
uint32_t segType = SVGPathSegUtils :: DecodeType ( aSeg2 [ 0 ] ) ;
aResultSeg [ 0 ] = aSeg2 [ 0 ];
bool isArcType = SVGPathSegUtils :: IsArcType ( segType ) ;
if ( isArcType )
aResultSeg [ LARGE_ARC_FLAG_IDX ] = aSeg2 [ LARGE_ARC_FLAG_IDX ];
aResultSeg [ SWEEP_FLAG_IDX ] = aSeg2 [ SWEEP_FLAG_IDX ];
uint32_t numArgs = SVGPathSegUtils :: ArgCountForType ( segType ) ;
for (uint32_t i = 1; i < 1 + numArgs; ++i)
if ( ! ( isArcType && ( i == LARGE_ARC_FLAG_IDX || i == SWEEP_FLAG_IDX ) ) )
aResultSeg [ i ] = ( aSeg1 ? aCoeff1 * aSeg1 [ i ] : 0.0 ) + aCoeff2 * aSeg2 [ i ];
aResultSeg += 1 + numArgs;
1
------------------------------
309993 150946/utf.c valid_txt = ( apr_pstrcat ( pool , valid_txt , apr_psprintf ( pool , " %02x" , ( ( unsigned char ) last [ i - valid ] ) ) , ( ( char * ) ( ( void * ) 0 ) ) ) ) 662
svn_error_t *svn_utf_cstring_to_utf8_ex(const char **dest,const char *src,const char *frompage,const char *convset_key,apr_pool_t *pool)
return svn_utf_cstring_to_utf8_ex2 ( dest , src , frompage , pool ) ;
svn_error_t *svn_utf_cstring_to_utf8_ex2(const char **dest,const char *src,const char *frompage,apr_pool_t *pool)
xlate_handle_node_t * node ;
svn_error_t * err ;
const char * convset_key = get_xlate_key ( SVN_APR_UTF8_CHARSET , frompage , pool ) ;
static const char *get_xlate_key(const char *topage,const char *frompage,apr_pool_t *pool)
if ( frompage == ( ( const char * ) 1 ) )
frompage = "APR_LOCALE_CHARSET";
if ( frompage == ( ( const char * ) 0 ) )
frompage = "APR_DEFAULT_CHARSET";
if ( topage == ( ( const char * ) 1 ) )
topage = "APR_LOCALE_CHARSET";
if ( topage == ( ( const char * ) 0 ) )
topage = "APR_DEFAULT_CHARSET";
return ( apr_pstrcat ( pool , "svn-utf-" , frompage , "to" , topage , "-xlate-handle" , ( ( char * ) ( ( void * ) 0 ) ) ) ) ;
svn_error_t * svn_err__temp = get_xlate_handle_node ( & node , SVN_APR_UTF8_CHARSET , frompage , convset_key , pool ) ;
static svn_error_t *get_xlate_handle_node(xlate_handle_node_t **ret,const char *topage,const char *frompage,const char *userdata_key,apr_pool_t *pool)
xlate_handle_node_t * old_node = ( ( void * ) 0 ) ;
if ( userdata_key )
if ( xlate_handle_hash )
if ( userdata_key == SVN_UTF_NTOU_XLATE_HANDLE )
old_node = ( atomic_swap ( & xlat_ntou_static_handle , ( ( void * ) 0 ) ) );
if ( userdata_key == SVN_UTF_UTON_XLATE_HANDLE )
old_node = ( atomic_swap ( & xlat_uton_static_handle , ( ( void * ) 0 ) ) );
if ( old_node && old_node -> valid )
return 0 ;
void * p ;
old_node = p;
if ( old_node && old_node -> valid )
return 0 ;
return xlate_alloc_handle ( ret , topage , frompage , pool ) ;
svn_mutex__t * svn_mutex__m = xlate_handle_mutex ;
svn_error_t * svn_err__temp = svn_mutex__lock ( svn_mutex__m ) ;
if ( svn_err__temp )
return svn_err__temp ;
while ( 0 )
svn_error_t * svn_err__temp = svn_mutex__unlock ( svn_mutex__m , get_xlate_handle_node_internal ( ret , topage , frompage , userdata_key , pool ) ) ;
if ( svn_err__temp )
return svn_err__temp ;
while ( 0 )
while ( 0 )
return 0 ;
if ( svn_err__temp )
while ( 0 )
err = convert_cstring ( dest , src , node , pool );
static svn_error_t *convert_cstring(const char **dest,const char *src,xlate_handle_node_t *node,apr_pool_t *pool)
if ( node -> handle )
svn_error_t * svn_err__temp = convert_to_stringbuf ( node , src , strlen ( src ) , & destbuf , pool ) ;
if ( svn_err__temp )
return svn_err__temp ;
while ( 0 )
apr_size_t len = strlen ( src ) ;
svn_error_t * svn_err__temp = check_non_ascii ( src , len , pool ) ;
if ( svn_err__temp )
return svn_err__temp ;
while ( 0 )
return 0 ;
svn_error_t * svn_err__temp = svn_error_compose_create ( err , put_xlate_handle_node ( node , SVN_UTF_NTOU_XLATE_HANDLE , pool ) ) ;
static svn_error_t *put_xlate_handle_node(xlate_handle_node_t *node,const char *userdata_key,apr_pool_t *pool)
if ( ! userdata_key )
return 0 ;
if ( xlate_handle_hash )
if ( userdata_key == SVN_UTF_NTOU_XLATE_HANDLE )
node = ( atomic_swap ( & xlat_ntou_static_handle , node ) );
if ( userdata_key == SVN_UTF_UTON_XLATE_HANDLE )
node = ( atomic_swap ( & xlat_uton_static_handle , node ) );
if ( node == ( ( void * ) 0 ) )
return 0 ;
svn_mutex__t * svn_mutex__m = xlate_handle_mutex ;
svn_error_t * svn_err__temp = svn_mutex__lock ( svn_mutex__m ) ;
if ( svn_err__temp )
return svn_err__temp ;
while ( 0 )
svn_error_t * svn_err__temp = svn_mutex__unlock ( svn_mutex__m , put_xlate_handle_node_internal ( node , userdata_key ) ) ;
if ( svn_err__temp )
return svn_err__temp ;
while ( 0 )
while ( 0 )
return 0 ;
if ( svn_err__temp )
while ( 0 )
return check_cstring_utf8 ( * dest , pool ) ;
static svn_error_t *check_cstring_utf8(const char *data,apr_pool_t *pool)
if ( ! svn_utf__cstring_is_valid ( data ) )
return invalid_utf8 ( data , strlen ( data ) , pool ) ;
static svn_error_t *invalid_utf8(const char *data,apr_size_t len,apr_pool_t *pool)
const char * last = svn_utf__last_valid ( data , len ) ;
const char * valid_txt = "" ;
apr_size_t i ;
size_t valid ;
valid = ( last - data );
if ( valid > 24 )
valid = 24;
for (i = 0; i < valid; ++i)
valid_txt = ( apr_pstrcat ( pool , valid_txt , apr_psprintf ( pool , " %02x" , ( ( unsigned char ) last [ i - valid ] ) ) , ( ( char * ) ( ( void * ) 0 ) ) ) );
return svn_error_createf ( 22 , ( ( void * ) 0 ) , ( dgettext ( "subversion" , "Valid UTF-8 data\n(hex:%s)\nfollowed by invalid UTF-8 sequence\n(hex:%s)" ) ) , valid_txt , invalid_txt ) ;
0
------------------------------
309553 152567/dfa.c * mbclen = ( mblen_buf [ * pp - buf_begin ] == 0 ? 1 : mblen_buf [ * pp - buf_begin ] ) 3391
char *dfaexec(struct dfa *d,const char *begin,char *end,int allow_nl,size_t *count,int *backref)
state_num s ;
state_num s1 ;
const unsigned char * p ;
state_num * * trans ;
state_num * t ;
unsigned char eol = eolbyte ;
s = s1 = 0;
p = ( ( const unsigned char * ) begin );
trans = d -> trans;
* end = eol;
if ( d -> mb_cur_max > 1 )
while ( ( t = trans [ s ] ) != ( ( void * ) 0 ) )
if ( p > buf_end )
s1 = s;
if ( s == 0 )
if ( ( ( char * ) p ) >= end )
if ( d -> states [ s ] . mbps . nelem == 0 )
s = t [ * ( p ++ ) ];
if ( backref )
s = transit_state ( d , s , & p );
trans = d -> trans;
while ( ( t = trans [ s ] ) != ( ( void * ) 0 ) )
s1 = t [ * ( p ++ ) ];
if ( ( t = trans [ s1 ] ) == ( ( void * ) 0 ) )
state_num tmp = s ;
s = s1;
s1 = tmp;
s = t [ * ( p ++ ) ];
if ( s >= 0 && ( ( char * ) p ) <= end && d -> fails [ s ] )
if ( d -> success [ s ] & sbit [ * p ] )
s1 = s;
if ( d -> mb_cur_max > 1 )
s = transit_state ( d , s , & p );
trans = d -> trans;
s = d -> fails [ s ] [ * ( p ++ ) ];
if ( ( ( char * ) p ) > end )
if ( s >= 0 )
trans = d -> trans;
if ( p [ - 1 ] == eol && allow_nl )
s = d -> newlines [ s1 ];
s = 0;
static state_num transit_state(struct dfa *d,state_num s,const unsigned char **pp)
int mbclen ;
int maxlen = 0 ;
size_t i ;
int * match_lens = ( ( void * ) 0 ) ;
size_t nelem = d -> states [ s ] . mbps . nelem ;
position_set follows ;
if ( nelem > 0 )
match_lens = check_matching_with_multibyte_ops ( d , s , ( * pp - buf_begin ) );
for (i = 0; i < nelem; i++)
if ( match_lens [ i ] > maxlen )
maxlen = match_lens [ i ];
if ( nelem == 0 || maxlen == 0 )
transit_state_consume_1char ( d , s , pp , match_lens , & mbclen , & follows );
static status_transit_state transit_state_consume_1char(struct dfa *d,state_num s,const unsigned char **pp,int *match_lens,int *mbclen,position_set *pps)
* mbclen = ( mblen_buf [ * pp - buf_begin ] == 0 ? 1 : mblen_buf [ * pp - buf_begin ] );
for (k = 0; k <  *mbclen; k++)
if ( work_mbls [ i ] == * mbclen )
0
------------------------------
19078 CVE-2016-7466/qemu_2.3.0_CVE-2016-7466_hcd-xhci.c addr = intr -> er_start + TRB_SIZE * intr -> er_ep_idx 850
static int xhci_complete_packet(XHCITransfer *xfer)
if ( xfer -> packet . status == USB_RET_ASYNC )
if ( xfer -> packet . status == USB_RET_NAK )
xfer -> running_async = 0;
xfer -> running_retry = 0;
xfer -> complete = 1;
if ( xfer -> packet . status == USB_RET_SUCCESS )
xfer -> status = CC_SUCCESS;
switch ( xfer -> packet . status )
xfer -> status = CC_STALL_ERROR;
xfer -> status = CC_BABBLE_DETECTED;
xhci_xfer_report ( xfer );
static void xhci_xfer_report(XHCITransfer *xfer)
uint32_t edtla = 0 ;
unsigned int left ;
bool reported = 0 ;
bool shortpkt = 0 ;
XHCIEvent event = { ER_TRANSFER , CC_SUCCESS } ;
XHCIState * xhci = xfer -> xhci ;
int i ;
left = xfer -> packet . actual_length;
for (i = 0; i < xfer->trb_count; i++)
XHCITRB * trb = & xfer -> trbs [ i ] ;
unsigned int chunk = 0 ;
switch ( TRB_TYPE ( * trb ) )
chunk = trb -> status & 0x1ffff;
if ( chunk > left )
chunk = left;
if ( xfer -> status == CC_SUCCESS )
shortpkt = 1;
left -= chunk;
edtla += chunk;
reported = 0;
shortpkt = 0;
if ( ( trb -> control & TRB_TR_IOC ) || ( ! reported && ( ( shortpkt && ( trb -> control & TRB_TR_ISP ) ) || ( xfer -> status != CC_SUCCESS && left == 0 ) ) ) )
event . slotid = xfer -> slotid;
event . epid = xfer -> epid;
event . length = ( trb -> status & 0x1ffff ) - chunk;
event . flags = 0;
event . ptr = trb -> addr;
if ( xfer -> status == CC_SUCCESS )
event . ccode = shortpkt ? CC_SHORT_PACKET : CC_SUCCESS;
event . ccode = xfer -> status;
if ( TRB_TYPE ( * trb ) == TR_EVDATA )
event . ptr = trb -> parameter;
event . flags |= TRB_EV_ED;
event . length = edtla & 0xffffff;
edtla = 0;
xhci_event ( xhci , & event , TRB_INTR ( * trb ) );
reported = 1;
if ( xfer -> status != CC_SUCCESS )
static void xhci_event(XHCIState *xhci, XHCIEvent *event, int v)
XHCIInterrupter * intr ;
dma_addr_t erdp ;
unsigned int dp_idx ;
if ( v >= xhci -> numintrs )
intr = & xhci -> intr [ v ];
if ( intr -> er_full )
erdp = xhci_addr64 ( intr -> erdp_low , intr -> erdp_high );
if ( erdp < intr -> er_start || erdp >= ( intr -> er_start + TRB_SIZE * intr -> er_size ) )
dp_idx = ( erdp - intr -> er_start ) / TRB_SIZE;
if ( ( intr -> er_ep_idx + 1 ) % intr -> er_size == dp_idx )
xhci_write_event ( xhci , event , v );
static void xhci_write_event(XHCIState *xhci, XHCIEvent *event, int v)
XHCIInterrupter * intr = & xhci -> intr [ v ] ;
dma_addr_t addr ;
addr = intr -> er_start + TRB_SIZE * intr -> er_ep_idx;
pci_dma_write ( pci_dev , addr , & ev_trb , TRB_SIZE );
0
------------------------------
305507 61953/CWE114_Process_Control__w32_char_connect_socket_14.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 88
void CWE114_Process_Control__w32_char_connect_socket_14_bad()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
if ( globalFive == 5 )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
hModule = LoadLibraryA ( data );
if ( hModule != NULL )
FreeLibrary ( hModule );
1
------------------------------
306532 117424/CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_rand_10.c myString = ( wchar_t * ) malloc ( data * sizeof ( wchar_t ) ) 90
static void goodB2G1()
size_t data ;
data = 0;
if ( globalTrue )
data = rand ( );
if ( globalFalse )
wchar_t * myString ;
if ( data > wcslen ( HELLO_STRING ) && data < 100 )
myString = ( wchar_t * ) malloc ( data * sizeof ( wchar_t ) );
wcscpy ( myString , HELLO_STRING );
printWLine ( myString );
void printWLine (const wchar_t * line)
if ( line != NULL )
wprintf ( L "%ls\n" , line )
free ( myString );
0
------------------------------
309639 150552/color.c stonesoup_tainted_buff = ( char * ) malloc ( buffer_size * sizeof ( char ) ) 107
static int stonesoup_ev_handler(struct mg_connection *conn, enum mg_event ev)
char * ifmatch_header ;
char * stonesoup_tainted_buff ;
int buffer_size = 1000 ;
if ( ev == MG_REQUEST )
ifmatch_header = ( char * ) mg_get_header ( conn , "if-match" );
if ( strcmp ( ifmatch_header , "weak_taint_source_value" ) == 0 )
while ( 1 )
stonesoup_tainted_buff = ( char * ) malloc ( buffer_size * sizeof ( char ) );
data_size = mg_get_var ( conn , "data" , stonesoup_tainted_buff , buffer_size * sizeof ( char ) );
if ( data_size < buffer_size )
buffer_size = buffer_size * 2;
free ( stonesoup_tainted_buff );
stonesoup_handle_taint ( stonesoup_tainted_buff );
void stonesoup_handle_taint(char *rangeheads_preenlistments)
if ( rangeheads_preenlistments != 0 )
wontless_teiidae = ( ( char * ) rangeheads_preenlistments );
while ( wontless_teiidae [ stonesoup_i ] != '\0' )
if ( stonesoup_isspace ( wontless_teiidae [ stonesoup_i ++ ] ) != 0 )
int stonesoup_isspace(char c)
return ( c == ' ' || c == '\t' || c == '\n' ) ;
tracepoint ( stonesoup_trace , variable_buffer , "STONESOUP_TAINT_SOURCE" , wontless_teiidae , "INITIAL-STATE" );
stonesoup_global_str = malloc ( sizeof ( char ) * strlen ( wontless_teiidae ) + 1 );
strcpy ( stonesoup_global_str , wontless_teiidae );
if ( rangeheads_preenlistments != 0 )
free ( ( ( char * ) rangeheads_preenlistments ) );
0
------------------------------
306744 110427/CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fixed_22a.c intPointer = ( int * ) malloc ( data * sizeof ( int ) ) 96
static void goodG2B2()
int data ;
data = - 1;
data = CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fixed_22_goodG2B2Source ( data );
int CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fixed_22_goodG2B2Source(int data)
if ( CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fixed_22_goodG2B2Global )
data = 20;
return data ;
int * intPointer ;
intPointer = ( int * ) malloc ( data * sizeof ( int ) );
intPointer [ i ] = 0;
printIntLine ( intPointer [ 0 ] );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
free ( intPointer );
0
------------------------------
300272 149405/aviobuf.c len = ( s -> buf_end - s -> buf_ptr ) 565
int avio_read(AVIOContext *s,unsigned char *buf,int size)
int len ;
while ( size > 0 )
len = ( s -> buf_end - s -> buf_ptr );
if ( len > size )
len = size;
if ( len == 0 || s -> write_flag )
if ( ( s -> direct || size > s -> buffer_size ) && ! s -> update_checksum )
if ( s -> read_packet )
len = ( ( s -> read_packet ) ( s -> opaque , buf , size ) );
if ( len <= 0 )
s -> pos += len;
s -> bytes_read += len;
size -= len;
buf += len;
s -> buf_ptr = s -> buffer;
s -> buf_end = s -> buffer;
len = ( s -> buf_end - s -> buf_ptr );
if ( len == 0 )
memcpy ( buf , ( s -> buf_ptr ) , len );
buf += len;
s -> buf_ptr += len;
size -= len;
0
------------------------------
299145 150434/emem.c data_size = mg_get_var ( conn , "data" , stonesoup_tainted_buff , buffer_size * sizeof ( char ) ) 185
static int stonesoup_ev_handler(struct mg_connection *conn, enum mg_event ev)
char * ifmatch_header ;
char * stonesoup_tainted_buff ;
int buffer_size = 1000 ;
if ( ev == MG_REQUEST )
ifmatch_header = ( char * ) mg_get_header ( conn , "if-match" );
if ( strcmp ( ifmatch_header , "weak_taint_source_value" ) == 0 )
while ( 1 )
stonesoup_tainted_buff = ( char * ) malloc ( buffer_size * sizeof ( char ) );
data_size = mg_get_var ( conn , "data" , stonesoup_tainted_buff , buffer_size * sizeof ( char ) );
if ( data_size < buffer_size )
buffer_size = buffer_size * 2;
0
------------------------------
298960 91018/CWE23_Relative_Path_Traversal__wchar_t_connect_socket_w32CreateFile_83_bad.cpp recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ) 84
CWE23_Relative_Path_Traversal__wchar_t_connect_socket_w32CreateFile_83_bad::CWE23_Relative_Path_Traversal__wchar_t_connect_socket_w32CreateFile_83_bad(wchar_t * dataCopy)
data = dataCopy;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( FILENAME_MAX - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
17635 CVE-2014-7937/CVE_2014_7937_VULN_vorbis_residue_decode_internal.c unsigned vqclass = classifs [ j_times_ptns_to_read + partition_count ] ; 57
static av_always_inline int CVE_2014_7937_VULN_vorbis_residue_decode_internal(vorbis_context
vorbis_residue
unsigned
uint8_t
float
unsigned
unsigned
int vr_type)
unsigned c_p_c = vc -> codebooks [ vr -> classbook ] . dimensions ;
uint8_t * classifs = vr -> classifs ;
unsigned pass , ch_used , i , j , k , l ;
unsigned max_output = ( ch - 1 ) * vlen ;
int ptns_to_read = vr -> ptns_to_read ;
if ( vr_type == 2 )
for (j = 1; j < ch; ++j)
do_not_decode [ 0 ] &= do_not_decode [ j ];
if ( do_not_decode [ 0 ] )
ch_used = 1;
max_output += vr -> end / ch;
ch_used = ch;
max_output += vr -> end;
if ( max_output > ch_left * vlen )
if ( max_output <= ch_left * vlen + vr -> partition_size * ch_used / ch )
ptns_to_read --;
for (pass = 0; pass <= vr->maxpass; ++pass)
int voffset , partition_count , j_times_ptns_to_read ;
for (partition_count = 0; partition_count < ptns_to_read;)
if ( ! pass )
int ret ;
if ( ( ret = setup_classifs ( vc , vr , do_not_decode , ch_used , partition_count ) ) < 0 )
for (i = 0; (i < c_p_c) && (partition_count < ptns_to_read); ++i)
for (j_times_ptns_to_read = 0, j = 0; j < ch_used; ++j)
if ( ! do_not_decode [ j ] )
unsigned vqclass = classifs [ j_times_ptns_to_read + partition_count ] ;
j_times_ptns_to_read += ptns_to_read;
1
------------------------------
308092 108976/CWE606_Unchecked_Loop_Condition__char_connect_socket_83_goodB2G.cpp recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 84
CWE606_Unchecked_Loop_Condition__char_connect_socket_83_goodB2G::CWE606_Unchecked_Loop_Condition__char_connect_socket_83_goodB2G(char * dataCopy)
data = dataCopy;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
0
------------------------------
19459 CVE-2015-2726/Firefox_38.8.0esr_CVE_2015_2726_js_src_ctypes_CTypes.cpp size_t index = sign * size_t ( i - ii * IntegerType ( radix ) ) ; 2084
static
BuildTypeSource(JSContext*
JSObject*
bool
AutoString& result)
RootedObject typeObj ( cx , typeObj_ ) ;
switch ( CType :: GetTypeCode ( typeObj ) )
FunctionInfo * fninfo = FunctionType :: GetFunctionInfo ( typeObj ) ;
if ( fninfo -> mArgTypes . length ( ) > 0 )
for (size_t i = 0; i < fninfo->mArgTypes.length(); ++i)
BuildTypeSource ( cx , fninfo -> mArgTypes [ i ] , true , result );
static
BuildTypeSource(JSContext*
JSObject*
bool
AutoString& result)
RootedObject typeObj ( cx , typeObj_ ) ;
switch ( CType :: GetTypeCode ( typeObj ) )
FunctionInfo * fninfo = FunctionType :: GetFunctionInfo ( typeObj ) ;
if ( fninfo -> mArgTypes . length ( ) > 0 )
BuildTypeSource ( cx , fninfo -> mArgTypes [ i ] , true , result );
static
BuildTypeSource(JSContext*
JSObject*
bool
AutoString& result)
RootedObject typeObj ( cx , typeObj_ ) ;
switch ( CType :: GetTypeCode ( typeObj ) )
size_t length ;
if ( ArrayType :: GetSafeLength ( typeObj , & length ) )
IntegerToString ( length , 10 , result );
template<class IntegerType, class CharType, size_t N, class

IntegerToString(IntegerType i, int radix, Vector<CharType, N, AP>& result)
const bool isNegative = IsNegative ( i ) ;
size_t sign = isNegative ? - 1 : 1 ;
IntegerType ii = i / IntegerType ( radix ) ;
size_t index = sign * size_t ( i - ii * IntegerType ( radix ) ) ;
* -- cp = "0123456789abcdefghijklmnopqrstuvwxyz" [ index ];
i = ii;
while ( i != 0 )
* -- cp = '-';
MOZ_ASSERT ( cp >= buffer );
result . append ( cp , end );
0
------------------------------
309230 120796/CWE78_OS_Command_Injection__wchar_t_connect_socket_w32spawnl_32.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 ) 105
void CWE78_OS_Command_Injection__wchar_t_connect_socket_w32spawnl_32_bad()
wchar_t * data ;
wchar_t * * dataPtr1 = & data ;
wchar_t dataBuffer [ 100 ] = L ""
data = dataBuffer;
wchar_t * data = * dataPtr1 ;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
306827 117363/CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_fscanf_81_bad.cpp myString = ( wchar_t * ) malloc ( data * sizeof ( wchar_t ) ) 36
void CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_fscanf_81_bad::action(size_t data) const
wchar_t * myString ;
if ( data > wcslen ( HELLO_STRING ) )
myString = ( wchar_t * ) malloc ( data * sizeof ( wchar_t ) );
wcscpy ( myString , HELLO_STRING );
printWLine ( myString );
void printWLine (const wchar_t * line)
if ( line != NULL )
wprintf ( L "%ls\n" , line )
free ( myString );
1
------------------------------
298345 94121/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_connect_socket_34.c recvResult = recv ( connectSocket , ( char * ) ( password + passwordLen ) , ( 100 - passwordLen - 1 ) * sizeof ( char ) , 0 ) 77
void CWE319_Cleartext_Tx_Sensitive_Info__w32_char_connect_socket_34_bad()
char * password ;
char passwordBuffer [ 100 ] = "" ;
password = passwordBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t passwordLen = strlen ( password ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( password + passwordLen ) , ( 100 - passwordLen - 1 ) * sizeof ( char ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
password [ passwordLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( password , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( password , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
myUnion . unionFirst = password;
char * password = myUnion . unionSecond ;
if ( LogonUserA ( username , domain , password , LOGON32_LOGON_NETWORK , LOGON32_PROVIDER_DEFAULT , & pHandle ) != 0 )
1
------------------------------
310159 152040/dirent_uri.c apr_size_t seglen = ( ptr - seg ) ; 1376
svn_error_t *svn_dirent_condense_targets(const char **pcommon,apr_array_header_t **pcondensed_targets,const apr_array_header_t *targets,svn_boolean_t remove_redundancies,apr_pool_t *result_pool,apr_pool_t *scratch_pool)
int i ;
if ( targets -> nelts <= 0 )
svn_error_t * svn_err__temp = svn_dirent_get_absolute ( pcommon , ( ( const char * * ) ( targets -> elts ) ) [ 0 ] , scratch_pool ) ;
if ( svn_err__temp )
while ( 0 )
if ( targets -> nelts == 1 )
for (i = 1; i < targets -> nelts; ++i)
const char * rel = ( ( const char * * ) ( targets -> elts ) ) [ i ] ;
svn_error_t * svn_err__temp = svn_dirent_get_absolute ( & absolute , rel , scratch_pool ) ;
if ( svn_err__temp )
while ( 0 )
svn_error_t *svn_dirent_get_absolute(const char **pabsolute,const char *relative,apr_pool_t *pool)
apr_status_t apr_err ;
const char * path_apr ;
if ( ! ( ! svn_path_is_url ( relative ) ) )
svn_error_t * svn_err__temp = svn_error__malfunction ( ! 0 , "dirent_uri.c" , 1571 , "! svn_path_is_url(relative)" ) ;
if ( svn_err__temp )
while ( 0 )
while ( 0 )
svn_error_t * svn_err__temp = svn_path_cstring_from_utf8 ( & path_apr , relative , pool ) ;
if ( svn_err__temp )
while ( 0 )
apr_err = apr_filepath_merge ( & buffer , ( ( void * ) 0 ) , path_apr , 0x04 , pool );
if ( apr_err )
if ( svn_dirent_is_absolute ( relative ) && svn_dirent_is_canonical ( relative , pool ) && ! svn_path_is_backpath_present ( relative ) )
svn_boolean_t svn_dirent_is_canonical(const char *dirent,apr_pool_t *scratch_pool)
const char * ptr = dirent ;
if ( ( * ptr ) == 47 )
ptr ++;
return relpath_is_canonical ( ptr ) ;
static svn_boolean_t relpath_is_canonical(const char *relpath)
const char * ptr = relpath ;
const char * seg = relpath ;
if ( ( * relpath ) == '\0' )
if ( ( * ptr ) == 47 )
while ( 1 )
apr_size_t seglen = ( ptr - seg ) ;
if ( seglen == 1 && ( * seg ) == 46 )
if ( ( * ptr ) == 47 && ( * ( ptr + 1 ) ) == 47 )
if ( ! ( * ptr ) && ( * ( ptr - 1 ) ) == 47 )
if ( ! ( * ptr ) )
if ( ( * ptr ) == 47 )
ptr ++;
seg = ptr;
while ( * ptr && ( * ptr ) != 47 )
ptr ++;
0
------------------------------
314563 110878/CWE680_Integer_Overflow_to_Buffer_Overflow__new_rand_66b.cpp dataBytes = data * sizeof ( int ) 32
void bad()
int data ;
int dataArray [ 5 ] ;
data = - 1;
data = RAND32 ( );
dataArray [ 2 ] = data;
badSink ( dataArray );
void badSink(int dataArray[])
int data = dataArray [ 2 ] ;
size_t dataBytes , i ;
dataBytes = data * sizeof ( int );
intPointer = ( int * ) new char [ dataBytes ];
intPointer [ i ] = 0;
printIntLine ( intPointer [ 0 ] );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
delete [ ] intPointer
1
------------------------------
306365 120542/CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_execv_08.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 ) 118
void CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_execv_08_bad()
wchar_t * data ;
wchar_t dataBuffer [ 100 ] = L ""
data = dataBuffer;
if ( staticReturnsTrue ( ) )
static int staticReturnsTrue()
return 1 ;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
300595 150200/dirent_uri.c dirent = ( apr_palloc ( pool , blen + add_separator + clen + 1 ) ) 926
char *svn_dirent_join(const char *base,const char *component,apr_pool_t *pool)
apr_size_t blen = strlen ( base ) ;
apr_size_t clen = strlen ( component ) ;
char * dirent ;
int add_separator ;
if ( svn_dirent_is_absolute ( component ) )
svn_boolean_t svn_dirent_is_absolute(const char *dirent)
if ( ! dirent )
return 0 ;
if ( dirent [ 0 ] == 47 )
return ! 0 ;
return 0 ;
if ( base [ 0 ] == '\0' )
if ( component [ 0 ] == '\0' )
add_separator = 1;
if ( base [ blen - 1 ] == 47 )
add_separator = 0;
dirent = ( apr_palloc ( pool , blen + add_separator + clen + 1 ) );
memcpy ( dirent , base , blen );
dirent [ blen ] = 47;
memcpy ( ( dirent + blen + add_separator ) , component , clen + 1 );
return dirent ;
0
------------------------------
298691 90586/CWE23_Relative_Path_Traversal__char_listen_socket_fopen_83_bad.cpp recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ) 97
CWE23_Relative_Path_Traversal__char_listen_socket_fopen_83_bad::CWE23_Relative_Path_Traversal__char_listen_socket_fopen_83_bad(char * dataCopy)
data = dataCopy;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
0
------------------------------
305045 83809/CWE190_Integer_Overflow__int_rand_square_22b.c int result = data * data ; 61
static void goodB2G1()
int data ;
data = 0;
data = RAND32 ( );
CWE190_Integer_Overflow__int_rand_square_22_goodB2G1Sink ( data );
void CWE190_Integer_Overflow__int_rand_square_22_goodB2G1Sink(int data)
if ( CWE190_Integer_Overflow__int_rand_square_22_goodB2G1Global )
if ( abs ( ( long ) data ) <= ( long ) sqrt ( ( double ) INT_MAX ) )
int result = data * data ;
printIntLine ( result );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
0
------------------------------
19497 CVE-2015-2726/Firefox_38.8.0esr_CVE_2015_2726_js_src_ctypes_CTypes.cpp IntegerType ii = i / IntegerType ( radix ) ; 2083
static
BuildTypeName(JSContext* cx, JSObject* typeObj_)
AutoString result ;
RootedObject typeObj ( cx , typeObj_ ) ;
while ( 1 )
currentGrouping = CType :: GetTypeCode ( typeObj );

CType::GetTypeCode(JSObject* typeObj)
jsval result = JS_GetReservedSlot ( typeObj , SLOT_TYPECODE ) ;
return TypeCode ( result . toInt32 ( ) ) ;
switch ( currentGrouping )
typeObj = PointerType :: GetBaseType ( typeObj );

PointerType::GetBaseType(JSObject* obj)
jsval type = JS_GetReservedSlot ( obj , SLOT_TARGET_T ) ;
return & type . toObject ( ) ;
size_t length ;
if ( ArrayType :: GetSafeLength ( typeObj , & length ) )

ArrayType::GetSafeLength(JSObject* obj, size_t* result)
jsval length = JS_GetReservedSlot ( obj , SLOT_LENGTH ) ;
if ( length . isInt32 ( ) )
return true ;
if ( length . isDouble ( ) )
return true ;
return false ;
IntegerToString ( length , 10 , result );
typeObj = ArrayType :: GetBaseType ( typeObj );

ArrayType::GetBaseType(JSObject* obj)
jsval type = JS_GetReservedSlot ( obj , SLOT_ELEMENT_T ) ;
return & type . toObject ( ) ;
FunctionInfo * fninfo = FunctionType :: GetFunctionInfo ( typeObj ) ;
typeObj = fninfo -> mReturnType;
template<class IntegerType, class CharType, size_t N, class

IntegerToString(IntegerType i, int radix, Vector<CharType, N, AP>& result)
IntegerType ii = i / IntegerType ( radix ) ;
size_t index = sign * size_t ( i - ii * IntegerType ( radix ) ) ;
* -- cp = "0123456789abcdefghijklmnopqrstuvwxyz" [ index ];
i = ii;
while ( i != 0 )
* -- cp = '-';
MOZ_ASSERT ( cp >= buffer );
result . append ( cp , end );
0
------------------------------
300444 152633/aviobuf.c s -> buf_end = s -> buffer + buffer_size 156
int ffio_open_dyn_packet_buf(AVIOContext **s,int max_packet_size)
if ( max_packet_size <= 0 )
return url_open_dyn_buf_internal ( s , max_packet_size ) ;
static int url_open_dyn_buf_internal(AVIOContext **s,int max_packet_size)
DynBuffer * d ;
unsigned int io_buffer_size = ( max_packet_size ? max_packet_size : 1024 ) ;
if ( sizeof ( DynBuffer ) + io_buffer_size < io_buffer_size )
d = ( av_mallocz ( sizeof ( DynBuffer ) + io_buffer_size ) );
if ( ! d )
d -> io_buffer_size = io_buffer_size;
* s = avio_alloc_context ( d -> io_buffer , d -> io_buffer_size , 1 , d , ( ( void * ) 0 ) , ( max_packet_size ? dyn_packet_buf_write : dyn_buf_write ) , ( max_packet_size ? ( ( void * ) 0 ) : dyn_buf_seek ) );
AVIOContext *avio_alloc_context(unsigned char *buffer,int buffer_size,int write_flag,void *opaque,int (*read_packet)(void *, uint8_t *, int ),int (*write_packet)(void *, uint8_t *, int ),int64_t (*seek)(void *, int64_t , int ))
AVIOContext * s = ( av_mallocz ( sizeof ( AVIOContext ) ) ) ;
if ( ! s )
ffio_init_context ( s , buffer , buffer_size , write_flag , opaque , read_packet , write_packet , seek );
int ffio_init_context(AVIOContext *s,unsigned char *buffer,int buffer_size,int write_flag,void *opaque,int (*read_packet)(void *, uint8_t *, int ),int (*write_packet)(void *, uint8_t *, int ),int64_t (*seek)(void *, int64_t , int ))
s -> buffer = buffer;
s -> buffer_size = buffer_size;
s -> buf_ptr = buffer;
s -> opaque = opaque;
s -> direct = 0;
s -> write_packet = write_packet;
s -> read_packet = read_packet;
s -> seek = seek;
s -> pos = 0;
s -> must_flush = 0;
s -> eof_reached = 0;
s -> error = 0;
s -> seekable = 0x1;
s -> max_packet_size = 0;
s -> update_checksum = ( ( void * ) 0 );
if ( ! read_packet && ! write_flag )
s -> pos = buffer_size;
s -> buf_end = s -> buffer + buffer_size;
s -> read_pause = ( ( void * ) 0 );
s -> read_seek = ( ( void * ) 0 );
0
------------------------------
306518 117420/CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_rand_06.c myString = ( wchar_t * ) malloc ( data * sizeof ( wchar_t ) ) 129
static void goodB2G2()
size_t data ;
data = 0;
if ( STATIC_CONST_FIVE == 5 )
data = rand ( );
if ( STATIC_CONST_FIVE == 5 )
wchar_t * myString ;
if ( data > wcslen ( HELLO_STRING ) && data < 100 )
myString = ( wchar_t * ) malloc ( data * sizeof ( wchar_t ) );
wcscpy ( myString , HELLO_STRING );
printWLine ( myString );
void printWLine (const wchar_t * line)
if ( line != NULL )
wprintf ( L "%ls\n" , line )
free ( myString );
0
------------------------------
310741 151097/aviobuf.c s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_ptr - s -> checksum_ptr ) ) ) 164
int avio_close_dyn_buf(AVIOContext *s,uint8_t **pbuffer)
avio_flush ( s );
void avio_flush(AVIOContext *s)
flush_buffer ( s );
static void flush_buffer(AVIOContext *s)
if ( s -> buf_ptr > s -> buffer )
if ( s -> update_checksum )
s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_ptr - s -> checksum_ptr ) ) );
s -> checksum_ptr = s -> buffer;
s -> buf_ptr = s -> buffer;
0
------------------------------
304728 80303/CWE134_Uncontrolled_Format_String__char_listen_socket_printf_06.c recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 103
void CWE134_Uncontrolled_Format_String__char_listen_socket_printf_06_bad()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
if ( STATIC_CONST_FIVE == 5 )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
printf ( data );
1
------------------------------
313469 89800/CWE23_Relative_Path_Traversal__char_connect_socket_w32CreateFile_45.cpp recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ) 117
void bad()
char * data ;
char dataBuffer [ FILENAME_MAX ] = BASEPATH ;
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
badData = data;
0
------------------------------
312548 149429/dirent_uri.c apr_size_t seglen = ( ptr - seg ) ; 1363
char *svn_fspath__join(const char *fspath,const char *relpath,apr_pool_t *result_pool)
char * result ;
if ( relpath [ 0 ] == '\0' )
result = apr_pstrdup ( result_pool , fspath );
if ( fspath [ 1 ] == '\0' )
result = apr_pstrcat ( result_pool , "/" , relpath , ( ( char * ) ( ( void * ) 0 ) ) );
result = apr_pstrcat ( result_pool , fspath , "/" , relpath , ( ( char * ) ( ( void * ) 0 ) ) );
svn_fspath__is_canonical ( result ) ? ( ( void ) 0 ) : __assert_fail ( "svn_fspath__is_canonical(result)" , "dirent_uri.c" , 2553 , __PRETTY_FUNCTION__ );
svn_boolean_t svn_fspath__is_canonical(const char *fspath)
return fspath [ 0 ] == 47 && relpath_is_canonical ( fspath + 1 ) ;
static svn_boolean_t relpath_is_canonical(const char *relpath)
const char * ptr = relpath ;
const char * seg = relpath ;
if ( ( * relpath ) == '\0' )
if ( ( * ptr ) == 47 )
while ( 1 )
apr_size_t seglen = ( ptr - seg ) ;
if ( seglen == 1 && ( * seg ) == 46 )
if ( ( * ptr ) == 47 && ( * ( ptr + 1 ) ) == 47 )
if ( ! ( * ptr ) && ( * ( ptr - 1 ) ) == 47 )
if ( ! ( * ptr ) )
if ( ( * ptr ) == 47 )
ptr ++;
seg = ptr;
while ( * ptr && ( * ptr ) != 47 )
ptr ++;
0
------------------------------
307982 116996/CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_14.c myString = ( char * ) malloc ( data * sizeof ( char ) ) 123
void CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_14_bad()
size_t data ;
data = 0;
if ( globalFive == 5 )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
char inputBuffer [ CHAR_ARRAY_SIZE ] ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
inputBuffer [ recvResult ] = '\0';
data = strtoul ( inputBuffer , NULL , 0 );
while ( 0 )
if ( globalFive == 5 )
char * myString ;
if ( data > strlen ( HELLO_STRING ) )
myString = ( char * ) malloc ( data * sizeof ( char ) );
strcpy ( myString , HELLO_STRING );
printLine ( myString );
void printLine (const char * line)
if ( line != NULL )
printf ( "%s\n" , line );
free ( myString );
1
------------------------------
308364 117081/CWE789_Uncontrolled_Mem_Alloc__malloc_char_fscanf_03.c myString = ( char * ) malloc ( data * sizeof ( char ) ) 163
static void goodG2B1()
size_t data ;
data = 0;
if ( 5 != 5 )
data = 20;
if ( 5 == 5 )
char * myString ;
if ( data > strlen ( HELLO_STRING ) )
myString = ( char * ) malloc ( data * sizeof ( char ) );
strcpy ( myString , HELLO_STRING );
printLine ( myString );
void printLine (const char * line)
if ( line != NULL )
printf ( "%s\n" , line );
free ( myString );
0
------------------------------
18265 CVE-2015-5154/Xen_4.5.0_CVE-2015-5154_ide.c size = ( s -> cd_sector_size - s -> io_buffer_index ) 1631
static void ide_atapi_cmd(IDEState *s)
const uint8_t * packet ;
int max_len ;
packet = s -> io_buffer;
if ( s -> sense_key == SENSE_UNIT_ATTENTION && s -> io_buffer [ 0 ] != GPCMD_REQUEST_SENSE && s -> io_buffer [ 0 ] != GPCMD_INQUIRY )
switch ( s -> io_buffer [ 0 ] )
if ( packet [ 0 ] == GPCMD_MODE_SENSE_10 )
max_len = ube16_to_cpu ( packet + 7 );
max_len = packet [ 4 ];
max_len = packet [ 4 ];
if ( s -> sense_key == SENSE_UNIT_ATTENTION )
s -> sense_key = SENSE_NONE;
uint64_t total_sectors ;
total_sectors >>= 2;
max_len = ube16_to_cpu ( packet + 8 );
int format , msf , start_track , len ;
uint64_t total_sectors ;
total_sectors >>= 2;
if ( total_sectors == 0 )
max_len = ube16_to_cpu ( packet + 7 );
format = packet [ 9 ] >> 6;
switch ( format )
ide_atapi_cmd_reply ( s , 12 , max_len );
static void ide_atapi_cmd_reply(IDEState *s, int size, int max_size)
if ( size > max_size )
size = max_size;
s -> lba = - 1;
s -> packet_transfer_size = size;
s -> io_buffer_size = size;
s -> elementary_transfer_size = 0;
s -> io_buffer_index = 0;
if ( s -> atapi_dma )
s -> status = READY_STAT | SEEK_STAT | DRQ_STAT;
s -> status = READY_STAT | SEEK_STAT;
ide_atapi_cmd_reply_end ( s );
static void ide_atapi_cmd_reply_end(IDEState *s)
int byte_count_limit , size , ret ;
if ( s -> packet_transfer_size <= 0 )
s -> status = READY_STAT | SEEK_STAT;
s -> nsector = ( s -> nsector & ~7 ) | ATAPI_INT_REASON_IO | ATAPI_INT_REASON_CD;
if ( s -> lba != - 1 && s -> io_buffer_index >= s -> cd_sector_size )
ret = cd_read_sector ( s -> bs , s -> lba , s -> io_buffer , s -> cd_sector_size );
if ( ret < 0 )
s -> lba ++;
s -> io_buffer_index = 0;
if ( s -> elementary_transfer_size > 0 )
size = s -> cd_sector_size - s -> io_buffer_index;
if ( size > s -> elementary_transfer_size )
size = s -> elementary_transfer_size;
s -> packet_transfer_size -= size;
s -> elementary_transfer_size -= size;
s -> io_buffer_index += size;
s -> nsector = ( s -> nsector & ~7 ) | ATAPI_INT_REASON_IO;
byte_count_limit = s -> lcyl | ( s -> hcyl << 8 );
if ( byte_count_limit == 0xffff )
byte_count_limit --;
size = s -> packet_transfer_size;
if ( size > byte_count_limit )
if ( byte_count_limit & 1 )
byte_count_limit --;
size = byte_count_limit;
s -> lcyl = size;
s -> hcyl = size >> 8;
s -> elementary_transfer_size = size;
if ( s -> lba != - 1 )
if ( size > ( s -> cd_sector_size - s -> io_buffer_index ) )
size = ( s -> cd_sector_size - s -> io_buffer_index );
ide_transfer_start ( s , s -> io_buffer + s -> io_buffer_index , size , ide_atapi_cmd_reply_end );
s -> packet_transfer_size -= size;
s -> elementary_transfer_size -= size;
s -> io_buffer_index += size;
ide_set_irq ( s );
printf ( "status=0x%x\n" , s -> status );
0
------------------------------
18295 CVE-2015-5154/Xen_4.5.0_CVE-2015-5154_ide.c s = ide_state + i 3149
void pci_piix3_ide_init(PCIBus *bus, BlockDriverState **hd_table, int
qemu_irq *pic)
PCIIDEState * d ;
d = ( PCIIDEState * ) pci_register_device ( bus , "PIIX3 IDE" , sizeof ( PCIIDEState ) , devfn , NULL , NULL );
d -> type = IDE_TYPE_PIIX3;
ide_init2 ( & d -> ide_if [ 2 ] , hd_table [ 2 ] , hd_table [ 3 ] , pic [ 15 ] );
static void ide_init2(IDEState
BlockDriverState *hd0, BlockDriverState
qemu_irq irq)
IDEState * s ;
int i , cylinders , heads , secs ;
for(i = 0; i < 2; i++)
s = ide_state + i;
s -> io_buffer = qemu_memalign ( 512 , IDE_DMA_BUF_SECTORS * 512 + 4 );
s -> bs = hd0;
s -> bs = hd1;
if ( s -> bs )
bdrv_get_geometry ( s -> bs , & nb_sectors );
bdrv_guess_geometry ( s -> bs , & cylinders , & heads , & secs );
s -> cylinders = cylinders;
s -> heads = heads;
s -> sectors = secs;
s -> nb_sectors = nb_sectors;
if ( bdrv_get_type_hint ( s -> bs ) == BDRV_TYPE_CDROM )
s -> is_cdrom = 1;
bdrv_set_change_cb ( s -> bs , cdrom_change_cb , s );
s -> drive_serial = drive_serial ++;
strncpy ( s -> drive_serial_str , drive_get_serial ( s -> bs ) , sizeof ( s -> drive_serial_str ) );
if ( strlen ( s -> drive_serial_str ) == 0 )
snprintf ( s -> drive_serial_str , sizeof ( s -> drive_serial_str ) , "QM%05d" , s -> drive_serial );
s -> irq = irq;
s -> sector_write_timer = qemu_new_timer ( vm_clock , ide_sector_write_timer_cb , s );
s -> write_cache = 0;
ide_reset ( s );
0
------------------------------
303644 79210/CWE134_Uncontrolled_Format_String__char_connect_socket_snprintf_17.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 97
void CWE134_Uncontrolled_Format_String__char_connect_socket_snprintf_17_bad()
int i , j ;
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
for(i = 0; i < 1; i++)
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
SNPRINTF ( dest , 100 - 1 , data );
1
------------------------------
16620 CVE-2011-3191/CVE_2011_3191_PATCHED_CIFSFindNext.c pSMB -> SearchCount = cpu_to_le16 ( CIFSMaxBufSize / sizeof ( FILE_UNIX_INFO ) ) 43
int CVE_2011_3191_PATCHED_CIFSFindNext(const int xid, struct cifsTconInfo
__u16 searchHandle, struct cifs_search_info *psrch_inf)
TRANSACTION2_FNEXT_REQ * pSMB = NULL ;
if ( psrch_inf -> endOfSearch )
rc = smb_init ( SMB_COM_TRANSACTION2 , 15 , tcon , ( void * * ) & pSMB , ( void * * ) & pSMBr );
if ( rc )
pSMB -> TotalDataCount = 0;
pSMB -> MaxParameterCount = cpu_to_le16 ( 8 );
pSMB -> MaxDataCount = cpu_to_le16 ( ( tcon -> ses -> server -> maxBuf - MAX_CIFS_HDR_SIZE ) & 0xFFFFFF00 );
pSMB -> MaxSetupCount = 0;
pSMB -> Reserved = 0;
pSMB -> Flags = 0;
pSMB -> Timeout = 0;
pSMB -> Reserved2 = 0;
pSMB -> ParameterOffset = cpu_to_le16
offsetof ( struct smb_com_transaction2_fnext_req , SearchHandle ) - 4 )
pSMB -> DataCount = 0;
pSMB -> DataOffset = 0;
pSMB -> SetupCount = 1;
pSMB -> Reserved3 = 0;
pSMB -> SubCommand = cpu_to_le16 ( TRANS2_FIND_NEXT );
pSMB -> SearchHandle = searchHandle;
pSMB -> SearchCount = cpu_to_le16 ( CIFSMaxBufSize / sizeof ( FILE_UNIX_INFO ) );
0
------------------------------
312653 150898/bufmgr.c oldPartitionLock = ( ( LWLockId ) ( FirstBufMappingLock + oldHash % 16 ) ) 884
void DropRelFileNodeAllBuffers(RelFileNodeBackend rnode)
int i ;
if ( rnode . backend != - 1 )
for (i = 0; i < NBuffers; i++)
volatile BufferDesc * bufHdr = ( & BufferDescriptors [ i ] ) ;
if ( ! ( bufHdr -> tag . rnode . relNode == rnode . node . relNode && bufHdr -> tag . rnode . dbNode == rnode . node . dbNode && bufHdr -> tag . rnode . spcNode == rnode . node . spcNode ) )
if ( bufHdr -> tag . rnode . relNode == rnode . node . relNode && bufHdr -> tag . rnode . dbNode == rnode . node . dbNode && bufHdr -> tag . rnode . spcNode == rnode . node . spcNode )
InvalidateBuffer ( bufHdr );
static void InvalidateBuffer(volatile BufferDesc *buf)
BufferTag oldTag ;
uint32 oldHash ;
LWLockId oldPartitionLock ;
oldTag = buf -> tag;
oldHash = BufTableHashCode ( & oldTag );
oldPartitionLock = ( ( LWLockId ) ( FirstBufMappingLock + oldHash % 16 ) );
LWLockAcquire ( oldPartitionLock , LW_EXCLUSIVE );
LWLockRelease ( oldPartitionLock );
LWLockRelease ( oldPartitionLock );
LWLockRelease ( oldPartitionLock );
0
------------------------------
305006 80328/CWE134_Uncontrolled_Format_String__char_listen_socket_printf_52a.c recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 206
static void goodB2G()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
CWE134_Uncontrolled_Format_String__char_listen_socket_printf_52b_goodB2GSink ( data );
void CWE134_Uncontrolled_Format_String__char_listen_socket_printf_52b_goodB2GSink(char * data)
CWE134_Uncontrolled_Format_String__char_listen_socket_printf_52c_goodB2GSink ( data );
void CWE134_Uncontrolled_Format_String__char_listen_socket_printf_52c_goodB2GSink(char * data)
printf ( "%s\n" , data );
0
------------------------------
303415 80479/CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_65a.c recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 102
void CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_65_bad()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
funcPtr ( data , data );
0
------------------------------
21374 CVE-2015-5307/linux_kernel_4.2.6_CVE_2015_5307_arch_x86_kvm_vmx.c u32 mask = 1 << ( seg * SEG_FIELD_NR + field ) ; 1518
static void enter_pmode(struct kvm_vcpu *vcpu)
struct vcpu_vmx * vmx = to_vmx ( vcpu ) ;
vmx_get_segment ( vcpu , & vmx -> rmode . segs [ VCPU_SREG_SS ] , VCPU_SREG_SS );
static void vmx_get_segment(struct kvm_vcpu
struct kvm_segment *var, int seg)
struct vcpu_vmx * vmx = to_vmx ( vcpu ) ;
if ( vmx -> rmode . vm86_active && seg != VCPU_SREG_LDTR )
var -> base = vmx_read_guest_seg_base ( vmx , seg );
var -> limit = vmx_read_guest_seg_limit ( vmx , seg );
var -> selector = vmx_read_guest_seg_selector ( vmx , seg );
static u16 vmx_read_guest_seg_selector(struct vcpu_vmx *vmx, unsigned seg)
if ( ! vmx_segment_cache_test_set ( vmx , seg , SEG_FIELD_SEL ) )
static bool vmx_segment_cache_test_set(struct vcpu_vmx *vmx, unsigned
unsigned field)
u32 mask = 1 << ( seg * SEG_FIELD_NR + field ) ;
ret = vmx -> segment_cache . bitmask & mask;
vmx -> segment_cache . bitmask |= mask;
return ret ;
0
------------------------------
312689 150892/dfa.c dfa -> multibyte_prop [ dfa -> tindex - 1 ] = dfa -> multibyte_prop [ tindex + i ] 2103
static void closure()
int i ;
size_t tindex ;
size_t ntokens ;
while ( tok == QMARK || tok == STAR || tok == PLUS || tok == REPMN )
if ( tok == REPMN && ( minrep || maxrep ) )
ntokens = nsubtoks ( dfa -> tindex );
tindex = dfa -> tindex - ntokens;
for (i = 1; i < minrep; ++i)
copytoks ( tindex , ntokens );
tok = lex ( );
if ( tok == REPMN )
dfa -> tindex -= nsubtoks ( dfa -> tindex );
tok = lex ( );
tok = lex ( );
static void copytoks(size_t tindex,size_t ntokens)
size_t i ;
for (i = 0; i < ntokens; ++i)
addtok ( dfa -> tokens [ tindex + i ] );
if ( __ctype_get_mb_cur_max ( ) > 1 && dfa -> tokens [ tindex + i ] == MBCSET )
dfa -> multibyte_prop [ dfa -> tindex - 1 ] = dfa -> multibyte_prop [ tindex + i ];
0
------------------------------
300724 153513/utils.c dest_end = dest + dest_len - 1 4422
void ff_parse_key_value(const char *str,ff_parse_key_val_cb callback_get_buf,void *context)
const char * ptr = str ;
const char * key ;
char * dest = ( ( void * ) 0 ) ;
char * dest_end ;
int dest_len = 0 ;
while ( * ptr && ( av_isspace ( ( * ptr ) ) || ( * ptr ) == ',' ) )
ptr ++;
if ( ! ( * ptr ) )
key = ptr;
if ( ! ( ptr = ( strchr ( key , '=' ) ) ) )
ptr ++;
dest_end = dest + dest_len - 1;
if ( ( * ptr ) == '\"' )
ptr ++;
while ( * ptr && ( * ptr ) != '\"' )
if ( ( * ptr ) == '\\' )
if ( ! ptr [ 1 ] )
if ( dest && dest < dest_end )
ptr += 2;
if ( dest && dest < dest_end )
ptr ++;
if ( ( * ptr ) == '\"' )
ptr ++;
for (;  *ptr && !(av_isspace(( *ptr)) || ( *ptr) == ','); ptr++)
if ( dest && dest < dest_end )
0
------------------------------
303067 84685/CWE190_Integer_Overflow__unsigned_int_rand_square_53d.c unsigned int result = data * data ; 28
void CWE190_Integer_Overflow__unsigned_int_rand_square_53_bad()
unsigned int data ;
data = 0;
data = ( unsigned int ) RAND32 ( );
CWE190_Integer_Overflow__unsigned_int_rand_square_53b_badSink ( data );
void CWE190_Integer_Overflow__unsigned_int_rand_square_53b_badSink(unsigned int data)
CWE190_Integer_Overflow__unsigned_int_rand_square_53c_badSink ( data );
void CWE190_Integer_Overflow__unsigned_int_rand_square_53c_badSink(unsigned int data)
CWE190_Integer_Overflow__unsigned_int_rand_square_53d_badSink ( data );
void CWE190_Integer_Overflow__unsigned_int_rand_square_53d_badSink(unsigned int data)
unsigned int result = data * data ;
printUnsignedLine ( result );
void printUnsignedLine(unsigned unsignedNumber)
printf ( "%u\n" , unsignedNumber );
1
------------------------------
16195 CVE-2013-1732/CVE_2013_1732_PATCHED_nsBlockFrame__Reflow.c bbox . y = position . mBaseline - metrics . ascent 187

CVE_2013_1732_PATCHED_nsBlockFrame::Reflow(nsPresContext*
nsHTMLReflowMetrics&
const nsHTMLReflowState&
nsReflowStatus&          aStatus)
const nsHTMLReflowState * reflowState = & aReflowState ;
nsAutoPtr < nsHTMLReflowState > mutableReflowState ;
if ( aReflowState . availableHeight != NS_UNCONSTRAINEDSIZE && aReflowState . ComputedHeight ( ) != NS_AUTOHEIGHT && ApplyOverflowClipping ( this , aReflowState . mStyleDisplay ) )
nsMargin heightExtras = aReflowState . mComputedBorderPadding ;
if ( GetSkipSides ( ) & NS_SIDE_TOP )
heightExtras . top = 0;
heightExtras . top += aReflowState . mComputedMargin . top;
if ( GetEffectiveComputedHeight ( aReflowState ) + heightExtras . TopBottom ( ) <= aReflowState . availableHeight )
mutableReflowState = new nsHTMLReflowState ( aReflowState );
mutableReflowState -> availableHeight = NS_UNCONSTRAINEDSIZE;
reflowState = mutableReflowState;
if ( IsFrameTreeTooDeep ( * reflowState , aMetrics , aStatus ) )
nsBlockReflowState state ( * reflowState , aPresContext , this , aMetrics , topMarginRoot , bottomMarginRoot , needFloatManager ) ;
state . mOverflowTracker = & tracker;
nsOverflowAreas fcBounds ;
nsReflowStatus fcStatus = NS_FRAME_COMPLETE ;
rv = ReflowPushedFloats ( state , fcBounds , fcStatus );
rv = ReflowDirtyLines ( state );
if ( NS_FAILED ( rv ) )
if ( HasOutsideBullet ( ) && ! mLines . empty ( ) && ( mLines . front ( ) -> IsBlock ( ) || ( 0 == mLines . front ( ) -> mBounds . height && mLines . front ( ) != mLines . back ( ) && mLines . begin ( ) . next ( ) -> IsBlock ( ) ) ) )
nsHTMLReflowMetrics metrics ;
nsLayoutUtils :: LinePosition position ;
bool havePosition = nsLayoutUtils :: GetFirstLinePosition ( this , & position ) ;
nsIFrame * bullet = GetOutsideBullet ( ) ;
if ( havePosition && ! BulletIsEmpty ( ) )
nsRect bbox = bullet -> GetRect ( ) ;
bbox . y = position . mBaseline - metrics . ascent;
0
------------------------------
308740 117260/CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_connect_socket_65b.c myString = ( wchar_t * ) malloc ( data * sizeof ( wchar_t ) ) 86
void CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_connect_socket_65b_goodG2BSink(size_t data)
wchar_t * myString ;
if ( data > wcslen ( HELLO_STRING ) )
myString = ( wchar_t * ) malloc ( data * sizeof ( wchar_t ) );
wcscpy ( myString , HELLO_STRING );
printWLine ( myString );
void printWLine (const wchar_t * line)
if ( line != NULL )
wprintf ( L "%ls\n" , line )
free ( myString );
0
------------------------------
17933 CVE-2016-5275/Firefox_49.0b1_CVE_2016_5275_gfx_src_FilterSupport.cpp aOutMatrix [ 1 ] = aAmount * aToMatrix [ 1 ] 384
static
ComputeColorMatrix(uint32_t aColorMatrixType, const nsTArray<float>&
float aOutMatrix[20])
static const float lumR = 0.2126f ;
static const float lumG = 0.7152f ;
static const float lumB = 0.0722f ;
static const float oneMinusLumR = 1 - lumR ;
static const float oneMinusLumG = 1 - lumG ;
static const float oneMinusLumB = 1 - lumB ;
static const float sepiaMatrix [ ] = { 0.393f , 0.769f , 0.189f , 0 , 0 , 0.349f , 0.686f , 0.168f , 0 , 0 , 0.272f , 0.534f , 0.131f , 0 , 0 , 0 , 0 , 0 , 1 , 0 } ;
static const float hueRotateR = 0.143f ;
static const float hueRotateG = 0.140f ;
static const float hueRotateB = 0.283f ;
switch ( aColorMatrixType )
if ( aValues . Length ( ) != 1 )
float hueRotateValue = aValues [ 0 ] ;
float c = static_cast < float > ( cos ( hueRotateValue * M_PI / 180 ) ) ;
float s = static_cast < float > ( sin ( hueRotateValue * M_PI / 180 ) ) ;
aOutMatrix [ 0 ] = lumR + oneMinusLumR * c - lumR * s;
aOutMatrix [ 1 ] = lumG - lumG * c - lumG * s;
aOutMatrix [ 2 ] = lumB - lumB * c + oneMinusLumB * s;
aOutMatrix [ 5 ] = lumR - lumR * c + hueRotateR * s;
aOutMatrix [ 6 ] = lumG + oneMinusLumG * c + hueRotateG * s;
aOutMatrix [ 7 ] = lumB - lumB * c - hueRotateB * s;
aOutMatrix [ 10 ] = lumR - lumR * c - oneMinusLumR * s;
aOutMatrix [ 11 ] = lumG - lumG * c + lumG * s;
aOutMatrix [ 12 ] = lumB + oneMinusLumB * c + lumB * s;
if ( aValues . Length ( ) != 1 )
float amount = aValues [ 0 ] ;
if ( amount < 0 || amount > 1 )
InterpolateFromIdentityMatrix ( sepiaMatrix , amount , aOutMatrix );
static
InterpolateFromIdentityMatrix(const float aToMatrix[20], float
float aOutMatrix[20])
float oneMinusAmount = 1 - aAmount ;
aOutMatrix [ 0 ] = aAmount * aToMatrix [ 0 ] + oneMinusAmount;
aOutMatrix [ 1 ] = aAmount * aToMatrix [ 1 ];
aOutMatrix [ 2 ] = aAmount * aToMatrix [ 2 ];
aOutMatrix [ 5 ] = aAmount * aToMatrix [ 5 ];
aOutMatrix [ 6 ] = aAmount * aToMatrix [ 6 ] + oneMinusAmount;
aOutMatrix [ 7 ] = aAmount * aToMatrix [ 7 ];
aOutMatrix [ 10 ] = aAmount * aToMatrix [ 10 ];
aOutMatrix [ 11 ] = aAmount * aToMatrix [ 11 ];
aOutMatrix [ 12 ] = aAmount * aToMatrix [ 12 ] + oneMinusAmount;
0
------------------------------
20057 CVE-2015-8817/qemu_1.6.0_CVE-2015-8817_exec.c * xlat = addr + section -> offset_within_region 261
uint64_t ldq_phys(hwaddr addr)
return ldq_phys_internal ( addr , DEVICE_NATIVE_ENDIAN ) ;
static inline uint64_t ldq_phys_internal(hwaddr
enum device_endian endian)
MemoryRegion * mr ;
mr = address_space_translate ( & address_space_memory , addr , & addr1 , & l , false );
MemoryRegion *address_space_translate(AddressSpace *as, hwaddr
hwaddr *xlat, hwaddr
bool is_write)
IOMMUTLBEntry iotlb ;
MemoryRegionSection * section ;
MemoryRegion * mr ;
section = address_space_translate_internal ( as -> dispatch , addr , & addr , plen , true );
mr = section -> mr;
if ( ! mr -> iommu_ops )
iotlb = mr -> iommu_ops -> translate ( mr , addr );
addr = ( ( iotlb . translated_addr & ~iotlb . addr_mask ) | ( addr & iotlb . addr_mask ) );
if ( ! ( iotlb . perm & ( 1 << is_write ) ) )
as = iotlb . target_as;
static MemoryRegionSection
address_space_translate_internal(AddressSpaceDispatch *d, hwaddr addr, hwaddr
hwaddr *plen, bool resolve_subpage)
MemoryRegionSection * section ;
section = address_space_lookup_region ( d , addr , resolve_subpage );
addr -= section -> offset_within_address_space;
* xlat = addr + section -> offset_within_region;
0
------------------------------
313344 90848/CWE23_Relative_Path_Traversal__wchar_t_connect_socket_ifstream_31.cpp recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ) 96
void bad()
wchar_t * data ;
wchar_t dataBuffer [ FILENAME_MAX ] = BASEPATH ;
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( FILENAME_MAX - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
302520 80528/CWE134_Uncontrolled_Format_String__char_listen_socket_w32_vsnprintf_66a.c recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 212
static void goodB2G()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
dataArray [ 2 ] = data;
CWE134_Uncontrolled_Format_String__char_listen_socket_w32_vsnprintf_66b_goodB2GSink ( dataArray );
void CWE134_Uncontrolled_Format_String__char_listen_socket_w32_vsnprintf_66b_goodB2GSink(char * dataArray[])
char * data = dataArray [ 2 ] ;
goodB2GVaSink ( data , data );
static void goodB2GVaSink(char * data, ...)
va_start ( args , data );
0
------------------------------
303838 84088/CWE190_Integer_Overflow__short_max_square_11.c short result = data * data ; 37
void CWE190_Integer_Overflow__short_max_square_11_bad()
short data ;
data = 0;
if ( globalReturnsTrue ( ) )
int globalReturnsTrue()
return 1 ;
data = SHRT_MAX;
if ( globalReturnsTrue ( ) )
int globalReturnsTrue()
return 1 ;
short result = data * data ;
printIntLine ( result );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
1
------------------------------
304506 82935/CWE190_Integer_Overflow__int64_t_rand_square_10.c int64_t result = data * data ; 37
void CWE190_Integer_Overflow__int64_t_rand_square_10_bad()
int64_t data ;
data = 0L L
if ( globalTrue )
data = ( int64_t ) RAND64 ( );
if ( globalTrue )
int64_t result = data * data ;
printLongLongLine ( result );
void printLongLongLine (int64_t longLongIntNumber)
printf ( "%lld\n" , longLongIntNumber );
1
------------------------------
314501 96934/CWE36_Absolute_Path_Traversal__wchar_t_connect_socket_w32CreateFile_05.cpp recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ) 99
void bad()
wchar_t * data ;
wchar_t dataBuffer [ FILENAME_MAX ] = L ""
data = dataBuffer;
if ( staticTrue )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( FILENAME_MAX - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
312299 151946/oids.c subids_overflow = subids + n 990
const gchar *oid_resolved_from_string(const gchar *oid_str)
guint subid_oid_length = oid_string2subid ( oid_str , & subid_oid ) ;
guint oid_string2subid(const char *str,guint32 **subids_p)
guint32 * subids ;
guint32 * subids_overflow ;
guint n = check_num_oid ( str ) ;
if ( ! n )
* subids_p = subids = ( ep_alloc0 ( sizeof ( guint32 ) * n ) );
subids_overflow = subids + n;
if ( subids >= subids_overflow || subid > 0xffffffff )
0
------------------------------
299676 150889/dfa.c wc = inputwcs [ * pp - mbclen - buf_begin ] 3458
char *dfaexec(struct dfa *d,const char *begin,char *end,int allow_nl,size_t *count,int *backref)
state_num s ;
state_num s1 ;
const unsigned char * p ;
state_num * * trans ;
state_num * t ;
unsigned char eol = eolbyte ;
s = s1 = 0;
p = ( ( const unsigned char * ) begin );
trans = d -> trans;
* end = eol;
if ( d -> mb_cur_max > 1 )
while ( ( t = trans [ s ] ) != ( ( void * ) 0 ) )
if ( p > buf_end )
s1 = s;
if ( s == 0 )
if ( ( ( char * ) p ) >= end )
if ( d -> states [ s ] . mbps . nelem == 0 )
s = t [ * ( p ++ ) ];
if ( backref )
s = transit_state ( d , s , & p );
trans = d -> trans;
while ( ( t = trans [ s ] ) != ( ( void * ) 0 ) )
s1 = t [ * ( p ++ ) ];
if ( ( t = trans [ s1 ] ) == ( ( void * ) 0 ) )
state_num tmp = s ;
s = s1;
s1 = tmp;
s = t [ * ( p ++ ) ];
if ( s >= 0 && ( ( char * ) p ) <= end && d -> fails [ s ] )
if ( d -> success [ s ] & sbit [ * p ] )
s1 = s;
if ( d -> mb_cur_max > 1 )
s = transit_state ( d , s , & p );
trans = d -> trans;
s = d -> fails [ s ] [ * ( p ++ ) ];
if ( ( ( char * ) p ) > end )
if ( s >= 0 )
trans = d -> trans;
if ( p [ - 1 ] == eol && allow_nl )
s = d -> newlines [ s1 ];
s = 0;
static state_num transit_state(struct dfa *d,state_num s,const unsigned char **pp)
int mbclen ;
int maxlen = 0 ;
size_t i ;
size_t nelem = d -> states [ s ] . mbps . nelem ;
const unsigned char * p1 = * pp ;
wchar_t wc ;
if ( nelem > 0 )
match_lens = check_matching_with_multibyte_ops ( d , s , ( * pp - buf_begin ) );
for (i = 0; i < nelem; i++)
if ( match_lens [ i ] > maxlen )
maxlen = match_lens [ i ];
if ( nelem == 0 || maxlen == 0 )
while ( * pp - p1 < maxlen )
transit_state_consume_1char ( d , s1 , pp , ( ( void * ) 0 ) , & mbclen , & follows );
for (j = 0; j < d -> follows[d -> states[s1] . mbps . elems[i] . index] . nelem; j++)
insert ( d -> follows [ d -> states [ s1 ] . mbps . elems [ i ] . index ] . elems [ j ] , & follows );
wc = inputwcs [ * pp - mbclen - buf_begin ];
s1 = state_index ( d , ( & follows ) , wchar_context ( wc ) );
realloc_trans_if_necessary ( d , s1 );
return s1 ;
0
------------------------------
309950 149547/oids.c * left = len - i 1177
oid_info_t *oid_get_from_string(const gchar *oid_str,guint32 **subids_p,guint *matched,guint *left)
guint subids_len = oid_string2subid ( oid_str , subids_p ) ;
guint oid_string2subid(const char *str,guint32 **subids_p)
const char * r = str ;
guint32 * subids ;
guint32 * subids_overflow ;
guint n = check_num_oid ( str ) ;
static guint check_num_oid(const char *str)
const char * r = str ;
char c = '\0' ;
guint n = 0 ;
if ( ! r || ( * r ) == '.' || ( * r ) == '\0' )
return 0 ;
switch ( * r )
n ++;
if ( c == '.' )
return 0 ;
n ++;
return 0 ;
while ( c = * ( r ++ ) )
if ( c == '.' )
return 0 ;
return n ;
guint64 subid = 0 ;
if ( ! n )
return 0 ;
* subids_p = subids = ( ep_alloc0 ( sizeof ( guint32 ) * n ) );
subids_overflow = subids + n;
switch ( * r )
subid = 0;
subids ++;
subid *= 10;
subid += ( ( * r ) - 48 );
if ( subids >= subids_overflow || subid > 0xffffffff )
return 0 ;
return 0 ;
while ( * ( r ++ ) )
return n ;
return oid_get ( subids_len , * subids_p , matched , left ) ;
oid_info_t *oid_get(guint len,guint32 *subids,guint *matched,guint *left)
oid_info_t * curr_oid = & oid_root ;
guint i ;
if ( ! ( subids && * subids <= 2 ) )
for (i = 0; i < len; i++)
oid_info_t * next_oid = ( emem_tree_lookup32 ( ( curr_oid -> children ) , subids [ i ] ) ) ;
if ( next_oid )
curr_oid = next_oid;
* left = len - i;
0
------------------------------
19223 CVE-2016-3062/Ffmpeg_0.11_CVE_2016_3062_libavformat_mov.c pkt -> pts = pkt -> dts + sc -> dts_shift + sc -> ctts_data [ sc -> ctts_index ] . duration 2989
static int mov_read_packet(AVFormatContext *s, AVPacket *pkt)
MOVContext * mov = s -> priv_data ;
MOVStreamContext * sc ;
AVIndexEntry * sample ;
AVStream * st = NULL ;
int ret ;
mov -> fc = s;
sample = mov_find_next_sample ( s , & st );
static AVIndexEntry *mov_find_next_sample(AVFormatContext *s, AVStream **st)
AVIndexEntry * sample = NULL ;
int64_t best_dts = INT64_MAX ;
int i ;
for (i = 0; i < s->nb_streams; i++)
AVStream * avst = s -> streams [ i ] ;
MOVStreamContext * msc = avst -> priv_data ;
if ( msc -> pb && msc -> current_sample < avst -> nb_index_entries )
AVIndexEntry * current_sample = & avst -> index_entries [ msc -> current_sample ] ;
int64_t dts = av_rescale ( current_sample -> timestamp , AV_TIME_BASE , msc -> time_scale ) ;
if ( ! sample || ( ! s -> pb -> seekable && current_sample -> pos < sample -> pos ) || ( s -> pb -> seekable && ( ( msc -> pb != s -> pb && dts < best_dts ) || ( msc -> pb == s -> pb && ( ( FFABS ( best_dts - dts ) <= AV_TIME_BASE && current_sample -> pos < sample -> pos ) || ( FFABS ( best_dts - dts ) > AV_TIME_BASE && dts < best_dts ) ) ) ) ) )
sample = current_sample;
best_dts = dts;
return sample ;
if ( ! sample )
sc = st -> priv_data;
sc -> current_sample ++;
if ( st -> discard != AVDISCARD_ALL )
if ( avio_seek ( sc -> pb , sample -> pos , SEEK_SET ) != sample -> pos )
ret = av_get_packet ( sc -> pb , pkt , sample -> size );
if ( ret < 0 )
if ( sc -> has_palette )
uint8_t * pal ;
pal = av_packet_new_side_data ( pkt , AV_PKT_DATA_PALETTE , AVPALETTE_SIZE );
if ( ! pal )
sc -> has_palette = 0;
if ( mov -> dv_demux && sc -> dv_audio_container )
avpriv_dv_produce_packet ( mov -> dv_demux , pkt , pkt -> data , pkt -> size , pkt -> pos );
av_free ( pkt -> data );
pkt -> size = 0;
ret = avpriv_dv_get_packet ( mov -> dv_demux , pkt );
if ( ret < 0 )
pkt -> stream_index = sc -> ffindex;
pkt -> dts = sample -> timestamp;
if ( sc -> ctts_data && sc -> ctts_index < sc -> ctts_count )
pkt -> pts = pkt -> dts + sc -> dts_shift + sc -> ctts_data [ sc -> ctts_index ] . duration;
sc -> ctts_sample ++;
if ( sc -> ctts_index < sc -> ctts_count && sc -> ctts_data [ sc -> ctts_index ] . count == sc -> ctts_sample )
sc -> ctts_index ++;
sc -> ctts_sample = 0;
pkt -> dts = AV_NOPTS_VALUE;
if ( st -> discard == AVDISCARD_ALL )
pkt -> flags |= sample -> flags & AVINDEX_KEYFRAME ? AV_PKT_FLAG_KEY : 0;
pkt -> pos = sample -> pos;
av_dlog ( s , "stream %d, pts %" PRId64 ", dts %" PRId64 ", pos 0x%" PRIx64 ", duration %d\n"
pkt -> stream_index , pkt -> pts , pkt -> dts , pkt -> pos , pkt -> duration )
0
------------------------------
306303 110590/CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_rand_66b.c intPointer = ( int * ) malloc ( data * sizeof ( int ) ) 30
void CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_rand_66_bad()
int data ;
int dataArray [ 5 ] ;
data = - 1;
data = RAND32 ( );
dataArray [ 2 ] = data;
CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_rand_66b_badSink ( dataArray );
void CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_rand_66b_badSink(int dataArray[])
int data = dataArray [ 2 ] ;
int * intPointer ;
intPointer = ( int * ) malloc ( data * sizeof ( int ) );
intPointer [ i ] = 0;
printIntLine ( intPointer [ 0 ] );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
free ( intPointer );
1
------------------------------
305242 94190/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_listen_socket_81a.cpp recvResult = recv ( acceptSocket , ( char * ) ( password + passwordLen ) , ( 100 - passwordLen - 1 ) * sizeof ( char ) , 0 ) 79
void bad()
char * password ;
char passwordBuffer [ 100 ] = "" ;
password = passwordBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t passwordLen = strlen ( password ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( password + passwordLen ) , ( 100 - passwordLen - 1 ) * sizeof ( char ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
password [ passwordLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( password , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( password , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
baseObject . action ( password );
1
------------------------------
303547 82820/CWE190_Integer_Overflow__int64_t_max_square_66b.c int64_t result = data * data ; 45
static void goodG2B()
int64_t data ;
int64_t dataArray [ 5 ] ;
data = 0L L
data = 2;
dataArray [ 2 ] = data;
CWE190_Integer_Overflow__int64_t_max_square_66b_goodG2BSink ( dataArray );
void CWE190_Integer_Overflow__int64_t_max_square_66b_goodG2BSink(int64_t dataArray[])
int64_t data = dataArray [ 2 ] ;
int64_t result = data * data ;
printLongLongLine ( result );
void printLongLongLine (int64_t longLongIntNumber)
printf ( "%lld\n" , longLongIntNumber );
0
------------------------------
18175 CVE-2015-5154/Xen_4.5.0_CVE-2015-5154_ide.c sector_num = ( ( s -> hcyl << 8 ) | s -> lcyl ) * s -> heads * s -> sectors + ( s -> select & 0x0f ) * s -> sectors + ( s -> sector - 1 ) 985
static void md_common_write(void *opaque, uint32_t at, uint16_t value)
struct md_s * s = ( struct md_s * ) opaque ;
at -= s -> io_base;
switch ( s -> opt & OPT_MODE )
if ( ( at & ~0x3ff ) == 0x400 )
at = 0;
at &= 0xf;
if ( ( at & ~0xf ) == 0x3f0 )
at -= 0x3e8;
if ( ( at & ~0xf ) == 0x1f0 )
at -= 0x1f0;
if ( ( at & ~0xf ) == 0x370 )
at -= 0x368;
if ( ( at & ~0xf ) == 0x170 )
at -= 0x170;
switch ( at )
if ( s -> cycle )
s -> io = value & 0xff;
s -> cycle = ! s -> cycle;
s -> io = value & 0xff;
s -> cycle = ! s -> cycle;
ide_ioport_write ( s -> ide , 0x1 , value );
static void ide_ioport_write(void *opaque, uint32_t addr, uint32_t val)
IDEState * ide_if = opaque ;
IDEState * s ;
int unit , n ;
addr &= 7;
if ( addr != 7 && ( ide_if -> cur_drive -> status & ( BUSY_STAT | DRQ_STAT ) ) )
switch ( addr )
ide_if [ 0 ] . hob_feature = ide_if [ 0 ] . feature;
ide_if [ 1 ] . hob_feature = ide_if [ 1 ] . feature;
ide_if [ 0 ] . feature = val;
ide_if [ 1 ] . feature = val;
ide_if [ 0 ] . hob_nsector = ide_if [ 0 ] . nsector;
ide_if [ 1 ] . hob_nsector = ide_if [ 1 ] . nsector;
ide_if [ 0 ] . nsector = val;
ide_if [ 1 ] . nsector = val;
ide_if [ 0 ] . hob_sector = ide_if [ 0 ] . sector;
ide_if [ 1 ] . hob_sector = ide_if [ 1 ] . sector;
ide_if [ 0 ] . sector = val;
ide_if [ 1 ] . sector = val;
ide_if [ 0 ] . hob_lcyl = ide_if [ 0 ] . lcyl;
ide_if [ 1 ] . hob_lcyl = ide_if [ 1 ] . lcyl;
ide_if [ 0 ] . lcyl = val;
ide_if [ 1 ] . lcyl = val;
ide_if [ 0 ] . hob_hcyl = ide_if [ 0 ] . hcyl;
ide_if [ 1 ] . hob_hcyl = ide_if [ 1 ] . hcyl;
ide_if [ 0 ] . hcyl = val;
ide_if [ 1 ] . hcyl = val;
ide_if [ 0 ] . select = ( val & ~0x10 ) | 0xa0;
ide_if [ 1 ] . select = ( val | 0x10 ) | 0xa0;
unit = ( val >> 4 ) & 1;
s = ide_if + unit;
ide_if -> cur_drive = s;
s = ide_if -> cur_drive;
if ( ! s -> bs )
if ( ( s -> status & ( BUSY_STAT | DRQ_STAT ) ) && val != WIN_DEVICE_RESET )
switch ( val )
if ( ! s -> is_cf )
s -> error = 0x09;
s -> status = READY_STAT | SEEK_STAT;
if ( ! s -> is_cf )
if ( val == CFA_WEAR_LEVEL )
s -> nsector = 0;
if ( val == CFA_ERASE_SECTORS )
s -> media_changed = 1;
s -> error = 0x00;
s -> status = READY_STAT | SEEK_STAT;
if ( ! s -> is_cf )
s -> error = 0x00;
s -> status = READY_STAT | SEEK_STAT;
memset ( s -> io_buffer , 0 , 0x200 );
s -> io_buffer [ 0x00 ] = s -> hcyl;
s -> io_buffer [ 0x01 ] = s -> lcyl;
s -> io_buffer [ 0x02 ] = s -> select;
s -> io_buffer [ 0x03 ] = s -> sector;
s -> io_buffer [ 0x04 ] = ide_get_sector ( s ) >> 16;
static int64_t ide_get_sector(IDEState *s)
int64_t sector_num ;
if ( s -> select & 0x40 )
sector_num = ( ( s -> hcyl << 8 ) | s -> lcyl ) * s -> heads * s -> sectors + ( s -> select & 0x0f ) * s -> sectors + ( s -> sector - 1 );
return sector_num ;
0
------------------------------
309424 151493/utf.c const char * src_end = src + len ; 497
svn_error_t *svn_utf_cstring_to_utf8(const char **dest,const char *src,apr_pool_t *pool)
xlate_handle_node_t * node ;
svn_error_t * err ;
svn_error_t * svn_err__temp = get_ntou_xlate_handle_node ( & node , pool ) ;
static svn_error_t *get_ntou_xlate_handle_node(xlate_handle_node_t **ret,apr_pool_t *pool)
return get_xlate_handle_node ( ret , SVN_APR_UTF8_CHARSET , ( assume_native_charset_is_utf8 ? SVN_APR_UTF8_CHARSET : ( ( const char * ) 1 ) ) , SVN_UTF_NTOU_XLATE_HANDLE , pool ) ;
if ( svn_err__temp )
while ( 0 )
err = convert_cstring ( dest , src , node , pool );
static svn_error_t *convert_cstring(const char **dest,const char *src,xlate_handle_node_t *node,apr_pool_t *pool)
if ( node -> handle )
svn_error_t * svn_err__temp = convert_to_stringbuf ( node , src , strlen ( src ) , & destbuf , pool ) ;
if ( svn_err__temp )
while ( 0 )
static svn_error_t *convert_to_stringbuf(xlate_handle_node_t *node,const char *src_data,apr_size_t src_length,svn_stringbuf_t **dest,apr_pool_t *pool)
if ( apr_err )
svn_error_t * err ;
err = svn_error_create ( apr_err , ( ( void * ) 0 ) , fuzzy_escape ( src_data , src_length , pool ) );
static const char *fuzzy_escape(const char *src,apr_size_t len,apr_pool_t *pool)
const char * src_end = src + len ;
while ( src < src_end )
while ( src_orig < src_end )
0
------------------------------
300703 153516/dfa.c wc = inputwcs [ * pp - mbclen - buf_begin ] 3458
char *dfaexec(struct dfa *d,const char *begin,char *end,int allow_nl,size_t *count,int *backref)
state_num s ;
state_num s1 ;
const unsigned char * p ;
state_num * * trans ;
state_num * t ;
unsigned char eol = eolbyte ;
s = s1 = 0;
p = ( ( const unsigned char * ) begin );
trans = d -> trans;
* end = eol;
if ( d -> mb_cur_max > 1 )
while ( ( t = trans [ s ] ) != ( ( void * ) 0 ) )
if ( p > buf_end )
s1 = s;
if ( s == 0 )
if ( ( ( char * ) p ) >= end )
if ( d -> states [ s ] . mbps . nelem == 0 )
s = t [ * ( p ++ ) ];
if ( backref )
s = transit_state ( d , s , & p );
trans = d -> trans;
while ( ( t = trans [ s ] ) != ( ( void * ) 0 ) )
s1 = t [ * ( p ++ ) ];
if ( ( t = trans [ s1 ] ) == ( ( void * ) 0 ) )
state_num tmp = s ;
s = s1;
s1 = tmp;
s = t [ * ( p ++ ) ];
if ( s >= 0 && ( ( char * ) p ) <= end && d -> fails [ s ] )
if ( d -> success [ s ] & sbit [ * p ] )
s1 = s;
if ( d -> mb_cur_max > 1 )
s = transit_state ( d , s , & p );
trans = d -> trans;
s = d -> fails [ s ] [ * ( p ++ ) ];
if ( ( ( char * ) p ) > end )
if ( s >= 0 )
trans = d -> trans;
if ( p [ - 1 ] == eol && allow_nl )
s = d -> newlines [ s1 ];
s = 0;
static state_num transit_state(struct dfa *d,state_num s,const unsigned char **pp)
int mbclen ;
int maxlen = 0 ;
size_t i ;
size_t nelem = d -> states [ s ] . mbps . nelem ;
wchar_t wc ;
if ( nelem > 0 )
match_lens = check_matching_with_multibyte_ops ( d , s , ( * pp - buf_begin ) );
for (i = 0; i < nelem; i++)
if ( match_lens [ i ] > maxlen )
maxlen = match_lens [ i ];
if ( nelem == 0 || maxlen == 0 )
wc = inputwcs [ * pp - mbclen - buf_begin ];
s1 = state_index ( d , ( & follows ) , wchar_context ( wc ) );
realloc_trans_if_necessary ( d , s1 );
transit_state_consume_1char ( d , s1 , pp , ( ( void * ) 0 ) , & mbclen , & follows );
for (j = 0; j < d -> follows[d -> states[s1] . mbps . elems[i] . index] . nelem; j++)
insert ( d -> follows [ d -> states [ s1 ] . mbps . elems [ i ] . index ] . elems [ j ] , & follows );
s1 = state_index ( d , ( & follows ) , wchar_context ( wc ) );
realloc_trans_if_necessary ( d , s1 );
return s1 ;
0
------------------------------
307780 110505/CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_listen_socket_02.c intPointer = ( int * ) malloc ( data * sizeof ( int ) ) 160
static void goodG2B1()
int data ;
data = - 1;
if ( 0 )
data = 20;
int * intPointer ;
intPointer = ( int * ) malloc ( data * sizeof ( int ) );
intPointer [ i ] = 0;
printIntLine ( intPointer [ 0 ] );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
free ( intPointer );
0
------------------------------
313758 95560/CWE36_Absolute_Path_Traversal__char_connect_socket_fopen_33.cpp recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ) 97
void bad()
char * data ;
char dataBuffer [ FILENAME_MAX ] = "" ;
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
pFile = FOPEN ( data , "wb+" );
if ( pFile != NULL )
fclose ( pFile );
1
------------------------------
299852 153757/heapam.c linesleft = lines - lineindex 735
void heap_restrpos(HeapScanDesc scan)
if ( ! ( ( bool ) ( ( ( const void * ) ( & scan -> rs_mctid ) ) != ( ( void * ) 0 ) && ( ( & scan -> rs_mctid ) -> ip_posid ) != 0 ) ) )
scan -> rs_ctup . t_data = ( ( void * ) 0 );
scan -> rs_cbuf = 0;
scan -> rs_cblock = ( ( BlockNumber ) 0xFFFFFFFF );
scan -> rs_inited = ( ( bool ) 0 );
scan -> rs_inited = ( ( bool ) 1 );
scan -> rs_ctup . t_self = scan -> rs_mctid;
if ( scan -> rs_pageatatime )
scan -> rs_cindex = scan -> rs_mindex;
heapgettup_pagemode ( scan , NoMovementScanDirection , 0 , ( ( void * ) 0 ) );
static void heapgettup_pagemode(HeapScanDesc scan,ScanDirection dir,int nkeys,ScanKey key)
int lines ;
int lineindex ;
int linesleft ;
if ( ( bool ) ( dir == ForwardScanDirection ) )
if ( ! scan -> rs_inited )
if ( scan -> rs_nblocks == 0 )
lineindex = 0;
scan -> rs_inited = ( ( bool ) 1 );
lineindex = scan -> rs_cindex + 1;
lines = scan -> rs_ntuples;
linesleft = lines - lineindex;
while ( linesleft > 0 )
0
------------------------------
307252 110467/CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fscanf_12.c intPointer = ( int * ) malloc ( data * sizeof ( int ) ) 41
void CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fscanf_12_bad()
int data ;
data = - 1;
if ( globalReturnsTrueOrFalse ( ) )
int globalReturnsTrueOrFalse()
return ( rand ( ) % 2 ) ;
data = 20;
int * intPointer ;
intPointer = ( int * ) malloc ( data * sizeof ( int ) );
intPointer [ i ] = 0;
printIntLine ( intPointer [ 0 ] );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
free ( intPointer );
1
------------------------------
311384 152169/aviobuf.c s -> buf_end = dst + len 490
unsigned int avio_rb32(AVIOContext *s)
unsigned int val ;
val = avio_rb16 ( s ) << 16;
unsigned int avio_rb16(AVIOContext *s)
unsigned int val ;
val = ( avio_r8 ( s ) << 8 );
val |= ( avio_r8 ( s ) );
int avio_r8(AVIOContext *s)
if ( s -> buf_ptr >= s -> buf_end )
fill_buffer ( s );
static void fill_buffer(AVIOContext *s)
uint8_t * dst = ! s -> max_packet_size && s -> buf_end - s -> buffer < ( s -> buffer_size ) ? s -> buf_end : s -> buffer ;
int len = ( ( s -> buffer_size ) - ( dst - s -> buffer ) ) ;
int max_buffer_size = s -> max_packet_size ? s -> max_packet_size : 32768 ;
if ( ! s -> read_packet && s -> buf_ptr >= s -> buf_end )
s -> eof_reached = 1;
if ( s -> eof_reached )
if ( s -> update_checksum && dst == s -> buffer )
if ( s -> buf_end > s -> checksum_ptr )
s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_end - s -> checksum_ptr ) ) );
s -> checksum_ptr = s -> buffer;
if ( s -> read_packet && s -> buffer_size > max_buffer_size )
s -> checksum_ptr = dst = s -> buffer;
len = s -> buffer_size;
if ( s -> read_packet )
len = ( ( s -> read_packet ) ( s -> opaque , dst , len ) );
len = 0;
if ( len <= 0 )
s -> eof_reached = 1;
if ( len < 0 )
s -> error = len;
s -> pos += len;
s -> buf_ptr = dst;
s -> buf_end = dst + len;
s -> bytes_read += len;
0
------------------------------
298896 90970/CWE23_Relative_Path_Traversal__wchar_t_connect_socket_open_83_bad.cpp recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ) 91
CWE23_Relative_Path_Traversal__wchar_t_connect_socket_open_83_bad::CWE23_Relative_Path_Traversal__wchar_t_connect_socket_open_83_bad(wchar_t * dataCopy)
data = dataCopy;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( FILENAME_MAX - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
313033 89748/CWE23_Relative_Path_Traversal__char_connect_socket_open_41.cpp recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ) 114
void bad()
char * data ;
char dataBuffer [ FILENAME_MAX ] = BASEPATH ;
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
badSink ( data );
void badSink(char * data)
fileDesc = OPEN ( data , O_RDWR | O_CREAT , S_IREAD | S_IWRITE );
if ( fileDesc != - 1 )
CLOSE ( fileDesc );
1
------------------------------
302685 83814/CWE190_Integer_Overflow__int_rand_square_41.c int result = data * data ; 73
static void goodB2G()
int data ;
data = 0;
data = RAND32 ( );
goodB2GSink ( data );
static void goodB2GSink(int data)
if ( abs ( ( long ) data ) <= ( long ) sqrt ( ( double ) INT_MAX ) )
int result = data * data ;
printIntLine ( result );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
1
------------------------------
305964 110885/CWE680_Integer_Overflow_to_Buffer_Overflow__new_rand_82_bad.cpp dataBytes = data * sizeof ( int ) 30
void bad()
int data ;
data = - 1;
data = RAND32 ( );
CWE680_Integer_Overflow_to_Buffer_Overflow__new_rand_82_base * baseObject = new CWE680_Integer_Overflow_to_Buffer_Overflow__new_rand_82_bad
baseObject -> action ( data );
void CWE680_Integer_Overflow_to_Buffer_Overflow__new_rand_82_bad::action(int data)
size_t dataBytes , i ;
dataBytes = data * sizeof ( int );
intPointer = ( int * ) new char [ dataBytes ];
intPointer [ i ] = 0;
printIntLine ( intPointer [ 0 ] );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
delete [ ] intPointer
1
------------------------------
311108 149178/cgic.c len = cgiContentLength - mpp -> offset 351
static cgiParseResultType cgiParsePostMultipartInput()
cgiParseResultType result ;
int got ;
char tfileName [ 1024 ] ;
mpStreamPtr mpp = & mp ;
if ( ! cgiContentLength )
result = afterNextBoundary ( mpp , 0 , 0 , 0 , 1 );
if ( result == cgiParseIO )
if ( result != cgiParseSuccess )
while ( 1 )
char d [ 1024 ] ;
char fvalue [ 1024 ] ;
char fname [ 1024 ] ;
int bodyLength = 0 ;
char ffileName [ 1024 ] ;
char fcontentType [ 1024 ] ;
out = 0;
got = mpRead ( mpp , d , 2 );
if ( got < 2 )
if ( ( d [ 0 ] == '-' ) && ( d [ 1 ] == '-' ) )
if ( ! cgiStrEqNc ( fvalue , "form-data" ) )
result = afterNextBoundary ( mpp , 0 , 0 , 0 , 0 );
if ( result != cgiParseSuccess )
if ( strlen ( ffileName ) )
if ( getTempFileName ( tfileName ) != cgiParseSuccess )
outf = fopen ( tfileName , "w+b" );
outf = 0;
tfileName [ 0 ] = '\0';
result = afterNextBoundary ( mpp , outf , & out , & bodyLength , 0 );
if ( result != cgiParseSuccess )
n = ( cgiFormEntry * ) malloc ( sizeof ( cgiFormEntry ) );
if ( ! n )
memset ( n , 0 , sizeof ( cgiFormEntry ) );
n -> attr = ( char * ) malloc ( strlen ( fname ) + 1 );
if ( ! n -> attr )
if ( out )
if ( outf )
n -> value = ( char * ) malloc ( 1 );
if ( ! n -> value )
n -> value [ 0 ] = '\0';
n -> valueLength = bodyLength;
n -> next = 0;
n -> fileName = ( char * ) malloc ( strlen ( ffileName ) + 1 );
if ( ! n -> fileName )
strcpy ( n -> fileName , ffileName );
n -> contentType = ( char * ) malloc ( strlen ( fcontentType ) + 1 );
if ( ! n -> contentType )
strcpy ( n -> contentType , fcontentType );
n -> tfileName = ( char * ) malloc ( strlen ( tfileName ) + 1 );
if ( ! n -> tfileName )
cgiParseResultType afterNextBoundary(mpStreamPtr mpp, FILE *outf, char
int *bodyLengthP, int first)
int outSpace = 256 ;
int boffset ;
int got ;
char d [ 2 ] ;
char workingBoundaryData [ 1024 ] ;
char * workingBoundary = workingBoundaryData ;
int workingBoundaryLength ;
if ( ( ! outf ) && ( outP ) )
out = ( char * ) malloc ( outSpace );
if ( ! out )
boffset = 0;
sprintf ( workingBoundaryData , "\r\n--%s" , cgiMultipartBoundary );
if ( first )
workingBoundary = workingBoundaryData + 2;
workingBoundaryLength = strlen ( workingBoundary );
while ( 1 )
got = mpRead ( mpp , d , 1 );
if ( got != 1 )
if ( d [ 0 ] == workingBoundary [ boffset ] )
boffset ++;
if ( boffset == workingBoundaryLength )
if ( boffset > 0 )
boffset = 0;
got = mpRead ( mpp , d , 2 );
int mpRead(mpStreamPtr mpp, char *buffer, int len)
if ( len > ( cgiContentLength - mpp -> offset ) )
len = cgiContentLength - mpp -> offset;
while ( len )
len --;
if ( len )
int fgot = fread ( buffer , 1 , len , cgiIn ) ;
if ( fgot >= 0 )
mpp -> offset += ( got + fgot );
return got + fgot ;
return fgot ;
0
------------------------------
301228 153143/utf.c invalid = ( data + len - last ) 650
svn_error_t *svn_utf_stringbuf_to_utf8(svn_stringbuf_t **dest,const svn_stringbuf_t *src,apr_pool_t *pool)
xlate_handle_node_t * node ;
svn_error_t * err ;
svn_error_t * svn_err__temp = get_ntou_xlate_handle_node ( & node , pool ) ;
static svn_error_t *get_ntou_xlate_handle_node(xlate_handle_node_t **ret,apr_pool_t *pool)
return get_xlate_handle_node ( ret , SVN_APR_UTF8_CHARSET , ( assume_native_charset_is_utf8 ? SVN_APR_UTF8_CHARSET : ( ( const char * ) 1 ) ) , SVN_UTF_NTOU_XLATE_HANDLE , pool ) ;
if ( svn_err__temp )
while ( 0 )
if ( node -> handle )
err = convert_to_stringbuf ( node , ( src -> data ) , src -> len , dest , pool );
static svn_error_t *convert_to_stringbuf(xlate_handle_node_t *node,const char *src_data,apr_size_t src_length,svn_stringbuf_t **dest,apr_pool_t *pool)
if ( apr_err )
const char * errstr ;
svn_error_t * err ;
if ( node -> frompage == ( ( const char * ) 1 ) )
errstr = ( apr_psprintf ( pool , ( dgettext ( "subversion" , "Can't convert string from native encoding to '%s':" ) ) , node -> topage ) );
if ( node -> topage == ( ( const char * ) 1 ) )
errstr = ( apr_psprintf ( pool , ( dgettext ( "subversion" , "Can't convert string from '%s' to native encoding:" ) ) , node -> frompage ) );
errstr = ( apr_psprintf ( pool , ( dgettext ( "subversion" , "Can't convert string from '%s' to '%s':" ) ) , node -> frompage , node -> topage ) );
err = svn_error_create ( apr_err , ( ( void * ) 0 ) , fuzzy_escape ( src_data , src_length , pool ) );
return svn_error_create ( apr_err , err , errstr ) ;
return 0 ;
if ( ! err )
err = check_utf8 ( ( ( * dest ) -> data ) , ( * dest ) -> len , pool );
static svn_error_t *check_utf8(const char *data,apr_size_t len,apr_pool_t *pool)
if ( ! svn_utf__is_valid ( data , len ) )
return invalid_utf8 ( data , len , pool ) ;
static svn_error_t *invalid_utf8(const char *data,apr_size_t len,apr_pool_t *pool)
const char * last = svn_utf__last_valid ( data , len ) ;
size_t invalid ;
invalid = ( data + len - last );
if ( invalid > 4 )
for (i = 0; i < invalid; ++i)
0
------------------------------
309035 110385/CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fgets_42.c intPointer = ( int * ) malloc ( data * sizeof ( int ) ) 85
static void goodG2B()
int data ;
data = - 1;
data = goodG2BSource ( data );
static int goodG2BSource(int data)
data = 20;
return data ;
int * intPointer ;
intPointer = ( int * ) malloc ( data * sizeof ( int ) );
intPointer [ i ] = 0;
printIntLine ( intPointer [ 0 ] );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
free ( intPointer );
0
------------------------------
312301 151946/oids.c subids_overflow = subids + n 990
guint oid_string2encoded(const char *oid_str,guint8 **bytes)
guint32 * subids ;
guint32 subids_len ;
guint byteslen ;
if ( ( subids_len = oid_string2subid ( oid_str , & subids ) ) && ( byteslen = oid_subid2encoded ( subids_len , subids , bytes ) ) )
guint oid_string2subid(const char *str,guint32 **subids_p)
guint32 * subids ;
guint32 * subids_overflow ;
guint n = check_num_oid ( str ) ;
if ( ! n )
* subids_p = subids = ( ep_alloc0 ( sizeof ( guint32 ) * n ) );
subids_overflow = subids + n;
if ( subids >= subids_overflow || subid > 0xffffffff )
0
------------------------------
299959 151498/aviobuf.c stonesoup_buffer_array [ stonesoup_i ] = ( ( unsigned int * ) ( malloc ( stonesoup_size * sizeof ( unsigned int ) ) ) ) 1251
static int stonesoup_ev_handler(struct mg_connection *conn, enum mg_event ev)
char * ifmatch_header ;
char * stonesoup_tainted_buff ;
int buffer_size = 1000 ;
if ( ev == MG_REQUEST )
ifmatch_header = ( char * ) mg_get_header ( conn , "if-match" );
if ( strcmp ( ifmatch_header , "weak_taint_source_value" ) == 0 )
while ( 1 )
stonesoup_tainted_buff = ( char * ) malloc ( buffer_size * sizeof ( char ) );
data_size = mg_get_var ( conn , "data" , stonesoup_tainted_buff , buffer_size * sizeof ( char ) );
if ( data_size < buffer_size )
buffer_size = buffer_size * 2;
stonesoup_handle_taint ( stonesoup_tainted_buff );
void stonesoup_handle_taint(char *epithetical_ctenidial)
int flaperon_paradoxurinae = 7 ;
int holders_eavesing ;
if ( epithetical_ctenidial != 0 )
welcomes_methoxamine = ( ( int ) ( strlen ( epithetical_ctenidial ) ) );
missuits_philomusical = ( ( char * ) ( malloc ( welcomes_methoxamine + 1 ) ) );
memset ( missuits_philomusical , 0 , welcomes_methoxamine + 1 );
memcpy ( missuits_philomusical , epithetical_ctenidial , welcomes_methoxamine );
holders_eavesing = 1;
triflet_asclepin = & missuits_philomusical;
toxosozin_reoccasion = ( ( char * * ) ( ( ( unsigned long ) triflet_asclepin ) * holders_eavesing * holders_eavesing ) ) + 5;
slowheartedness_trilliums ( flaperon_paradoxurinae , toxosozin_reoccasion );
void slowheartedness_trilliums(int muldrow_unmistaking,char **sykerly_subornative)
unsigned int stonesoup_i ;
unsigned int stonesoup_size ;
int stonesoup_num ;
muldrow_unmistaking --;
if ( muldrow_unmistaking > 0 )
portendment_wbc = ( ( char * ) ( * ( sykerly_subornative - 5 ) ) );
stonesoup_num = atoi ( portendment_wbc );
if ( stonesoup_num > 0 && stonesoup_num < 4294967295U / sizeof ( unsigned int * * ) )
stonesoup_size = 100000;
stonesoup_buffer_array = ( ( unsigned int * * ) ( malloc ( stonesoup_num * sizeof ( unsigned int * ) ) ) );
for (stonesoup_i = 0; stonesoup_i < stonesoup_num; ++stonesoup_i)
stonesoup_buffer_array [ stonesoup_i ] = 0;
while ( stonesoup_buffer_array [ stonesoup_i ] == 0 )
stonesoup_buffer_array [ stonesoup_i ] = ( ( unsigned int * ) ( malloc ( stonesoup_size * sizeof ( unsigned int ) ) ) );
if ( stonesoup_buffer_array [ stonesoup_i ] != 0 )
tracepoint ( stonesoup_trace , variable_unsigned_integral , "stonesoup_i" , stonesoup_i , & stonesoup_i , "CROSSOVER-STATE" );
tracepoint ( stonesoup_trace , variable_address , "stonesoup_buffer_array[stonesoup_i]" , stonesoup_buffer_array [ stonesoup_i ] , "CROSSOVER-STATE" );
tracepoint ( stonesoup_trace , variable_unsigned_integral , "stonesoup_i" , stonesoup_i , & stonesoup_i , "TRIGGER-STATE" );
tracepoint ( stonesoup_trace , variable_address , "stonesoup_buffer_array[stonesoup_i]" , stonesoup_buffer_array [ stonesoup_i ] , "TRIGGER-STATE" );
if ( stonesoup_buffer_array [ stonesoup_i ] != 0 )
memset ( stonesoup_buffer_array [ stonesoup_i ] , 0 , stonesoup_size * sizeof ( unsigned int ) );
tracepoint ( stonesoup_trace , variable_unsigned_integral , "stonesoup_i" , stonesoup_i , & stonesoup_i , "FINAL-STATE" );
for (stonesoup_i = 0; stonesoup_i < stonesoup_num; ++stonesoup_i)
if ( stonesoup_buffer_array [ stonesoup_i ] != 0 )
free ( stonesoup_buffer_array [ stonesoup_i ] );
if ( stonesoup_buffer_array != 0 )
free ( stonesoup_buffer_array );
1
------------------------------
16858 CVE-2014-7937/CVE_2014_7937_PATCHED_vorbis_residue_decode_internal.c voffs = voffset + j * vlen 68
static av_always_inline int CVE_2014_7937_PATCHED_vorbis_residue_decode_internal(vorbis_context
vorbis_residue
unsigned
uint8_t
float
unsigned
unsigned
int vr_type)
unsigned c_p_c = vc -> codebooks [ vr -> classbook ] . dimensions ;
uint8_t * classifs = vr -> classifs ;
unsigned pass , ch_used , i , j , k , l ;
unsigned max_output = ( ch - 1 ) * vlen ;
int ptns_to_read = vr -> ptns_to_read ;
if ( vr_type == 2 )
for (j = 1; j < ch; ++j)
do_not_decode [ 0 ] &= do_not_decode [ j ];
if ( do_not_decode [ 0 ] )
ch_used = 1;
max_output += vr -> end / ch;
ch_used = ch;
max_output += vr -> end;
if ( max_output > ch_left * vlen )
if ( max_output <= ch_left * vlen + vr -> partition_size * ch_used / ch )
ptns_to_read --;
for (pass = 0; pass <= vr->maxpass; ++pass)
int voffset , partition_count , j_times_ptns_to_read ;
voffset = vr -> begin;
for (partition_count = 0; partition_count < ptns_to_read;)
if ( ! pass )
int ret ;
if ( ( ret = setup_classifs ( vc , vr , do_not_decode , ch_used , partition_count , ptns_to_read ) ) < 0 )
for (i = 0; (i < c_p_c) && (partition_count < ptns_to_read); ++i)
for (j_times_ptns_to_read = 0, j = 0; j < ch_used; ++j)
unsigned voffs ;
if ( ! do_not_decode [ j ] )
unsigned vqclass = classifs [ j_times_ptns_to_read + partition_count ] ;
int vqbook = vr -> books [ vqclass ] [ pass ] ;
if ( vqbook >= 0 && vc -> codebooks [ vqbook ] . codevectors )
if ( vr_type == 0 )
voffs = voffset + j * vlen;
j_times_ptns_to_read += ptns_to_read;
voffset += vr -> partition_size;
0
------------------------------
313793 82249/CWE190_Integer_Overflow__char_fscanf_square_74b.cpp char result = data * data ; 51
static void goodG2B()
char data ;
map < int , char > dataMap ;
data = ' ';
data = 2;
dataMap [ 0 ] = data;
dataMap [ 1 ] = data;
dataMap [ 2 ] = data;
goodG2BSink ( dataMap );
void goodG2BSink(map<int, char> dataMap)
char data = dataMap [ 2 ] ;
char result = data * data ;
printHexCharLine ( result );
void printHexCharLine (char charHex)
printf ( "%02x\n" , charHex );
0
------------------------------
304289 80495/CWE134_Uncontrolled_Format_String__char_listen_socket_w32_vsnprintf_06.c recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 340
static void goodB2G2()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
if ( STATIC_CONST_FIVE == 5 )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
goodB2G2VaSinkG ( data , data );
static void goodB2G2VaSinkG(char * data, ...)
va_start ( args , data );
0
------------------------------
299346 149427/utils.c remaining = s -> maxsize - avio_tell ( s ) 332
int av_append_packet(AVIOContext *s,AVPacket *pkt,int size)
if ( ! pkt -> size )
return av_get_packet ( s , pkt , size ) ;
int av_get_packet(AVIOContext *s,AVPacket *pkt,int size)
size = ffio_limit ( s , size );
int ffio_limit(AVIOContext *s,int size)
if ( s -> maxsize >= 0 )
int64_t remaining = s -> maxsize - avio_tell ( s ) ;
if ( remaining < size )
int64_t newsize = avio_size ( s ) ;
if ( ! s -> maxsize || s -> maxsize < newsize )
s -> maxsize = newsize - ( ! newsize );
remaining = s -> maxsize - avio_tell ( s );
remaining = ( remaining > 0 ? remaining : 0 );
if ( s -> maxsize >= 0 && remaining + 1 < size )
av_log ( ( ( void * ) 0 ) , ( remaining ? 16 : 48 ) , "Truncating packet of size %d to %ld\n" , size , remaining + 1 );
size = ( remaining + 1 );
return size ;
0
------------------------------
301093 153289/aviobuf.c s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_end - s -> checksum_ptr ) ) ) 493
int avio_get_str(AVIOContext *s,int maxlen,char *buf,int buflen)
int i ;
if ( buflen <= 0 )
buflen = ( buflen - 1 > maxlen ? maxlen : buflen - 1 );
for (i = 0; i < buflen; i++)
if ( ! ( buf [ i ] = ( avio_r8 ( s ) ) ) )
int avio_r8(AVIOContext *s)
if ( s -> buf_ptr >= s -> buf_end )
fill_buffer ( s );
static void fill_buffer(AVIOContext *s)
uint8_t * dst = ! s -> max_packet_size && s -> buf_end - s -> buffer < ( s -> buffer_size ) ? s -> buf_end : s -> buffer ;
if ( ! s -> read_packet && s -> buf_ptr >= s -> buf_end )
s -> eof_reached = 1;
if ( s -> eof_reached )
if ( s -> update_checksum && dst == s -> buffer )
if ( s -> buf_end > s -> checksum_ptr )
s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_end - s -> checksum_ptr ) ) );
s -> checksum_ptr = s -> buffer;
if ( s -> read_packet && s -> buffer_size > max_buffer_size )
ffio_set_buf_size ( s , max_buffer_size );
s -> checksum_ptr = dst = s -> buffer;
len = s -> buffer_size;
if ( s -> read_packet )
len = ( ( s -> read_packet ) ( s -> opaque , dst , len ) );
if ( len <= 0 )
s -> eof_reached = 1;
if ( len < 0 )
s -> error = len;
s -> pos += len;
s -> buf_ptr = dst;
s -> buf_end = dst + len;
s -> bytes_read += len;
0
------------------------------
304264 81977/CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_w32_vsnprintf_84_bad.cpp recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 ) 93
void bad()
wchar_t * data ;
wchar_t dataBuffer [ 100 ] = L ""
data = dataBuffer;
CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_w32_vsnprintf_84_bad * badObject = new CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_w32_vsnprintf_84_bad ( data ) ;
CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_w32_vsnprintf_84_bad::CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_w32_vsnprintf_84_bad(wchar_t * dataCopy)
data = dataCopy;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
309320 149381/file_wrappers.c have = ( ( unsigned int ) ( strm -> next_out - state -> next ) ) 1586
unsigned int gzwfile_write(GZWFILE_T state,const void *buf,unsigned int len)
unsigned int n ;
z_streamp strm ;
strm = & state -> strm;
if ( state -> err != 0 )
if ( len == 0 )
if ( state -> size == 0 && gz_init ( state ) == - 1 )
if ( len < state -> size )
if ( strm -> avail_in == 0 )
strm -> next_in = state -> in;
n = state -> size - strm -> avail_in;
if ( n > len )
n = len;
memcpy ( ( strm -> next_in + strm -> avail_in ) , buf , n );
strm -> avail_in += n;
state -> pos += n;
buf = ( ( ( char * ) buf ) + n );
len -= n;
if ( len && gz_comp ( state , 0 ) == - 1 )
while ( len )
static int gz_comp(GZWFILE_T state,int flush)
int ret ;
int got ;
unsigned int have ;
z_streamp strm = & state -> strm ;
if ( state -> size == 0 && gz_init ( state ) == - 1 )
ret = 0;
if ( strm -> avail_out == 0 || flush != 0 && ( flush != 4 || ret == 1 ) )
have = ( ( unsigned int ) ( strm -> next_out - state -> next ) );
if ( have )
got = ( write ( state -> fd , ( state -> next ) , have ) );
if ( got < 0 )
if ( ( ( unsigned int ) got ) != have )
if ( strm -> avail_out == 0 )
strm -> avail_out = state -> size;
strm -> next_out = state -> out;
state -> next = strm -> next_out;
have = strm -> avail_out;
ret = deflate ( strm , flush );
if ( ret == - 2 )
have -= strm -> avail_out;
while ( have )
0
------------------------------
302250 80672/CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_snprintf_66a.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 ) 98
void CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_snprintf_66_bad()
wchar_t * data ;
wchar_t dataBuffer [ 100 ] = L ""
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
300665 151912/dfa.c mblen_buf = ( ( sizeof ( ( * mblen_buf ) ) == 1 ? xmalloc ( ( end - begin + 2 ) ) : xnmalloc ( ( end - begin + 2 ) , sizeof ( ( * mblen_buf ) ) ) ) ) 3569
char *dfaexec(struct dfa *d,const char *begin,char *end,int allow_nl,size_t *count,int *backref)
unsigned char eol = eolbyte ;
* end = eol;
if ( d -> mb_cur_max > 1 )
mblen_buf = ( ( sizeof ( ( * mblen_buf ) ) == 1 ? xmalloc ( ( end - begin + 2 ) ) : xnmalloc ( ( end - begin + 2 ) , sizeof ( ( * mblen_buf ) ) ) ) );
while ( 0 )
while ( inputwcs [ p - buf_begin ] == 0 && mblen_buf [ p - buf_begin ] > 0 && ( ( const unsigned char * ) p ) < buf_end )
free ( mblen_buf );
free ( mblen_buf );
free ( mblen_buf );
free ( mblen_buf );
0
------------------------------
305587 117256/CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_connect_socket_61a.c myString = ( wchar_t * ) malloc ( data * sizeof ( wchar_t ) ) 128
static void goodB2G()
size_t data ;
data = 0;
data = CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_connect_socket_61b_goodB2GSource ( data );
size_t CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_connect_socket_61b_goodB2GSource(size_t data)
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
char inputBuffer [ CHAR_ARRAY_SIZE ] ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
inputBuffer [ recvResult ] = '\0';
data = strtoul ( inputBuffer , NULL , 0 );
while ( 0 )
return data ;
wchar_t * myString ;
if ( data > wcslen ( HELLO_STRING ) && data < 100 )
myString = ( wchar_t * ) malloc ( data * sizeof ( wchar_t ) );
wcscpy ( myString , HELLO_STRING );
printWLine ( myString );
void printWLine (const wchar_t * line)
if ( line != NULL )
wprintf ( L "%ls\n" , line )
free ( myString );
0
------------------------------
20007 CVE-2015-8785/linux_kernel_4.3_CVE_2015_8785_fs_fuse_file.c req -> page_descs [ i ] . length = PAGE_SIZE - req -> page_descs [ i ] . offset 1224
static long fuse_file_ioctl(struct file *file, unsigned int
unsigned long arg)
return fuse_ioctl_common ( file , cmd , arg , 0 ) ;
long fuse_ioctl_common(struct file *file, unsigned int
unsigned long arg, unsigned int flags)
struct inode * inode = file_inode ( file ) ;
struct fuse_conn * fc = get_fuse_conn ( inode ) ;
if ( ! fuse_allow_current_process ( fc ) )
if ( is_bad_inode ( inode ) )
return fuse_do_ioctl ( file , cmd , arg , flags ) ;
long fuse_do_ioctl(struct file *file, unsigned int cmd, unsigned long
unsigned int flags)
struct fuse_file * ff = file -> private_data ;
struct fuse_conn * fc = ff -> fc ;
struct fuse_ioctl_in inarg
. fh = ff -> fh
. cmd = cmd
. arg = arg
. flags = flags
struct fuse_ioctl_out outarg ;
struct page * * pages = NULL ;
struct iovec * in_iov = NULL , * out_iov = NULL ;
unsigned int in_iovs = 0 , out_iovs = 0 , num_pages = 0 , max_pages ;
size_t in_size , out_size , transferred ;
int err ;
inarg . flags |= FUSE_IOCTL_32BIT;
err = - ENOMEM;
pages = kcalloc ( FUSE_MAX_PAGES_PER_REQ , sizeof ( pages [ 0 ] ) , GFP_KERNEL );
iov_page = ( struct iovec * ) __get_free_page ( GFP_KERNEL );
if ( ! pages || ! iov_page )
if ( ! ( flags & FUSE_IOCTL_UNRESTRICTED ) )
struct iovec * iov = iov_page ;
iov -> iov_base = ( void __user * ) arg;
iov -> iov_len = _IOC_SIZE ( cmd );
if ( _IOC_DIR ( cmd ) & _IOC_WRITE )
in_iov = iov;
in_iovs = 1;
if ( _IOC_DIR ( cmd ) & _IOC_READ )
out_iov = iov;
out_iovs = 1;
inarg . in_size = in_size = iov_length ( in_iov , in_iovs );
inarg . out_size = out_size = iov_length ( out_iov , out_iovs );
out_size = max_t ( size_t , out_size , PAGE_SIZE );
max_pages = DIV_ROUND_UP ( max ( in_size , out_size ) , PAGE_SIZE );
err = - ENOMEM;
if ( max_pages > FUSE_MAX_PAGES_PER_REQ )
while ( num_pages < max_pages )
pages [ num_pages ] = alloc_page ( GFP_KERNEL | __GFP_HIGHMEM );
if ( ! pages [ num_pages ] )
num_pages ++;
req = fuse_get_req ( fc , num_pages );
if ( IS_ERR ( req ) )
memcpy ( req -> pages , pages , sizeof ( req -> pages [ 0 ] ) * num_pages );
req -> num_pages = num_pages;
fuse_page_descs_length_init ( req , 0 , req -> num_pages );
req -> in . h . opcode = FUSE_IOCTL;
req -> in . h . nodeid = ff -> nodeid;
req -> in . numargs = 1;
req -> in . args [ 0 ] . size = sizeof ( inarg );
req -> in . args [ 0 ] . value = & inarg;
if ( in_size )
req -> in . numargs ++;
req -> in . args [ 1 ] . size = in_size;
req -> in . argpages = 1;
err = fuse_ioctl_copy_user ( pages , in_iov , in_iovs , in_size , false );
if ( err )
req -> out . numargs = 2;
req -> out . args [ 0 ] . size = sizeof ( outarg );
req -> out . args [ 0 ] . value = & outarg;
req -> out . args [ 1 ] . size = out_size;
req -> out . argpages = 1;
req -> out . argvar = 1;
err = req -> out . h . error;
transferred = req -> out . args [ 1 ] . size;
if ( err )
if ( outarg . flags & FUSE_IOCTL_RETRY )
void * vaddr ;
if ( ! ( flags & FUSE_IOCTL_UNRESTRICTED ) )
in_iovs = outarg . in_iovs;
out_iovs = outarg . out_iovs;
if ( in_iovs > FUSE_IOCTL_MAX_IOV || out_iovs > FUSE_IOCTL_MAX_IOV || in_iovs + out_iovs > FUSE_IOCTL_MAX_IOV )
vaddr = kmap_atomic ( pages [ 0 ] );
err = fuse_copy_ioctl_iovec ( fc , iov_page , vaddr , transferred , in_iovs + out_iovs , ( flags & FUSE_IOCTL_COMPAT ) != 0 );
if ( err )
in_iov = iov_page;
out_iov = in_iov + in_iovs;
err = fuse_verify_ioctl_iov ( in_iov , in_iovs );
if ( err )
err = fuse_verify_ioctl_iov ( out_iov , out_iovs );
if ( err )
static inline void fuse_page_descs_length_init(struct fuse_req
unsigned index, unsigned nr_pages)
int i ;
for (i = index; i < index + nr_pages; i++)
req -> page_descs [ i ] . length = PAGE_SIZE - req -> page_descs [ i ] . offset;
0
------------------------------
19819 CVE-2016-2522/Wireshark_2.0.1_CVE_2016_2522_epan_dissectors_packet-ber.c end_offset = offset + val_length 2082

dissect_ber_GeneralizedTime(gboolean implicit_tag, asn1_ctx_t *actx, proto_tree *tree, tvbuff_t *tvb, int offset, gint hf_id)
gint8 ber_class ;
gint32 tag ;
guint32 len ;
proto_item * cause ;
if ( ! implicit_tag )
offset = dissect_ber_identifier ( actx -> pinfo , tree , tvb , offset , & ber_class , & pc , & tag );
offset = dissect_ber_length ( actx -> pinfo , tree , tvb , offset , & len , NULL );
if ( ( ber_class != BER_CLASS_UNI ) || ( tag != BER_UNI_TAG_GeneralizedTime ) )
len = tvb_reported_length_remaining ( tvb , offset );
if ( ( len < 14 ) || ( len > 23 ) )
cause = proto_tree_add_string_format_value ( tree , hf_ber_error , tvb , offset , len , "illegal_length" , "GeneralizedTime invalid length: %u" , len );
if ( decode_unexpected )
proto_tree * unknown_tree = proto_item_add_subtree ( cause , ett_ber_unknown ) ;
dissect_unknown_ber ( actx -> pinfo , tvb , offset , unknown_tree );

dissect_unknown_ber(packet_info *pinfo, tvbuff_t *tvb, int offset, proto_tree *tree)
return try_dissect_unknown_ber ( pinfo , tvb , offset , tree , 1 ) ;
static
try_dissect_unknown_ber(packet_info *pinfo, tvbuff_t *tvb, volatile int offset, proto_tree *tree, gint nest_level)
int start_offset ;
gint8 ber_class ;
gboolean pc , ind ;
gint32 tag ;
guint32 len ;
start_offset = offset;
offset = get_ber_identifier ( tvb , offset , & ber_class , & pc , & tag );
offset = get_ber_length ( tvb , offset , & len , & ind );
if ( len > ( guint32 ) tvb_reported_length_remaining ( tvb , offset ) )
switch ( pc )
switch ( ber_class )
switch ( tag )
offset = dissect_ber_real ( FALSE , & asn1_ctx , tree , tvb , start_offset , hf_ber_unknown_REAL , NULL );

dissect_ber_real(gboolean implicit_tag, asn1_ctx_t *actx, proto_tree *tree, tvbuff_t *tvb, int offset, gint hf_id _U_, double *value)
guint32 val_length = 0 , len_remain , end_offset ;
if ( ! implicit_tag )
offset = dissect_ber_identifier ( actx -> pinfo , tree , tvb , offset , & ber_class , & pc , & tag );
offset = dissect_ber_length ( actx -> pinfo , tree , tvb , offset , & val_length , NULL );
end_offset = offset + val_length;
actx -> created_item = proto_tree_add_double ( tree , hf_id , tvb , end_offset - val_length , val_length , val );
return end_offset ;
1
------------------------------
300470 152633/aviobuf.c s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_ptr - s -> checksum_ptr ) ) ) 189
void avio_wl64(AVIOContext *s,uint64_t val)
avio_wl32 ( s , ( ( uint32_t ) ( val & 0xffffffff ) ) );
void avio_wl32(AVIOContext *s,unsigned int val)
avio_w8 ( s , ( ( uint8_t ) val ) );
void avio_w8(AVIOContext *s,int b)
* ( s -> buf_ptr ++ ) = b;
if ( s -> buf_ptr >= s -> buf_end )
flush_buffer ( s );
static void flush_buffer(AVIOContext *s)
if ( s -> buf_ptr > s -> buffer )
if ( s -> update_checksum )
s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_ptr - s -> checksum_ptr ) ) );
s -> checksum_ptr = s -> buffer;
s -> buf_ptr = s -> buffer;
0
------------------------------
306519 117427/CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_rand_13.c myString = ( wchar_t * ) malloc ( data * sizeof ( wchar_t ) ) 47
void CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_rand_13_bad()
size_t data ;
data = 0;
if ( GLOBAL_CONST_FIVE == 5 )
data = rand ( );
if ( GLOBAL_CONST_FIVE == 5 )
wchar_t * myString ;
if ( data > wcslen ( HELLO_STRING ) )
myString = ( wchar_t * ) malloc ( data * sizeof ( wchar_t ) );
wcscpy ( myString , HELLO_STRING );
printWLine ( myString );
void printWLine (const wchar_t * line)
if ( line != NULL )
wprintf ( L "%ls\n" , line )
free ( myString );
1
------------------------------
312188 153760/aviobuf.c uint8_t * dst = ! s -> max_packet_size && s -> buf_end - s -> buffer < ( s -> buffer_size ) ? s -> buf_end : s -> buffer ; 476
int ffio_read_partial(AVIOContext *s,unsigned char *buf,int size)
int len ;
if ( size < 0 )
if ( s -> read_packet && s -> write_flag )
len = ( s -> buf_end - s -> buf_ptr );
if ( len == 0 )
s -> buf_end = s -> buf_ptr = s -> buffer;
len = ( s -> buf_end - s -> buf_ptr );
if ( len > size )
len = size;
s -> buf_ptr += len;
if ( ! len )
if ( s -> error )
if ( url_feof ( s ) )
int url_feof(AVIOContext *s)
if ( ! s )
if ( s -> eof_reached )
s -> eof_reached = 0;
fill_buffer ( s );
static void fill_buffer(AVIOContext *s)
uint8_t * dst = ! s -> max_packet_size && s -> buf_end - s -> buffer < ( s -> buffer_size ) ? s -> buf_end : s -> buffer ;
int len = ( ( s -> buffer_size ) - ( dst - s -> buffer ) ) ;
if ( s -> update_checksum && dst == s -> buffer )
len = ( ( s -> read_packet ) ( s -> opaque , dst , len ) );
if ( len <= 0 )
if ( len < 0 )
s -> error = len;
s -> pos += len;
s -> buf_ptr = dst;
s -> buf_end = dst + len;
s -> bytes_read += len;
0
------------------------------
305788 118308/CWE78_OS_Command_Injection__char_connect_socket_w32_spawnv_51a.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 104
void CWE78_OS_Command_Injection__char_connect_socket_w32_spawnv_51_bad()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
CWE78_OS_Command_Injection__char_connect_socket_w32_spawnv_51b_badSink ( data );
void CWE78_OS_Command_Injection__char_connect_socket_w32_spawnv_51b_badSink(char * data)
0
------------------------------
305707 117068/CWE789_Uncontrolled_Mem_Alloc__malloc_char_fgets_65b.c myString = ( char * ) malloc ( data * sizeof ( char ) ) 39
void CWE789_Uncontrolled_Mem_Alloc__malloc_char_fgets_65b_badSink(size_t data)
char * myString ;
if ( data > strlen ( HELLO_STRING ) )
myString = ( char * ) malloc ( data * sizeof ( char ) );
strcpy ( myString , HELLO_STRING );
printLine ( myString );
void printLine (const char * line)
if ( line != NULL )
printf ( "%s\n" , line );
free ( myString );
1
------------------------------
314066 110712/CWE680_Integer_Overflow_to_Buffer_Overflow__new_fixed_17.cpp dataBytes = data * sizeof ( int ) 41
void bad()
int i ;
int data ;
data = - 1;
for(i = 0; i < 1; i++)
data = INT_MAX / 2 + 2;
size_t dataBytes , i ;
dataBytes = data * sizeof ( int );
intPointer = ( int * ) new char [ dataBytes ];
intPointer [ i ] = 0;
printIntLine ( intPointer [ 0 ] );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
delete [ ] intPointer
1
------------------------------
314674 97874/CWE36_Absolute_Path_Traversal__wchar_t_listen_socket_open_54a.cpp recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ) 109
void bad()
wchar_t * data ;
wchar_t dataBuffer [ FILENAME_MAX ] = L ""
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( FILENAME_MAX - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
20319 CVE-2016-4006/Wireshark_2.0.2_CVE_2016_4006_epan_proto.c new_fi -> length = n + length 1687
proto_item
proto_tree_add_bitmask_with_flags(proto_tree *parent_tree, tvbuff_t *tvb, const guint
const int hf_hdr, const gint ett, const int **fields, const guint encoding, const int flags)
header_field_info * hf ;
int len ;
len = ftype_length ( hf -> type );
if ( parent_tree )
item = proto_tree_add_item ( parent_tree , hf_hdr , tvb , offset , len , encoding );
proto_item
proto_tree_add_item(proto_tree *tree, int hfindex, tvbuff_t
const gint start, gint length, const guint encoding)
register header_field_info * hfinfo ;
return proto_tree_add_item_new ( tree , hfinfo , tvb , start , length , encoding ) ;
proto_item
proto_tree_add_item_new(proto_tree *tree, header_field_info *hfinfo, tvbuff_t
const gint start, gint length, const guint encoding)
field_info * new_fi ;
gint item_length ;
new_fi = new_field_info ( tree , hfinfo , tvb , start , item_length );
if ( new_fi == NULL )
return proto_tree_new_item ( new_fi , tree , tvb , start , length , encoding ) ;
static proto_item
proto_tree_new_item(field_info *new_fi, proto_tree
tvbuff_t *tvb, gint start, gint
guint encoding)
guint32 value , n ;
switch ( new_fi -> hfinfo -> type )
if ( encoding )
encoding = ENC_LITTLE_ENDIAN;
n = get_uint_value ( tree , tvb , start , length , encoding );
new_fi -> length = n + length;
proto_tree_set_boolean ( new_fi , get_uint64_value ( tree , tvb , start , length , encoding ) );
proto_tree_set_uint ( new_fi , get_uint_value ( tree , tvb , start , length , encoding ) );
proto_tree_set_uint64 ( new_fi , get_uint64_value ( tree , tvb , start , length , encoding ) );
proto_tree_set_int ( new_fi , get_int_value ( tree , tvb , start , length , encoding ) );
proto_tree_set_int64 ( new_fi , get_int64_value ( tree , tvb , start , length , encoding ) );
proto_tree_set_ipv4 ( new_fi , encoding ? GUINT32_SWAP_LE_BE ( value ) : value );
proto_tree_set_ipxnet ( new_fi , get_uint_value ( tree , tvb , start , FT_IPXNET_LEN , ENC_BIG_ENDIAN ) );
proto_tree_set_ipv6_tvb ( new_fi , tvb , start , length );
proto_tree_set_fcwwn_tvb ( new_fi , tvb , start , length );
proto_tree_set_ax25_tvb ( new_fi , tvb , start );
proto_tree_set_vines_tvb ( new_fi , tvb , start );
proto_tree_set_ether_tvb ( new_fi , tvb , start );
proto_tree_set_eui64_tvb ( new_fi , tvb , start , encoding );
proto_tree_set_guid_tvb ( new_fi , tvb , start , encoding );
proto_tree_set_oid_tvb ( new_fi , tvb , start , length );
proto_tree_set_system_id_tvb ( new_fi , tvb , start , length );
proto_tree_set_float ( new_fi , floatval );
proto_tree_set_double ( new_fi , doubleval );
proto_tree_set_string_tvb ( new_fi , tvb , start , length , encoding );
new_fi -> length = length;
proto_tree_set_string ( new_fi , string );
proto_tree_set_string_tvb ( new_fi , tvb , start + length , n , encoding );
new_fi -> length = n + length;
proto_tree_set_string_tvb ( new_fi , tvb , start , length , encoding );
proto_tree_set_time ( new_fi , & time_stamp );
proto_tree_set_time ( new_fi , & time_stamp );
g_error ( "new_fi->hfinfo->type %d (%s) not handled\n" , new_fi -> hfinfo -> type , ftype_name ( new_fi -> hfinfo -> type ) );
FI_SET_FLAG ( new_fi , ( encoding & ENC_LITTLE_ENDIAN ) ? FI_LITTLE_ENDIAN : FI_BIG_ENDIAN );
pi = proto_tree_add_node ( tree , new_fi );
return pi ;
0
------------------------------
298864 95069/CWE369_Divide_by_Zero__int_fgets_divide_12.c printIntLine ( 100 / data ) 118
static void goodB2G()
int data ;
data = - 1;
if ( globalReturnsTrueOrFalse ( ) )
int globalReturnsTrueOrFalse()
return ( rand ( ) % 2 ) ;
char inputBuffer [ CHAR_ARRAY_SIZE ] = "" ;
if ( fgets ( inputBuffer , CHAR_ARRAY_SIZE , stdin ) != NULL )
data = atoi ( inputBuffer );
char inputBuffer [ CHAR_ARRAY_SIZE ] = "" ;
if ( fgets ( inputBuffer , CHAR_ARRAY_SIZE , stdin ) != NULL )
data = atoi ( inputBuffer );
if ( globalReturnsTrueOrFalse ( ) )
int globalReturnsTrueOrFalse()
return ( rand ( ) % 2 ) ;
if ( data != 0 )
printIntLine ( 100 / data );
0
------------------------------
311329 152169/aviobuf.c s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_ptr - s -> checksum_ptr ) ) ) 172
void avio_wb24(AVIOContext *s,unsigned int val)
avio_wb16 ( s , ( ( ( int ) val ) >> 8 ) );
void avio_wb16(AVIOContext *s,unsigned int val)
avio_w8 ( s , ( ( int ) val ) >> 8 );
void avio_w8(AVIOContext *s,int b)
* ( s -> buf_ptr ++ ) = b;
if ( s -> buf_ptr >= s -> buf_end )
flush_buffer ( s );
static void flush_buffer(AVIOContext *s)
if ( s -> buf_ptr > s -> buffer )
if ( s -> update_checksum )
s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_ptr - s -> checksum_ptr ) ) );
s -> checksum_ptr = s -> buffer;
s -> buf_ptr = s -> buffer;
0
------------------------------
18874 CVE-2015-2716/Firefox_37.0b7_CVE_2015_2716_parser_expat_lib_xmlparse.c pool -> end = pool -> start + pool -> blocks -> size 6238
static
reportProcessingInstruction(XML_Parser parser, const ENCODING
const char *start, const char *end)
const XML_Char * target ;
XML_Char * data ;
const char * tem ;
if ( ! processingInstructionHandler )
start += enc -> minBytesPerChar * 2;
tem = start + XmlNameLength ( enc , start );
target = poolStoreString ( & tempPool , enc , start , tem );
if ( ! target )
data = poolStoreString ( & tempPool , enc , XmlSkipS ( enc , tem ) , end - enc -> minBytesPerChar * 2 );
static XML_Char
poolStoreString(STRING_POOL *pool, const ENCODING
const char *ptr, const char *end)
if ( ! poolAppend ( pool , enc , ptr , end ) )
static XML_Char
poolAppend(STRING_POOL *pool, const ENCODING
const char *ptr, const char *end)
if ( ! pool -> ptr && ! poolGrow ( pool ) )
static XML_Bool
poolGrow(STRING_POOL *pool)
if ( pool -> freeBlocks )
if ( pool -> start == 0 )
pool -> blocks = pool -> freeBlocks;
pool -> freeBlocks = pool -> freeBlocks -> next;
pool -> blocks -> next = NULL;
pool -> start = pool -> blocks -> s;
pool -> end = pool -> start + pool -> blocks -> size;
pool -> ptr = pool -> start;
0
------------------------------
307389 104492/CWE469_Use_of_Pointer_Subtraction_to_Determine_Size__wchar_t_15.c indexOfSlashInString1 = ( size_t ) ( slashInString1 - string2 ) 40
void CWE469_Use_of_Pointer_Subtraction_to_Determine_Size__wchar_t_15_bad()
switch ( 6 )
wchar_t string2 [ ] = SOURCE_STRING ;
wchar_t * slashInString1 ;
size_t indexOfSlashInString1 ;
slashInString1 = wcschr ( string1 , L '/' )
indexOfSlashInString1 = ( size_t ) ( slashInString1 - string2 );
printUnsignedLine ( indexOfSlashInString1 );
void printUnsignedLine(unsigned unsignedNumber)
printf ( "%u\n" , unsignedNumber );
1
------------------------------
314068 110713/CWE680_Integer_Overflow_to_Buffer_Overflow__new_fixed_18.cpp dataBytes = data * sizeof ( int ) 39
void bad()
int data ;
data = - 1;
data = INT_MAX / 2 + 2;
size_t dataBytes , i ;
dataBytes = data * sizeof ( int );
intPointer = ( int * ) new char [ dataBytes ];
intPointer [ i ] = 0;
printIntLine ( intPointer [ 0 ] );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
delete [ ] intPointer
1
------------------------------
307114 120304/CWE78_OS_Command_Injection__char_listen_socket_w32_spawnvp_10.c recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 111
void CWE78_OS_Command_Injection__char_listen_socket_w32_spawnvp_10_bad()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
if ( globalTrue )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
0
------------------------------
306714 120190/CWE78_OS_Command_Injection__char_listen_socket_w32_spawnlp_67a.c recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 118
void CWE78_OS_Command_Injection__char_listen_socket_w32_spawnlp_67_bad()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
myStruct . structFirst = data;
CWE78_OS_Command_Injection__char_listen_socket_w32_spawnlp_67b_badSink ( myStruct );
void CWE78_OS_Command_Injection__char_listen_socket_w32_spawnlp_67b_badSink(CWE78_OS_Command_Injection__char_listen_socket_w32_spawnlp_67_structType myStruct)
char * data = myStruct . structFirst ;
0
------------------------------
307397 104491/CWE469_Use_of_Pointer_Subtraction_to_Determine_Size__wchar_t_14.c indexOfSlashInString1 = ( size_t ) ( slashInString1 - string1 ) 92
static void good2()
if ( globalFive == 5 )
wchar_t string1 [ ] = SOURCE_STRING ;
wchar_t * slashInString1 ;
size_t indexOfSlashInString1 ;
slashInString1 = wcschr ( string1 , L '/' )
indexOfSlashInString1 = ( size_t ) ( slashInString1 - string1 );
printUnsignedLine ( indexOfSlashInString1 );
void printUnsignedLine(unsigned unsignedNumber)
printf ( "%u\n" , unsignedNumber );
0
------------------------------
314855 110615/CWE680_Integer_Overflow_to_Buffer_Overflow__new_connect_socket_16.cpp dataBytes = data * sizeof ( int ) 115
void bad()
int data ;
data = - 1;
while ( 1 )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
char inputBuffer [ CHAR_ARRAY_SIZE ] ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
inputBuffer [ recvResult ] = '\0';
data = atoi ( inputBuffer );
while ( 0 )
size_t dataBytes , i ;
dataBytes = data * sizeof ( int );
intPointer = ( int * ) new char [ dataBytes ];
intPointer [ i ] = 0;
printIntLine ( intPointer [ 0 ] );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
delete [ ] intPointer
1
------------------------------
17565 CVE-2013-1588/CVE_2013_1588_VULN_dissect_pft_fec_detailed.c got = ep_alloc ( fcount * sizeof ( guint32 ) ) 45
static tvbuff_t
CVE_2013_1588_VULN_dissect_pft_fec_detailed(tvbuff_t * tvb, packet_info * pinfo, proto_tree *
guint32 findex
guint32
guint16
gint
guint16
gboolean fec
guint16
guint16
fragment_data
)
if ( fcount > MAX_FRAGMENTS )
if ( fdx )
guint32 * got ;
got = ep_alloc ( fcount * sizeof ( guint32 ) );
0
------------------------------
305474 94227/CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_connect_socket_61b.c recvResult = recv ( connectSocket , ( char * ) ( password + passwordLen ) , ( 100 - passwordLen - 1 ) * sizeof ( wchar_t ) , 0 ) 67
void CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_connect_socket_61_bad()
wchar_t * password ;
wchar_t passwordBuffer [ 100 ] = L ""
password = passwordBuffer;
password = CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_connect_socket_61b_badSource ( password );
wchar_t * CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_connect_socket_61b_badSource(wchar_t * password)
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t passwordLen = wcslen ( password ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( password + passwordLen ) , ( 100 - passwordLen - 1 ) * sizeof ( wchar_t ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
1
------------------------------
301019 153289/aviobuf.c s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_ptr - s -> checksum_ptr ) ) ) 202
int avio_close_dyn_buf(AVIOContext *s,uint8_t **pbuffer)
avio_flush ( s );
void avio_flush(AVIOContext *s)
flush_buffer ( s );
static void flush_buffer(AVIOContext *s)
if ( s -> buf_ptr > s -> buffer )
if ( s -> update_checksum )
s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_ptr - s -> checksum_ptr ) ) );
s -> checksum_ptr = s -> buffer;
s -> buf_ptr = s -> buffer;
0
------------------------------
313361 90639/CWE23_Relative_Path_Traversal__char_listen_socket_ofstream_04.cpp recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ) 112
void bad()
char * data ;
char dataBuffer [ FILENAME_MAX ] = BASEPATH ;
data = dataBuffer;
if ( STATIC_CONST_TRUE )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
outputFile . open ( ( char * ) data );
1
------------------------------
20989 CVE-2016-2550/linux_kernel_4.3.5_CVE_2016_2550_net_unix_af_unix.c err = ( flags & MSG_TRUNC ) ? skb -> len - skip : size 2188
static int unix_seqpacket_recvmsg(struct socket *sock, struct msghdr
size_t size, int flags)
struct sock * sk = sock -> sk ;
if ( sk -> sk_state != TCP_ESTABLISHED )
return unix_dgram_recvmsg ( sock , msg , size , flags ) ;
static int unix_dgram_recvmsg(struct socket *sock, struct msghdr
size_t size, int flags)
struct sock * sk = sock -> sk ;
struct unix_sock * u = unix_sk ( sk ) ;
struct sk_buff * skb ;
int err ;
int peeked , skip ;
err = - EOPNOTSUPP;
if ( flags & MSG_OOB )
err = mutex_lock_interruptible ( & u -> readlock );
if ( unlikely ( err ) )
skip = sk_peek_offset ( sk , flags );
skb = __skb_recv_datagram ( sk , flags , & peeked , & skip , & err );
if ( ! skb )
if ( size > skb -> len - skip )
size = skb -> len - skip;
if ( size < skb -> len - skip )
msg -> msg_flags |= MSG_TRUNC;
err = skb_copy_datagram_msg ( skb , skip , msg , size );
if ( err )
err = ( flags & MSG_TRUNC ) ? skb -> len - skip : size;
return err ;
0
------------------------------
307591 110527/CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_listen_socket_34.c intPointer = ( int * ) malloc ( data * sizeof ( int ) ) 132
void CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_listen_socket_34_bad()
int data ;
CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_listen_socket_34_unionType myUnion ;
data = - 1;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
char inputBuffer [ CHAR_ARRAY_SIZE ] ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
inputBuffer [ recvResult ] = '\0';
data = atoi ( inputBuffer );
while ( 0 )
myUnion . unionFirst = data;
int data = myUnion . unionSecond ;
int * intPointer ;
intPointer = ( int * ) malloc ( data * sizeof ( int ) );
intPointer [ i ] = 0;
printIntLine ( intPointer [ 0 ] );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
free ( intPointer );
1
------------------------------
301031 153289/aviobuf.c s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_ptr - s -> checksum_ptr ) ) ) 202
void avio_wb64(AVIOContext *s,uint64_t val)
avio_wb32 ( s , ( ( uint32_t ) ( val & 0xffffffff ) ) );
void avio_wb32(AVIOContext *s,unsigned int val)
avio_w8 ( s , ( ( uint8_t ) ( val >> 16 ) ) );
void avio_w8(AVIOContext *s,int b)
* ( s -> buf_ptr ++ ) = b;
if ( s -> buf_ptr >= s -> buf_end )
flush_buffer ( s );
static void flush_buffer(AVIOContext *s)
if ( s -> buf_ptr > s -> buffer )
if ( s -> update_checksum )
s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_ptr - s -> checksum_ptr ) ) );
s -> checksum_ptr = s -> buffer;
s -> buf_ptr = s -> buffer;
0
------------------------------
307872 117163/CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_64b.c myString = ( char * ) malloc ( data * sizeof ( char ) ) 94
static void goodG2B()
size_t data ;
data = 0;
data = 20;
CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_64b_goodG2BSink ( & data );
void CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_64b_goodG2BSink(void * dataVoidPtr)
size_t * dataPtr = ( size_t * ) dataVoidPtr ;
size_t data = ( * dataPtr ) ;
char * myString ;
if ( data > strlen ( HELLO_STRING ) )
myString = ( char * ) malloc ( data * sizeof ( char ) );
strcpy ( myString , HELLO_STRING );
printLine ( myString );
void printLine (const char * line)
if ( line != NULL )
printf ( "%s\n" , line );
free ( myString );
0
------------------------------
299631 149616/aviobuf.c s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_ptr - s -> checksum_ptr ) ) ) 199
int avio_close_dyn_buf(AVIOContext *s,uint8_t **pbuffer)
avio_flush ( s );
void avio_flush(AVIOContext *s)
flush_buffer ( s );
static void flush_buffer(AVIOContext *s)
if ( s -> buf_ptr > s -> buffer )
if ( s -> update_checksum )
s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_ptr - s -> checksum_ptr ) ) );
s -> checksum_ptr = s -> buffer;
s -> buf_ptr = s -> buffer;
0
------------------------------
16549 CVE-2014-1508/CVE_2014_1508_PATCHED_nsDisplayNotation__Paint.c gfxFloat w = W * f ; 51
void CVE_2014_1508_PATCHED_nsDisplayNotation::Paint(nsDisplayListBuilder*
nsRenderingContext* aCtx)
nsPresContext * presContext = mFrame -> PresContext ( ) ;
gfxRect rect = presContext -> AppUnitsToGfxUnits ( mRect + ToReferenceFrame ( ) ) ;
gfxFloat e = presContext -> AppUnitsToGfxUnits ( mThickness ) ;
switch ( mType )
gfxFloat W = rect . Width ( ) ;
gfxFloat H = rect . Height ( ) ;
gfxFloat l = sqrt ( W * W + H * H ) ;
gfxFloat f = gfxFloat ( kArrowHeadSize ) * e / l ;
gfxFloat w = W * f ;
0
------------------------------
16610 CVE-2014-8547/CVE_2014_8547_PATCHED_gif_read_image.c height = s -> screen_height - top 73
static int CVE_2014_8547_PATCHED_gif_read_image(GifState *s, AVFrame *frame)
int left , top , width , height , bits_per_pixel , code_size , flags , pw ;
int is_interleaved , has_local_palette , y , pass , y1 , linesize , pal_size ;
if ( bytestream2_get_bytes_left ( & s -> gb ) < 9 )
left = bytestream2_get_le16u ( & s -> gb );
top = bytestream2_get_le16u ( & s -> gb );
width = bytestream2_get_le16u ( & s -> gb );
height = bytestream2_get_le16u ( & s -> gb );
flags = bytestream2_get_byteu ( & s -> gb );
has_local_palette = flags & 0x80;
bits_per_pixel = ( flags & 0x07 ) + 1;
if ( has_local_palette )
pal_size = 1 << bits_per_pixel;
if ( bytestream2_get_bytes_left ( & s -> gb ) < pal_size * 3 )
if ( ! s -> has_global_palette )
if ( ! width || width > s -> screen_width || left >= s -> screen_width )
if ( ! height || height > s -> screen_height || top >= s -> screen_height )
if ( top + height > s -> screen_height )
height = s -> screen_height - top;
0
------------------------------
313708 90541/CWE23_Relative_Path_Traversal__char_listen_socket_fopen_02.cpp recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ) 109
void bad()
char * data ;
char dataBuffer [ FILENAME_MAX ] = BASEPATH ;
data = dataBuffer;
if ( 1 )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
pFile = FOPEN ( data , "wb+" );
if ( pFile != NULL )
fclose ( pFile );
1
------------------------------
302923 79160/CWE134_Uncontrolled_Format_String__char_connect_socket_printf_15.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 190
static void goodB2G1()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
switch ( 6 )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
printf ( "%s\n" , data );
0
------------------------------
299813 150220/ffmpeg.c filepath = ( char * ) malloc ( size_filepath * sizeof ( char ) ) 167
void stonesoup_setup_printf_context()
ss_tc_root = getenv ( "SS_TC_ROOT" );
if ( ss_tc_root != NULL )
size_dirpath = strlen ( ss_tc_root ) + strlen ( "testData" ) + 2;
dirpath = ( char * ) malloc ( size_dirpath * sizeof ( char ) );
if ( dirpath != NULL )
sprintf ( dirpath , "%s/%s" , ss_tc_root , "testData" );
retval = 0;
if ( stat ( dirpath , & st ) == - 1 )
retval = mkdir ( dirpath , 0700 );
if ( retval == 0 )
size_filepath = strlen ( dirpath ) + strlen ( "logfile.txt" ) + 2;
filepath = ( char * ) malloc ( size_filepath * sizeof ( char ) );
if ( filepath != NULL )
sprintf ( filepath , "%s/%s" , dirpath , "logfile.txt" );
stonesoup_printf_context = fopen ( filepath , "w" );
free ( filepath );
if ( stonesoup_printf_context == NULL )
0
------------------------------
305281 103049/CWE427_Uncontrolled_Search_Path_Element__char_listen_socket_02.c recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 250 - dataLen - 1 ) , 0 ) 102
void CWE427_Uncontrolled_Search_Path_Element__char_listen_socket_02_bad()
char * data ;
char dataBuffer [ 250 ] = "PATH=" ;
data = dataBuffer;
if ( 1 )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 250 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
PUTENV ( data );
1
------------------------------
302332 81798/CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_snprintf_13.c recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 ) 311
static void goodB2G2()
wchar_t * data ;
wchar_t dataBuffer [ 100 ] = L ""
data = dataBuffer;
if ( GLOBAL_CONST_FIVE == 5 )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
303607 83232/CWE190_Integer_Overflow__int_fgets_square_21.c int result = data * data ; 164
static void goodG2B()
int data ;
data = 0;
data = 2;
goodG2BSink ( data );
static void goodG2BSink(int data)
if ( goodG2BStatic )
int result = data * data ;
printIntLine ( result );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
0
------------------------------
307917 110328/CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_connect_socket_17.c intPointer = ( int * ) malloc ( data * sizeof ( int ) ) 113
void CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_connect_socket_17_bad()
int i ;
int data ;
data = - 1;
for(i = 0; i < 1; i++)
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
char inputBuffer [ CHAR_ARRAY_SIZE ] ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
inputBuffer [ recvResult ] = '\0';
data = atoi ( inputBuffer );
while ( 0 )
int * intPointer ;
intPointer = ( int * ) malloc ( data * sizeof ( int ) );
intPointer [ i ] = 0;
printIntLine ( intPointer [ 0 ] );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
free ( intPointer );
1
------------------------------
306847 117196/CWE789_Uncontrolled_Mem_Alloc__malloc_char_rand_32.c myString = ( char * ) malloc ( data * sizeof ( char ) ) 50
void CWE789_Uncontrolled_Mem_Alloc__malloc_char_rand_32_bad()
size_t data ;
size_t * dataPtr2 = & data ;
data = 0;
data = rand ( );
size_t data = * dataPtr2 ;
char * myString ;
if ( data > strlen ( HELLO_STRING ) )
myString = ( char * ) malloc ( data * sizeof ( char ) );
strcpy ( myString , HELLO_STRING );
printLine ( myString );
void printLine (const char * line)
if ( line != NULL )
printf ( "%s\n" , line );
free ( myString );
1
------------------------------
305482 90731/CWE23_Relative_Path_Traversal__char_listen_socket_open_84_bad.cpp recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ) 99
void bad()
char * data ;
char dataBuffer [ FILENAME_MAX ] = BASEPATH ;
data = dataBuffer;
CWE23_Relative_Path_Traversal__char_listen_socket_open_84_bad * badObject = new CWE23_Relative_Path_Traversal__char_listen_socket_open_84_bad ( data ) ;
CWE23_Relative_Path_Traversal__char_listen_socket_open_84_bad::CWE23_Relative_Path_Traversal__char_listen_socket_open_84_bad(char * dataCopy)
data = dataCopy;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
0
------------------------------
20123 CVE-2017-6474/wireshark_2.0.5_CVE_2017_6474_wiretap_netscaler.c nstrace_buflen = GET_READ_PAGE_SIZE ( ( nstrace -> file_size - nstrace -> xxx_offset ) ) 1049
static gboolean nstrace_read_v10(wtap *wth, int *err, gchar **err_info, gint64 *data_offset)
nstrace_t * nstrace = ( nstrace_t * ) wth -> priv ;
gchar * nstrace_buf = nstrace -> pnstrace_buf ;
gint32 nstrace_buflen = nstrace -> nstrace_buflen ;
int bytes_read ;
while ( ( nstrace_buf_offset < nstrace_buflen ) && ( ( nstrace_buflen - nstrace_buf_offset ) >= ( ( gint32 ) sizeof ( ( ( nspr_header_v10_t * ) & nstrace_buf [ nstrace_buf_offset ] ) -> ph_RecordType ) ) ) )
PACKET_DESCRIBE ( phdr , FULL , full , ver , fp , HEADERVER );
switch ( pletoh16 ( & ( ( nspr_header_v10_t * ) & nstrace_buf [ nstrace_buf_offset ] ) -> ph_RecordType ) )
nspr_pktracefull_v10_t * fp = ( nspr_pktracefull_v10_t * ) & nstrace_buf [ nstrace_buf_offset ] ;
ns_setabstime ( nstrace , pletoh32 ( ( ( nspr_abstime_v10_t * ) fp ) -> abs_Time ) , pletoh32 ( & ( ( nspr_abstime_v10_t * ) fp ) -> abs_RelTime ) );
nstrace_buf_offset += pletoh16 ( & fp -> nsprRecordSize );
nspr_pktracefull_v10_t * fp = ( nspr_pktracefull_v10_t * ) & nstrace_buf [ nstrace_buf_offset ] ;
ns_setrelativetime ( nstrace , pletoh32 ( ( ( nspr_abstime_v10_t * ) fp ) -> abs_RelTime ) );
nstrace_buf_offset += pletoh16 ( & fp -> nsprRecordSize );
nstrace_buf_offset = nstrace_buflen;
nspr_pktracefull_v10_t * fp = ( nspr_pktracefull_v10_t * ) & nstrace_buf [ nstrace_buf_offset ] ;
nstrace_buf_offset += pletoh16 ( & fp -> nsprRecordSize );
nstrace -> xxx_offset += nstrace_buflen;
nstrace_buflen = GET_READ_PAGE_SIZE ( ( nstrace -> file_size - nstrace -> xxx_offset ) );
while ( ( nstrace_buflen > 0 ) && ( bytes_read = file_read ( nstrace_buf , nstrace_buflen , wth -> fh ) ) && ( bytes_read == nstrace_buflen ) )
0
------------------------------
303337 84513/CWE190_Integer_Overflow__unsigned_int_max_square_04.c unsigned int result = data * data ; 43
void CWE190_Integer_Overflow__unsigned_int_max_square_04_bad()
unsigned int data ;
data = 0;
if ( STATIC_CONST_TRUE )
data = UINT_MAX;
if ( STATIC_CONST_TRUE )
unsigned int result = data * data ;
printUnsignedLine ( result );
void printUnsignedLine(unsigned unsignedNumber)
printf ( "%u\n" , unsignedNumber );
1
------------------------------
311423 152169/aviobuf.c s -> buf_end = s -> buffer + s -> buffer_size 920
static int url_open_dyn_buf_internal(AVIOContext **s,int max_packet_size)
DynBuffer * d ;
unsigned int io_buffer_size = ( max_packet_size ? max_packet_size : 1024 ) ;
if ( sizeof ( DynBuffer ) + io_buffer_size < io_buffer_size )
d = ( av_mallocz ( sizeof ( DynBuffer ) + io_buffer_size ) );
if ( ! d )
d -> io_buffer_size = io_buffer_size;
* s = avio_alloc_context ( d -> io_buffer , d -> io_buffer_size , 1 , d , ( ( void * ) 0 ) , ( max_packet_size ? dyn_packet_buf_write : dyn_buf_write ) , ( max_packet_size ? ( ( void * ) 0 ) : dyn_buf_seek ) );
AVIOContext *avio_alloc_context(unsigned char *buffer,int buffer_size,int write_flag,void *opaque,int (*read_packet)(void *, uint8_t *, int ),int (*write_packet)(void *, uint8_t *, int ),int64_t (*seek)(void *, int64_t , int ))
AVIOContext * s = ( av_mallocz ( sizeof ( AVIOContext ) ) ) ;
if ( ! s )
ffio_init_context ( s , buffer , buffer_size , write_flag , opaque , read_packet , write_packet , seek );
int ffio_init_context(AVIOContext *s,unsigned char *buffer,int buffer_size,int write_flag,void *opaque,int (*read_packet)(void *, uint8_t *, int ),int (*write_packet)(void *, uint8_t *, int ),int64_t (*seek)(void *, int64_t , int ))
s -> buffer = buffer;
s -> buffer_size = buffer_size;
s -> buf_ptr = buffer;
s -> opaque = opaque;
s -> direct = 0;
url_resetbuf ( s , ( write_flag ? 2 : 1 ) );
static int url_resetbuf(AVIOContext *s,int flags)
if ( flags & 2 )
s -> buf_end = s -> buffer + s -> buffer_size;
s -> write_flag = 1;
0
------------------------------
18339 CVE-2015-5158/qemu_2.3.0_CVE-2015-5158_scsi-bus.c r -> buf [ pages ] = r -> len - pages - 1 425
static int32_t scsi_target_send_command(SCSIRequest *req, uint8_t *buf)
SCSITargetReq * r = DO_UPCAST ( SCSITargetReq , req , req ) ;
switch ( buf [ 0 ] )
if ( ! scsi_target_emulate_inquiry ( r ) )
static bool scsi_target_emulate_inquiry(SCSITargetReq *r)
if ( r -> req . cmd . buf [ 1 ] & 0x2 )
if ( r -> req . cmd . buf [ 1 ] & 0x1 )
uint8_t page_code = r -> req . cmd . buf [ 2 ] ;
r -> buf [ r -> len ++ ] = page_code;
r -> buf [ r -> len ++ ] = 0x00;
switch ( page_code )
int pages ;
pages = r -> len ++;
r -> buf [ r -> len ++ ] = 0x00;
r -> buf [ pages ] = r -> len - pages - 1;
assert ( r -> len < r -> buf_len );
r -> len = MIN ( r -> req . cmd . xfer , r -> len );
0
------------------------------
300604 150205/heapam.c linesleft = lines - lineoff + 1 596
HeapTuple heap_getnext(HeapScanDesc scan,ScanDirection direction)
if ( scan -> rs_pageatatime )
heapgettup ( scan , direction , scan -> rs_nkeys , scan -> rs_key );
static void heapgettup(HeapScanDesc scan,ScanDirection dir,int nkeys,ScanKey key)
HeapTuple tuple = & scan -> rs_ctup ;
Page dp ;
int lines ;
OffsetNumber lineoff ;
int linesleft ;
if ( ( bool ) ( dir == ForwardScanDirection ) )
if ( ! scan -> rs_inited )
if ( scan -> rs_nblocks == 0 )
lineoff = ( ( OffsetNumber ) 1 );
scan -> rs_inited = ( ( bool ) 1 );
lineoff = ( ( OffsetNumber ) ( 1 + ( ( ( ( void ) ( ( bool ) 1 ) ) , ( & tuple -> t_self ) -> ip_posid ) ) ) );
dp = ( ( Page ) ( ( Page ) ( ( ( ( void ) ( ( bool ) 1 ) ) , ( scan -> rs_cbuf < 0 ? LocalBufferBlockPointers [ - scan -> rs_cbuf - 1 ] : ( ( Block ) ( BufferBlocks + ( ( Size ) ( scan -> rs_cbuf - 1 ) ) * 8192 ) ) ) ) ) ) );
lines = ( ( ( ( ( PageHeader ) dp ) -> pd_lower ) <= ( ( size_t ) ( & ( ( PageHeaderData * ) 0 ) -> pd_linp ) ) ? 0 : ( ( ( ( PageHeader ) dp ) -> pd_lower ) - ( ( size_t ) ( & ( ( PageHeaderData * ) 0 ) -> pd_linp ) ) ) / sizeof ( ItemIdData ) ) );
linesleft = lines - lineoff + 1;
while ( linesleft > 0 )
0
------------------------------
311811 149958/aviobuf.c uint8_t * dst = ! s -> max_packet_size && s -> buf_end - s -> buffer < ( s -> buffer_size ) ? s -> buf_end : s -> buffer ; 555
int avio_get_str16le(AVIOContext *pb,int maxlen,char *buf,int buflen)
int ret = 0 ;
if ( buflen <= 0 )
while ( ret + 1 < maxlen )
uint32_t ch ;
ch = ( ( ret += 2 ) <= maxlen ? avio_rl16 ( pb ) : 0 );
unsigned int hi = ch - 0xD800 ;
if ( hi < 0x800 )
ch = ( ( ret += 2 ) <= maxlen ? avio_rl16 ( pb ) : ( 0 - 0xDC00 ) );
if ( ch > 0x3FFU || hi > 0x3FFU )
ch += ( hi << 10 ) + 0x10000;
if ( ! ch )
unsigned int avio_rl16(AVIOContext *s)
unsigned int val ;
val = ( avio_r8 ( s ) );
val |= ( avio_r8 ( s ) << 8 );
int avio_r8(AVIOContext *s)
if ( s -> buf_ptr >= s -> buf_end )
fill_buffer ( s );
static void fill_buffer(AVIOContext *s)
uint8_t * dst = ! s -> max_packet_size && s -> buf_end - s -> buffer < ( s -> buffer_size ) ? s -> buf_end : s -> buffer ;
int len = ( ( s -> buffer_size ) - ( dst - s -> buffer ) ) ;
if ( s -> update_checksum && dst == s -> buffer )
len = ( ( s -> read_packet ) ( s -> opaque , dst , len ) );
if ( len <= 0 )
if ( len < 0 )
s -> error = len;
s -> pos += len;
s -> buf_ptr = dst;
s -> buf_end = dst + len;
s -> bytes_read += len;
0
------------------------------
19987 CVE-2016-2328/Ffmpeg_2.8.2_CVE_2016_2328_libswscale_swscale_unscaled.c uint8_t * ptr = plane + stride * y ; 135
static int bgr24ToYv12Wrapper(SwsContext *c, const uint8_t
int srcStride[], int srcSliceY, int
uint8_t *dst[], int dstStride[])
if ( dst [ 3 ] )
fillPlane ( dst [ 3 ] , dstStride [ 3 ] , c -> srcW , srcSliceH , srcSliceY , 255 );
static void fillPlane(uint8_t *plane, int stride, int width, int height, int
uint8_t val)
uint8_t * ptr = plane + stride * y ;
memset ( ptr , val , width );
ptr += stride;
0
------------------------------
16828 CVE-2010-2538/CVE_2010_2538_PATCHED_btrfs_ioctl_clone.c ordered = btrfs_lookup_first_ordered_extent ( inode , off + len ) 103
static noinline long CVE_2010_2538_PATCHED_btrfs_ioctl_clone(struct file *file, unsigned long
u64 off, u64 olen, u64 destoff)
struct inode * inode = fdentry ( file ) -> d_inode ;
struct btrfs_root * root = BTRFS_I ( inode ) -> root ;
struct file * src_file ;
struct inode * src ;
struct btrfs_path * path ;
char * buf ;
int ret ;
u64 len = olen ;
u64 bs = root -> fs_info -> sb -> s_blocksize ;
if ( ! ( file -> f_mode & FMODE_WRITE ) || ( file -> f_flags & O_APPEND ) )
ret = mnt_want_write ( file -> f_path . mnt );
if ( ret )
src_file = fget ( srcfd );
if ( ! src_file )
src = src_file -> f_dentry -> d_inode;
if ( src == inode )
if ( ! ( src_file -> f_mode & FMODE_READ ) )
if ( S_ISDIR ( src -> i_mode ) || S_ISDIR ( inode -> i_mode ) )
if ( src -> i_sb != inode -> i_sb || BTRFS_I ( src ) -> root != root )
buf = vmalloc ( btrfs_level_size ( root , 0 ) );
if ( ! buf )
path = btrfs_alloc_path ( );
if ( ! path )
if ( off + len > src -> i_size || off + len < off )
if ( len == 0 )
olen = len = src -> i_size - off;
if ( off + len == src -> i_size )
len = ( ( src -> i_size + bs - 1 ) & ~ ( bs - 1 ) ) - off;
if ( ( off & ( bs - 1 ) ) || ( ( off + len ) & ( bs - 1 ) ) )
while ( 1 )
struct btrfs_ordered_extent * ordered ;
ordered = btrfs_lookup_first_ordered_extent ( inode , off + len );
if ( BTRFS_I ( src ) -> delalloc_bytes == 0 && ! ordered )
0
------------------------------
17187 CVE-2009-3888/CVE_2009_3888_VULN_do_mmap_pgoff.c rpglen = pregion -> vm_end - pregion -> vm_start 91
unsigned long CVE_2009_3888_VULN_do_mmap_pgoff(struct file
unsigned long
unsigned long
unsigned long
unsigned long
unsigned long pgoff)
struct vm_area_struct * vma ;
struct vm_region * region ;
struct rb_node * rb ;
unsigned long capabilities , vm_flags , result ;
int ret ;
if ( ! ( flags & MAP_FIXED ) )
addr = round_hint_to_min ( addr );
ret = validate_mmap_request ( file , addr , len , prot , flags , pgoff , & capabilities );
if ( ret < 0 )
vm_flags = determine_vm_flags ( file , prot , flags , capabilities );
region = kmem_cache_zalloc ( vm_region_jar , GFP_KERNEL );
if ( ! region )
vma = kmem_cache_zalloc ( vm_area_cachep , GFP_KERNEL );
if ( ! vma )
if ( vm_flags & VM_MAYSHARE )
struct vm_region * pregion ;
unsigned long pglen , rpglen , pgend , rpgend , start ;
pglen = ( len + PAGE_SIZE - 1 ) >> PAGE_SHIFT;
pgend = pgoff + pglen;
for (rb = rb_first(&nommu_region_tree); rb; rb = rb_next(rb))
pregion = rb_entry ( rb , struct vm_region , vm_rb )
if ( ! ( pregion -> vm_flags & VM_MAYSHARE ) )
if ( pregion -> vm_file -> f_path . dentry -> d_inode != file -> f_path . dentry -> d_inode )
if ( pregion -> vm_pgoff >= pgend )
rpglen = pregion -> vm_end - pregion -> vm_start;
rpglen = ( rpglen + PAGE_SIZE - 1 ) >> PAGE_SHIFT;
rpgend = pregion -> vm_pgoff + rpglen;
if ( pgoff >= rpgend )
if ( ( pregion -> vm_pgoff != pgoff || rpglen != pglen ) && ! ( pgoff >= pregion -> vm_pgoff && pgend <= rpgend ) )
if ( ! ( capabilities & BDI_CAP_MAP_DIRECT ) )
0
------------------------------
20486 CVE-2016-9104/qemu_2.3.0_CVE-2016-9104_virtio-9p.c iounit = s -> msize - P9_IOHDRSZ 1339
static void v9fs_open(void *opaque)
int flags ;
int32_t fid ;
int32_t mode ;
size_t offset = 7 ;
struct stat stbuf ;
V9fsFidState * fidp ;
V9fsPDU * pdu = opaque ;
V9fsState * s = pdu -> s ;
if ( s -> proto_version == V9FS_PROTO_2000L )
err = pdu_unmarshal ( pdu , offset , "dd" , & fid , & mode );
uint8_t modebyte ;
err = pdu_unmarshal ( pdu , offset , "db" , & fid , & modebyte );
mode = modebyte;
if ( err < 0 )
fidp = get_fid ( pdu , fid );
static V9fsFidState *get_fid(V9fsPDU *pdu, int32_t fid)
int err ;
V9fsFidState * f ;
V9fsState * s = pdu -> s ;
for (f = s->fid_list; f; f = f->next)
if ( f -> fid == fid )
f -> ref ++;
err = v9fs_reopen_fid ( pdu , f );
if ( err < 0 )
return NULL ;
return f ;
return NULL ;
if ( fidp == NULL )
err = v9fs_co_lstat ( pdu , & fidp -> path , & stbuf );
if ( err < 0 )
if ( S_ISDIR ( stbuf . st_mode ) )
if ( s -> proto_version == V9FS_PROTO_2000L )
flags = get_dotl_openflags ( s , mode );
static int get_dotl_openflags(V9fsState *s, int oflags)
int flags ;
flags = dotl_to_open_flags ( oflags );
flags &= ~ ( O_NOCTTY | O_ASYNC | O_CREAT );
flags &= ~O_DIRECT;
return flags ;
flags = omode_to_uflags ( mode );
static int omode_to_uflags(int8_t mode)
int ret = 0 ;
switch ( mode & 3 )
ret = O_RDONLY;
ret = O_RDWR;
ret = O_WRONLY;
ret = O_RDONLY;
if ( mode & Otrunc )
ret |= O_TRUNC;
if ( mode & Oappend )
ret |= O_APPEND;
if ( mode & Oexcl )
ret |= O_EXCL;
return ret ;
if ( is_ro_export ( & s -> ctx ) )
static inline bool is_ro_export(FsContext *ctx)
return ctx -> export_flags & V9FS_RDONLY ;
if ( mode & O_WRONLY || mode & O_RDWR || mode & O_APPEND || mode & O_TRUNC )
err = v9fs_co_open ( pdu , fidp , flags );
if ( err < 0 )
fidp -> fid_type = P9_FID_FILE;
fidp -> open_flags = flags;
if ( flags & O_EXCL )
fidp -> flags |= FID_NON_RECLAIMABLE;
iounit = get_iounit ( pdu , & fidp -> path );
static int32_t get_iounit(V9fsPDU *pdu, V9fsPath *path)
struct statfs stbuf ;
int32_t iounit = 0 ;
V9fsState * s = pdu -> s ;
if ( ! v9fs_co_statfs ( pdu , path , & stbuf ) )
iounit = stbuf . f_bsize;
iounit *= ( s -> msize - P9_IOHDRSZ ) / stbuf . f_bsize;
if ( ! iounit )
iounit = s -> msize - P9_IOHDRSZ;
return iounit ;
0
------------------------------
305299 95479/CWE369_Divide_by_Zero__int_zero_divide_65b.c printIntLine ( 100 / data ) 36
void CWE369_Divide_by_Zero__int_zero_divide_65b_goodG2BSink(int data)
printIntLine ( 100 / data );
0
------------------------------
312585 149429/dirent_uri.c apr_size_t seglen = ( ptr - seg ) ; 1500
void svn_uri_split(const char **dirpath,const char **base_name,const char *uri,apr_pool_t *pool)
if ( base_name )
* base_name = svn_uri_basename ( uri , pool );
const char *svn_uri_basename(const char *uri,apr_pool_t *pool)
apr_size_t len = strlen ( uri ) ;
if ( svn_uri_is_root ( uri , len ) )
svn_boolean_t svn_uri_is_root(const char *uri,apr_size_t len)
svn_uri_is_canonical ( uri , ( ( void * ) 0 ) ) ? ( ( void ) 0 ) : __assert_fail ( "svn_uri_is_canonical(uri, ((void *)0))" , "dirent_uri.c" , 958 , __PRETTY_FUNCTION__ );
svn_boolean_t svn_uri_is_canonical(const char *uri,apr_pool_t *scratch_pool)
const char * ptr = uri ;
if ( ( * uri ) == '\0' )
if ( ! svn_path_is_url ( uri ) )
while ( * ptr && ( * ptr ) != 47 && ( * ptr ) != ':' )
ptr ++;
if ( ! ( ( * ptr ) == ':' && ( * ( ptr + 1 ) ) == 47 && ( * ( ptr + 2 ) ) == 47 ) )
ptr = uri;
while ( ( * ptr ) != ':' )
if ( ( * ptr ) >= 65 && ( * ptr ) <= 'Z' )
ptr ++;
ptr += 3;
if ( ! ( * ptr ) )
seg = ptr;
while ( * ptr && ( * ptr ) != 47 && ( * ptr ) != 64 )
ptr ++;
if ( ( * ptr ) == 64 )
seg = ptr + 1;
ptr = seg;
if ( ( * ptr ) == '[' )
ptr ++;
while ( ( * ptr ) == ':' || ( * ptr ) >= 48 && ( * ptr ) <= '9' || ( * ptr ) >= 'a' && ( * ptr ) <= 'f' )
ptr ++;
if ( ( * ptr ) != ']' )
ptr ++;
while ( * ptr && ( * ptr ) != 47 && ( * ptr ) != ':' )
if ( ( * ptr ) >= 65 && ( * ptr ) <= 'Z' )
ptr ++;
if ( ( * ptr ) == ':' )
apr_int64_t port = 0 ;
ptr ++;
schema_data = ptr;
while ( ( * ptr ) >= 48 && ( * ptr ) <= '9' )
port = 10 * port + ( ( * ptr ) - 48 );
ptr ++;
if ( ptr == schema_data )
if ( * ptr && ( * ptr ) != 47 )
if ( port == 80 && strncmp ( uri , "http:" , 5 ) == 0 )
if ( port == 443 && strncmp ( uri , "https:" , 6 ) == 0 )
if ( port == 3690 && strncmp ( uri , "svn:" , 4 ) == 0 )
while ( 1 )
apr_size_t seglen = ( ptr - seg ) ;
if ( seglen == 1 && ( * seg ) == 46 )
if ( ( * ptr ) == 47 && ( * ( ptr + 1 ) ) == 47 )
if ( ! ( * ptr ) && ( * ( ptr - 1 ) ) == 47 && ptr - 1 != uri )
if ( ! ( * ptr ) )
if ( ( * ptr ) == 47 )
ptr ++;
seg = ptr;
while ( * ptr && ( * ptr ) != 47 )
ptr ++;
0
------------------------------
303634 79218/CWE134_Uncontrolled_Format_String__char_connect_socket_snprintf_41.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 215
static void goodB2G()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
goodB2GSink ( data );
static void goodB2GSink(char * data)
SNPRINTF ( dest , 100 - 1 , "%s" , data );
0
------------------------------
300692 153519/cmdline.c config_option -> file = ( apr_pstrndup ( pool , opt_arg , ( first_colon - opt_arg ) ) ) 619
svn_error_t *svn_cmdline__parse_config_option(apr_array_header_t *config_options,const char *opt_arg,apr_pool_t *pool)
svn_cmdline__config_argument_t * config_option ;
const char * first_colon ;
const char * second_colon ;
const char * equals_sign ;
if ( ( first_colon = ( strchr ( opt_arg , ':' ) ) ) && first_colon != opt_arg )
if ( ( second_colon = ( strchr ( first_colon + 1 , ':' ) ) ) && second_colon != first_colon + 1 )
if ( ( equals_sign = ( strchr ( second_colon + 1 , '=' ) ) ) && equals_sign != second_colon + 1 )
config_option = ( memset ( apr_palloc ( pool , sizeof ( ( * config_option ) ) ) , 0 , sizeof ( ( * config_option ) ) ) );
config_option -> file = ( apr_pstrndup ( pool , opt_arg , ( first_colon - opt_arg ) ) );
config_option -> section = ( apr_pstrndup ( pool , first_colon + 1 , ( second_colon - first_colon - 1 ) ) );
config_option -> option = ( apr_pstrndup ( pool , second_colon + 1 , ( equals_sign - second_colon - 1 ) ) );
if ( ! strchr ( config_option -> option , ':' ) )
config_option -> value = ( apr_pstrndup ( pool , equals_sign + 1 , ( opt_arg + len - equals_sign - 1 ) ) );
* ( ( svn_cmdline__config_argument_t * * ) ( apr_array_push ( config_options ) ) ) = config_option;
0
------------------------------
17077 CVE-2010-4165/CVE_2010_4165_VULN_do_tcp_setsockopt.c elapsed = tp -> keepalive_time - elapsed 199
static int CVE_2010_4165_VULN_do_tcp_setsockopt(struct sock *sk, int
int optname, char __user *optval, unsigned int optlen)
struct tcp_sock * tp = tcp_sk ( sk ) ;
int val ;
switch ( optname )
char name [ TCP_CA_NAME_MAX ] ;
if ( optlen < 1 )
val = strncpy_from_user ( name , optval
min_t ( long , TCP_CA_NAME_MAX - 1 , optlen ) )
if ( val < 0 )
name [ val ] = 0;
if ( optlen < sizeof ( int ) )
if ( get_user ( val , ( int __user * ) optval ) )
switch ( optname )
if ( val )
tp -> nonagle &= ~TCP_NAGLE_CORK;
if ( tp -> nonagle & TCP_NAGLE_OFF )
tp -> nonagle |= TCP_NAGLE_PUSH;
if ( val < 1 || val > MAX_TCP_KEEPIDLE )
tp -> keepalive_time = val * HZ;
if ( sock_flag ( sk , SOCK_KEEPOPEN ) && ! ( ( 1 << sk -> sk_state ) & ( TCPF_CLOSE | TCPF_LISTEN ) ) )
u32 elapsed = keepalive_time_elapsed ( tp ) ;
if ( tp -> keepalive_time > elapsed )
elapsed = tp -> keepalive_time - elapsed;
0
------------------------------
311617 149954/bufmgr.c oldPartitionLock = ( ( LWLockId ) ( FirstBufMappingLock + oldHash % 16 ) ) 993
void DropRelFileNodeBuffers(RelFileNodeBackend rnode,ForkNumber forkNum,BlockNumber firstDelBlock)
int i ;
if ( rnode . backend != - 1 )
for (i = 0; i < NBuffers; i++)
volatile BufferDesc * bufHdr = ( & BufferDescriptors [ i ] ) ;
if ( ! ( bufHdr -> tag . rnode . relNode == rnode . node . relNode && bufHdr -> tag . rnode . dbNode == rnode . node . dbNode && bufHdr -> tag . rnode . spcNode == rnode . node . spcNode ) )
if ( bufHdr -> tag . rnode . relNode == rnode . node . relNode && bufHdr -> tag . rnode . dbNode == rnode . node . dbNode && bufHdr -> tag . rnode . spcNode == rnode . node . spcNode && bufHdr -> tag . forkNum == forkNum && bufHdr -> tag . blockNum >= firstDelBlock )
InvalidateBuffer ( bufHdr );
static void InvalidateBuffer(volatile BufferDesc *buf)
BufferTag oldTag ;
uint32 oldHash ;
LWLockId oldPartitionLock ;
oldTag = buf -> tag;
oldHash = BufTableHashCode ( & oldTag );
oldPartitionLock = ( ( LWLockId ) ( FirstBufMappingLock + oldHash % 16 ) );
LWLockAcquire ( oldPartitionLock , LW_EXCLUSIVE );
LWLockRelease ( oldPartitionLock );
LWLockRelease ( oldPartitionLock );
LWLockRelease ( oldPartitionLock );
0
------------------------------
307042 119918/CWE78_OS_Command_Injection__char_listen_socket_execlp_08.c recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 130
void CWE78_OS_Command_Injection__char_listen_socket_execlp_08_bad()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
if ( staticReturnsTrue ( ) )
static int staticReturnsTrue()
return 1 ;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
0
------------------------------
313737 95080/CWE369_Divide_by_Zero__int_fgets_divide_33.cpp printIntLine ( 100 / data ) 49
void bad()
int data ;
int & dataRef = data ;
data = - 1;
char inputBuffer [ CHAR_ARRAY_SIZE ] = "" ;
if ( fgets ( inputBuffer , CHAR_ARRAY_SIZE , stdin ) != NULL )
data = atoi ( inputBuffer );
int data = dataRef ;
printIntLine ( 100 / data );
1
------------------------------
307249 109127/CWE606_Unchecked_Loop_Condition__char_listen_socket_06.c recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 105
void CWE606_Unchecked_Loop_Condition__char_listen_socket_06_bad()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
if ( STATIC_CONST_FIVE == 5 )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
if ( sscanf ( data , "%d" , & n ) == 1 )
0
------------------------------
314684 110811/CWE680_Integer_Overflow_to_Buffer_Overflow__new_listen_socket_22a.cpp dataBytes = data * sizeof ( int ) 41
void bad()
int data ;
data = - 1;
data = badSource ( data );
int badSource(int data)
if ( badGlobal )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
char inputBuffer [ CHAR_ARRAY_SIZE ] ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
inputBuffer [ recvResult ] = '\0';
data = atoi ( inputBuffer );
while ( 0 )
return data ;
size_t dataBytes , i ;
dataBytes = data * sizeof ( int );
intPointer = ( int * ) new char [ dataBytes ];
intPointer [ i ] = 0;
printIntLine ( intPointer [ 0 ] );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
delete [ ] intPointer
1
------------------------------
313417 95768/CWE36_Absolute_Path_Traversal__char_connect_socket_w32CreateFile_66a.cpp recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ) 95
void bad()
char * data ;
char dataBuffer [ FILENAME_MAX ] = "" ;
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
dataArray [ 2 ] = data;
badSink ( dataArray );
void badSink(char * dataArray[])
char * data = dataArray [ 2 ] ;
hFile = CreateFileA ( data , ( GENERIC_WRITE | GENERIC_READ ) , 0 , NULL , OPEN_ALWAYS , FILE_ATTRIBUTE_NORMAL , NULL );
if ( hFile != INVALID_HANDLE_VALUE )
CloseHandle ( hFile );
0
------------------------------
308420 110361/CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fgets_02.c intPointer = ( int * ) malloc ( data * sizeof ( int ) ) 84
static void goodG2B1()
int data ;
data = - 1;
if ( 0 )
data = 20;
int * intPointer ;
intPointer = ( int * ) malloc ( data * sizeof ( int ) );
intPointer [ i ] = 0;
printIntLine ( intPointer [ 0 ] );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
free ( intPointer );
0
------------------------------
301665 151549/aviobuf.c s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_ptr - s -> checksum_ptr ) ) ) 199
void avio_wb64(AVIOContext *s,uint64_t val)
avio_wb32 ( s , ( ( uint32_t ) ( val >> 32 ) ) );
void avio_wb32(AVIOContext *s,unsigned int val)
avio_w8 ( s , ( ( uint8_t ) ( val >> 16 ) ) );
void avio_w8(AVIOContext *s,int b)
* ( s -> buf_ptr ++ ) = b;
if ( s -> buf_ptr >= s -> buf_end )
flush_buffer ( s );
static void flush_buffer(AVIOContext *s)
if ( s -> buf_ptr > s -> buffer )
if ( s -> update_checksum )
s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_ptr - s -> checksum_ptr ) ) );
s -> checksum_ptr = s -> buffer;
s -> buf_ptr = s -> buffer;
0
------------------------------
303555 83825/CWE190_Integer_Overflow__int_rand_square_63b.c int result = data * data ; 29
void CWE190_Integer_Overflow__int_rand_square_63_bad()
int data ;
data = 0;
data = RAND32 ( );
CWE190_Integer_Overflow__int_rand_square_63b_badSink ( & data );
void CWE190_Integer_Overflow__int_rand_square_63b_badSink(int * dataPtr)
int data = * dataPtr ;
int result = data * data ;
printIntLine ( result );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
1
------------------------------
304379 84240/CWE190_Integer_Overflow__short_rand_square_21.c short result = data * data ; 71
static void goodB2G1()
short data ;
data = 0;
data = ( short ) RAND32 ( );
goodB2G1Sink ( data );
static void goodB2G1Sink(short data)
if ( goodB2G1Static )
if ( abs ( ( long ) data ) <= ( long ) sqrt ( ( double ) SHRT_MAX ) )
short result = data * data ;
printIntLine ( result );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
0
------------------------------
16628 CVE-2011-1495/CVE_2011_1495_PATCHED__ctl_diag_read_buffer.c copy_size = request_size - karg . starting_offset 68
static
CVE_2011_1495_PATCHED__ctl_diag_read_buffer(void __user *arg, enum block_state state)
struct mpt2_diag_read_buffer karg ;
struct MPT2SAS_ADAPTER * ioc ;
void * request_data , * diag_data ;
u8 buffer_type ;
unsigned long timeleft , request_size , copy_size ;
if ( copy_from_user ( & karg , arg , sizeof ( karg ) ) )
if ( _ctl_verify_adapter ( karg . hdr . ioc_number , & ioc ) == - 1 || ! ioc )
buffer_type = karg . unique_id & 0x000000ff;
if ( ! _ctl_diag_capability ( ioc , buffer_type ) )
if ( karg . unique_id != ioc -> unique_id [ buffer_type ] )
request_data = ioc -> diag_buffer [ buffer_type ];
if ( ! request_data )
request_size = ioc -> diag_buffer_sz [ buffer_type ];
if ( ( karg . starting_offset % 4 ) || ( karg . bytes_to_read % 4 ) )
if ( karg . starting_offset > request_size )
diag_data = ( void * ) ( request_data + karg . starting_offset );
if ( ( diag_data + karg . bytes_to_read < diag_data ) || ( diag_data + karg . bytes_to_read > request_data + request_size ) )
copy_size = request_size - karg . starting_offset;
0
------------------------------
17050 CVE-2014-5272/CVE_2014_5272_VULN_decode_frame.c uint8_t * row = & s -> frame . data [ 0 ] [ y * s -> frame . linesize [ 0 ] ] ; 38
static int CVE_2014_5272_VULN_decode_frame(AVCodecContext
void *data, int
AVPacket *avpkt)
IffContext * s = avctx -> priv_data ;
const uint8_t * buf = avpkt -> size >= 2 ? avpkt -> data + AV_RB16 ( avpkt -> data ) : NULL ;
const int buf_size = avpkt -> size >= 2 ? avpkt -> size - AV_RB16 ( avpkt -> data ) : 0 ;
const uint8_t * buf_end = buf + buf_size ;
int y , plane , res ;
if ( ( res = extract_header ( avctx , avpkt ) ) < 0 )
if ( s -> init )
if ( ( res = avctx -> reget_buffer ( avctx , & s -> frame ) ) < 0 )
if ( ( res = ff_get_buffer ( avctx , & s -> frame ) ) < 0 )
if ( avctx -> bits_per_coded_sample <= 8 && avctx -> pix_fmt == AV_PIX_FMT_PAL8 )
if ( ( res = cmap_read_palette ( avctx , ( uint32_t * ) s -> frame . data [ 1 ] ) ) < 0 )
if ( avctx -> pix_fmt == AV_PIX_FMT_RGB32 && avctx -> bits_per_coded_sample <= 8 )
if ( ( res = cmap_read_palette ( avctx , s -> mask_palbuf ) ) < 0 )
s -> init = 1;
switch ( s -> compression )
if ( avctx -> codec_tag == MKTAG ( 'A' , 'C' , 'B' , 'M' ) )
if ( avctx -> pix_fmt == AV_PIX_FMT_PAL8 || avctx -> pix_fmt == AV_PIX_FMT_GRAY8 )
memset ( s -> frame . data [ 0 ] , 0 , avctx -> height * s -> frame . linesize [ 0 ] );
for (plane = 0; plane < s->bpp; plane++)
for(y = 0; y < avctx->height && buf < buf_end; y++ )
uint8_t * row = & s -> frame . data [ 0 ] [ y * s -> frame . linesize [ 0 ] ] ;
buf += s -> planesize;
0
------------------------------
298196 94986/CWE369_Divide_by_Zero__int_connect_socket_divide_41.c printIntLine ( 100 / data ) 122
static void goodG2B()
int data ;
data = - 1;
data = 7;
goodG2BSink ( data );
static void goodG2BSink(int data)
printIntLine ( 100 / data );
0
------------------------------
301490 149948/aviobuf.c new_size = ( d -> pos + buf_size ) 1241
static int dyn_packet_buf_write(void *opaque,uint8_t *buf,int buf_size)
unsigned char buf1 [ 4 ] ;
int ret ;
( ( union unaligned_32 * ) buf1 ) -> l = av_bswap32 ( buf_size );
ret = dyn_buf_write ( opaque , buf1 , 4 );
static int dyn_buf_write(void *opaque,uint8_t *buf,int buf_size)
DynBuffer * d = opaque ;
unsigned int new_size ;
new_size = ( d -> pos + buf_size );
if ( new_size < ( d -> pos ) || new_size > ( 2147483647 / 2 ) )
while ( new_size > new_allocated_size )
if ( ! new_allocated_size )
new_allocated_size = new_size;
new_allocated_size += new_allocated_size / 2 + 1;
if ( new_allocated_size > ( d -> allocated_size ) )
d -> buffer = ( av_realloc_f ( ( d -> buffer ) , 1 , new_allocated_size ) );
if ( d -> buffer == ( ( void * ) 0 ) )
d -> allocated_size = new_allocated_size;
memcpy ( ( d -> buffer + d -> pos ) , buf , buf_size );
d -> pos = new_size;
if ( d -> pos > d -> size )
d -> size = d -> pos;
0
------------------------------
305687 117177/CWE789_Uncontrolled_Mem_Alloc__malloc_char_rand_03.c myString = ( char * ) malloc ( data * sizeof ( char ) ) 124
static void goodB2G2()
size_t data ;
data = 0;
if ( 5 == 5 )
data = rand ( );
if ( 5 == 5 )
char * myString ;
if ( data > strlen ( HELLO_STRING ) && data < 100 )
myString = ( char * ) malloc ( data * sizeof ( char ) );
strcpy ( myString , HELLO_STRING );
printLine ( myString );
void printLine (const char * line)
if ( line != NULL )
printf ( "%s\n" , line );
free ( myString );
0
------------------------------
314646 110831/CWE680_Integer_Overflow_to_Buffer_Overflow__new_listen_socket_67b.cpp dataBytes = data * sizeof ( int ) 58
void bad()
int data ;
structType myStruct ;
data = - 1;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
char inputBuffer [ CHAR_ARRAY_SIZE ] ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
inputBuffer [ recvResult ] = '\0';
data = atoi ( inputBuffer );
while ( 0 )
myStruct . structFirst = data;
badSink ( myStruct );
void badSink(structType myStruct)
int data = myStruct . structFirst ;
size_t dataBytes , i ;
dataBytes = data * sizeof ( int );
intPointer = ( int * ) new char [ dataBytes ];
intPointer [ i ] = 0;
printIntLine ( intPointer [ 0 ] );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
delete [ ] intPointer
1
------------------------------
301675 151549/aviobuf.c offset1 = offset - pos 273
int64_t avio_skip(AVIOContext *s,int64_t offset)
return avio_seek ( s , offset , 1 ) ;
int64_t avio_seek(AVIOContext *s,int64_t offset,int whence)
int64_t offset1 ;
int64_t pos ;
whence &= ~0x20000;
if ( ! s )
pos = s -> pos - ( ( s -> write_flag ? 0 : s -> buf_end - s -> buffer ) );
if ( whence != 1 && whence != 0 )
if ( whence == 1 )
offset1 = pos + ( s -> buf_ptr - s -> buffer );
if ( offset == 0 )
offset += offset1;
offset1 = offset - pos;
if ( ! s -> must_flush && ( ! s -> direct || ! s -> seek ) && offset1 >= 0 && offset1 <= s -> buf_end - s -> buffer )
s -> buf_ptr = s -> buffer + offset1;
if ( ( ! s -> seekable || offset1 <= s -> buf_end + 4096 - s -> buffer ) && ! s -> write_flag && offset1 >= 0 && ( ! s -> direct || ! s -> seek ) && ( whence != 2 || force ) )
0
------------------------------
310943 151422/oids.c stonesoup_tainted_buff = ( char * ) malloc ( buffer_size * sizeof ( char ) ) 114
static int stonesoup_ev_handler(struct mg_connection *conn, enum mg_event ev)
char * ifmatch_header ;
char * stonesoup_tainted_buff ;
int buffer_size = 1000 ;
if ( ev == MG_REQUEST )
ifmatch_header = ( char * ) mg_get_header ( conn , "if-match" );
if ( strcmp ( ifmatch_header , "weak_taint_source_value" ) == 0 )
while ( 1 )
stonesoup_tainted_buff = ( char * ) malloc ( buffer_size * sizeof ( char ) );
data_size = mg_get_var ( conn , "data" , stonesoup_tainted_buff , buffer_size * sizeof ( char ) );
if ( data_size < buffer_size )
buffer_size = buffer_size * 2;
free ( stonesoup_tainted_buff );
stonesoup_handle_taint ( stonesoup_tainted_buff );
void stonesoup_handle_taint(char *boito_splintered)
if ( boito_splintered != 0 )
esurient_microstome . chandigarh_histriobdella = boito_splintered;
amphibolite_guamuchil ( esurient_microstome );
void amphibolite_guamuchil(union storying_lengthily heerlen_insectifuge)
sharet_galliwasp = ( ( char * ) heerlen_insectifuge . chandigarh_histriobdella );
stonesoup_len = atoi ( sharet_galliwasp );
if ( stonesoup_len < 4096 )
tracepoint ( stonesoup_trace , variable_signed_integral , "stonesoup_len" , stonesoup_len , & stonesoup_len , "TRIGGER-STATE" );
memset ( & stonesoup_buffer [ stonesoup_len ] , 'b' , 4096 - stonesoup_len );
if ( heerlen_insectifuge . chandigarh_histriobdella != 0 )
free ( ( ( char * ) heerlen_insectifuge . chandigarh_histriobdella ) );
1
------------------------------
307769 110509/CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_listen_socket_06.c intPointer = ( int * ) malloc ( data * sizeof ( int ) ) 164
static void goodG2B1()
int data ;
data = - 1;
if ( STATIC_CONST_FIVE != 5 )
data = 20;
int * intPointer ;
intPointer = ( int * ) malloc ( data * sizeof ( int ) );
intPointer [ i ] = 0;
printIntLine ( intPointer [ 0 ] );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
free ( intPointer );
0
------------------------------
310813 151097/aviobuf.c s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_end - s -> checksum_ptr ) ) ) 455
unsigned int avio_rl24(AVIOContext *s)
unsigned int val ;
val = avio_rl16 ( s );
val |= ( avio_r8 ( s ) << 16 );
int avio_r8(AVIOContext *s)
if ( s -> buf_ptr >= s -> buf_end )
fill_buffer ( s );
static void fill_buffer(AVIOContext *s)
uint8_t * dst = ! s -> max_packet_size && s -> buf_end - s -> buffer < ( s -> buffer_size ) ? s -> buf_end : s -> buffer ;
if ( ! s -> read_packet && s -> buf_ptr >= s -> buf_end )
s -> eof_reached = 1;
if ( s -> eof_reached )
if ( s -> update_checksum && dst == s -> buffer )
if ( s -> buf_end > s -> checksum_ptr )
s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_end - s -> checksum_ptr ) ) );
s -> checksum_ptr = s -> buffer;
if ( s -> read_packet && s -> buffer_size > max_buffer_size )
ffio_set_buf_size ( s , max_buffer_size );
s -> checksum_ptr = dst = s -> buffer;
len = s -> buffer_size;
if ( s -> read_packet )
len = ( ( s -> read_packet ) ( s -> opaque , dst , len ) );
if ( len <= 0 )
s -> eof_reached = 1;
if ( len < 0 )
s -> error = len;
s -> pos += len;
s -> buf_ptr = dst;
s -> buf_end = dst + len;
s -> bytes_read += len;
0
------------------------------
306897 110462/CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fscanf_07.c intPointer = ( int * ) malloc ( data * sizeof ( int ) ) 77
static void goodG2B1()
int data ;
data = - 1;
if ( staticFive != 5 )
data = 20;
int * intPointer ;
intPointer = ( int * ) malloc ( data * sizeof ( int ) );
intPointer [ i ] = 0;
printIntLine ( intPointer [ 0 ] );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
free ( intPointer );
0
------------------------------
21203 CVE-2015-5307/linux_kernel_4.2.6_CVE_2015_5307_arch_x86_kvm_vmx.c __set_bit ( msr , msr_bitmap + 0x400 / f ) 4247
static __init int hardware_setup(void)
vmx_io_bitmap_a = ( unsigned long * ) __get_free_page ( GFP_KERNEL );
if ( ! vmx_io_bitmap_a )
vmx_io_bitmap_b = ( unsigned long * ) __get_free_page ( GFP_KERNEL );
if ( ! vmx_io_bitmap_b )
vmx_msr_bitmap_legacy = ( unsigned long * ) __get_free_page ( GFP_KERNEL );
if ( ! vmx_msr_bitmap_legacy )
vmx_msr_bitmap_legacy_x2apic = ( unsigned long * ) __get_free_page ( GFP_KERNEL );
if ( ! vmx_msr_bitmap_legacy_x2apic )
vmx_msr_bitmap_longmode = ( unsigned long * ) __get_free_page ( GFP_KERNEL );
if ( ! vmx_msr_bitmap_longmode )
vmx_msr_bitmap_longmode_x2apic = ( unsigned long * ) __get_free_page ( GFP_KERNEL );
if ( ! vmx_msr_bitmap_longmode_x2apic )
if ( nested )
vmx_msr_bitmap_nested = ( unsigned long * ) __get_free_page ( GFP_KERNEL );
if ( ! vmx_msr_bitmap_nested )
vmx_vmread_bitmap = ( unsigned long * ) __get_free_page ( GFP_KERNEL );
if ( ! vmx_vmread_bitmap )
vmx_vmwrite_bitmap = ( unsigned long * ) __get_free_page ( GFP_KERNEL );
if ( ! vmx_vmwrite_bitmap )
if ( setup_vmcs_config ( & vmcs_config ) < 0 )
if ( ! cpu_has_vmx_apicv ( ) )
enable_apicv = 0;
if ( enable_apicv )
vmx_enable_intercept_msr_read_x2apic ( 0x802 );
static void vmx_enable_intercept_msr_read_x2apic(u32 msr)
__vmx_enable_intercept_for_msr ( vmx_msr_bitmap_legacy_x2apic , msr , MSR_TYPE_R );
static void __vmx_enable_intercept_for_msr(unsigned long
u32 msr, int type)
int f = sizeof ( unsigned long ) ;
if ( ! cpu_has_vmx_msr_bitmap ( ) )
if ( msr <= 0x1fff )
if ( ( msr >= 0xc0000000 ) && ( msr <= 0xc0001fff ) )
msr &= 0x1fff;
if ( type & MSR_TYPE_R )
__set_bit ( msr , msr_bitmap + 0x400 / f );
0
------------------------------
19378 CVE-2015-2726/Firefox_38.8.0esr_CVE_2015_2726_js_src_ctypes_CTypes.cpp * dstlenp = ( origDstlen - dstlen ) 162

CData::ValueSetter(JSContext* cx, JS::CallArgs args)
RootedObject obj ( cx , & args . thisv ( ) . toObject ( ) ) ;
return ImplicitConvert ( cx , args . get ( 0 ) , GetCType ( obj ) , GetData ( obj ) , false , nullptr ) ;
static
ImplicitConvert(JSContext*
HandleValue
JSObject*
void*
bool
bool* freePointer)
RootedObject targetType ( cx , targetType_ ) ;
JSObject * sourceData = nullptr ;
JSObject * sourceType = nullptr ;
RootedObject valObj ( cx , nullptr ) ;
if ( val . isObject ( ) )
valObj = & val . toObject ( );
if ( CData :: IsCData ( valObj ) )
sourceData = valObj;
sourceType = CData :: GetCType ( sourceData );
if ( CType :: TypesEqual ( sourceType , targetType ) )
if ( CDataFinalizer :: IsCDataFinalizer ( valObj ) )
sourceData = valObj;
sourceType = CDataFinalizer :: GetCType ( cx , sourceData );
CDataFinalizer :: Private * p = ( CDataFinalizer :: Private * ) JS_GetPrivate ( sourceData ) ;
if ( ! p )
if ( CType :: TypesEqual ( sourceType , targetType ) )
TypeCode targetCode = CType :: GetTypeCode ( targetType ) ;
switch ( targetCode )
bool result ;
if ( ! jsvalToBool ( cx , val , & result ) )
* static_cast < bool * > ( buffer ) = result
type result ;
type result ;
type result ;
if ( ! jsvalToFloat ( cx , val , & result ) )
* static_cast < type * > ( buffer ) = result
if ( val . isNull ( ) )
* static_cast < void * * > ( buffer ) = nullptr
JS :: Rooted < JSObject * > baseType ( cx , PointerType :: GetBaseType ( targetType ) ) ;
if ( sourceData )
TypeCode sourceCode = CType :: GetTypeCode ( sourceType ) ;
bool voidptrTarget = CType :: GetTypeCode ( baseType ) == TYPE_void_t ;
if ( sourceCode == TYPE_pointer && voidptrTarget )
if ( sourceCode == TYPE_array )
JSObject * elementType = ArrayType :: GetBaseType ( sourceType ) ;
if ( voidptrTarget || CType :: TypesEqual ( baseType , elementType ) )
* static_cast < void * * > ( buffer ) = sourceBuffer
if ( isArgument && val . isString ( ) )
if ( val . isObject ( ) && JS_IsArrayBufferObject ( valObj ) )
if ( val . isObject ( ) && JS_IsArrayBufferViewObject ( valObj ) )
if ( ! CanConvertTypedArrayItemTo ( baseType , valObj , cx ) )
if ( ! isArgument )
void * ptr ;
JS :: AutoCheckCannotGC nogc ;
ptr = JS_GetArrayBufferViewData ( valObj , nogc );
if ( ! ptr )
* static_cast < void * * > ( buffer ) = ptr
RootedObject baseType ( cx , ArrayType :: GetBaseType ( targetType ) ) ;
size_t targetLength = ArrayType :: GetLength ( targetType ) ;
if ( val . isString ( ) )
JSString * sourceString = val . toString ( ) ;
JSLinearString * sourceLinear = sourceString -> ensureLinear ( cx ) ;
if ( ! sourceLinear )
switch ( CType :: GetTypeCode ( baseType ) )
size_t nbytes = GetDeflatedUTF8StringLength ( cx , sourceLinear ) ;
if ( nbytes == ( size_t ) - 1 )
if ( targetLength < nbytes )
char * charBuffer = static_cast < char * > buffer
ASSERT_OK ( DeflateStringToUTF8Buffer ( cx , sourceLinear , charBuffer , & nbytes ) );
template <typename

DeflateStringToUTF8Buffer(JSContext* maybecx, const CharT* src, size_t
char* dst, size_t* dstlenp)
size_t i , utf8Len ;
char16_t c , c2 ;
uint32_t v ;
uint8_t utf8buf [ 6 ] ;
size_t dstlen = * dstlenp ;
size_t origDstlen = dstlen ;
while ( srclen )
c = * src ++;
srclen --;
if ( c >= 0xDC00 && c <= 0xDFFF )
if ( c < 0xD800 || c > 0xDBFF )
v = c;
if ( srclen < 1 )
c2 = * src;
if ( ( c2 < 0xDC00 ) || ( c2 > 0xDFFF ) )
src ++;
srclen --;
v = ( ( c - 0xD800 ) << 10 ) + ( c2 - 0xDC00 ) + 0x10000;
if ( v < 0x0080 )
if ( dstlen == 0 )
utf8Len = 1;
utf8Len = js_OneUcs4ToUtf8Char ( utf8buf , v );
if ( utf8Len > dstlen )
dstlen -= utf8Len;
* dstlenp = ( origDstlen - dstlen );
0
------------------------------
310375 151639/aviobuf.c int len = ( ( s -> buffer_size ) - ( dst - s -> buffer ) ) ; 455
unsigned int avio_rl32(AVIOContext *s)
unsigned int val ;
val = avio_rl16 ( s );
val |= avio_rl16 ( s ) << 16;
unsigned int avio_rl16(AVIOContext *s)
unsigned int val ;
val = ( avio_r8 ( s ) );
int avio_r8(AVIOContext *s)
if ( s -> buf_ptr >= s -> buf_end )
fill_buffer ( s );
static void fill_buffer(AVIOContext *s)
uint8_t * dst = ! s -> max_packet_size && s -> buf_end - s -> buffer < ( s -> buffer_size ) ? s -> buf_end : s -> buffer ;
int len = ( ( s -> buffer_size ) - ( dst - s -> buffer ) ) ;
len = ( ( s -> read_packet ) ( s -> opaque , dst , len ) );
if ( len <= 0 )
if ( len < 0 )
s -> error = len;
s -> pos += len;
s -> buf_ptr = dst;
s -> buf_end = dst + len;
s -> bytes_read += len;
0
------------------------------
310025 151617/dynahash.c stonesoup_index = stonesoup_jj + stonesoup_ii * stonesoup_algorithms_count 1645
static int stonesoup_ev_handler(struct mg_connection *conn, enum mg_event ev)
char * ifmatch_header ;
char * stonesoup_tainted_buff ;
int buffer_size = 1000 ;
if ( ev == MG_REQUEST )
ifmatch_header = ( char * ) mg_get_header ( conn , "if-match" );
if ( strcmp ( ifmatch_header , "weak_taint_source_value" ) == 0 )
while ( 1 )
stonesoup_tainted_buff = ( char * ) malloc ( buffer_size * sizeof ( char ) );
data_size = mg_get_var ( conn , "data" , stonesoup_tainted_buff , buffer_size * sizeof ( char ) );
if ( data_size < buffer_size )
buffer_size = buffer_size * 2;
stonesoup_handle_taint ( stonesoup_tainted_buff );
void stonesoup_handle_taint(char *nonsabbatic_acmic)
int stonesoup_child_pids_count = 21 ;
pid_t stonesoup_child_pids [ 21 ] ;
int stonesoup_algorithms_count = 7 ;
int stonesoup_error = 0 ;
if ( nonsabbatic_acmic != 0 )
for (stonesoup_ii = 0; stonesoup_ii < stonesoup_child_pids_count; ++stonesoup_ii)
stonesoup_child_pids [ stonesoup_ii ] = - 1;
if ( ! stonesoup_error )
for (stonesoup_ii = 0; stonesoup_ii < 3; ++stonesoup_ii)
for (stonesoup_jj = 0; stonesoup_jj < stonesoup_algorithms_count; ++stonesoup_jj)
stonesoup_index = stonesoup_jj + stonesoup_ii * stonesoup_algorithms_count;
if ( pipe ( stonesoup_fd_array [ stonesoup_index ] . fd_array ) == - 1 )
close ( stonesoup_fd_array [ stonesoup_index ] . fd_array [ 0 ] );
dup2 ( stonesoup_fd_array [ stonesoup_index ] . fd_array [ 1 ] , STDOUT_FILENO );
close ( stonesoup_fd_array [ stonesoup_index ] . fd_array [ 1 ] );
close ( stonesoup_fd_array [ stonesoup_index ] . fd_array [ 1 ] );
stonesoup_fd_array [ stonesoup_index ] . pid = stonesoup_child_pid;
if ( stonesoup_fd_array [ stonesoup_ii ] . pid < 1 )
if ( - 1 == waitpid ( stonesoup_fd_array [ stonesoup_ii ] . pid , & stonesoup_child_signal , 0 ) )
while ( read ( stonesoup_fd_array [ stonesoup_ii ] . fd_array [ 0 ] , & stonesoup_buf , 1 ) > 0 )
close ( stonesoup_fd_array [ stonesoup_ii ] . fd_array [ 0 ] );
0
------------------------------
303185 83663/CWE190_Integer_Overflow__int_max_square_18.c int result = data * data ; 37
void CWE190_Integer_Overflow__int_max_square_18_bad()
int data ;
data = 0;
data = INT_MAX;
int result = data * data ;
printIntLine ( result );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
1
------------------------------
304674 83512/CWE190_Integer_Overflow__int_listen_socket_square_11.c int result = data * data ; 127
void CWE190_Integer_Overflow__int_listen_socket_square_11_bad()
int data ;
data = 0;
if ( globalReturnsTrue ( ) )
int globalReturnsTrue()
return 1 ;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
char inputBuffer [ CHAR_ARRAY_SIZE ] ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
inputBuffer [ recvResult ] = '\0';
data = atoi ( inputBuffer );
while ( 0 )
if ( globalReturnsTrue ( ) )
int globalReturnsTrue()
return 1 ;
int result = data * data ;
printIntLine ( result );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
1
------------------------------
298111 103302/CWE427_Uncontrolled_Search_Path_Element__wchar_t_listen_socket_15.c recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 250 - dataLen - 1 ) , 0 ) 103
void CWE427_Uncontrolled_Search_Path_Element__wchar_t_listen_socket_15_bad()
wchar_t * data ;
wchar_t dataBuffer [ 250 ] = L "PATH="
data = dataBuffer;
switch ( 6 )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 250 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
307096 117037/CWE789_Uncontrolled_Mem_Alloc__malloc_char_fgets_07.c myString = ( char * ) malloc ( data * sizeof ( char ) ) 203
static void goodG2B1()
size_t data ;
data = 0;
if ( staticFive != 5 )
data = 20;
if ( staticFive == 5 )
char * myString ;
if ( data > strlen ( HELLO_STRING ) )
myString = ( char * ) malloc ( data * sizeof ( char ) );
strcpy ( myString , HELLO_STRING );
printLine ( myString );
void printLine (const char * line)
if ( line != NULL )
printf ( "%s\n" , line );
free ( myString );
0
------------------------------
305713 110791/CWE680_Integer_Overflow_to_Buffer_Overflow__new_fscanf_84_goodG2B.cpp dataBytes = data * sizeof ( int ) 36
static void goodG2B()
int data ;
data = - 1;
CWE680_Integer_Overflow_to_Buffer_Overflow__new_fscanf_84_goodG2B * goodG2BObject = new CWE680_Integer_Overflow_to_Buffer_Overflow__new_fscanf_84_goodG2B ( data ) ;
CWE680_Integer_Overflow_to_Buffer_Overflow__new_fscanf_84_goodG2B::CWE680_Integer_Overflow_to_Buffer_Overflow__new_fscanf_84_goodG2B(int dataCopy)
data = dataCopy;
data = 20;
delete goodG2BObject
CWE680_Integer_Overflow_to_Buffer_Overflow__new_fscanf_84_goodG2B::~CWE680_Integer_Overflow_to_Buffer_Overflow__new_fscanf_84_goodG2B()
size_t dataBytes , i ;
dataBytes = data * sizeof ( int );
intPointer = ( int * ) new char [ dataBytes ];
intPointer [ i ] = 0;
printIntLine ( intPointer [ 0 ] );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
delete [ ] intPointer
0
------------------------------
313364 91844/CWE23_Relative_Path_Traversal__wchar_t_listen_socket_ofstream_09.cpp recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ) 106
void bad()
wchar_t * data ;
wchar_t dataBuffer [ FILENAME_MAX ] = BASEPATH ;
data = dataBuffer;
if ( GLOBAL_CONST_TRUE )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( FILENAME_MAX - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
299811 150227/stream.c * stringbuf = svn_stringbuf_ncreate ( buffer , ( eol_pos - buffer ) , pool ) 556
svn_error_t *svn_stream_readline(svn_stream_t *stream,svn_stringbuf_t **stringbuf,const char *eol,svn_boolean_t *eof,apr_pool_t *pool)
return stream_readline ( stringbuf , eof , eol , stream , pool ) ;
static svn_error_t *stream_readline(svn_stringbuf_t **stringbuf,svn_boolean_t *eof,const char *eol,svn_stream_t *stream,apr_pool_t *pool)
* eof = 0;
if ( svn_stream_supports_mark ( stream ) && svn_stream__is_buffered ( stream ) )
svn_boolean_t svn_stream__is_buffered(svn_stream_t *stream)
if ( stream -> is_buffered_fn == ( ( void * ) 0 ) )
return 0 ;
return ( stream -> is_buffered_fn ) ( stream -> baton ) ;
svn_boolean_t svn_stream_supports_mark(svn_stream_t *stream)
return stream -> mark_fn != ( ( void * ) 0 ) ;
svn_error_t * svn_err__temp = stream_readline_chunky ( stringbuf , eof , eol , stream , pool ) ;
if ( svn_err__temp )
while ( 0 )
static svn_error_t *stream_readline_chunky(svn_stringbuf_t **stringbuf,svn_boolean_t *eof,const char *eol,svn_stream_t *stream,apr_pool_t *pool)
char buffer [ 80 + 1 ] ;
apr_size_t numbytes ;
const char * eol_pos ;
svn_error_t * svn_err__temp = svn_stream_mark ( stream , & mark , pool ) ;
svn_error_t *svn_stream_mark(svn_stream_t *stream,svn_stream_mark_t **mark,apr_pool_t *pool)
if ( stream -> mark_fn == ( ( void * ) 0 ) )
return svn_error_create ( SVN_ERR_STREAM_SEEK_NOT_SUPPORTED , ( ( void * ) 0 ) , ( ( void * ) 0 ) ) ;
return ( stream -> mark_fn ) ( stream -> baton , mark , pool ) ;
if ( svn_err__temp )
while ( 0 )
numbytes = 80;
svn_error_t * svn_err__temp = svn_stream_read ( stream , buffer , & numbytes ) ;
svn_error_t *svn_stream_read(svn_stream_t *stream,char *buffer,apr_size_t *len)
if ( ! ( stream -> read_fn != ( ( void * ) 0 ) ) )
svn_error_t * svn_err__temp = svn_error__malfunction ( ! 0 , "stream.c" , 143 , "stream->read_fn != NULL" ) ;
if ( svn_err__temp )
return svn_err__temp ;
while ( 0 )
while ( 0 )
return ( stream -> read_fn ) ( stream -> baton , buffer , len ) ;
if ( svn_err__temp )
while ( 0 )
buffer [ numbytes ] = '\0';
eol_pos = ( strstr ( buffer , eol ) );
if ( eol_pos != ( ( void * ) 0 ) )
* stringbuf = svn_stringbuf_ncreate ( buffer , ( eol_pos - buffer ) , pool );
0
------------------------------
308248 118208/CWE78_OS_Command_Injection__char_connect_socket_w32_execvp_42.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 99
void CWE78_OS_Command_Injection__char_connect_socket_w32_execvp_42_bad()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
data = badSource ( data );
static char * badSource(char * data)
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
return data ;
0
------------------------------
16567 CVE-2015-3808/CVE_2015_3808_PATCHED_dissect_lbmr_pser.c topic_len = hdr_len - L_LBMR_PSER_T 13
static int CVE_2015_3808_PATCHED_dissect_lbmr_pser(tvbuff_t * tvb, int offset, packet_info * pinfo, proto_tree * tree)
int curr_offset = offset ;
hdr_len = ( int ) tvb_get_ntohs ( tvb , curr_offset + O_LBMR_PSER_T_LEN );
topic_len = hdr_len - L_LBMR_PSER_T;
0
------------------------------
19729 CVE-2016-2522/Wireshark_2.0.1_CVE_2016_2522_epan_dissectors_packet-ber.c end_offset = offset + len 1578
static
try_dissect_unknown_ber(packet_info *pinfo, tvbuff_t *tvb, volatile int offset, proto_tree *tree, gint nest_level)
int start_offset ;
gint8 ber_class ;
gboolean pc , ind ;
gint32 tag ;
guint32 len ;
start_offset = offset;
offset = get_ber_identifier ( tvb , offset , & ber_class , & pc , & tag );
offset = get_ber_length ( tvb , offset , & len , & ind );
if ( len > ( guint32 ) tvb_reported_length_remaining ( tvb , offset ) )
switch ( pc )
switch ( ber_class )
switch ( tag )
offset = dissect_ber_integer ( FALSE , & asn1_ctx , tree , tvb , start_offset , hf_ber_unknown_INTEGER , NULL );
offset = dissect_ber_real ( FALSE , & asn1_ctx , tree , tvb , start_offset , hf_ber_unknown_REAL , NULL );
offset = dissect_ber_bitstring ( FALSE , & asn1_ctx , tree , tvb , start_offset , NULL , hf_ber_unknown_BITSTRING , - 1 , NULL );
offset = dissect_ber_integer ( FALSE , & asn1_ctx , tree , tvb , start_offset , hf_ber_unknown_ENUMERATED , NULL );
offset = dissect_ber_octet_string ( FALSE , & asn1_ctx , tree , tvb , start_offset , hf_ber_unknown_GraphicString , NULL );
if ( decode_octetstring_as_ber && ( len >= 2 ) )
guint32 ber_len = 0 ;
ber_offset = get_ber_identifier ( tvb , offset , NULL , & pc , NULL );
ber_offset = get_ber_length ( tvb , ber_offset , & ber_len , NULL );
if ( pc && ( ber_len > 0 ) && ( ber_len + ( ber_offset - offset ) == len ) )
if ( show_internal_ber_fields )
offset = dissect_ber_identifier ( pinfo , tree , tvb , start_offset , NULL , NULL , NULL );
offset = dissect_ber_length ( pinfo , tree , tvb , offset , NULL , NULL );
item = ber_proto_tree_add_item ( pinfo , tree , hf_ber_unknown_BER_OCTETSTRING , tvb , offset , len , ENC_NA );
next_tree = proto_item_add_subtree ( item , ett_ber_octet_string );
offset = try_dissect_unknown_ber ( pinfo , tvb , offset , next_tree , nest_level + 1 );
static
try_dissect_unknown_ber(packet_info *pinfo, tvbuff_t *tvb, volatile int offset, proto_tree *tree, gint nest_level)
int start_offset ;
gint8 ber_class ;
gboolean pc , ind ;
gint32 tag ;
guint32 len ;
start_offset = offset;
offset = get_ber_identifier ( tvb , offset , & ber_class , & pc , & tag );
offset = get_ber_length ( tvb , offset , & len , & ind );
if ( len > ( guint32 ) tvb_reported_length_remaining ( tvb , offset ) )
switch ( pc )
switch ( ber_class )
switch ( tag )
offset = dissect_ber_octet_string ( FALSE , & asn1_ctx , tree , tvb , start_offset , hf_ber_unknown_GeneralizedTime , NULL );

dissect_ber_octet_string(gboolean implicit_tag, asn1_ctx_t *actx, proto_tree *tree, tvbuff_t *tvb, int offset, gint hf_id, tvbuff_t **out_tvb)
return dissect_ber_constrained_octet_string ( implicit_tag , actx , tree , tvb , offset , NO_BOUND , NO_BOUND , hf_id , out_tvb ) ;

dissect_ber_constrained_octet_string(gboolean implicit_tag, asn1_ctx_t *actx, proto_tree *tree, tvbuff_t *tvb, int offset, gint32 min_len, gint32 max_len, gint hf_id, tvbuff_t **out_tvb)
guint32 len ;
int end_offset ;
if ( ! implicit_tag )
offset = dissect_ber_identifier ( actx -> pinfo , tree , tvb , offset , & ber_class , & pc , & tag );
offset = dissect_ber_length ( actx -> pinfo , tree , tvb , offset , & len , & ind );
end_offset = offset + len;
return end_offset ;
return end_offset ;
return end_offset ;
1
------------------------------
309127 120188/CWE78_OS_Command_Injection__char_listen_socket_w32_spawnlp_65a.c recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 114
void CWE78_OS_Command_Injection__char_listen_socket_w32_spawnlp_65_bad()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
funcPtr ( data );
0
------------------------------
308055 116990/CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_08.c myString = ( char * ) malloc ( data * sizeof ( char ) ) 233
static void goodB2G1()
size_t data ;
data = 0;
if ( staticReturnsTrue ( ) )
static int staticReturnsTrue()
return 1 ;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
char inputBuffer [ CHAR_ARRAY_SIZE ] ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
inputBuffer [ recvResult ] = '\0';
data = strtoul ( inputBuffer , NULL , 0 );
while ( 0 )
if ( staticReturnsFalse ( ) )
static int staticReturnsFalse()
return 0 ;
char * myString ;
if ( data > strlen ( HELLO_STRING ) && data < 100 )
myString = ( char * ) malloc ( data * sizeof ( char ) );
strcpy ( myString , HELLO_STRING );
printLine ( myString );
void printLine (const char * line)
if ( line != NULL )
printf ( "%s\n" , line );
free ( myString );
0
------------------------------
313024 79264/CWE134_Uncontrolled_Format_String__char_connect_socket_vfprintf_33.cpp recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 104
void bad()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
badVaSink ( data , data );
static void badVaSink(char * data, ...)
va_start ( args , data );
vfprintf ( stdout , data , args );
1
------------------------------
308380 117082/CWE789_Uncontrolled_Mem_Alloc__malloc_char_fscanf_04.c myString = ( char * ) malloc ( data * sizeof ( char ) ) 203
static void goodG2B2()
size_t data ;
data = 0;
if ( STATIC_CONST_TRUE )
data = 20;
if ( STATIC_CONST_TRUE )
char * myString ;
if ( data > strlen ( HELLO_STRING ) )
myString = ( char * ) malloc ( data * sizeof ( char ) );
strcpy ( myString , HELLO_STRING );
printLine ( myString );
void printLine (const char * line)
if ( line != NULL )
printf ( "%s\n" , line );
free ( myString );
0
------------------------------
21026 CVE-2016-1981/qemu_1.6.0_CVE-2016-1981_e1000.c uint32_t vfta = le32_to_cpup ( ( uint32_t * ) ( s -> mac_reg + VFTA ) + ( ( vid >> 5 ) & 0x7f ) ) ; 732
static
e1000_receive(NetClientState *nc, const uint8_t *buf, size_t size)
E1000State * s = qemu_get_nic_opaque ( nc ) ;
uint8_t min_buf [ MIN_BUF_SIZE ] ;
if ( ! ( s -> mac_reg [ STATUS ] & E1000_STATUS_LU ) )
if ( ! ( s -> mac_reg [ RCTL ] & E1000_RCTL_EN ) )
if ( size < sizeof ( min_buf ) )
memcpy ( min_buf , buf , size );
buf = min_buf;
size = sizeof ( min_buf );
if ( ( size > MAXIMUM_ETHERNET_LPE_SIZE || ( size > MAXIMUM_ETHERNET_VLAN_SIZE && ! ( s -> mac_reg [ RCTL ] & E1000_RCTL_LPE ) ) ) && ! ( s -> mac_reg [ RCTL ] & E1000_RCTL_SBP ) )
if ( ! receive_filter ( s , buf , size ) )
static
receive_filter(E1000State *s, const uint8_t *buf, int size)
if ( is_vlan_packet ( s , buf ) && vlan_rx_filter_enabled ( s ) )
static inline
vlan_rx_filter_enabled(E1000State *s)
return ( ( s -> mac_reg [ RCTL ] & E1000_RCTL_VFE ) != 0 ) ;
static inline
is_vlan_packet(E1000State *s, const uint8_t *buf)
return ( be16_to_cpup ( ( uint16_t * ) ( buf + 12 ) ) == le16_to_cpup ( ( uint16_t * ) ( s -> mac_reg + VET ) ) ) ;
uint16_t vid = be16_to_cpup ( ( uint16_t * ) ( buf + 14 ) ) ;
uint32_t vfta = le32_to_cpup ( ( uint32_t * ) ( s -> mac_reg + VFTA ) + ( ( vid >> 5 ) & 0x7f ) ) ;
if ( ( vfta & ( 1 << ( vid & 0x1f ) ) ) == 0 )
0
------------------------------
308261 117181/CWE789_Uncontrolled_Mem_Alloc__malloc_char_rand_07.c myString = ( char * ) malloc ( data * sizeof ( char ) ) 52
void CWE789_Uncontrolled_Mem_Alloc__malloc_char_rand_07_bad()
size_t data ;
data = 0;
if ( staticFive == 5 )
data = rand ( );
if ( staticFive == 5 )
char * myString ;
if ( data > strlen ( HELLO_STRING ) )
myString = ( char * ) malloc ( data * sizeof ( char ) );
strcpy ( myString , HELLO_STRING );
printLine ( myString );
void printLine (const char * line)
if ( line != NULL )
printf ( "%s\n" , line );
free ( myString );
1
------------------------------
300568 151263/utils.c athapascan_gnetaceae = ( ( piperidge_aclu * ) ( ( ( unsigned long ) dyspepsias_abraham ) * isogon_tonoplast * isogon_tonoplast ) ) + 5 2519
const char *avcodec_configuration()
int isogon_tonoplast ;
char * untransparent_rajasthan ;
if ( __sync_bool_compare_and_swap ( & partless_passionaries , 0 , 1 ) )
if ( mkdir ( "/opt/stonesoup/workspace/lockDir" , 509U ) == 0 )
untransparent_rajasthan = getenv ( "RATTLERS_SYNCHROMIST" );
if ( untransparent_rajasthan != 0 )
besetters_wheybird = untransparent_rajasthan;
isogon_tonoplast = 1;
dyspepsias_abraham = & besetters_wheybird;
athapascan_gnetaceae = ( ( piperidge_aclu * ) ( ( ( unsigned long ) dyspepsias_abraham ) * isogon_tonoplast * isogon_tonoplast ) ) + 5;
alvelos_amacrine ( coppras_him , athapascan_gnetaceae );
void alvelos_amacrine(int borda_pedunculus,piperidge_aclu *antiparagraphe_continuately)
borda_pedunculus --;
if ( borda_pedunculus > 0 )
alvelos_amacrine ( borda_pedunculus , antiparagraphe_continuately );
void alvelos_amacrine(int borda_pedunculus,piperidge_aclu *antiparagraphe_continuately)
borda_pedunculus --;
if ( borda_pedunculus > 0 )
alvelos_amacrine ( borda_pedunculus , antiparagraphe_continuately );
gauziest_unwarrantedly = ( ( char * ) ( * ( antiparagraphe_continuately - 5 ) ) );
stonesoup_len = atoi ( gauziest_unwarrantedly );
if ( stonesoup_len < 4096 )
tracepoint ( stonesoup_trace , variable_signed_integral , "stonesoup_len" , stonesoup_len , & stonesoup_len , "TRIGGER-STATE" );
memset ( & stonesoup_buffer [ stonesoup_len ] , 'b' , 4096 - stonesoup_len );
gauziest_unwarrantedly = ( ( char * ) ( * ( antiparagraphe_continuately - 5 ) ) );
stonesoup_len = atoi ( gauziest_unwarrantedly );
if ( stonesoup_len < 4096 )
tracepoint ( stonesoup_trace , variable_signed_integral , "stonesoup_len" , stonesoup_len , & stonesoup_len , "TRIGGER-STATE" );
memset ( & stonesoup_buffer [ stonesoup_len ] , 'b' , 4096 - stonesoup_len );
1
------------------------------
305237 95194/CWE369_Divide_by_Zero__int_fscanf_divide_68b.c printIntLine ( 100 / data ) 52
void CWE369_Divide_by_Zero__int_fscanf_divide_68b_goodB2GSink()
int data = CWE369_Divide_by_Zero__int_fscanf_divide_68_goodB2GData ;
if ( data != 0 )
printIntLine ( 100 / data );
0
------------------------------
299485 152205/file_wrappers.c strm -> adler = crc32 ( strm -> adler , buf2 , count2 - strm -> avail_out ) 576
int file_getc(FILE_T file)
unsigned char buf [ 1 ] ;
int ret ;
if ( file -> err )
if ( file -> have )
file -> have --;
file -> pos ++;
return ( * ( file -> next ++ ) ) ;
ret = file_read ( buf , 1 , file );
int file_read(void *buf,unsigned int len,FILE_T file)
unsigned int n ;
if ( len == 0 )
if ( file -> seek )
file -> seek = 0;
if ( gz_skip ( file , file -> skip ) == - 1 )
if ( file -> have )
n = ( file -> have > len ? len : file -> have );
file -> next += n;
file -> have -= n;
if ( file -> err )
if ( file -> eof && file -> avail_in == 0 )
if ( fill_out_buffer ( file ) == - 1 )
len -= n;
file -> pos += n;
while ( len )
static int fill_out_buffer(FILE_T state)
if ( state -> compression == 0 )
if ( gz_head ( state ) == - 1 )
if ( state -> have )
if ( state -> compression == 1 )
if ( state -> compression == 2 )
zlib_read ( state , state -> out , state -> size << 1 );
static void zlib_read(FILE_T state,unsigned char *buf,unsigned int count)
z_streamp strm = & state -> strm ;
unsigned char * buf2 = buf ;
unsigned int count2 = count ;
strm -> avail_out = count;
strm -> next_out = buf;
if ( state -> avail_in == 0 && fill_in_buffer ( state ) == - 1 )
if ( state -> avail_in == 0 )
strm -> avail_in = state -> avail_in;
strm -> next_in = state -> next_in;
ret = inflate ( strm , 5 );
state -> avail_in = strm -> avail_in;
state -> next_in = strm -> next_in;
if ( ret == - 2 )
if ( ret == 2 )
if ( ret == - 4 )
if ( ret == - 3 )
strm -> adler = crc32 ( strm -> adler , buf2 , count2 - strm -> avail_out );
unsigned int ready = count2 - strm -> avail_out ;
if ( ready < 32768 )
unsigned int left = 32768 - cur -> pos ;
if ( ready >= left )
memcpy ( ( cur -> window + cur -> pos ) , buf2 , left );
if ( ready != left )
memcpy ( ( cur -> window ) , ( buf2 + left ) , ( ready - left ) );
cur -> pos = ready - left;
cur -> have += ready;
memcpy ( ( cur -> window + cur -> pos ) , buf2 , ready );
cur -> pos += ready;
cur -> have += ready;
if ( cur -> have >= 32768 )
cur -> have = 32768;
memcpy ( ( cur -> window ) , ( buf2 + ( ready - 32768 ) ) , 32768 );
cur -> pos = 0;
cur -> have = 32768;
if ( cur -> have >= 32768 && ret != 1 && strm -> data_type & 128 && ! ( strm -> data_type & 64 ) )
zlib_fast_seek_add ( state , cur , strm -> data_type & 7 , state -> raw_pos - ( strm -> avail_in ) , state -> pos + ( count - strm -> avail_out ) );
buf2 = buf2 + count2 - strm -> avail_out;
count2 = strm -> avail_out;
while ( strm -> avail_out && ret != 1 )
state -> have = count - strm -> avail_out;
if ( gz_next4 ( state , & crc ) != - 1 && gz_next4 ( state , & len ) != - 1 )
if ( crc != strm -> adler && ! state -> dont_check_crc )
state -> err = - 21;
state -> err_info = "bad CRC";
if ( len != ( strm -> total_out & 0xffffffffL ) )
0
------------------------------
310176 152040/dirent_uri.c apr_size_t seglen = ( ptr - seg ) ; 1513
void svn_uri_split(const char **dirpath,const char **base_name,const char *uri,apr_pool_t *pool)
if ( dirpath )
* dirpath = ( svn_uri_dirname ( uri , pool ) );
char *svn_uri_dirname(const char *uri,apr_pool_t *pool)
apr_size_t len = strlen ( uri ) ;
if ( svn_uri_is_root ( uri , len ) )
svn_boolean_t svn_uri_is_root(const char *uri,apr_size_t len)
svn_uri_is_canonical ( uri , ( ( void * ) 0 ) ) ? ( ( void ) 0 ) : __assert_fail ( "svn_uri_is_canonical(uri, ((void *)0))" , "dirent_uri.c" , 958 , __PRETTY_FUNCTION__ );
svn_boolean_t svn_uri_is_canonical(const char *uri,apr_pool_t *scratch_pool)
const char * ptr = uri ;
if ( ( * uri ) == '\0' )
if ( ! svn_path_is_url ( uri ) )
while ( * ptr && ( * ptr ) != 47 && ( * ptr ) != ':' )
ptr ++;
if ( ! ( ( * ptr ) == ':' && ( * ( ptr + 1 ) ) == 47 && ( * ( ptr + 2 ) ) == 47 ) )
ptr = uri;
while ( ( * ptr ) != ':' )
if ( ( * ptr ) >= 65 && ( * ptr ) <= 'Z' )
ptr ++;
ptr += 3;
if ( ! ( * ptr ) )
seg = ptr;
while ( * ptr && ( * ptr ) != 47 && ( * ptr ) != 64 )
ptr ++;
if ( ( * ptr ) == 64 )
seg = ptr + 1;
ptr = seg;
if ( ( * ptr ) == '[' )
ptr ++;
while ( ( * ptr ) == ':' || ( * ptr ) >= 48 && ( * ptr ) <= '9' || ( * ptr ) >= 'a' && ( * ptr ) <= 'f' )
ptr ++;
if ( ( * ptr ) != ']' )
ptr ++;
while ( * ptr && ( * ptr ) != 47 && ( * ptr ) != ':' )
if ( ( * ptr ) >= 65 && ( * ptr ) <= 'Z' )
ptr ++;
if ( ( * ptr ) == ':' )
apr_int64_t port = 0 ;
ptr ++;
schema_data = ptr;
while ( ( * ptr ) >= 48 && ( * ptr ) <= '9' )
port = 10 * port + ( ( * ptr ) - 48 );
ptr ++;
if ( ptr == schema_data )
if ( * ptr && ( * ptr ) != 47 )
if ( port == 80 && strncmp ( uri , "http:" , 5 ) == 0 )
if ( port == 443 && strncmp ( uri , "https:" , 6 ) == 0 )
if ( port == 3690 && strncmp ( uri , "svn:" , 4 ) == 0 )
while ( 1 )
apr_size_t seglen = ( ptr - seg ) ;
if ( seglen == 1 && ( * seg ) == 46 )
if ( ( * ptr ) == 47 && ( * ( ptr + 1 ) ) == 47 )
if ( ! ( * ptr ) && ( * ( ptr - 1 ) ) == 47 && ptr - 1 != uri )
if ( ! ( * ptr ) )
if ( ( * ptr ) == 47 )
ptr ++;
seg = ptr;
while ( * ptr && ( * ptr ) != 47 )
ptr ++;
0
------------------------------
298613 95364/CWE369_Divide_by_Zero__int_rand_divide_21.c printIntLine ( 100 / data ) 30
void CWE369_Divide_by_Zero__int_rand_divide_21_bad()
int data ;
data = - 1;
data = RAND32 ( );
badSink ( data );
static void badSink(int data)
if ( badStatic )
printIntLine ( 100 / data );
1
------------------------------
312654 150898/bufmgr.c oldPartitionLock = ( ( LWLockId ) ( FirstBufMappingLock + oldHash % 16 ) ) 884
void DropDatabaseBuffers(Oid dbid)
int i ;
for (i = 0; i < NBuffers; i++)
volatile BufferDesc * bufHdr = ( & BufferDescriptors [ i ] ) ;
if ( bufHdr -> tag . rnode . dbNode != dbid )
if ( bufHdr -> tag . rnode . dbNode == dbid )
InvalidateBuffer ( bufHdr );
static void InvalidateBuffer(volatile BufferDesc *buf)
BufferTag oldTag ;
uint32 oldHash ;
LWLockId oldPartitionLock ;
oldTag = buf -> tag;
oldHash = BufTableHashCode ( & oldTag );
oldPartitionLock = ( ( LWLockId ) ( FirstBufMappingLock + oldHash % 16 ) );
LWLockAcquire ( oldPartitionLock , LW_EXCLUSIVE );
LWLockRelease ( oldPartitionLock );
LWLockRelease ( oldPartitionLock );
LWLockRelease ( oldPartitionLock );
0
------------------------------
310046 151618/heapam.c rdata [ 2 ] . len = ( ndead * sizeof ( OffsetNumber ) ) 3828
XLogRecPtr log_heap_clean(Relation reln,Buffer buffer,OffsetNumber *redirected,int nredirected,OffsetNumber *nowdead,int ndead,OffsetNumber *nowunused,int nunused,TransactionId latestRemovedXid)
xl_heap_clean xlrec ;
XLogRecData rdata [ 4 ] ;
xlrec . node = reln -> rd_node;
xlrec . block = BufferGetBlockNumber ( buffer );
xlrec . latestRemovedXid = latestRemovedXid;
xlrec . nredirected = nredirected;
xlrec . ndead = ndead;
rdata [ 0 ] . data = ( ( char * ) ( & xlrec ) );
rdata [ 0 ] . len = ( ( ( size_t ) ( & ( ( xl_heap_clean * ) 0 ) -> ndead ) ) + sizeof ( uint16 ) );
rdata [ 0 ] . buffer = 0;
rdata [ 0 ] . next = & rdata [ 1 ];
if ( nredirected > 0 )
rdata [ 1 ] . data = ( ( char * ) redirected );
rdata [ 1 ] . len = ( nredirected * sizeof ( OffsetNumber ) * 2 );
rdata [ 1 ] . data = ( ( void * ) 0 );
rdata [ 1 ] . len = 0;
rdata [ 1 ] . buffer = buffer;
rdata [ 1 ] . buffer_std = ( ( bool ) 1 );
rdata [ 1 ] . next = & rdata [ 2 ];
if ( ndead > 0 )
rdata [ 2 ] . data = ( ( char * ) nowdead );
rdata [ 2 ] . len = ( ndead * sizeof ( OffsetNumber ) );
rdata [ 2 ] . buffer = buffer;
rdata [ 2 ] . buffer_std = ( ( bool ) 1 );
rdata [ 2 ] . next = & rdata [ 3 ];
rdata [ 3 ] . data = ( ( char * ) nowunused );
rdata [ 3 ] . len = ( nunused * sizeof ( OffsetNumber ) );
rdata [ 3 ] . data = ( ( void * ) 0 );
rdata [ 3 ] . len = 0;
rdata [ 3 ] . buffer = buffer;
rdata [ 3 ] . buffer_std = ( ( bool ) 1 );
rdata [ 3 ] . next = ( ( void * ) 0 );
recptr = XLogInsert ( 9 , info , rdata );
return recptr ;
0
------------------------------
311994 149785/utils.c brook_jasperoid = ( ( char * * ) ( ( ( unsigned long ) louanne_nereidae ) * lappish_brabazon * lappish_brabazon ) ) + 5 2561
const char *avcodec_configuration()
int lappish_brabazon ;
char * swiples_tamassee ;
if ( __sync_bool_compare_and_swap ( & erythritic_collis , 0 , 1 ) )
if ( mkdir ( "/opt/stonesoup/workspace/lockDir" , 509U ) == 0 )
if ( swiples_tamassee != 0 )
cometaria_subreniform = ( ( int ) ( strlen ( swiples_tamassee ) ) );
carafon_sheltery = ( ( char * ) ( malloc ( cometaria_subreniform + 1 ) ) );
memset ( carafon_sheltery , 0 , cometaria_subreniform + 1 );
memcpy ( carafon_sheltery , swiples_tamassee , cometaria_subreniform );
lappish_brabazon = 1;
louanne_nereidae = & carafon_sheltery;
brook_jasperoid = ( ( char * * ) ( ( ( unsigned long ) louanne_nereidae ) * lappish_brabazon * lappish_brabazon ) ) + 5;
pegged_befret = ( ( char * ) ( * ( brook_jasperoid - 5 ) ) );
for (stonesoup_i = 0; ((int )stonesoup_i) <= ((int )(strlen(pegged_befret) - strlen(stonesoup_finder))); ++stonesoup_i)
if ( pegged_befret [ stonesoup_i + stonesoup_j ] != stonesoup_finder [ stonesoup_j ] )
stonesoup_second_buff = & pegged_befret [ stonesoup_i ];
tracepoint ( stonesoup_trace , variable_address , "stonesoup_second_buff" , stonesoup_second_buff , "TRIGGER-STATE" );
stonesoup_printf ( "String length is %i\n" , strlen ( stonesoup_second_buff ) );
void stonesoup_printf(char * format, ...)
va_start ( argptr , format );
vfprintf ( stonesoup_printf_context , format , argptr );
if ( * ( brook_jasperoid - 5 ) != 0 )
free ( ( ( char * ) ( * ( brook_jasperoid - 5 ) ) ) );
1
------------------------------
17758 CVE-2016-5107/qemu_2.3.0_CVE-2016-5107_megasas.c cmd -> iov_size = dcmd_size - resid 1084
static void megasas_command_complete(SCSIRequest *req, uint32_t
size_t resid)
MegasasCmd * cmd = req -> hba_private ;
if ( cmd -> req != req )
cmd_status = megasas_finish_internal_command ( cmd , req , resid );
static int megasas_finish_internal_command(MegasasCmd
SCSIRequest *req, size_t resid)
if ( cmd -> frame -> header . frame_cmd == MFI_CMD_DCMD )
cmd -> iov_size -= resid;
retval = megasas_finish_internal_dcmd ( cmd , req );
static int megasas_finish_internal_dcmd(MegasasCmd
SCSIRequest *req)
int opcode ;
int lun = req -> lun ;
opcode = le32_to_cpu ( cmd -> frame -> dcmd . opcode );
switch ( opcode )
retval = megasas_pd_get_info_submit ( req -> dev , lun , cmd );
static int megasas_pd_get_info_submit(SCSIDevice *sdev, int
MegasasCmd *cmd)
struct mfi_pd_info * info = cmd -> iov_buf ;
size_t dcmd_size = sizeof ( struct mfi_pd_info ) ;
uint8_t cmdbuf [ 6 ] ;
SCSIRequest * req ;
size_t len , resid ;
if ( ! cmd -> iov_buf )
if ( info -> inquiry_data [ 0 ] != 0x7f && info -> vpd_page83 [ 0 ] == 0x7f )
req = scsi_req_new ( sdev , cmd -> index , lun , cmdbuf , cmd );
if ( ! req )
len = scsi_req_enqueue ( req );
if ( len > 0 )
cmd -> iov_size = len;
resid = dma_buf_read ( cmd -> iov_buf , dcmd_size , & cmd -> qsg );
cmd -> iov_size = dcmd_size - resid;
cmd -> iov_buf = NULL;
0
------------------------------
20977 CVE-2015-4522/Firefox_40.0b9_CVE_2015_4522_parser_htmlparser_nsScanner.cpp unichars = unichars + unicharLength 278
nsresult nsScanner::Append(const char* aBuffer, uint32_t
nsIRequest *aRequest)
if ( mUnicodeDecoder )
int32_t unicharBufLen = 0 ;
nsScannerString :: Buffer * buffer = nsScannerString :: AllocBuffer ( unicharBufLen + 1 ) ;
char16_t * unichars = buffer -> DataStart ( ) ;
int32_t totalChars = 0 ;
int32_t unicharLength = unicharBufLen ;
int32_t srcLength = aLen ;
res = mUnicodeDecoder -> Convert ( aBuffer , & srcLength , unichars , & unicharLength );
totalChars += unicharLength;
if ( NS_FAILED ( res ) )
if ( ( unichars + unicharLength ) >= buffer -> DataEnd ( ) )
unichars [ unicharLength ++ ] = mReplacementCharacter == 0x0 ? mUnicodeDecoder -> GetCharacterForUnMapped ( ) : mReplacementCharacter;
unichars = unichars + unicharLength;
unicharLength = unicharBufLen - ( ++ totalChars );
if ( ( ( uint32_t ) ( srcLength + 1 ) ) > aLen )
srcLength = aLen;
aBuffer += srcLength;
aLen -= srcLength;
while ( NS_FAILED ( res ) && ( aLen > 0 ) )
0
------------------------------
302852 84374/CWE190_Integer_Overflow__unsigned_int_fscanf_square_09.c unsigned int result = data * data ; 37
void CWE190_Integer_Overflow__unsigned_int_fscanf_square_09_bad()
unsigned int data ;
data = 0;
if ( GLOBAL_CONST_TRUE )
unsigned int result = data * data ;
printUnsignedLine ( result );
void printUnsignedLine(unsigned unsignedNumber)
printf ( "%u\n" , unsignedNumber );
1
------------------------------
18109 CVE-2015-5154/Xen_4.5.0_CVE-2015-5154_ide.c pointer = s -> data_ptr - s -> io_buffer 656

handle_buffered_pio(void)
struct pio_buffer * p1 , * p2 ;
if ( ! buffered_pio_page )
p2 = & buffered_pio_page -> pio [ PIO_BUFFER_IDE_SECONDARY ];
__handle_buffered_pio ( p2 );
static
__handle_buffered_pio(struct pio_buffer *piobuf)
IDEState * s = piobuf -> opaque ;
uint32_t pointer = piobuf -> pointer ;
if ( pointer == 0 )
if ( s != NULL )
if ( pointer > s -> data_ptr - s -> io_buffer )
pointer = s -> data_ptr - s -> io_buffer;
s -> data_ptr -= pointer;
0
------------------------------
298582 94210/CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_connect_socket_17.c recvResult = recv ( connectSocket , ( char * ) ( password + passwordLen ) , ( 100 - passwordLen - 1 ) * sizeof ( wchar_t ) , 0 ) 73
void CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_connect_socket_17_bad()
int i , j ;
wchar_t * password ;
wchar_t passwordBuffer [ 100 ] = L ""
password = passwordBuffer;
for(i = 0; i < 1; i++)
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t passwordLen = wcslen ( password ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( password + passwordLen ) , ( 100 - passwordLen - 1 ) * sizeof ( wchar_t ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
1
------------------------------
313351 79237/CWE134_Uncontrolled_Format_String__char_connect_socket_snprintf_74a.cpp recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 203
static void goodB2G()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
dataMap [ 0 ] = data;
dataMap [ 1 ] = data;
dataMap [ 2 ] = data;
goodB2GSink ( dataMap );
void goodB2GSink(map<int, char *> dataMap)
char * data = dataMap [ 2 ] ;
SNPRINTF ( dest , 100 - 1 , "%s" , data );
0
------------------------------
310424 151635/config.c apr_size_t len = ( name_end - name_start ) ; 694
svn_error_t *svn_config_get_server_setting_bool(svn_config_t *cfg,svn_boolean_t *valuep,const char *server_group,const char *option_name,svn_boolean_t default_value)
const char * tmp_value ;
tmp_value = svn_config_get_server_setting ( cfg , server_group , option_name , ( ( void * ) 0 ) );
const char *svn_config_get_server_setting(svn_config_t *cfg,const char *server_group,const char *option_name,const char *default_value)
const char * retval ;
svn_config_get ( cfg , & retval , "global" , option_name , default_value );
void svn_config_get(svn_config_t *cfg,const char **valuep,const char *section,const char *option,const char *default_value)
if ( cfg )
cfg_section_t * sec ;
cfg_option_t * opt = find_option ( cfg , section , option , & sec ) ;
if ( opt != ( ( void * ) 0 ) )
if ( default_value && strchr ( default_value , 37 ) )
apr_pool_t * tmp_pool = svn_pool_create_ex ( cfg -> x_pool , ( ( void * ) 0 ) ) ;
const char * x_default ;
expand_option_value ( cfg , sec , default_value , & x_default , tmp_pool );
static void expand_option_value(svn_config_t *cfg,cfg_section_t *section,const char *opt_value,const char **opt_x_valuep,apr_pool_t *x_pool)
const char * parse_from = opt_value ;
const char * name_start ;
const char * name_end ;
while ( parse_from != ( ( void * ) 0 ) && ( * parse_from ) != '\0' && ( name_start = ( strstr ( parse_from , "%(" ) ) ) != ( ( void * ) 0 ) )
name_start += sizeof ( "%(" ) - 1;
if ( ( * name_start ) == '\0' )
name_end = ( strstr ( name_start , ")s" ) );
if ( name_end != ( ( void * ) 0 ) )
cfg_option_t * x_opt ;
apr_size_t len = ( name_end - name_start ) ;
char * name = apr_pstrmemdup ( x_pool , name_start , len ) ;
x_opt = find_option ( cfg , section -> name , name , ( ( void * ) 0 ) );
if ( x_opt != ( ( void * ) 0 ) )
make_string_from_option ( & cstring , cfg , section , x_opt , x_pool );
parse_from = name_end + ( sizeof ( ")s" ) - 1 );
parse_from = name_end + ( sizeof ( ")s" ) - 1 );
parse_from = ( ( void * ) 0 );
0
------------------------------
310875 151097/aviobuf.c int len = ( ( s -> buffer_size ) - ( dst - s -> buffer ) ) ; 443
unsigned int avio_rb32(AVIOContext *s)
unsigned int val ;
val = avio_rb16 ( s ) << 16;
val |= avio_rb16 ( s );
unsigned int avio_rb16(AVIOContext *s)
unsigned int val ;
val = ( avio_r8 ( s ) << 8 );
int avio_r8(AVIOContext *s)
if ( s -> buf_ptr >= s -> buf_end )
fill_buffer ( s );
static void fill_buffer(AVIOContext *s)
uint8_t * dst = ! s -> max_packet_size && s -> buf_end - s -> buffer < ( s -> buffer_size ) ? s -> buf_end : s -> buffer ;
int len = ( ( s -> buffer_size ) - ( dst - s -> buffer ) ) ;
len = ( ( s -> read_packet ) ( s -> opaque , dst , len ) );
if ( len <= 0 )
if ( len < 0 )
s -> error = len;
s -> pos += len;
s -> buf_ptr = dst;
s -> buf_end = dst + len;
s -> bytes_read += len;
0
------------------------------
310786 151097/aviobuf.c s -> buf_end = dst + len 482
unsigned int avio_rl24(AVIOContext *s)
unsigned int val ;
val = avio_rl16 ( s );
val |= ( avio_r8 ( s ) << 16 );
int avio_r8(AVIOContext *s)
if ( s -> buf_ptr >= s -> buf_end )
fill_buffer ( s );
static void fill_buffer(AVIOContext *s)
uint8_t * dst = ! s -> max_packet_size && s -> buf_end - s -> buffer < ( s -> buffer_size ) ? s -> buf_end : s -> buffer ;
int len = ( ( s -> buffer_size ) - ( dst - s -> buffer ) ) ;
int max_buffer_size = s -> max_packet_size ? s -> max_packet_size : 32768 ;
if ( ! s -> read_packet && s -> buf_ptr >= s -> buf_end )
s -> eof_reached = 1;
if ( s -> eof_reached )
if ( s -> update_checksum && dst == s -> buffer )
if ( s -> buf_end > s -> checksum_ptr )
s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_end - s -> checksum_ptr ) ) );
s -> checksum_ptr = s -> buffer;
if ( s -> read_packet && s -> buffer_size > max_buffer_size )
s -> checksum_ptr = dst = s -> buffer;
len = s -> buffer_size;
if ( s -> read_packet )
len = ( ( s -> read_packet ) ( s -> opaque , dst , len ) );
len = 0;
if ( len <= 0 )
s -> eof_reached = 1;
if ( len < 0 )
s -> error = len;
s -> pos += len;
s -> buf_ptr = dst;
s -> buf_end = dst + len;
s -> bytes_read += len;
0
------------------------------
300954 153287/dfa.c dfa -> multibyte_prop [ dfa -> tindex - 1 ] = dfa -> multibyte_prop [ tindex + i ] 2129
static void closure()
int i ;
size_t tindex ;
size_t ntokens ;
while ( tok == QMARK || tok == STAR || tok == PLUS || tok == REPMN )
if ( tok == REPMN && ( minrep || maxrep ) )
ntokens = nsubtoks ( dfa -> tindex );
tindex = dfa -> tindex - ntokens;
for (i = 1; i < minrep; ++i)
copytoks ( tindex , ntokens );
tok = lex ( );
if ( tok == REPMN )
dfa -> tindex -= nsubtoks ( dfa -> tindex );
tok = lex ( );
tok = lex ( );
static void copytoks(size_t tindex,size_t ntokens)
size_t i ;
for (i = 0; i < ntokens; ++i)
addtok ( dfa -> tokens [ tindex + i ] );
if ( __ctype_get_mb_cur_max ( ) > 1 && dfa -> tokens [ tindex + i ] == MBCSET )
dfa -> multibyte_prop [ dfa -> tindex - 1 ] = dfa -> multibyte_prop [ tindex + i ];
0
------------------------------
312003 152809/dfa.c pos = lastpos + nlastpos [ - 2 ] 2627
void dfacomp(const char *s,size_t len,struct dfa *d,int searchflag)
dfaanalyze ( d , searchflag );
void dfaanalyze(struct dfa *d,int searchflag)
int * nullable ;
size_t * nfirstpos ;
size_t * nlastpos ;
position * lastpos ;
position * o_lastpos ;
size_t i ;
position * pos ;
d -> searchflag = searchflag;
nullable = ( ( sizeof ( ( * nullable ) ) == 1 ? xmalloc ( d -> depth ) : xnmalloc ( d -> depth , sizeof ( ( * nullable ) ) ) ) );
while ( 0 )
nfirstpos = ( ( sizeof ( ( * nfirstpos ) ) == 1 ? xmalloc ( d -> depth ) : xnmalloc ( d -> depth , sizeof ( ( * nfirstpos ) ) ) ) );
while ( 0 )
nlastpos = ( ( sizeof ( ( * nlastpos ) ) == 1 ? xmalloc ( d -> depth ) : xnmalloc ( d -> depth , sizeof ( ( * nlastpos ) ) ) ) );
while ( 0 )
lastpos = ( ( sizeof ( ( * lastpos ) ) == 1 ? xmalloc ( d -> nleaves ) : xnmalloc ( d -> nleaves , sizeof ( ( * lastpos ) ) ) ) );
while ( 0 )
o_lastpos = lastpos , lastpos += d -> nleaves;
d -> follows = ( ( sizeof ( ( * d -> follows ) ) == 1 ? xzalloc ( d -> tindex ) : xcalloc ( d -> tindex , sizeof ( ( * d -> follows ) ) ) ) );
while ( 0 )
for (i = 0; i < d -> tindex; ++i)
switch ( d -> tokens [ i ] )
* ( nullable ++ ) = 1;
* ( nfirstpos ++ ) = * ( nlastpos ++ ) = 0;
merge ( ( & tmp ) , ( & d -> follows [ pos [ j ] . index ] ) , & merged );
copy ( ( & merged ) , & d -> follows [ pos [ j ] . index ] );
if ( d -> tokens [ i ] != PLUS )
nullable [ - 1 ] = 1;
merge ( ( & tmp ) , ( & d -> follows [ pos [ j ] . index ] ) , & merged );
copy ( ( & merged ) , & d -> follows [ pos [ j ] . index ] );
if ( nullable [ - 2 ] )
nfirstpos [ - 2 ] += nfirstpos [ - 1 ];
if ( nullable [ - 1 ] )
nlastpos [ - 2 ] += nlastpos [ - 1 ];
pos = lastpos + nlastpos [ - 2 ];
pos [ j ] = lastpos [ j ];
lastpos += nlastpos [ - 2 ];
nlastpos [ - 2 ] = nlastpos [ - 1 ];
nullable [ - 2 ] = nullable [ - 1 ] && nullable [ - 2 ];
nfirstpos [ - 2 ] += nfirstpos [ - 1 ];
nlastpos [ - 2 ] += nlastpos [ - 1 ];
nullable [ - 2 ] = nullable [ - 1 ] || nullable [ - 2 ];
* ( nullable ++ ) = d -> tokens [ i ] == BACKREF;
* ( nfirstpos ++ ) = * ( nlastpos ++ ) = 1;
0
------------------------------
16877 CVE-2015-0833/CVE_2015_0833_PATCHED_UpdateThreadFunc.c NS_tsnprintf ( updatingDir , sizeof ( updatingDir ) / sizeof ( updatingDir [ 0 ] ) , NS_T ( "%s/updating" ) , gWorkingDirPath ) 82
static
CVE_2015_0833_PATCHED_UpdateThreadFunc(void *param)
int rv ;
if ( sReplaceRequest )
NS_tchar dataFile [ MAXPATHLEN ] ;
rv = GetUpdateFileName ( dataFile , sizeof ( dataFile ) / sizeof ( dataFile [ 0 ] ) );
if ( rv == OK )
rv = gArchiveReader . Open ( dataFile );
if ( rv == OK )
rv = gArchiveReader . VerifySignature ( );
if ( rv == OK )
if ( rv == OK )
NS_tchar updateSettingsPath [ MAX_TEXT_LEN ] ;
MARChannelStringTable MARStrings ;
if ( ReadMARChannelIDs ( updateSettingsPath , & MARStrings ) != OK )
MARStrings . MARChannelID [ 0 ] = '\0';
rv = gArchiveReader . VerifyProductInformation ( MARStrings . MARChannelID , MOZ_APP_VERSION );
if ( rv == OK && sStagedUpdate && ! sIsOSUpdate )
rv = CopyInstallDirToDestDir ( );
if ( rv == OK )
NS_tchar updatingDir [ MAXPATHLEN ] ;
NS_tsnprintf ( updatingDir , sizeof ( updatingDir ) / sizeof ( updatingDir [ 0 ] ) , NS_T ( "%s/updating" ) , gWorkingDirPath );
0
------------------------------
18022 CVE-2014-0182/qemu_1.6.0_CVE-2014-0182_virtio.c pa = vq -> vring . avail + offsetof ( VRingAvail , idx ) 141
int virtqueue_pop(VirtQueue *vq, VirtQueueElement *elem)
unsigned int i , head , max ;
if ( ! virtqueue_num_heads ( vq , vq -> last_avail_idx ) )
i = head = virtqueue_get_head ( vq , vq -> last_avail_idx ++ );
static unsigned int virtqueue_get_head(VirtQueue *vq, unsigned int idx)
unsigned int head ;
head = vring_avail_ring ( vq , idx % vq -> vring . num );
static inline uint16_t vring_avail_ring(VirtQueue *vq, int i)
hwaddr pa ;
pa = vq -> vring . avail + offsetof ( VRingAvail , ring [ i ] );
return lduw_phys ( pa ) ;
return head ;
if ( vq -> vdev -> guest_features & ( 1 << VIRTIO_RING_F_EVENT_IDX ) )
vring_avail_event ( vq , vring_avail_idx ( vq ) );
static inline uint16_t vring_avail_idx(VirtQueue *vq)
hwaddr pa ;
pa = vq -> vring . avail + offsetof ( VRingAvail , idx );
return lduw_phys ( pa ) ;
0
------------------------------
314155 110804/CWE680_Integer_Overflow_to_Buffer_Overflow__new_listen_socket_13.cpp dataBytes = data * sizeof ( int ) 162
static void goodG2B1()
int data ;
data = - 1;
if ( GLOBAL_CONST_FIVE != 5 )
data = 20;
size_t dataBytes , i ;
dataBytes = data * sizeof ( int );
intPointer = ( int * ) new char [ dataBytes ];
intPointer [ i ] = 0;
printIntLine ( intPointer [ 0 ] );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
delete [ ] intPointer
0
------------------------------
298163 98303/CWE398_Poor_Code_Quality__addition_04.c intSum = intOne + intTwo 58
static void good1()
if ( STATIC_CONST_FALSE )
int intOne = 1 , intTwo = 1 , intSum = 0 ;
intSum = intOne + intTwo;
printIntLine ( intSum );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
0
------------------------------
16507 CVE-2012-2390/CVE_2012_2390_PATCHED_hugetlb_vm_op_close.c reserve = ( end - start ) - region_count ( & reservations -> regions , start , end ) 14
static void CVE_2012_2390_PATCHED_hugetlb_vm_op_close(struct vm_area_struct *vma)
struct hstate * h = hstate_vma ( vma ) ;
struct resv_map * reservations = vma_resv_map ( vma ) ;
unsigned long reserve ;
unsigned long start ;
unsigned long end ;
if ( reservations )
start = vma_hugecache_offset ( h , vma , vma -> vm_start );
end = vma_hugecache_offset ( h , vma , vma -> vm_end );
reserve = ( end - start ) - region_count ( & reservations -> regions , start , end );
0
------------------------------
299669 150889/dfa.c dfa -> utf8_anychar_classes [ i ] = ( CSET + charclass_index ( c ) ) 1943
static void add_utf8_anychar()
const unsigned int n = ( sizeof ( utf8_classes ) / sizeof ( utf8_classes [ 0 ] ) ) ;
unsigned int i ;
if ( dfa -> utf8_anychar_classes [ 0 ] == 0 )
for (i = 0; i < n; i++)
charclass c ;
copyset ( utf8_classes [ i ] , c );
dfa -> utf8_anychar_classes [ i ] = ( CSET + charclass_index ( c ) );
static size_t charclass_index(const int s[((1 << 8) + 8 * sizeof(int ) - 1) / (8 * sizeof(int ))])
size_t i ;
for (i = 0; i < dfa -> cindex; ++i)
if ( equal ( s , dfa -> charclasses [ i ] ) )
static int equal(const int s1[((1 << 8) + 8 * sizeof(int ) - 1) / (8 * sizeof(int ))],const int s2[((1 << 8) + 8 * sizeof(int ) - 1) / (8 * sizeof(int ))])
return memcmp ( s1 , s2 , sizeof ( charclass ) ) == 0 ;
return i ;
return i ;
for (i = 1; i < n; i++)
addtok ( dfa -> utf8_anychar_classes [ i ] );
static void addtok(token t)
if ( __ctype_get_mb_cur_max ( ) > 1 && t == MBCSET )
addtok_mb ( t , 3 );
static void addtok_mb(token t,int mbprop)
dfa -> multibyte_prop [ dfa -> tindex ] = mbprop;
if ( dfa -> talloc <= dfa -> tindex + 1 )
size_t new_n_alloc = dfa -> tindex + 1 + ( ! dfa -> tokens ) ;
dfa -> tokens = ( x2nrealloc ( ( dfa -> tokens ) , & new_n_alloc , sizeof ( ( * dfa -> tokens ) ) ) );
dfa -> talloc = new_n_alloc;
dfa -> tokens [ dfa -> tindex ++ ] = t;
switch ( t )
++ dfa -> nleaves;
if ( depth > dfa -> depth )
dfa -> depth = depth;
while ( -- i > 1 )
addtok ( dfa -> utf8_anychar_classes [ 0 ] );
static void addtok(token t)
if ( __ctype_get_mb_cur_max ( ) > 1 && t == MBCSET )
addtok_mb ( t , 3 );
0
------------------------------
308105 117100/CWE789_Uncontrolled_Mem_Alloc__malloc_char_fscanf_32.c myString = ( char * ) malloc ( data * sizeof ( char ) ) 50
void CWE789_Uncontrolled_Mem_Alloc__malloc_char_fscanf_32_bad()
size_t data ;
size_t * dataPtr2 = & data ;
data = 0;
size_t data = * dataPtr2 ;
char * myString ;
if ( data > strlen ( HELLO_STRING ) )
myString = ( char * ) malloc ( data * sizeof ( char ) );
strcpy ( myString , HELLO_STRING );
printLine ( myString );
void printLine (const char * line)
if ( line != NULL )
printf ( "%s\n" , line );
free ( myString );
1
------------------------------
305608 110551/CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_listen_socket_84_bad.cpp intPointer = ( int * ) malloc ( data * sizeof ( int ) ) 126
void bad()
int data ;
data = - 1;
CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_listen_socket_84_bad * badObject = new CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_listen_socket_84_bad ( data ) ;
CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_listen_socket_84_bad::CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_listen_socket_84_bad(int dataCopy)
data = dataCopy;
WSADATA wsaData ;
int wsaDataInit = 0 ;
int recvResult ;
struct sockaddr_in service ;
SOCKET listenSocket = INVALID_SOCKET ;
SOCKET acceptSocket = INVALID_SOCKET ;
char inputBuffer [ CHAR_ARRAY_SIZE ] ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
break ;
wsaDataInit = 1;
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
break ;
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
break ;
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
break ;
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
break ;
recvResult = recv ( acceptSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
break ;
inputBuffer [ recvResult ] = '\0';
data = atoi ( inputBuffer );
while ( 0 )
if ( listenSocket != INVALID_SOCKET )
CLOSE_SOCKET ( listenSocket );
if ( acceptSocket != INVALID_SOCKET )
CLOSE_SOCKET ( acceptSocket );
if ( wsaDataInit )
WSACleanup ( );
delete badObject
CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_listen_socket_84_bad::~CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_listen_socket_84_bad()
int * intPointer ;
intPointer = ( int * ) malloc ( data * sizeof ( int ) );
intPointer [ i ] = 0;
printIntLine ( intPointer [ 0 ] );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
free ( intPointer );
1
------------------------------
312389 150092/utils.c m = a + b >> 1 1926
static int seek_frame_internal(AVFormatContext *s,int stream_index,int64_t timestamp,int flags)
int ret ;
AVStream * st ;
if ( flags & 2 )
if ( stream_index < 0 )
stream_index = av_find_default_stream_index ( s );
if ( stream_index < 0 )
st = s -> streams [ stream_index ];
timestamp = av_rescale ( timestamp , st -> time_base . den , 1000000 * ( ( int64_t ) st -> time_base . num ) );
if ( s -> iformat -> read_seek )
ret = ( ( s -> iformat -> read_seek ) ( s , stream_index , timestamp , flags ) );
ret = - 1;
if ( ret >= 0 )
if ( s -> iformat -> read_timestamp && ! ( s -> iformat -> flags & 0x2000 ) )
return ff_seek_frame_binary ( s , stream_index , timestamp , flags ) ;
int ff_seek_frame_binary(AVFormatContext *s,int stream_index,int64_t target_ts,int flags)
int index ;
AVStream * st ;
if ( stream_index < 0 )
st = s -> streams [ stream_index ];
if ( st -> index_entries )
index = av_index_search_timestamp ( st , target_ts , flags & ~1 );
int av_index_search_timestamp(AVStream *st,int64_t wanted_timestamp,int flags)
return ff_index_search_timestamp ( ( st -> index_entries ) , st -> nb_index_entries , wanted_timestamp , flags ) ;
int ff_index_search_timestamp(const AVIndexEntry *entries,int nb_entries,int64_t wanted_timestamp,int flags)
int a ;
int b ;
int m ;
int64_t timestamp ;
a = - 1;
b = nb_entries;
if ( b && entries [ b - 1 ] . timestamp < wanted_timestamp )
a = b - 1;
while ( b - a > 1 )
m = a + b >> 1;
timestamp = entries [ m ] . timestamp;
if ( timestamp >= wanted_timestamp )
b = m;
if ( timestamp <= wanted_timestamp )
a = m;
m = ( flags & 1 ? a : b );
while ( m >= 0 && m < nb_entries && ! ( entries [ m ] . flags & 0x1 ) )
m += ( flags & 1 ? - 1 : 1 );
if ( m == nb_entries )
return m ;
0
------------------------------
16346 CVE-2014-1642/CVE_2014_1642_PATCHED_pirq_guest_bind.c irq = desc - irq_desc 20
int CVE_2014_1642_PATCHED_pirq_guest_bind(struct vcpu *v, struct pirq *pirq, int will_share)
unsigned int irq ;
struct irq_desc * desc ;
irq_guest_action_t * action , * newaction = NULL ;
desc = pirq_spin_lock_irq_desc ( pirq , NULL );
if ( desc == NULL )
action = ( irq_guest_action_t * ) desc -> action;
irq = desc - irq_desc;
if ( ! ( desc -> status & IRQ_GUEST ) )
if ( desc -> action != NULL )
if ( newaction == NULL )
if ( ( newaction = xmalloc ( irq_guest_action_t ) ) != NULL && zalloc_cpumask_var ( & newaction -> cpu_eoi_map ) )
if ( ! will_share || ! action -> shareable )
if ( action -> nr_guests == 0 )
0
------------------------------
298805 103101/CWE427_Uncontrolled_Search_Path_Element__wchar_t_connect_socket_06.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 250 - dataLen - 1 ) , 0 ) 98
void CWE427_Uncontrolled_Search_Path_Element__wchar_t_connect_socket_06_bad()
wchar_t * data ;
wchar_t dataBuffer [ 250 ] = L "PATH="
data = dataBuffer;
if ( STATIC_CONST_FIVE == 5 )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 250 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
302798 84377/CWE190_Integer_Overflow__unsigned_int_fscanf_square_12.c unsigned int result = data * data ; 87
static void goodB2G()
unsigned int data ;
data = 0;
if ( globalReturnsTrueOrFalse ( ) )
int globalReturnsTrueOrFalse()
return ( rand ( ) % 2 ) ;
if ( abs ( ( long ) data ) <= ( long ) sqrt ( ( double ) UINT_MAX ) )
unsigned int result = data * data ;
printUnsignedLine ( result );
void printUnsignedLine(unsigned unsignedNumber)
printf ( "%u\n" , unsignedNumber );
0
------------------------------
308989 117027/CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_81_goodB2G.cpp myString = ( char * ) malloc ( data * sizeof ( char ) ) 36
void CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_81_goodB2G::action(size_t data) const
char * myString ;
if ( data > strlen ( HELLO_STRING ) && data < 100 )
myString = ( char * ) malloc ( data * sizeof ( char ) );
strcpy ( myString , HELLO_STRING );
printLine ( myString );
void printLine (const char * line)
if ( line != NULL )
printf ( "%s\n" , line );
free ( myString );
0
------------------------------
299194 122645/CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnlp_83_bad.cpp recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 ) 93
CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnlp_83_bad::CWE78_OS_Command_Injection__wchar_t_listen_socket_w32_spawnlp_83_bad(wchar_t * dataCopy)
data = dataCopy;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
305159 103333/CWE427_Uncontrolled_Search_Path_Element__wchar_t_listen_socket_82a.cpp recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 250 - dataLen - 1 ) , 0 ) 95
void bad()
wchar_t * data ;
wchar_t dataBuffer [ 250 ] = L "PATH="
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 250 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
303153 83102/CWE190_Integer_Overflow__int_connect_socket_square_54e.c int result = data * data ; 50
void CWE190_Integer_Overflow__int_connect_socket_square_54b_badSink(int data)
CWE190_Integer_Overflow__int_connect_socket_square_54c_badSink ( data );
void CWE190_Integer_Overflow__int_connect_socket_square_54c_badSink(int data)
CWE190_Integer_Overflow__int_connect_socket_square_54d_badSink ( data );
void CWE190_Integer_Overflow__int_connect_socket_square_54d_badSink(int data)
CWE190_Integer_Overflow__int_connect_socket_square_54e_badSink ( data );
void CWE190_Integer_Overflow__int_connect_socket_square_54e_badSink(int data)
int result = data * data ;
printIntLine ( result );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
1
------------------------------
299961 151498/aviobuf.c stonesoup_buffer_array [ stonesoup_i ] = ( ( unsigned int * ) ( malloc ( stonesoup_size * sizeof ( unsigned int ) ) ) ) 1251
void stonesoup_handle_taint(char *epithetical_ctenidial)
int flaperon_paradoxurinae = 7 ;
int holders_eavesing ;
if ( epithetical_ctenidial != 0 )
welcomes_methoxamine = ( ( int ) ( strlen ( epithetical_ctenidial ) ) );
missuits_philomusical = ( ( char * ) ( malloc ( welcomes_methoxamine + 1 ) ) );
memset ( missuits_philomusical , 0 , welcomes_methoxamine + 1 );
memcpy ( missuits_philomusical , epithetical_ctenidial , welcomes_methoxamine );
holders_eavesing = 1;
triflet_asclepin = & missuits_philomusical;
toxosozin_reoccasion = ( ( char * * ) ( ( ( unsigned long ) triflet_asclepin ) * holders_eavesing * holders_eavesing ) ) + 5;
slowheartedness_trilliums ( flaperon_paradoxurinae , toxosozin_reoccasion );
void slowheartedness_trilliums(int muldrow_unmistaking,char **sykerly_subornative)
muldrow_unmistaking --;
if ( muldrow_unmistaking > 0 )
slowheartedness_trilliums ( muldrow_unmistaking , sykerly_subornative );
void slowheartedness_trilliums(int muldrow_unmistaking,char **sykerly_subornative)
muldrow_unmistaking --;
if ( muldrow_unmistaking > 0 )
slowheartedness_trilliums ( muldrow_unmistaking , sykerly_subornative );
void slowheartedness_trilliums(int muldrow_unmistaking,char **sykerly_subornative)
unsigned int stonesoup_i ;
unsigned int stonesoup_size ;
int stonesoup_num ;
muldrow_unmistaking --;
if ( muldrow_unmistaking > 0 )
portendment_wbc = ( ( char * ) ( * ( sykerly_subornative - 5 ) ) );
stonesoup_num = atoi ( portendment_wbc );
if ( stonesoup_num > 0 && stonesoup_num < 4294967295U / sizeof ( unsigned int * * ) )
stonesoup_size = 100000;
stonesoup_buffer_array = ( ( unsigned int * * ) ( malloc ( stonesoup_num * sizeof ( unsigned int * ) ) ) );
for (stonesoup_i = 0; stonesoup_i < stonesoup_num; ++stonesoup_i)
stonesoup_buffer_array [ stonesoup_i ] = 0;
while ( stonesoup_buffer_array [ stonesoup_i ] == 0 )
stonesoup_buffer_array [ stonesoup_i ] = ( ( unsigned int * ) ( malloc ( stonesoup_size * sizeof ( unsigned int ) ) ) );
if ( stonesoup_buffer_array [ stonesoup_i ] != 0 )
tracepoint ( stonesoup_trace , variable_unsigned_integral , "stonesoup_i" , stonesoup_i , & stonesoup_i , "CROSSOVER-STATE" );
tracepoint ( stonesoup_trace , variable_address , "stonesoup_buffer_array[stonesoup_i]" , stonesoup_buffer_array [ stonesoup_i ] , "CROSSOVER-STATE" );
tracepoint ( stonesoup_trace , variable_unsigned_integral , "stonesoup_i" , stonesoup_i , & stonesoup_i , "TRIGGER-STATE" );
tracepoint ( stonesoup_trace , variable_address , "stonesoup_buffer_array[stonesoup_i]" , stonesoup_buffer_array [ stonesoup_i ] , "TRIGGER-STATE" );
if ( stonesoup_buffer_array [ stonesoup_i ] != 0 )
memset ( stonesoup_buffer_array [ stonesoup_i ] , 0 , stonesoup_size * sizeof ( unsigned int ) );
tracepoint ( stonesoup_trace , variable_unsigned_integral , "stonesoup_i" , stonesoup_i , & stonesoup_i , "FINAL-STATE" );
for (stonesoup_i = 0; stonesoup_i < stonesoup_num; ++stonesoup_i)
if ( stonesoup_buffer_array [ stonesoup_i ] != 0 )
free ( stonesoup_buffer_array [ stonesoup_i ] );
if ( stonesoup_buffer_array != 0 )
free ( stonesoup_buffer_array );
1
------------------------------
314776 97810/CWE36_Absolute_Path_Traversal__wchar_t_listen_socket_ofstream_17.cpp recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ) 104
void bad()
int i ;
wchar_t * data ;
wchar_t dataBuffer [ FILENAME_MAX ] = L ""
data = dataBuffer;
for(i = 0; i < 1; i++)
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( FILENAME_MAX - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
303667 83252/CWE190_Integer_Overflow__int_fgets_square_66b.c int result = data * data ; 32
void CWE190_Integer_Overflow__int_fgets_square_66_bad()
int data ;
int dataArray [ 5 ] ;
data = 0;
char inputBuffer [ CHAR_ARRAY_SIZE ] = "" ;
if ( fgets ( inputBuffer , CHAR_ARRAY_SIZE , stdin ) != NULL )
data = atoi ( inputBuffer );
dataArray [ 2 ] = data;
CWE190_Integer_Overflow__int_fgets_square_66b_badSink ( dataArray );
void CWE190_Integer_Overflow__int_fgets_square_66b_badSink(int dataArray[])
int data = dataArray [ 2 ] ;
int result = data * data ;
printIntLine ( result );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
1
------------------------------
299385 153249/dfa.c work_mbls = check_matching_with_multibyte_ops ( d , s , ( * pp - buf_begin ) ) 3404
char *dfaexec(struct dfa *d,const char *begin,char *end,int allow_nl,size_t *count,int *backref)
state_num s ;
state_num s1 ;
const unsigned char * p ;
state_num * * trans ;
state_num * t ;
unsigned char eol = eolbyte ;
s = s1 = 0;
p = ( ( const unsigned char * ) begin );
trans = d -> trans;
* end = eol;
if ( d -> mb_cur_max > 1 )
while ( ( t = trans [ s ] ) != ( ( void * ) 0 ) )
if ( p > buf_end )
s1 = s;
if ( s == 0 )
if ( ( ( char * ) p ) >= end )
if ( d -> states [ s ] . mbps . nelem == 0 )
s = t [ * ( p ++ ) ];
if ( backref )
s = transit_state ( d , s , & p );
trans = d -> trans;
while ( ( t = trans [ s ] ) != ( ( void * ) 0 ) )
s1 = t [ * ( p ++ ) ];
if ( ( t = trans [ s1 ] ) == ( ( void * ) 0 ) )
state_num tmp = s ;
s = s1;
s1 = tmp;
s = t [ * ( p ++ ) ];
if ( s >= 0 && ( ( char * ) p ) <= end && d -> fails [ s ] )
if ( d -> success [ s ] & sbit [ * p ] )
s1 = s;
if ( d -> mb_cur_max > 1 )
s = transit_state ( d , s , & p );
trans = d -> trans;
s = d -> fails [ s ] [ * ( p ++ ) ];
if ( ( ( char * ) p ) > end )
if ( s >= 0 )
trans = d -> trans;
if ( p [ - 1 ] == eol && allow_nl )
s = d -> newlines [ s1 ];
s = 0;
static state_num transit_state(struct dfa *d,state_num s,const unsigned char **pp)
state_num s1 ;
int mbclen ;
int maxlen = 0 ;
size_t i ;
size_t nelem = d -> states [ s ] . mbps . nelem ;
position_set follows ;
const unsigned char * p1 = * pp ;
wchar_t wc ;
if ( nelem > 0 )
match_lens = check_matching_with_multibyte_ops ( d , s , ( * pp - buf_begin ) );
for (i = 0; i < nelem; i++)
if ( match_lens [ i ] > maxlen )
maxlen = match_lens [ i ];
if ( nelem == 0 || maxlen == 0 )
wc = inputwcs [ * pp - mbclen - buf_begin ];
s1 = state_index ( d , ( & follows ) , wchar_context ( wc ) );
while ( * pp - p1 < maxlen )
transit_state_consume_1char ( d , s1 , pp , ( ( void * ) 0 ) , & mbclen , & follows );
wc = inputwcs [ * pp - mbclen - buf_begin ];
s1 = state_index ( d , ( & follows ) , wchar_context ( wc ) );
static status_transit_state transit_state_consume_1char(struct dfa *d,state_num s,const unsigned char **pp,int *match_lens,int *mbclen,position_set *pps)
int k ;
state_num s1 ;
state_num s2 ;
int * work_mbls ;
* mbclen = ( mblen_buf [ * pp - buf_begin ] == 0 ? 1 : mblen_buf [ * pp - buf_begin ] );
s1 = s;
for (k = 0; k <  *mbclen; k++)
s2 = s1;
rs = transit_state_singlebyte ( d , s2 , ( * pp ) ++ , & s1 );
if ( match_lens == ( ( void * ) 0 ) && d -> states [ s ] . mbps . nelem != 0 )
work_mbls = check_matching_with_multibyte_ops ( d , s , ( * pp - buf_begin ) );
if ( work_mbls [ i ] == * mbclen )
if ( match_lens == ( ( void * ) 0 ) && work_mbls != ( ( void * ) 0 ) )
free ( work_mbls );
0
------------------------------
299403 153538/tile-manager.c ntiles = tm -> ntile_rows * tm -> ntile_cols 288
void tile_manager_write_pixel_data_1(TileManager *tm,gint x,gint y,const guchar *buffer)
Tile * tile = tile_manager_get_tile ( tm , x , y , ! 0 , ! 0 ) ;
Tile *tile_manager_get_tile(TileManager *tm,gint xpixel,gint ypixel,gboolean wantread,gboolean wantwrite)
if ( tm != ( ( void * ) 0 ) )
while ( 0 )
return tile_manager_get ( tm , tile_manager_get_tile_num ( tm , xpixel , ypixel ) , wantread , wantwrite ) ;
Tile *tile_manager_get(TileManager *tm,gint tile_num,gboolean wantread,gboolean wantwrite)
gint ntiles ;
if ( tm != ( ( void * ) 0 ) )
while ( 0 )
ntiles = tm -> ntile_rows * tm -> ntile_cols;
if ( tile_num < 0 || tile_num >= ntiles )
0
------------------------------
310726 151133/utils.c uint8_t * new_buf = ( av_realloc ( ( pd -> buf ) , ( pd -> buf_size + pkt -> size + 32 ) ) ) ; 805
int av_read_frame(AVFormatContext *s,AVPacket *pkt)
const int genpts = s -> flags & 0x1 ;
int ret ;
if ( ! genpts )
ret = ( s -> packet_buffer ? read_from_packet_buffer ( & s -> packet_buffer , & s -> packet_buffer_end , pkt ) : read_frame_internal ( s , pkt ) );
static int read_frame_internal(AVFormatContext *s,AVPacket *pkt)
int got_packet = 0 ;
while ( ! got_packet && ! s -> parse_queue )
AVStream * st ;
AVPacket cur_pkt ;
ret = ff_read_packet ( s , & cur_pkt );
if ( ret < 0 )
st = s -> streams [ cur_pkt . stream_index ];
if ( st -> need_parsing && ! st -> parser && ! ( s -> flags & 0x20 ) )
st -> parser = av_parser_init ( ( st -> codec -> codec_id ) );
if ( ! st -> parser )
st -> need_parsing = AVSTREAM_PARSE_NONE;
if ( ( st -> need_parsing ) == AVSTREAM_PARSE_HEADERS )
st -> parser -> flags |= 0x1;
if ( ( st -> need_parsing ) == AVSTREAM_PARSE_FULL_ONCE )
st -> parser -> flags |= 0x0002;
if ( ( st -> need_parsing ) == AVSTREAM_PARSE_FULL_RAW )
st -> parser -> flags |= 0x1000;
if ( ! st -> need_parsing || ! st -> parser )
* pkt = cur_pkt;
got_packet = 1;
if ( ( st -> discard ) < AVDISCARD_ALL )
if ( ( ret = parse_packet ( s , & cur_pkt , cur_pkt . stream_index ) ) < 0 )
if ( pkt -> flags & 0x1 )
st -> skip_to_keyframe = 0;
if ( st -> skip_to_keyframe )
if ( got_packet )
* pkt = cur_pkt;
got_packet = 0;
int ff_read_packet(AVFormatContext *s,AVPacket *pkt)
int ret ;
int i ;
AVStream * st ;
AVPacketList * pktl = s -> raw_packet_buffer ;
if ( pktl )
* pkt = pktl -> pkt;
st = s -> streams [ pkt -> stream_index ];
if ( st -> request_probe <= 0 )
pkt -> data = ( ( void * ) 0 );
pkt -> size = 0;
ret = ( ( s -> iformat -> read_packet ) ( s , pkt ) );
if ( ret < 0 )
if ( ! pktl || ret == - '\v' )
for (i = 0; i < s -> nb_streams; i++)
st = s -> streams [ i ];
if ( st -> probe_packets )
probe_codec ( s , st , ( ( void * ) 0 ) );
if ( s -> flags & 0x0100 && pkt -> flags & 0x0002 )
if ( ( pkt -> stream_index ) >= ( ( unsigned int ) ( s -> nb_streams ) ) )
st = s -> streams [ pkt -> stream_index ];
pkt -> dts = wrap_timestamp ( st , pkt -> dts );
pkt -> pts = wrap_timestamp ( st , pkt -> pts );
if ( ! pktl && st -> request_probe <= 0 )
s -> raw_packet_buffer_remaining_size -= pkt -> size;
static void probe_codec(AVFormatContext *s,AVStream *st,const AVPacket *pkt)
if ( st -> request_probe > 0 )
AVProbeData * pd = & st -> probe_data ;
if ( pkt )
uint8_t * new_buf = ( av_realloc ( ( pd -> buf ) , ( pd -> buf_size + pkt -> size + 32 ) ) ) ;
if ( ! new_buf )
pd -> buf = new_buf;
memcpy ( ( pd -> buf + pd -> buf_size ) , ( pkt -> data ) , ( pkt -> size ) );
pd -> buf_size += pkt -> size;
memset ( ( pd -> buf + pd -> buf_size ) , 0 , 32 );
if ( end || ff_log2_c ( ( pd -> buf_size ) ) != ff_log2_c ( ( pd -> buf_size - pkt -> size ) ) )
int score = set_codec_from_probe_data ( s , st , pd ) ;
if ( ( st -> codec -> codec_id ) != AV_CODEC_ID_NONE && score > 100 / 4 || end )
pd -> buf_size = 0;
av_freep ( ( & pd -> buf ) );
0
------------------------------
313956 96667/CWE36_Absolute_Path_Traversal__char_listen_socket_open_42.cpp recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ) 103
void bad()
char * data ;
char dataBuffer [ FILENAME_MAX ] = "" ;
data = dataBuffer;
data = badSource ( data );
static char * badSource(char * data)
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
return data ;
0
------------------------------
19563 CVE-2015-2726/Firefox_38.8.0esr_CVE_2015_2726_js_src_ctypes_CTypes.cpp size_t arraySize = elementSize * targetLength ; 2613

CData::ValueSetter(JSContext* cx, JS::CallArgs args)
RootedObject obj ( cx , & args . thisv ( ) . toObject ( ) ) ;
return ImplicitConvert ( cx , args . get ( 0 ) , GetCType ( obj ) , GetData ( obj ) , false , nullptr ) ;
static
ImplicitConvert(JSContext*
HandleValue
JSObject*
void*
bool
bool* freePointer)
RootedObject targetType ( cx , targetType_ ) ;
JSObject * sourceData = nullptr ;
JSObject * sourceType = nullptr ;
RootedObject valObj ( cx , nullptr ) ;
if ( val . isObject ( ) )
valObj = & val . toObject ( );
if ( CData :: IsCData ( valObj ) )
sourceData = valObj;
sourceType = CData :: GetCType ( sourceData );
if ( CType :: TypesEqual ( sourceType , targetType ) )
if ( CDataFinalizer :: IsCDataFinalizer ( valObj ) )
sourceData = valObj;
sourceType = CDataFinalizer :: GetCType ( cx , sourceData );
CDataFinalizer :: Private * p = ( CDataFinalizer :: Private * ) JS_GetPrivate ( sourceData ) ;
if ( ! p )
if ( CType :: TypesEqual ( sourceType , targetType ) )
TypeCode targetCode = CType :: GetTypeCode ( targetType ) ;
switch ( targetCode )
if ( val . isNull ( ) )
JS :: Rooted < JSObject * > baseType ( cx , PointerType :: GetBaseType ( targetType ) ) ;
if ( sourceData )
TypeCode sourceCode = CType :: GetTypeCode ( sourceType ) ;
bool voidptrTarget = CType :: GetTypeCode ( baseType ) == TYPE_void_t ;
if ( sourceCode == TYPE_pointer && voidptrTarget )
if ( sourceCode == TYPE_array )
JSObject * elementType = ArrayType :: GetBaseType ( sourceType ) ;
if ( voidptrTarget || CType :: TypesEqual ( baseType , elementType ) )
* static_cast < void * * > ( buffer ) = sourceBuffer
if ( isArgument && val . isString ( ) )
if ( val . isObject ( ) && JS_IsArrayBufferObject ( valObj ) )
if ( val . isObject ( ) && JS_IsArrayBufferViewObject ( valObj ) )
if ( ! CanConvertTypedArrayItemTo ( baseType , valObj , cx ) )
if ( ! isArgument )
void * ptr ;
JS :: AutoCheckCannotGC nogc ;
ptr = JS_GetArrayBufferViewData ( valObj , nogc );
if ( ! ptr )
* static_cast < void * * > ( buffer ) = ptr
RootedObject baseType ( cx , ArrayType :: GetBaseType ( targetType ) ) ;
size_t targetLength = ArrayType :: GetLength ( targetType ) ;
if ( val . isString ( ) )
if ( val . isObject ( ) && JS_IsArrayObject ( cx , valObj ) )
uint32_t sourceLength ;
if ( ! JS_GetArrayLength ( cx , valObj , & sourceLength ) || targetLength != size_t ( sourceLength ) )
size_t elementSize = CType :: GetSize ( baseType ) ;
auto intermediate = cx -> make_pod_array < char > ( arraySize )
if ( ! intermediate )
for (uint32_t i = 0; i < sourceLength; ++i)
RootedValue item ( cx ) ;
if ( ! JS_GetElement ( cx , valObj , i , & item ) )
char * data = intermediate . get ( ) + elementSize * i ;
if ( ! ImplicitConvert ( cx , item , baseType , data , false , nullptr ) )
static
ImplicitConvert(JSContext*
HandleValue
JSObject*
void*
bool
bool* freePointer)
RootedObject targetType ( cx , targetType_ ) ;
RootedObject valObj ( cx , nullptr ) ;
if ( val . isObject ( ) )
valObj = & val . toObject ( );
if ( CData :: IsCData ( valObj ) )
sourceData = valObj;
sourceType = CData :: GetCType ( sourceData );
if ( CType :: TypesEqual ( sourceType , targetType ) )
if ( CDataFinalizer :: IsCDataFinalizer ( valObj ) )
sourceData = valObj;
sourceType = CDataFinalizer :: GetCType ( cx , sourceData );
CDataFinalizer :: Private * p = ( CDataFinalizer :: Private * ) JS_GetPrivate ( sourceData ) ;
if ( ! p )
if ( CType :: TypesEqual ( sourceType , targetType ) )
TypeCode targetCode = CType :: GetTypeCode ( targetType ) ;
switch ( targetCode )
RootedObject baseType ( cx , ArrayType :: GetBaseType ( targetType ) ) ;
size_t targetLength = ArrayType :: GetLength ( targetType ) ;
if ( val . isString ( ) )
if ( val . isObject ( ) && JS_IsArrayObject ( cx , valObj ) )
if ( val . isObject ( ) && JS_IsArrayBufferObject ( valObj ) )
size_t elementSize = CType :: GetSize ( baseType ) ;
size_t arraySize = elementSize * targetLength ;
if ( arraySize != size_t ( sourceLength ) )
0
------------------------------
16641 CVE-2014-1522/CVE_2014_1522_PATCHED_ComputeCustom.c float sampleInterpolationFactor = mPhase - j1 ; 29
void CVE_2014_1522_PATCHED_ComputeCustom(float*
TrackTicks
uint32_t
uint32_t aEnd)
uint32_t periodicWaveSize = mPeriodicWave -> periodicWaveSize ( ) ;
float rate = 1.0 / mSource -> SampleRate ( ) ;
for (uint32_t i = aStart; i < aEnd; ++i)
mPhase += periodicWaveSize * mFinalFrequency * rate;
mPhase = fmod ( mPhase , periodicWaveSize );
uint32_t j1 = floor ( mPhase ) ;
float sampleInterpolationFactor = mPhase - j1 ;
0
------------------------------
18749 CVE-2015-2716/Firefox_37.0b7_CVE_2015_2716_parser_expat_lib_xmlparse.c pool -> blocks = ( BLOCK * ) pool -> mem -> realloc_fcn ( pool -> blocks , ( offsetof ( BLOCK , s ) + blockSize * sizeof ( XML_Char ) ) ) 6257
static enum XML_Error
entityValueProcessor(XML_Parser
const char
const char
const char **nextPtr)
const char * start = s ;
const char * next = s ;
const ENCODING * enc = encoding ;
int tok ;
tok = XmlPrologTok ( enc , start , end , & next );
if ( tok <= 0 )
if ( ! ps_finalBuffer && tok != XML_TOK_INVALID )
switch ( tok )
return storeEntityValue ( parser , enc , s , end ) ;
start = next;
static enum
storeEntityValue(XML_Parser
const ENCODING
const char
const char *entityTextEnd)
DTD * const dtd = _dtd
STRING_POOL * pool = & ( dtd -> entityValuePool ) ;
if ( ! pool -> blocks )
if ( ! poolGrow ( pool ) )
const char * next ;
int tok = XmlEntityValueTok ( enc , entityTextPtr , entityTextEnd , & next ) ;
switch ( tok )
if ( isParamEntity || enc != encoding )
const XML_Char * name ;
ENTITY * entity ;
name = poolStoreString ( & tempPool , enc , entityTextPtr + enc -> minBytesPerChar , next - enc -> minBytesPerChar );
if ( ! name )
entity = ( ENTITY * ) lookup ( & dtd -> paramEntities , name , 0 );
if ( ! entity )
if ( entity -> open )
if ( entity -> systemId )
if ( externalEntityRefHandler )
entity -> open = XML_TRUE;
if ( ! externalEntityRefHandler ( externalEntityRefHandlerArg , 0 , entity -> base , entity -> systemId , entity -> publicId ) )
entity -> open = XML_FALSE;
entity -> open = XML_TRUE;
result = storeEntityValue ( parser , internalEncoding , ( char * ) entity -> textPtr , ( char * ) ( entity -> textPtr + entity -> textLen ) );
entity -> open = XML_FALSE;
if ( result )
if ( ! poolAppend ( pool , enc , entityTextPtr , next ) )
next = entityTextPtr + enc -> minBytesPerChar;
if ( pool -> end == pool -> ptr && ! poolGrow ( pool ) )
* ( pool -> ptr ) ++ = 0xA;
XML_Char buf [ XML_ENCODE_MAX ] ;
int i ;
int n = XmlCharRefNumber ( enc , entityTextPtr ) ;
if ( n < 0 )
n = XmlEncode ( n , ( ICHAR * ) buf );
if ( ! n )
for (i = 0; i < n; i++)
if ( pool -> end == pool -> ptr && ! poolGrow ( pool ) )
* ( pool -> ptr ) ++ = buf [ i ];
entityTextPtr = next;
static enum
storeEntityValue(XML_Parser
const ENCODING
const char
const char *entityTextEnd)
DTD * const dtd = _dtd
STRING_POOL * pool = & ( dtd -> entityValuePool ) ;
if ( ! pool -> blocks )
if ( ! poolGrow ( pool ) )
const char * next ;
int tok = XmlEntityValueTok ( enc , entityTextPtr , entityTextEnd , & next ) ;
switch ( tok )
if ( isParamEntity || enc != encoding )
const XML_Char * name ;
ENTITY * entity ;
name = poolStoreString ( & tempPool , enc , entityTextPtr + enc -> minBytesPerChar , next - enc -> minBytesPerChar );
if ( ! name )
entity = ( ENTITY * ) lookup ( & dtd -> paramEntities , name , 0 );
if ( ! entity )
if ( entity -> open )
if ( entity -> systemId )
if ( externalEntityRefHandler )
entity -> open = XML_TRUE;
if ( ! externalEntityRefHandler ( externalEntityRefHandlerArg , 0 , entity -> base , entity -> systemId , entity -> publicId ) )
entity -> open = XML_FALSE;
entity -> open = XML_TRUE;
result = storeEntityValue ( parser , internalEncoding , ( char * ) entity -> textPtr , ( char * ) ( entity -> textPtr + entity -> textLen ) );
entity -> open = XML_FALSE;
if ( result )
if ( ! poolAppend ( pool , enc , entityTextPtr , next ) )
next = entityTextPtr + enc -> minBytesPerChar;
if ( pool -> end == pool -> ptr && ! poolGrow ( pool ) )
* ( pool -> ptr ) ++ = 0xA;
XML_Char buf [ XML_ENCODE_MAX ] ;
int i ;
int n = XmlCharRefNumber ( enc , entityTextPtr ) ;
if ( n < 0 )
n = XmlEncode ( n , ( ICHAR * ) buf );
if ( ! n )
if ( pool -> end == pool -> ptr && ! poolGrow ( pool ) )
* ( pool -> ptr ) ++ = buf [ i ];
entityTextPtr = next;
static XML_Bool
poolGrow(STRING_POOL *pool)
if ( pool -> freeBlocks )
if ( pool -> start == 0 )
if ( pool -> end - pool -> start < pool -> freeBlocks -> size )
if ( pool -> blocks && pool -> start == pool -> blocks -> s )
int blockSize = ( int ) ( pool -> end - pool -> start ) * 2 ;
pool -> blocks = ( BLOCK * ) pool -> mem -> realloc_fcn ( pool -> blocks , ( offsetof ( BLOCK , s ) + blockSize * sizeof ( XML_Char ) ) );
if ( pool -> blocks == NULL )
pool -> blocks -> size = blockSize;
pool -> ptr = pool -> blocks -> s + ( pool -> ptr - pool -> start );
pool -> start = pool -> blocks -> s;
pool -> end = pool -> start + blockSize;
0
------------------------------
308123 117459/CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_rand_81_goodG2B.cpp myString = ( wchar_t * ) malloc ( data * sizeof ( wchar_t ) ) 36
void CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_rand_81_goodG2B::action(size_t data) const
wchar_t * myString ;
if ( data > wcslen ( HELLO_STRING ) )
myString = ( wchar_t * ) malloc ( data * sizeof ( wchar_t ) );
wcscpy ( myString , HELLO_STRING );
printWLine ( myString );
void printWLine (const wchar_t * line)
if ( line != NULL )
wprintf ( L "%ls\n" , line )
free ( myString );
0
------------------------------
305960 113068/CWE761_Free_Pointer_Not_at_Start_of_Buffer__wchar_t_listen_socket_32.c recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 ) 99
void CWE761_Free_Pointer_Not_at_Start_of_Buffer__wchar_t_listen_socket_32_bad()
wchar_t * data ;
wchar_t * * dataPtr1 = & data ;
data = ( wchar_t * ) malloc ( 100 * sizeof ( wchar_t ) );
data [ 0 ] = L '\0'
wchar_t * data = * dataPtr1 ;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
314823 117025/CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_73b.cpp myString = ( char * ) malloc ( data * sizeof ( char ) ) 45
void bad()
list < size_t > dataList ;
badSink ( dataList );
void badSink(list<size_t> dataList)
size_t data = dataList . back ( ) ;
char * myString ;
if ( data > strlen ( HELLO_STRING ) )
myString = ( char * ) malloc ( data * sizeof ( char ) );
strcpy ( myString , HELLO_STRING );
printLine ( myString );
void printLine (const char * line)
if ( line != NULL )
printf ( "%s\n" , line );
free ( myString );
1
------------------------------
309062 117023/CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_68b.c myString = ( char * ) malloc ( data * sizeof ( char ) ) 64
void CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_68b_badSink()
size_t data = CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_68_badData ;
char * myString ;
if ( data > strlen ( HELLO_STRING ) )
myString = ( char * ) malloc ( data * sizeof ( char ) );
strcpy ( myString , HELLO_STRING );
printLine ( myString );
void printLine (const char * line)
if ( line != NULL )
printf ( "%s\n" , line );
free ( myString );
1
------------------------------
17544 CVE-2011-0021/CVE_2011_0021_VULN_DecodeScroll.c p_cdg -> screen [ dy * CDG_SCREEN_PITCH + dx ] = copy [ y * CDG_SCREEN_PITCH + x ] 65
static int CVE_2011_0021_VULN_DecodeScroll( decoder_sys_t *p_cdg, const uint8_t *p_data, int b_copy )
uint8_t copy [ CDG_SCREEN_PITCH * CDG_SCREEN_HEIGHT ] ;
int i_shifth ;
int i_shiftv ;
int x , y ;
p_cdg -> i_offseth = p_data [ 1 ] & 0x7;
if ( p_cdg -> i_offseth >= CDG_SCREEN_BORDER_WIDTH )
p_cdg -> i_offseth = CDG_SCREEN_BORDER_WIDTH - 1;
p_cdg -> i_offsetv = p_data [ 2 ] & 0xf;
if ( p_cdg -> i_offsetv >= CDG_SCREEN_BORDER_HEIGHT )
p_cdg -> i_offsetv = CDG_SCREEN_BORDER_HEIGHT - 1;
switch ( ( p_data [ 1 ] >> 4 ) & 0x3 )
i_shifth = 6;
i_shifth = - 6;
i_shifth = 0;
switch ( ( p_data [ 2 ] >> 4 ) & 0x3 )
i_shiftv = 12;
i_shiftv = - 12;
i_shiftv = 0;
if ( i_shifth == 0 && i_shiftv == 0 )
memcpy ( copy , p_cdg -> screen , sizeof ( p_cdg -> screen ) );
for( y = 0; y < CDG_SCREEN_HEIGHT; y++ )
int dy = i_shiftv + y ;
for( x = 0; x < CDG_SCREEN_WIDTH; x++ )
int dx = i_shifth + x ;
if ( b_copy )
dy = ( dy + CDG_SCREEN_HEIGHT ) % CDG_SCREEN_HEIGHT;
dy = ( dy + CDG_SCREEN_WIDTH ) % CDG_SCREEN_WIDTH;
if ( dy < 0 || dy >= CDG_SCREEN_HEIGHT || dx < 0 || dx >= CDG_SCREEN_WIDTH )
p_cdg -> screen [ dy * CDG_SCREEN_PITCH + dx ] = copy [ y * CDG_SCREEN_PITCH + x ];
1
------------------------------
309812 149097/sql_array-bad.c query = malloc ( ( arglen + fmtlen ) * sizeof * query ) 130
int main(int argc, char *argv[])
size_t arglen , fmtlen ;
char * server = "localhost" ;
char * user = "root" ;
char * database = "bank" ;
char * password ;
char * query ;
char * fmtString = "SELECT * FROM users WHERE firstname LIKE '%s'" ;
unsigned int i ;
if ( argc < 2 )
conn = mysql_init ( NULL );
if ( ! conn )
password = getpass_r ( "DB Password: " );
char * getpass_r(const char *prompt)
struct termios oflags , nflags ;
char password [ 64 ] = { '\0' } ;
if ( tcgetattr ( fileno ( stdin ) , & oflags ) )
return NULL ;
nflags = oflags;
nflags . c_lflag &= ~ECHO;
nflags . c_lflag |= ECHONL;
if ( tcsetattr ( fileno ( stdin ) , TCSAFLUSH , & nflags ) )
return NULL ;
ret = fgets ( password , sizeof ( password ) , stdin );
if ( tcsetattr ( fileno ( stdin ) , TCSAFLUSH , & oflags ) )
return NULL ;
if ( ret )
ret = strdup ( password );
return ret ;
if ( ! password )
if ( ! mysql_real_connect ( conn , server , user , password , database , 0 , NULL , 0 ) )
for (i = 1; i < argc; ++i)
arglen = strlen ( argv [ i ] );
fmtlen = strlen ( fmtString );
if ( arglen > SIZE_MAX / sizeof * query - fmtlen )
query = malloc ( ( arglen + fmtlen ) * sizeof * query );
if ( query == NULL )
sprintf ( query , fmtString , argv [ i ] );
if ( mysql_query ( conn , query ) )
free ( query );
free ( query );
1
------------------------------
310256 151639/aviobuf.c s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_ptr - s -> checksum_ptr ) ) ) 176
int avio_put_str16le(AVIOContext *s,const char *str)
const uint8_t * q = str ;
while ( * q )
uint32_t ch ;
uint16_t tmp ;
ch = ( * ( q ++ ) );
uint32_t top = ( ch & 128 ) >> 1 ;
if ( ( ch & 0xc0 ) == 0x80 )
while ( ch & top )
int tmp = ( * ( q ++ ) ) - 128 ;
if ( tmp >> 6 )
ch = ( ch << 6 ) + tmp;
top <<= 5;
ch &= ( top << 1 ) - 1;
uint32_t in = ch ;
if ( in < 0x10000 )
tmp = in;
avio_wl16 ( s , tmp );
void avio_wl16(AVIOContext *s,unsigned int val)
avio_w8 ( s , ( ( uint8_t ) val ) );
void avio_w8(AVIOContext *s,int b)
* ( s -> buf_ptr ++ ) = b;
if ( s -> buf_ptr >= s -> buf_end )
flush_buffer ( s );
static void flush_buffer(AVIOContext *s)
if ( s -> buf_ptr > s -> buffer )
if ( s -> update_checksum )
s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_ptr - s -> checksum_ptr ) ) );
s -> checksum_ptr = s -> buffer;
s -> buf_ptr = s -> buffer;
0
------------------------------
18510 CVE-2015-2716/Firefox_37.0b7_CVE_2015_2716_parser_expat_lib_xmlparse.c pool -> end = tem -> s + blockSize 6287
static ELEMENT_TYPE
getElementType(XML_Parser
const ENCODING
const char
const char *end)
DTD * const dtd = _dtd
const XML_Char * name = poolStoreString ( & dtd -> pool , enc , ptr , end ) ;
static XML_Char
poolStoreString(STRING_POOL *pool, const ENCODING
const char *ptr, const char *end)
if ( ! poolAppend ( pool , enc , ptr , end ) )
static XML_Char
poolAppend(STRING_POOL *pool, const ENCODING
const char *ptr, const char *end)
if ( ! pool -> ptr && ! poolGrow ( pool ) )
if ( ptr == end )
if ( ! poolGrow ( pool ) )
static XML_Bool
poolGrow(STRING_POOL *pool)
if ( pool -> freeBlocks )
if ( pool -> start == 0 )
if ( pool -> end - pool -> start < pool -> freeBlocks -> size )
if ( pool -> blocks && pool -> start == pool -> blocks -> s )
BLOCK * tem ;
int blockSize = ( int ) ( pool -> end - pool -> start ) ;
if ( blockSize < INIT_BLOCK_SIZE )
blockSize = INIT_BLOCK_SIZE;
blockSize *= 2;
tem = ( BLOCK * ) pool -> mem -> malloc_fcn ( offsetof ( BLOCK , s ) + blockSize * sizeof ( XML_Char ) );
if ( ! tem )
tem -> size = blockSize;
tem -> next = pool -> blocks;
pool -> blocks = tem;
if ( pool -> ptr != pool -> start )
memcpy ( tem -> s , pool -> start , ( pool -> ptr - pool -> start ) * sizeof ( XML_Char ) );
pool -> ptr = tem -> s + ( pool -> ptr - pool -> start );
pool -> start = tem -> s;
pool -> end = tem -> s + blockSize;
0
------------------------------
19347 CVE-2015-2726/Firefox_38.8.0esr_CVE_2015_2726_js_src_ctypes_CTypes.cpp * dstlenp = ( origDstlen - dstlen ) 166

CData::ValueSetter(JSContext* cx, JS::CallArgs args)
RootedObject obj ( cx , & args . thisv ( ) . toObject ( ) ) ;
return ImplicitConvert ( cx , args . get ( 0 ) , GetCType ( obj ) , GetData ( obj ) , false , nullptr ) ;
static
ImplicitConvert(JSContext*
HandleValue
JSObject*
void*
bool
bool* freePointer)
RootedObject targetType ( cx , targetType_ ) ;
JSObject * sourceData = nullptr ;
RootedObject valObj ( cx , nullptr ) ;
if ( val . isObject ( ) )
valObj = & val . toObject ( );
if ( CData :: IsCData ( valObj ) )
sourceData = valObj;
sourceType = CData :: GetCType ( sourceData );
if ( CType :: TypesEqual ( sourceType , targetType ) )
if ( CDataFinalizer :: IsCDataFinalizer ( valObj ) )
sourceData = valObj;
sourceType = CDataFinalizer :: GetCType ( cx , sourceData );
CDataFinalizer :: Private * p = ( CDataFinalizer :: Private * ) JS_GetPrivate ( sourceData ) ;
if ( ! p )
if ( CType :: TypesEqual ( sourceType , targetType ) )
TypeCode targetCode = CType :: GetTypeCode ( targetType ) ;
switch ( targetCode )
bool result ;
if ( ! jsvalToBool ( cx , val , & result ) )
* static_cast < bool * > ( buffer ) = result
type result ;
type result ;
type result ;
if ( ! jsvalToFloat ( cx , val , & result ) )
* static_cast < type * > ( buffer ) = result
if ( val . isNull ( ) )
* static_cast < void * * > ( buffer ) = nullptr
JS :: Rooted < JSObject * > baseType ( cx , PointerType :: GetBaseType ( targetType ) ) ;
if ( sourceData )
if ( isArgument && val . isString ( ) )
JSString * sourceString = val . toString ( ) ;
JSLinearString * sourceLinear = sourceString -> ensureLinear ( cx ) ;
if ( ! sourceLinear )
switch ( CType :: GetTypeCode ( baseType ) )
size_t nbytes = GetDeflatedUTF8StringLength ( cx , sourceLinear ) ;
if ( nbytes == ( size_t ) - 1 )
char * * charBuffer = static_cast < char * * > buffer
* charBuffer = cx -> pod_malloc < char > ( nbytes + 1 );
if ( ! * charBuffer )
ASSERT_OK ( DeflateStringToUTF8Buffer ( cx , sourceLinear , * charBuffer , & nbytes ) );
template <typename

DeflateStringToUTF8Buffer(JSContext* maybecx, const CharT* src, size_t
char* dst, size_t* dstlenp)
size_t i , utf8Len ;
char16_t c , c2 ;
uint32_t v ;
uint8_t utf8buf [ 6 ] ;
size_t dstlen = * dstlenp ;
size_t origDstlen = dstlen ;
while ( srclen )
c = * src ++;
srclen --;
if ( c >= 0xDC00 && c <= 0xDFFF )
if ( c < 0xD800 || c > 0xDBFF )
v = c;
if ( srclen < 1 )
c2 = * src;
if ( ( c2 < 0xDC00 ) || ( c2 > 0xDFFF ) )
src ++;
srclen --;
v = ( ( c - 0xD800 ) << 10 ) + ( c2 - 0xDC00 ) + 0x10000;
if ( v < 0x0080 )
if ( dstlen == 0 )
utf8Len = 1;
utf8Len = js_OneUcs4ToUtf8Char ( utf8buf , v );
if ( utf8Len > dstlen )
dstlen -= utf8Len;
* dstlenp = ( origDstlen - dstlen );
* dstlenp = ( origDstlen - dstlen );
0
------------------------------
311638 149958/aviobuf.c s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_ptr - s -> checksum_ptr ) ) ) 277
void ff_put_v(AVIOContext *bc,uint64_t val)
avio_w8 ( bc , ( val & 127 ) );
void avio_w8(AVIOContext *s,int b)
* ( s -> buf_ptr ++ ) = b;
if ( s -> buf_ptr >= s -> buf_end )
flush_buffer ( s );
static void flush_buffer(AVIOContext *s)
if ( s -> buf_ptr > s -> buffer )
if ( s -> update_checksum )
s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_ptr - s -> checksum_ptr ) ) );
s -> checksum_ptr = s -> buffer;
s -> buf_ptr = s -> buffer;
0
------------------------------
18566 CVE-2015-2716/Firefox_37.0b7_CVE_2015_2716_parser_expat_lib_xmlparse.c pool -> ptr = tem -> s + ( pool -> ptr - pool -> start ) 6285
static enum
storeEntityValue(XML_Parser
const ENCODING
const char
const char *entityTextEnd)
DTD * const dtd = _dtd
STRING_POOL * pool = & ( dtd -> entityValuePool ) ;
if ( ! pool -> blocks )
if ( ! poolGrow ( pool ) )
const char * next ;
int tok = XmlEntityValueTok ( enc , entityTextPtr , entityTextEnd , & next ) ;
switch ( tok )
if ( isParamEntity || enc != encoding )
const XML_Char * name ;
ENTITY * entity ;
name = poolStoreString ( & tempPool , enc , entityTextPtr + enc -> minBytesPerChar , next - enc -> minBytesPerChar );
if ( ! name )
entity = ( ENTITY * ) lookup ( & dtd -> paramEntities , name , 0 );
if ( ! entity )
if ( entity -> open )
if ( entity -> systemId )
if ( externalEntityRefHandler )
entity -> open = XML_TRUE;
if ( ! externalEntityRefHandler ( externalEntityRefHandlerArg , 0 , entity -> base , entity -> systemId , entity -> publicId ) )
entity -> open = XML_FALSE;
entity -> open = XML_TRUE;
result = storeEntityValue ( parser , internalEncoding , ( char * ) entity -> textPtr , ( char * ) ( entity -> textPtr + entity -> textLen ) );
entity -> open = XML_FALSE;
if ( result )
if ( ! poolAppend ( pool , enc , entityTextPtr , next ) )
next = entityTextPtr + enc -> minBytesPerChar;
if ( pool -> end == pool -> ptr && ! poolGrow ( pool ) )
* ( pool -> ptr ) ++ = 0xA;
XML_Char buf [ XML_ENCODE_MAX ] ;
int i ;
int n = XmlCharRefNumber ( enc , entityTextPtr ) ;
if ( n < 0 )
n = XmlEncode ( n , ( ICHAR * ) buf );
if ( ! n )
for (i = 0; i < n; i++)
if ( pool -> end == pool -> ptr && ! poolGrow ( pool ) )
* ( pool -> ptr ) ++ = buf [ i ];
entityTextPtr = next;
static enum
storeEntityValue(XML_Parser
const ENCODING
const char
const char *entityTextEnd)
DTD * const dtd = _dtd
STRING_POOL * pool = & ( dtd -> entityValuePool ) ;
if ( ! pool -> blocks )
if ( ! poolGrow ( pool ) )
const char * next ;
int tok = XmlEntityValueTok ( enc , entityTextPtr , entityTextEnd , & next ) ;
switch ( tok )
if ( isParamEntity || enc != encoding )
const XML_Char * name ;
ENTITY * entity ;
name = poolStoreString ( & tempPool , enc , entityTextPtr + enc -> minBytesPerChar , next - enc -> minBytesPerChar );
if ( ! name )
entity = ( ENTITY * ) lookup ( & dtd -> paramEntities , name , 0 );
if ( ! entity )
if ( entity -> open )
if ( entity -> systemId )
if ( externalEntityRefHandler )
entity -> open = XML_TRUE;
if ( ! externalEntityRefHandler ( externalEntityRefHandlerArg , 0 , entity -> base , entity -> systemId , entity -> publicId ) )
entity -> open = XML_FALSE;
entity -> open = XML_TRUE;
result = storeEntityValue ( parser , internalEncoding , ( char * ) entity -> textPtr , ( char * ) ( entity -> textPtr + entity -> textLen ) );
entity -> open = XML_FALSE;
if ( result )
if ( ! poolAppend ( pool , enc , entityTextPtr , next ) )
next = entityTextPtr + enc -> minBytesPerChar;
if ( pool -> end == pool -> ptr && ! poolGrow ( pool ) )
* ( pool -> ptr ) ++ = 0xA;
XML_Char buf [ XML_ENCODE_MAX ] ;
int i ;
int n = XmlCharRefNumber ( enc , entityTextPtr ) ;
if ( n < 0 )
n = XmlEncode ( n , ( ICHAR * ) buf );
if ( ! n )
if ( pool -> end == pool -> ptr && ! poolGrow ( pool ) )
* ( pool -> ptr ) ++ = buf [ i ];
entityTextPtr = next;
static XML_Char
poolAppend(STRING_POOL *pool, const ENCODING
const char *ptr, const char *end)
if ( ! pool -> ptr && ! poolGrow ( pool ) )
if ( ptr == end )
if ( ! poolGrow ( pool ) )
static XML_Bool
poolGrow(STRING_POOL *pool)
if ( pool -> freeBlocks )
if ( pool -> start == 0 )
if ( pool -> end - pool -> start < pool -> freeBlocks -> size )
if ( pool -> blocks && pool -> start == pool -> blocks -> s )
BLOCK * tem ;
int blockSize = ( int ) ( pool -> end - pool -> start ) ;
if ( blockSize < INIT_BLOCK_SIZE )
blockSize = INIT_BLOCK_SIZE;
blockSize *= 2;
tem = ( BLOCK * ) pool -> mem -> malloc_fcn ( offsetof ( BLOCK , s ) + blockSize * sizeof ( XML_Char ) );
if ( ! tem )
tem -> size = blockSize;
tem -> next = pool -> blocks;
pool -> blocks = tem;
if ( pool -> ptr != pool -> start )
memcpy ( tem -> s , pool -> start , ( pool -> ptr - pool -> start ) * sizeof ( XML_Char ) );
pool -> ptr = tem -> s + ( pool -> ptr - pool -> start );
pool -> start = tem -> s;
pool -> end = tem -> s + blockSize;
0
------------------------------
305845 117454/CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_rand_67b.c myString = ( wchar_t * ) malloc ( data * sizeof ( wchar_t ) ) 43
void CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_rand_67_bad()
size_t data ;
CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_rand_67_structType myStruct ;
data = 0;
data = rand ( );
myStruct . structFirst = data;
CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_rand_67b_badSink ( myStruct );
void CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_rand_67b_badSink(CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_rand_67_structType myStruct)
size_t data = myStruct . structFirst ;
wchar_t * myString ;
if ( data > wcslen ( HELLO_STRING ) )
myString = ( wchar_t * ) malloc ( data * sizeof ( wchar_t ) );
wcscpy ( myString , HELLO_STRING );
printWLine ( myString );
void printWLine (const wchar_t * line)
if ( line != NULL )
wprintf ( L "%ls\n" , line )
free ( myString );
1
------------------------------
311349 152169/aviobuf.c s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_ptr - s -> checksum_ptr ) ) ) 172
int avio_put_str16le(AVIOContext *s,const char *str)
const uint8_t * q = str ;
while ( * q )
uint32_t ch ;
uint16_t tmp ;
ch = ( * ( q ++ ) );
uint32_t top = ( ch & 128 ) >> 1 ;
if ( ( ch & 0xc0 ) == 0x80 )
while ( ch & top )
int tmp = ( * ( q ++ ) ) - 128 ;
if ( tmp >> 6 )
ch = ( ch << 6 ) + tmp;
top <<= 5;
ch &= ( top << 1 ) - 1;
uint32_t in = ch ;
if ( in < 0x10000 )
tmp = ( 0xD800 | in - 0x10000 >> 10 );
avio_wl16 ( s , tmp );
void avio_wl16(AVIOContext *s,unsigned int val)
avio_w8 ( s , ( ( uint8_t ) val ) );
void avio_w8(AVIOContext *s,int b)
* ( s -> buf_ptr ++ ) = b;
if ( s -> buf_ptr >= s -> buf_end )
flush_buffer ( s );
static void flush_buffer(AVIOContext *s)
if ( s -> buf_ptr > s -> buffer )
if ( s -> update_checksum )
s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_ptr - s -> checksum_ptr ) ) );
s -> checksum_ptr = s -> buffer;
s -> buf_ptr = s -> buffer;
0
------------------------------
20884 CVE-2016-7425/linux_kernel_4.8.2_CVE_2016_7425_drivers_scsi_arcmsr_arcmsr_hba.c pARCMSR_CDB = ( struct ARCMSR_CDB * ) ( acb -> vir2phy_offset + ccb_cdb_phy ) 1286
static int arcmsr_bus_reset(struct scsi_cmnd *cmd)
struct AdapterControlBlock * acb ;
acb = ( struct AdapterControlBlock * ) cmd -> device -> host -> hostdata;
acb -> num_resets ++;
switch ( acb -> adapter_type )
if ( acb -> acb_flags & ACB_F_BUS_RESET )
long timeout ;
timeout = wait_event_timeout ( wait_q , ( acb -> acb_flags & ACB_F_BUS_RESET ) == 0 , 220 * HZ );
if ( timeout )
acb -> acb_flags |= ACB_F_BUS_RESET;
if ( ! arcmsr_iop_reset ( acb ) )
static uint8_t arcmsr_iop_reset(struct AdapterControlBlock *acb)
if ( atomic_read ( & acb -> ccboutstandingcount ) != 0 )
arcmsr_done4abort_postqueue ( acb );
static void arcmsr_done4abort_postqueue(struct AdapterControlBlock *acb)
int i = 0 ;
uint32_t flag_ccb , ccb_cdb_phy ;
struct ARCMSR_CDB * pARCMSR_CDB ;
switch ( acb -> adapter_type )
struct MessageUnit_A __iomem * reg = acb -> pmuA ;
while ( ( ( flag_ccb = readl ( & reg -> outbound_queueport ) ) != 0xFFFFFFFF ) && ( i ++ < ARCMSR_MAX_OUTSTANDING_CMD ) )
struct MessageUnit_B * reg = acb -> pmuB ;
for (i = 0; i < ARCMSR_MAX_HBB_POSTQUEUE; i++)
flag_ccb = reg -> done_qbuffer [ i ];
if ( flag_ccb != 0 )
reg -> done_qbuffer [ i ] = 0;
reg -> post_qbuffer [ i ] = 0;
reg -> doneq_index = 0;
reg -> postq_index = 0;
struct MessageUnit_C __iomem * reg = acb -> pmuC ;
while ( ( readl ( & reg -> host_int_status ) & ARCMSR_HBCMU_OUTBOUND_POSTQUEUE_ISR ) && ( i ++ < ARCMSR_MAX_OUTSTANDING_CMD ) )
flag_ccb = readl ( & reg -> outbound_queueport_low );
ccb_cdb_phy = ( flag_ccb & 0xFFFFFFF0 );
struct MessageUnit_D * pmu = acb -> pmuD ;
uint32_t outbound_write_pointer ;
uint32_t doneq_index , index_stripped , addressLow , residual , toggle ;
residual = atomic_read ( & acb -> ccboutstandingcount );
for (i = 0; i < residual; i++)
outbound_write_pointer = pmu -> done_qbuffer [ 0 ] . addressLow + 1;
doneq_index = pmu -> doneq_index;
if ( ( doneq_index & 0xFFF ) != ( outbound_write_pointer & 0xFFF ) )
toggle = doneq_index & 0x4000;
index_stripped = ( doneq_index & 0xFFF ) + 1;
index_stripped %= ARCMSR_MAX_ARC1214_DONEQUEUE;
pmu -> doneq_index = index_stripped ? ( index_stripped | toggle ) : ( ( toggle ^ 0x4000 ) + 1 );
doneq_index = pmu -> doneq_index;
addressLow = pmu -> done_qbuffer [ doneq_index & 0xFFF ] . addressLow;
ccb_cdb_phy = ( addressLow & 0xFFFFFFF0 );
pARCMSR_CDB = ( struct ARCMSR_CDB * ) ( acb -> vir2phy_offset + ccb_cdb_phy );
pCCB = container_of ( pARCMSR_CDB
struct CommandControlBlock , arcmsr_cdb )
arcmsr_drain_donequeue ( acb , pCCB , error );
0
------------------------------
303756 79273/CWE134_Uncontrolled_Format_String__char_connect_socket_vfprintf_53a.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 92
void CWE134_Uncontrolled_Format_String__char_connect_socket_vfprintf_53_bad()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
CWE134_Uncontrolled_Format_String__char_connect_socket_vfprintf_53b_badSink ( data );
void CWE134_Uncontrolled_Format_String__char_connect_socket_vfprintf_53b_badSink(char * data)
CWE134_Uncontrolled_Format_String__char_connect_socket_vfprintf_53c_badSink ( data );
void CWE134_Uncontrolled_Format_String__char_connect_socket_vfprintf_53c_badSink(char * data)
CWE134_Uncontrolled_Format_String__char_connect_socket_vfprintf_53d_badSink ( data );
void CWE134_Uncontrolled_Format_String__char_connect_socket_vfprintf_53d_badSink(char * data)
badVaSink ( data , data );
static void badVaSink(char * data, ...)
va_start ( args , data );
vfprintf ( stdout , data , args );
0
------------------------------
17007 CVE-2013-0868/CVE_2013_0868_VULN_generate_joint_tables.c len [ i ] = len0 + len1 18
static void CVE_2013_0868_VULN_generate_joint_tables(HYuvContext *s)
uint16_t symbols [ 1 << VLC_BITS ] ;
uint16_t bits [ 1 << VLC_BITS ] ;
uint8_t len [ 1 << VLC_BITS ] ;
if ( s -> bitstream_bpp < 24 )
int p , i , y , u ;
for (p = 0; p < 3; p++)
for (i = y = 0; y < 256; y++)
int len0 = s -> len [ 0 ] [ y ] ;
int limit = VLC_BITS - len0 ;
if ( limit <= 0 )
for (u = 0; u < 256; u++)
int len1 = s -> len [ p ] [ u ] ;
if ( len1 > limit )
len [ i ] = len0 + len1;
bits [ i ] = ( s -> bits [ 0 ] [ y ] << len1 ) + s -> bits [ p ] [ u ];
symbols [ i ] = ( y << 8 ) + u;
if ( symbols [ i ] != 0xffff )
i ++;
1
------------------------------
310666 148895/packet-per.c val_start = ( offset - num_bits ) >> 3 1238

dissect_per_IA5String(tvbuff_t *tvb, guint32 offset, asn1_ctx_t *actx, proto_tree *tree, int hf_index, int min_len, int max_len, gboolean has_extension)
offset = dissect_per_restricted_character_string_sorted ( tvb , offset , actx , tree , hf_index , min_len , max_len , has_extension , NULL , 128 , NULL );
static
dissect_per_restricted_character_string_sorted(tvbuff_t *tvb, guint32 offset, asn1_ctx_t *actx, proto_tree *tree, int hf_index, int min_len, int max_len, gboolean has_extension _U_,const char *alphabet, int alphabet_length, tvbuff_t **value_tvb)
guint32 length ;
if ( max_len == 0 )
if ( min_len == NO_BOUND )
min_len = 0;
if ( has_extension )
gboolean extension_present ;
offset = dissect_per_boolean ( tvb , offset , actx , tree , hf_per_extension_present_bit , & extension_present );
if ( extension_present )
min_len = NO_BOUND;
max_len = NO_BOUND;
length = max_len;
if ( max_len == NO_BOUND )
if ( min_len != max_len )
offset = dissect_per_constrained_integer ( tvb , offset , actx , tree , hf_per_octet_string_length , min_len , max_len , & length , FALSE );

dissect_per_constrained_integer(tvbuff_t *tvb, guint32 offset, asn1_ctx_t *actx, proto_tree *tree, int hf_index, guint32 min, guint32 max, guint32 *value, gboolean has_extension)
guint32 range , val ;
gint val_start , val_length ;
int num_bits ;
if ( has_extension )
gboolean extension_present ;
offset = dissect_per_boolean ( tvb , offset , actx , tree , hf_per_extension_present_bit , & extension_present );
if ( extension_present )
if ( ( ( max - min ) > 65536 ) && ( actx -> aligned ) )
range = 1000000;
if ( ( max == 0x7fffffff && min == 0x80000000 ) || ( max == 0xffffffff && min == 0x00000000 ) )
range = 0xffffffff;
range = max - min + 1;
if ( range == 1 )
if ( ( range <= 255 ) || ( ! actx -> aligned ) )
int i , bit , length ;
guint32 mask , mask2 ;
mask = 0x80000000;
mask2 = 0x7fffffff;
i = 32;
while ( ( range & mask ) == 0 )
i = i - 1;
mask = mask >> 1;
mask2 = mask2 >> 1;
if ( ( range & mask2 ) == 0 )
i = i - 1;
num_bits = i;
if ( range <= 2 )
num_bits = 1;
for(i=0;i<num_bits;i++)
offset = dissect_per_boolean ( tvb , offset , actx , tree , - 1 , & tmp );
val_start = ( offset - num_bits ) >> 3;
proto_tree_add_text ( tree , tvb , val_start , val_length , "Range = %u Bitfield length %u, %s" , range , num_bits , str );
it = proto_tree_add_uint ( tree , hf_index , tvb , val_start , val_length , val );
per_check_value ( val , min , max , actx , it , FALSE );
it = proto_tree_add_int ( tree , hf_index , tvb , val_start , val_length , val );
per_check_value ( val , min , max , actx , it , TRUE );
it = proto_tree_add_time ( tree , hf_index , tvb , val_start , val_length , & timeval );
actx -> created_item = it;
0
------------------------------
310237 151639/aviobuf.c s -> buf_end = s -> buffer + buffer_size 143
int avio_open_dyn_buf(AVIOContext **s)
return url_open_dyn_buf_internal ( s , 0 ) ;
static int url_open_dyn_buf_internal(AVIOContext **s,int max_packet_size)
DynBuffer * d ;
unsigned int io_buffer_size = ( max_packet_size ? max_packet_size : 1024 ) ;
if ( sizeof ( DynBuffer ) + io_buffer_size < io_buffer_size )
d = ( av_mallocz ( sizeof ( DynBuffer ) + io_buffer_size ) );
if ( ! d )
d -> io_buffer_size = io_buffer_size;
* s = avio_alloc_context ( d -> io_buffer , d -> io_buffer_size , 1 , d , ( ( void * ) 0 ) , ( max_packet_size ? dyn_packet_buf_write : dyn_buf_write ) , ( max_packet_size ? ( ( void * ) 0 ) : dyn_buf_seek ) );
AVIOContext *avio_alloc_context(unsigned char *buffer,int buffer_size,int write_flag,void *opaque,int (*read_packet)(void *, uint8_t *, int ),int (*write_packet)(void *, uint8_t *, int ),int64_t (*seek)(void *, int64_t , int ))
AVIOContext * s = ( av_mallocz ( sizeof ( AVIOContext ) ) ) ;
if ( ! s )
ffio_init_context ( s , buffer , buffer_size , write_flag , opaque , read_packet , write_packet , seek );
int ffio_init_context(AVIOContext *s,unsigned char *buffer,int buffer_size,int write_flag,void *opaque,int (*read_packet)(void *, uint8_t *, int ),int (*write_packet)(void *, uint8_t *, int ),int64_t (*seek)(void *, int64_t , int ))
s -> buffer = buffer;
s -> buffer_size = buffer_size;
s -> buf_ptr = buffer;
s -> opaque = opaque;
s -> direct = 0;
s -> write_packet = write_packet;
s -> read_packet = read_packet;
s -> seek = seek;
s -> pos = 0;
s -> must_flush = 0;
s -> eof_reached = 0;
s -> error = 0;
s -> seekable = 0x1;
s -> max_packet_size = 0;
s -> update_checksum = ( ( void * ) 0 );
if ( ! read_packet && ! write_flag )
s -> pos = buffer_size;
s -> buf_end = s -> buffer + buffer_size;
s -> read_pause = ( ( void * ) 0 );
s -> read_seek = ( ( void * ) 0 );
0
------------------------------
300419 152811/oids.c subid_overflow = subids + n 1094
void oid_both_from_encoded(const guint8 *oid,gint oid_len,char **resolved_p,char **numeric_p)
guint subids_len = oid_encoded2subid ( oid , oid_len , & subids ) ;
guint oid_encoded2subid(const guint8 *oid_bytes,gint oid_len,guint32 **subids_p)
gint i ;
guint n = 1 ;
guint32 * subids ;
guint32 * subid_overflow ;
for (i = 0; i < oid_len; i++)
if ( ! ( oid_bytes [ i ] & 0x0080 ) )
n ++;
* subids_p = subids = ( ep_alloc ( sizeof ( guint32 ) * n ) );
subid_overflow = subids + n;
if ( subids >= subid_overflow || subid > 0xffffffff )
0
------------------------------
298671 95367/CWE369_Divide_by_Zero__int_rand_divide_32.c printIntLine ( 100 / data ) 38
void CWE369_Divide_by_Zero__int_rand_divide_32_bad()
int data ;
int * dataPtr2 = & data ;
data = - 1;
data = RAND32 ( );
int data = * dataPtr2 ;
printIntLine ( 100 / data );
1
------------------------------
313234 90770/CWE23_Relative_Path_Traversal__char_listen_socket_w32CreateFile_66a.cpp recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ) 106
void bad()
char * data ;
char dataBuffer [ FILENAME_MAX ] = BASEPATH ;
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
dataArray [ 2 ] = data;
badSink ( dataArray );
void badSink(char * dataArray[])
char * data = dataArray [ 2 ] ;
hFile = CreateFileA ( data , ( GENERIC_WRITE | GENERIC_READ ) , 0 , NULL , OPEN_ALWAYS , FILE_ATTRIBUTE_NORMAL , NULL );
if ( hFile != INVALID_HANDLE_VALUE )
CloseHandle ( hFile );
0
------------------------------
313651 89733/CWE23_Relative_Path_Traversal__char_connect_socket_open_10.cpp recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ) 103
void bad()
char * data ;
char dataBuffer [ FILENAME_MAX ] = BASEPATH ;
data = dataBuffer;
if ( globalTrue )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
fileDesc = OPEN ( data , O_RDWR | O_CREAT , S_IREAD | S_IWRITE );
if ( fileDesc != - 1 )
CLOSE ( fileDesc );
1
------------------------------
304488 83967/CWE190_Integer_Overflow__short_fscanf_square_61a.c short result = data * data ; 69
static void goodB2G()
short data ;
data = 0;
data = CWE190_Integer_Overflow__short_fscanf_square_61b_goodB2GSource ( data );
short CWE190_Integer_Overflow__short_fscanf_square_61b_goodB2GSource(short data)
return data ;
if ( abs ( ( long ) data ) <= ( long ) sqrt ( ( double ) SHRT_MAX ) )
short result = data * data ;
printIntLine ( result );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
0
------------------------------
298246 95154/CWE369_Divide_by_Zero__int_fscanf_divide_01.c printIntLine ( 100 / data ) 60
static void goodB2G()
int data ;
data = - 1;
if ( data != 0 )
printIntLine ( 100 / data );
0
------------------------------
307394 110569/CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_rand_18.c intPointer = ( int * ) malloc ( data * sizeof ( int ) ) 35
void CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_rand_18_bad()
int data ;
data = - 1;
data = RAND32 ( );
int * intPointer ;
intPointer = ( int * ) malloc ( data * sizeof ( int ) );
intPointer [ i ] = 0;
printIntLine ( intPointer [ 0 ] );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
free ( intPointer );
1
------------------------------
302459 79185/CWE134_Uncontrolled_Format_String__char_connect_socket_printf_67a.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 196
static void goodB2G()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
myStruct . structFirst = data;
CWE134_Uncontrolled_Format_String__char_connect_socket_printf_67b_goodB2GSink ( myStruct );
void CWE134_Uncontrolled_Format_String__char_connect_socket_printf_67b_goodB2GSink(CWE134_Uncontrolled_Format_String__char_connect_socket_printf_67_structType myStruct)
char * data = myStruct . structFirst ;
printf ( "%s\n" , data );
0
------------------------------
16478 CVE-2014-4608/CVE_2014_4608_PATCHED_lzo1x_decompress_safe.c * out_len = op - out 193
int CVE_2014_4608_PATCHED_lzo1x_decompress_safe(const unsigned char *in, size_t
unsigned char *out, size_t *out_len)
unsigned char * op ;
const unsigned char * ip ;
size_t t , next ;
size_t state = 0 ;
const unsigned char * m_pos ;
op = out;
ip = in;
if ( unlikely ( in_len < 3 ) )
if ( * ip > 17 )
t = * ip ++ - 17;
if ( t < 4 )
next = t;
t = * ip ++;
if ( t < 16 )
if ( likely ( state == 0 ) )
if ( unlikely ( t == 0 ) )
while ( unlikely ( * ip == 0 ) )
t += 255;
ip ++;
t += 15 + * ip ++;
t += 3;
if ( likely ( HAVE_IP ( t , 15 ) && HAVE_OP ( t , 15 ) ) )
const unsigned char * ie = ip + t ;
unsigned char * oe = op + t ;
ip = ie;
op = oe;
* op ++ = * ip ++;
while ( -- t > 0 )
state = 4;
if ( state != 4 )
next = t & 3;
m_pos = op - 1;
m_pos -= t >> 2;
m_pos -= * ip ++ << 2;
op [ 0 ] = m_pos [ 0 ];
op [ 1 ] = m_pos [ 1 ];
op += 2;
next = t & 3;
m_pos = op - ( 1 + M2_MAX_OFFSET );
m_pos -= t >> 2;
m_pos -= * ip ++ << 2;
t = 3;
if ( t >= 64 )
next = t & 3;
m_pos = op - 1;
m_pos -= ( t >> 2 ) & 7;
m_pos -= * ip ++ << 3;
t = ( t >> 5 ) - 1 + ( 3 - 1 );
if ( t >= 32 )
t = ( t & 31 ) + ( 3 - 1 );
if ( unlikely ( t == 2 ) )
while ( unlikely ( * ip == 0 ) )
t += 255;
ip ++;
t += 31 + * ip ++;
m_pos = op - 1;
next = get_unaligned_le16 ( ip );
ip += 2;
m_pos -= next >> 2;
next &= 3;
m_pos = op;
m_pos -= ( t & 8 ) << 11;
t = ( t & 7 ) + ( 3 - 1 );
if ( unlikely ( t == 2 ) )
while ( unlikely ( * ip == 0 ) )
t += 255;
ip ++;
t += 7 + * ip ++;
next = get_unaligned_le16 ( ip );
ip += 2;
m_pos -= next >> 2;
next &= 3;
if ( m_pos == op )
m_pos -= 0x4000;
if ( op - m_pos >= 8 )
unsigned char * oe = op + t ;
if ( likely ( HAVE_OP ( t , 15 ) ) )
op += 8;
op += 8;
while ( op < oe )
op = oe;
if ( HAVE_IP ( 6 , 0 ) )
state = next;
op += next;
ip += next;
* op ++ = * m_pos ++;
while ( op < oe )
unsigned char * oe = op + t ;
op [ 0 ] = m_pos [ 0 ];
op [ 1 ] = m_pos [ 1 ];
op += 2;
m_pos += 2;
* op ++ = * m_pos ++;
while ( op < oe )
state = next;
t = next;
if ( likely ( HAVE_IP ( 6 , 0 ) && HAVE_OP ( 4 , 0 ) ) )
op += t;
ip += t;
while ( t > 0 )
* op ++ = * ip ++;
t --;
* out_len = op - out;
* out_len = op - out;
0
------------------------------
303774 82784/CWE190_Integer_Overflow__int64_t_max_square_03.c int64_t result = data * data ; 37
void CWE190_Integer_Overflow__int64_t_max_square_03_bad()
int64_t data ;
data = 0L L
if ( 5 == 5 )
data = LLONG_MAX;
if ( 5 == 5 )
int64_t result = data * data ;
printLongLongLine ( result );
void printLongLongLine (int64_t longLongIntNumber)
printf ( "%lld\n" , longLongIntNumber );
1
------------------------------
20441 CVE-2016-4805/linux_kernel_4.2.5_CVE_2016_4805_drivers_net_ppp_ppp_generic.c q = skb_put ( frag , flen + hdrlen ) 1586
static
ppp_start_xmit(struct sk_buff *skb, struct net_device *dev)
struct ppp * ppp = netdev_priv ( dev ) ;
int npi , proto ;
npi = ethertype_to_npindex ( ntohs ( skb -> protocol ) );
static inline int ethertype_to_npindex(int ethertype)
switch ( ethertype )
return NP_IP ;
return NP_IPV6 ;
return NP_IPX ;
return NP_AT ;
return NP_MPLS_UC ;
return NP_MPLS_MC ;
return - 1 ;
if ( npi < 0 )
switch ( ppp -> npmode [ npi ] )
if ( skb_cow_head ( skb , PPP_HDRLEN ) )
ppp_xmit_process ( ppp );
static
ppp_xmit_process(struct ppp *ppp)
if ( ! ppp -> closing )
ppp_push ( ppp );
static
ppp_push(struct ppp *ppp)
struct list_head * list ;
struct sk_buff * skb = ppp -> xmit_pending ;
if ( ! skb )
list = & ppp -> channels;
if ( list_empty ( list ) )
if ( ( ppp -> flags & SC_MULTILINK ) == 0 )
if ( ! ppp_mp_explode ( ppp , skb ) )
static int ppp_mp_explode(struct ppp *ppp, struct sk_buff *skb)
int len , totlen ;
int i , bits , hdrlen , mtu ;
int flen ;
int navail , nfree , nzero ;
int nbigger ;
int totspeed ;
int totfree ;
unsigned char * p , * q ;
struct list_head * list ;
struct channel * pch ;
struct sk_buff * frag ;
totspeed = 0;
nfree = 0;
navail = 0;
nzero = 0;
totfree = 0;
hdrlen = ( ppp -> flags & SC_MP_XSHORTSEQ ) ? MPHDRLEN_SSN : MPHDRLEN;
i = 0;
if ( pch -> chan )
pch -> avail = 1;
navail ++;
pch -> speed = pch -> chan -> speed;
pch -> avail = 0;
if ( pch -> avail )
if ( skb_queue_empty ( & pch -> file . xq ) || ! pch -> had_frag )
if ( pch -> speed == 0 )
nzero ++;
totspeed += pch -> speed;
pch -> avail = 2;
if ( ! pch -> had_frag && i < ppp -> nxchan )
ppp -> nxchan = i;
if ( nfree == 0 || nfree < navail / 2 )
len = skb -> len;
totlen = len;
nbigger = len % nfree;
list = & ppp -> channels;
for (i = 0; i < ppp->nxchan; ++i)
list = list -> next;
if ( list == & ppp -> channels )
while ( len > 0 )
list = list -> next;
if ( list == & ppp -> channels )
pch = list_entry ( list , struct channel , clist )
if ( ! pch -> avail )
if ( pch -> avail == 1 )
if ( nfree > 0 )
pch -> avail = 1;
if ( pch -> chan == NULL )
if ( pch -> speed == 0 )
nzero --;
totspeed -= pch -> speed;
pch -> avail = 0;
totlen = len;
totfree --;
nfree --;
if ( -- navail == 0 )
flen = len;
if ( nfree > 0 )
if ( pch -> speed == 0 )
flen = len / nfree;
if ( nbigger > 0 )
flen ++;
nbigger --;
flen = ( ( ( totfree - nzero ) * ( totlen + hdrlen * totfree ) ) / ( ( totspeed * totfree ) / pch -> speed ) ) - hdrlen;
if ( nbigger > 0 )
flen += ( ( totfree - nzero ) * pch -> speed ) / totspeed;
nbigger -= ( ( totfree - nzero ) * pch -> speed ) / totspeed;
nfree --;
if ( ( nfree <= 0 ) || ( flen > len ) )
flen = len;
if ( flen <= 0 )
pch -> avail = 2;
mtu = pch -> chan -> mtu - ( hdrlen - 2 );
if ( mtu < 4 )
mtu = 4;
if ( flen > mtu )
flen = mtu;
frag = alloc_skb ( flen + hdrlen + ( flen == 0 ) , GFP_ATOMIC );
if ( ! frag )
q = skb_put ( frag , flen + hdrlen );
put_unaligned_be16 ( PPP_MP , q );
q [ 2 ] = bits + ( ( ppp -> nxseq >> 8 ) & 0xf );
q [ 3 ] = ppp -> nxseq;
q [ 2 ] = bits;
q [ 3 ] = ppp -> nxseq >> 16;
q [ 4 ] = ppp -> nxseq >> 8;
q [ 5 ] = ppp -> nxseq;
memcpy ( q + hdrlen , p , flen );
pch -> had_frag = 1;
len -= flen;
0
------------------------------
310567 148892/packet-assa_r3.c fn = val_to_str_ext_const ( tvb_get_guint8 ( tvb , start_offset + i + 1 ) , & r3_checksumresultnames_ext , "[Unknown Field Name]" ) 5341
static void dissect_r3_upstreammfgfield_checksumresults (tvbuff_t *tvb, guint32 start_offset, guint32 length _U_, packet_info *pinfo, proto_tree *tree)
guint32 l = tvb_length_remaining ( tvb , start_offset ) ;
guint32 i ;
if ( l % 3 != 0 )
for (i = start_offset; i < l; i += tvb_get_guint8 (tvb, start_offset + i))
for (i = 0; i < l; i += tvb_get_guint8 (tvb, start_offset + i))
const gchar * fn ;
fn = val_to_str_ext_const ( tvb_get_guint8 ( tvb , start_offset + i + 1 ) , & r3_checksumresultnames_ext , "[Unknown Field Name]" );
proto_item_append_text ( res_item , " %s (%s)" , fn , tvb_get_guint8 ( tvb , start_offset + i + 2 ) ? "Error" : "No Error" );
0
------------------------------
305480 94968/CWE369_Divide_by_Zero__int_connect_socket_divide_07.c printIntLine ( 100 / data ) 324
static void goodG2B2()
int data ;
data = - 1;
if ( staticFive == 5 )
data = 7;
if ( staticFive == 5 )
printIntLine ( 100 / data );
0
------------------------------
309017 117212/CWE789_Uncontrolled_Mem_Alloc__malloc_char_rand_65b.c myString = ( char * ) malloc ( data * sizeof ( char ) ) 64
void CWE789_Uncontrolled_Mem_Alloc__malloc_char_rand_65b_goodG2BSink(size_t data)
char * myString ;
if ( data > strlen ( HELLO_STRING ) )
myString = ( char * ) malloc ( data * sizeof ( char ) );
strcpy ( myString , HELLO_STRING );
printLine ( myString );
void printLine (const char * line)
if ( line != NULL )
printf ( "%s\n" , line );
free ( myString );
0
------------------------------
304791 79133/CWE134_Uncontrolled_Format_String__char_connect_socket_fprintf_63a.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 91
void CWE134_Uncontrolled_Format_String__char_connect_socket_fprintf_63_bad()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
CWE134_Uncontrolled_Format_String__char_connect_socket_fprintf_63b_badSink ( & data );
void CWE134_Uncontrolled_Format_String__char_connect_socket_fprintf_63b_badSink(char * * dataPtr)
char * data = * dataPtr ;
fprintf ( stdout , data );
0
------------------------------
310937 151420/gimpdisplay.c x2 = ( x + w > image_width ? image_width : ( ( x + w < 0 ? 0 : x + w ) ) ) 1280
static void gimp_display_flush_whenever(GimpDisplay *display,gboolean now)
GimpDisplayPrivate * private = ( GimpDisplayPrivate * ) ( g_type_instance_get_private ( ( ( GTypeInstance * ) display ) , gimp_display_get_type ( ) ) ) ;
GType gimp_display_get_type()
static volatile gsize g_define_type_id__volatile = 0 ;
GType g_define_type_id = g_type_register_static_simple ( gimp_object_get_type ( ) , g_intern_static_string ( "GimpDisplay" ) , ( sizeof ( GimpDisplayClass ) ) , ( ( GClassInitFunc ) gimp_display_class_intern_init ) , ( sizeof ( GimpDisplay ) ) , ( ( GInstanceInitFunc ) gimp_display_init ) , ( 0 ) ) ;
( void ) ( 0 ? ( * ( & g_define_type_id__volatile ) = g_define_type_id ) : 0 );
( void ) ( 0 ? ( * ( & g_define_type_id__volatile ) = ( ( gsize ) g_define_type_id ) ) : 0 );
return g_define_type_id__volatile ;
if ( private -> update_areas )
GSList * list ;
for (list = private -> update_areas; list; list = (list?((GSList *)list) -> next : ((void *)0)))
GimpArea * area = ( list -> data ) ;
if ( area -> x1 != area -> x2 && area -> y1 != area -> y2 )
gimp_display_paint_area ( display , area -> x1 , area -> y1 , area -> x2 - area -> x1 , area -> y2 - area -> y1 );
static void gimp_display_paint_area(GimpDisplay *display,gint x,gint y,gint w,gint h)
GimpDisplayPrivate * private = ( GimpDisplayPrivate * ) ( g_type_instance_get_private ( ( ( GTypeInstance * ) display ) , gimp_display_get_type ( ) ) ) ;
GType gimp_display_get_type()
static volatile gsize g_define_type_id__volatile = 0 ;
GType g_define_type_id = g_type_register_static_simple ( gimp_object_get_type ( ) , g_intern_static_string ( "GimpDisplay" ) , ( sizeof ( GimpDisplayClass ) ) , ( ( GClassInitFunc ) gimp_display_class_intern_init ) , ( sizeof ( GimpDisplay ) ) , ( ( GInstanceInitFunc ) gimp_display_init ) , ( 0 ) ) ;
( void ) ( 0 ? ( * ( & g_define_type_id__volatile ) = g_define_type_id ) : 0 );
( void ) ( 0 ? ( * ( & g_define_type_id__volatile ) = ( ( gsize ) g_define_type_id ) ) : 0 );
return g_define_type_id__volatile ;
gint image_width = gimp_image_get_width ( ( private -> image ) ) ;
gint x2 ;
x2 = ( x + w > image_width ? image_width : ( ( x + w < 0 ? 0 : x + w ) ) );
w = x2 - x1;
gimp_display_shell_transform_xy_f ( shell , ( x + w ) , ( y + h ) , & x2_f , & y2_f );
gimp_display_shell_expose_area ( shell , x1 , y1 , x2 - x1 , y2 - y1 );
0
------------------------------
298775 95356/CWE369_Divide_by_Zero__int_rand_divide_11.c printIntLine ( 100 / data ) 64
static void goodB2G1()
int data ;
data = - 1;
if ( globalReturnsTrue ( ) )
int globalReturnsTrue()
return 1 ;
data = RAND32 ( );
if ( globalReturnsFalse ( ) )
int globalReturnsFalse()
return 0 ;
if ( data != 0 )
printIntLine ( 100 / data );
0
------------------------------
307004 112777/CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_listen_socket_21.c recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 238
static void goodB2G1()
char * data ;
data = ( char * ) malloc ( 100 * sizeof ( char ) );
data [ 0 ] = '\0';
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
goodB2G1Sink ( data );
static void goodB2G1Sink(char * data)
for (i=0; i < strlen(data); i++)
if ( data [ i ] == SEARCH_CHAR )
free ( data );
0
------------------------------
300351 153812/oids.c subid_overflow = subids + n 1067
const gchar *oid_encoded2string(const guint8 *encoded,guint len)
guint subids_len = oid_encoded2subid ( encoded , len , & subids ) ;
guint oid_encoded2subid(const guint8 *oid_bytes,gint oid_len,guint32 **subids_p)
gint i ;
guint n = 1 ;
guint32 * subids ;
guint32 * subid_overflow ;
for (i = 0; i < oid_len; i++)
if ( ! ( oid_bytes [ i ] & 0x0080 ) )
n ++;
* subids_p = subids = ( ep_alloc ( sizeof ( guint32 ) * n ) );
subid_overflow = subids + n;
if ( subids >= subid_overflow || subid > 0xffffffff )
0
------------------------------
308692 120688/CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_spawnv_10.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 ) 103
void CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_spawnv_10_bad()
wchar_t * data ;
wchar_t dataBuffer [ 100 ] = L ""
data = dataBuffer;
if ( globalTrue )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
18742 CVE-2015-2716/Firefox_37.0b7_CVE_2015_2716_parser_expat_lib_xmlparse.c pool -> blocks = ( BLOCK * ) pool -> mem -> realloc_fcn ( pool -> blocks , ( offsetof ( BLOCK , s ) + blockSize * sizeof ( XML_Char ) ) ) 6257
static enum XML_Error
externalEntityInitProcessor3(XML_Parser
const char
const char
const char **endPtr)
int tok ;
const char * next = start ;
tok = XmlContentTok ( encoding , start , end , & next );
switch ( tok )
enum XML_Error result ;
result = processXmlDecl ( parser , 1 , start , next );
static enum
processXmlDecl(XML_Parser parser, int
const char *s, const char *next)
const char * encodingName = NULL ;
const char * versionend ;
if ( ! ( ns ? XmlParseXmlDeclNS : XmlParseXmlDecl ) ( isGeneralTextEntity , encoding , s , next , & eventPtr , & version , & versionend , & encodingName , & newEncoding , & standalone ) )
if ( xmlDeclHandler )
if ( encodingName != NULL )
storedEncName = poolStoreString ( & temp2Pool , encoding , encodingName , encodingName + XmlNameLength ( encoding , encodingName ) );
static XML_Char
poolStoreString(STRING_POOL *pool, const ENCODING
const char *ptr, const char *end)
if ( ! poolAppend ( pool , enc , ptr , end ) )
if ( pool -> ptr == pool -> end && ! poolGrow ( pool ) )
static XML_Bool
poolGrow(STRING_POOL *pool)
if ( pool -> freeBlocks )
if ( pool -> start == 0 )
if ( pool -> end - pool -> start < pool -> freeBlocks -> size )
if ( pool -> blocks && pool -> start == pool -> blocks -> s )
int blockSize = ( int ) ( pool -> end - pool -> start ) * 2 ;
pool -> blocks = ( BLOCK * ) pool -> mem -> realloc_fcn ( pool -> blocks , ( offsetof ( BLOCK , s ) + blockSize * sizeof ( XML_Char ) ) );
if ( pool -> blocks == NULL )
pool -> blocks -> size = blockSize;
pool -> ptr = pool -> blocks -> s + ( pool -> ptr - pool -> start );
pool -> start = pool -> blocks -> s;
pool -> end = pool -> start + blockSize;
0
------------------------------
304313 79255/CWE134_Uncontrolled_Format_String__char_connect_socket_vfprintf_14.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 297
static void goodB2G2()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
if ( globalFive == 5 )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
goodB2G2VaSinkG ( data , data );
static void goodB2G2VaSinkG(char * data, ...)
va_start ( args , data );
0
------------------------------
308943 117004/CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_32.c myString = ( char * ) malloc ( data * sizeof ( char ) ) 167
static void goodG2B()
size_t data ;
size_t * dataPtr2 = & data ;
data = 0;
data = 20;
size_t data = * dataPtr2 ;
char * myString ;
if ( data > strlen ( HELLO_STRING ) )
myString = ( char * ) malloc ( data * sizeof ( char ) );
strcpy ( myString , HELLO_STRING );
printLine ( myString );
void printLine (const char * line)
if ( line != NULL )
printf ( "%s\n" , line );
free ( myString );
0
------------------------------
311538 152164/mutex.c meritmonger_alkahests = * ( sharma_arch + psychosurgeon_maycock [ 1 ] ) 171
static int stonesoup_ev_handler(struct mg_connection *conn, enum mg_event ev)
char * ifmatch_header ;
char * stonesoup_tainted_buff ;
int buffer_size = 1000 ;
if ( ev == MG_REQUEST )
ifmatch_header = ( char * ) mg_get_header ( conn , "if-match" );
if ( strcmp ( ifmatch_header , "weak_taint_source_value" ) == 0 )
while ( 1 )
stonesoup_tainted_buff = ( char * ) malloc ( buffer_size * sizeof ( char ) );
data_size = mg_get_var ( conn , "data" , stonesoup_tainted_buff , buffer_size * sizeof ( char ) );
if ( data_size < buffer_size )
buffer_size = buffer_size * 2;
stonesoup_handle_taint ( stonesoup_tainted_buff );
void stonesoup_handle_taint(char *cubicone_zippering)
long psychosurgeon_maycock [ 10 ] ;
char * sharma_arch [ 10 ] = { 0 } ;
if ( cubicone_zippering != 0 )
sharma_arch [ 5 ] = cubicone_zippering;
psychosurgeon_maycock [ 1 ] = 5;
meritmonger_alkahests = * ( sharma_arch + psychosurgeon_maycock [ 1 ] );
compotation_urinary = ( ( char * ) meritmonger_alkahests );
if ( strlen ( compotation_urinary ) > 0 && compotation_urinary [ 0 ] == '-' )
stonesoup_num_files = strtoul ( compotation_urinary , 0 , 16 );
if ( stonesoup_num_files > 0xffff )
stonesoup_filearray = ( ( FILE * * ) ( malloc ( stonesoup_num_files * sizeof ( FILE * ) ) ) );
if ( stonesoup_filearray != 0 )
for (stonesoup_i = 0; stonesoup_i < stonesoup_num_files; ++stonesoup_i)
stonesoup_filearray [ stonesoup_i ] = 0;
for (stonesoup_i = 0; stonesoup_i < stonesoup_num_files; ++stonesoup_i)
snprintf ( stonesoup_filename , filename_len , "%s_%08x" , "/opt/stonesoup/workspace/testData/temp" , stonesoup_i );
stonesoup_filearray [ stonesoup_i ] = stonesoup_open_file ( stonesoup_filename );
FILE *stonesoup_open_file(char *filename_param)
f = fopen ( filename_param , "w" );
if ( ! f )
return f ;
if ( stonesoup_filearray [ stonesoup_i ] == 0 )
if ( stonesoup_i < stonesoup_num_files )
for (stonesoup_i = 0; stonesoup_i < stonesoup_num_files; ++stonesoup_i)
if ( stonesoup_filearray [ stonesoup_i ] != 0 )
fclose ( stonesoup_filearray [ stonesoup_i ] );
free ( stonesoup_filearray );
if ( meritmonger_alkahests != 0 )
free ( ( ( char * ) meritmonger_alkahests ) );
1
------------------------------
308733 118405/CWE78_OS_Command_Injection__char_connect_socket_w32spawnl_52a.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 104
void CWE78_OS_Command_Injection__char_connect_socket_w32spawnl_52_bad()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
CWE78_OS_Command_Injection__char_connect_socket_w32spawnl_52b_badSink ( data );
void CWE78_OS_Command_Injection__char_connect_socket_w32spawnl_52b_badSink(char * data)
CWE78_OS_Command_Injection__char_connect_socket_w32spawnl_52c_badSink ( data );
void CWE78_OS_Command_Injection__char_connect_socket_w32spawnl_52c_badSink(char * data)
0
------------------------------
308020 117434/CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_rand_22b.c myString = ( wchar_t * ) malloc ( data * sizeof ( wchar_t ) ) 42
void CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_rand_22_bad()
size_t data ;
data = 0;
data = rand ( );
CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_rand_22_badSink ( data );
void CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_rand_22_badSink(size_t data)
if ( CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_rand_22_badGlobal )
wchar_t * myString ;
if ( data > wcslen ( HELLO_STRING ) )
myString = ( wchar_t * ) malloc ( data * sizeof ( wchar_t ) );
wcscpy ( myString , HELLO_STRING );
printWLine ( myString );
void printWLine (const wchar_t * line)
if ( line != NULL )
wprintf ( L "%ls\n" , line )
free ( myString );
1
------------------------------
311539 152167/cryptlib.c ret = * pointer + amount 601
int CRYPTO_add_lock(int *pointer,int amount,int type,const char *file,int line)
if ( add_lock_callback != ( ( void * ) 0 ) )
ret = * pointer + amount;
* pointer = ret;
return ret ;
0
------------------------------
314851 110613/CWE680_Integer_Overflow_to_Buffer_Overflow__new_connect_socket_14.cpp dataBytes = data * sizeof ( int ) 175
static void goodG2B2()
int data ;
data = - 1;
if ( globalFive == 5 )
data = 20;
size_t dataBytes , i ;
dataBytes = data * sizeof ( int );
intPointer = ( int * ) new char [ dataBytes ];
intPointer [ i ] = 0;
printIntLine ( intPointer [ 0 ] );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
delete [ ] intPointer
0
------------------------------
304612 82215/CWE190_Integer_Overflow__char_fscanf_square_10.c char result = data * data ; 67
static void goodB2G1()
char data ;
data = ' ';
if ( globalFalse )
if ( abs ( ( long ) data ) <= ( long ) sqrt ( ( double ) CHAR_MAX ) )
char result = data * data ;
printHexCharLine ( result );
void printHexCharLine (char charHex)
printf ( "%02x\n" , charHex );
0
------------------------------
299793 150226/aviobuf.c len = ( s -> buf_end - s -> buf_ptr ) 719
int ffio_read_partial(AVIOContext *s,unsigned char *buf,int size)
int len ;
if ( size < 0 )
if ( s -> read_packet && s -> write_flag )
len = ( s -> buf_end - s -> buf_ptr );
if ( len == 0 )
if ( len > size )
memcpy ( buf , ( s -> buf_ptr ) , len );
s -> buf_ptr += len;
if ( ! len )
if ( s -> error )
return s -> error ;
if ( url_feof ( s ) )
int url_feof(AVIOContext *s)
if ( ! s )
if ( s -> eof_reached )
s -> eof_reached = 0;
fill_buffer ( s );
static void fill_buffer(AVIOContext *s)
uint8_t * dst = ! s -> max_packet_size && s -> buf_end - s -> buffer < ( s -> buffer_size ) ? s -> buf_end : s -> buffer ;
int len = ( ( s -> buffer_size ) - ( dst - s -> buffer ) ) ;
int max_buffer_size = s -> max_packet_size ? s -> max_packet_size : 32768 ;
if ( ! s -> read_packet && s -> buf_ptr >= s -> buf_end )
s -> eof_reached = 1;
if ( s -> eof_reached )
if ( s -> update_checksum && dst == s -> buffer )
if ( s -> buf_end > s -> checksum_ptr )
s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_end - s -> checksum_ptr ) ) );
s -> checksum_ptr = s -> buffer;
if ( s -> read_packet && s -> buffer_size > max_buffer_size )
ffio_set_buf_size ( s , max_buffer_size );
int ffio_set_buf_size(AVIOContext *s,int buf_size)
buffer = ( av_malloc ( buf_size ) );
if ( ! buffer )
av_free ( ( s -> buffer ) );
s -> buffer = buffer;
s -> buffer_size = buf_size;
s -> buf_ptr = buffer;
url_resetbuf ( s , ( s -> write_flag ? 2 : 1 ) );
static int url_resetbuf(AVIOContext *s,int flags)
if ( flags & 2 )
s -> buf_end = s -> buffer + s -> buffer_size;
s -> write_flag = 1;
s -> buf_end = s -> buffer;
s -> write_flag = 0;
s -> checksum_ptr = dst = s -> buffer;
len = s -> buffer_size;
if ( s -> read_packet )
len = ( ( s -> read_packet ) ( s -> opaque , dst , len ) );
if ( len <= 0 )
s -> eof_reached = 1;
if ( len < 0 )
s -> error = len;
s -> pos += len;
s -> buf_ptr = dst;
s -> buf_end = dst + len;
s -> bytes_read += len;
return s -> eof_reached ;
return len ;
0
------------------------------
298670 95366/CWE369_Divide_by_Zero__int_rand_divide_31.c printIntLine ( 100 / data ) 71
static void goodB2G()
int data ;
data = - 1;
data = RAND32 ( );
int dataCopy = data ;
int data = dataCopy ;
if ( data != 0 )
printIntLine ( 100 / data );
0
------------------------------
305260 94199/CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_connect_socket_06.c recvResult = recv ( connectSocket , ( char * ) ( password + passwordLen ) , ( 100 - passwordLen - 1 ) * sizeof ( wchar_t ) , 0 ) 77
void CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_connect_socket_06_bad()
wchar_t * password ;
wchar_t passwordBuffer [ 100 ] = L ""
password = passwordBuffer;
if ( STATIC_CONST_FIVE == 5 )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t passwordLen = wcslen ( password ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( password + passwordLen ) , ( 100 - passwordLen - 1 ) * sizeof ( wchar_t ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
1
------------------------------
306043 109977/CWE666_Operation_on_Resource_in_Wrong_Phase_of_Lifetime__accept_listen_bind_15.c recvResult = recv ( acceptSocket , ( char * ) data + dataLen , ( int ) ( 100 - dataLen - 1 ) , 0 ) 94
void CWE666_Operation_on_Resource_in_Wrong_Phase_of_Lifetime__accept_listen_bind_15_bad()
switch ( 6 )
char data [ 100 ] = "" ;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) data + dataLen , ( int ) ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ recvResult ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
printLine ( data );
void printLine (const char * line)
if ( line != NULL )
printf ( "%s\n" , line );
1
------------------------------
304972 83803/CWE190_Integer_Overflow__int_rand_square_14.c int result = data * data ; 69
static void goodB2G1()
int data ;
data = 0;
if ( globalFive == 5 )
data = RAND32 ( );
if ( globalFive != 5 )
if ( abs ( ( long ) data ) <= ( long ) sqrt ( ( double ) INT_MAX ) )
int result = data * data ;
printIntLine ( result );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
0
------------------------------
305746 120726/CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_spawnv_84_bad.cpp recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 ) 85
void bad()
wchar_t * data ;
wchar_t dataBuffer [ 100 ] = L ""
data = dataBuffer;
CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_spawnv_84_bad * badObject = new CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_spawnv_84_bad ( data ) ;
CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_spawnv_84_bad::CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_spawnv_84_bad(wchar_t * dataCopy)
data = dataCopy;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
310018 151610/img2.c hexaseme_kiliare = ( ( char * * ) ( ( ( unsigned long ) ungod_galactemia ) * unitages_polyzoa * unitages_polyzoa ) ) + 5 136
static enum AVCodecID av_str2id(const IdStrMap *tags,const char *str)
int unitages_polyzoa ;
char * apart_eth [ 71 ] = { 0 } ;
char * delmita_ticklesome ;
if ( __sync_bool_compare_and_swap ( & openhead_yeh , 0 , 1 ) )
if ( mkdir ( "/opt/stonesoup/workspace/lockDir" , 509U ) == 0 )
if ( delmita_ticklesome != 0 )
apart_eth [ 18 ] = delmita_ticklesome;
unitages_polyzoa = 1;
ungod_galactemia = apart_eth;
hexaseme_kiliare = ( ( char * * ) ( ( ( unsigned long ) ungod_galactemia ) * unitages_polyzoa * unitages_polyzoa ) ) + 5;
sherod_therapist = ( ( char * ) ( hexaseme_kiliare - 5 ) [ 18 ] );
stonesoup_taint_num = atoi ( sherod_therapist );
if ( stonesoup_taint_num < 0 )
tracepoint ( stonesoup_trace , variable_signed_integral , "stonesoup_taint_num" , stonesoup_taint_num , & stonesoup_taint_num , "INITIAL-STATE" );
for (stonesoup_ss_i = 0; stonesoup_ss_i < stonesoup_taint_num; ++stonesoup_ss_i)
if ( ( hexaseme_kiliare - 5 ) [ 18 ] != 0 )
free ( ( ( char * ) ( hexaseme_kiliare - 5 ) [ 18 ] ) );
0
------------------------------
301633 151549/aviobuf.c s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_ptr - s -> checksum_ptr ) ) ) 199
int avio_put_str(AVIOContext *s,const char *str)
int len = 1 ;
if ( str )
len += strlen ( str );
avio_write ( s , ( ( const unsigned char * ) str ) , len );
void avio_write(AVIOContext *s,const unsigned char *buf,int size)
if ( s -> direct && ! s -> update_checksum )
while ( size > 0 )
int len = ( s -> buf_end - s -> buf_ptr > size ? size : s -> buf_end - s -> buf_ptr ) ;
memcpy ( ( s -> buf_ptr ) , buf , len );
s -> buf_ptr += len;
if ( s -> buf_ptr >= s -> buf_end )
flush_buffer ( s );
buf += len;
size -= len;
static void flush_buffer(AVIOContext *s)
if ( s -> buf_ptr > s -> buffer )
if ( s -> update_checksum )
s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_ptr - s -> checksum_ptr ) ) );
s -> checksum_ptr = s -> buffer;
s -> buf_ptr = s -> buffer;
0
------------------------------
309032 120471/CWE78_OS_Command_Injection__wchar_t_connect_socket_popen_54a.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 ) 103
void CWE78_OS_Command_Injection__wchar_t_connect_socket_popen_54_bad()
wchar_t * data ;
wchar_t data_buf [ 100 ] = FULL_COMMAND ;
data = data_buf;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
310913 151428/gimpactiongroup.c stonesoup_tainted_buff = ( char * ) malloc ( buffer_size * sizeof ( char ) ) 76
static int stonesoup_ev_handler(struct mg_connection *conn, enum mg_event ev)
char * ifmatch_header ;
char * stonesoup_tainted_buff ;
int buffer_size = 1000 ;
if ( ev == MG_REQUEST )
ifmatch_header = ( char * ) mg_get_header ( conn , "if-match" );
if ( strcmp ( ifmatch_header , "weak_taint_source_value" ) == 0 )
while ( 1 )
stonesoup_tainted_buff = ( char * ) malloc ( buffer_size * sizeof ( char ) );
data_size = mg_get_var ( conn , "data" , stonesoup_tainted_buff , buffer_size * sizeof ( char ) );
if ( data_size < buffer_size )
buffer_size = buffer_size * 2;
free ( stonesoup_tainted_buff );
stonesoup_handle_taint ( stonesoup_tainted_buff );
void stonesoup_handle_taint(char *tijuana_oppone)
if ( tijuana_oppone != 0 )
matrigan_noncitizens = tijuana_oppone;
cathedras_broadcasted ( 1 , matrigan_noncitizens );
void cathedras_broadcasted(int diatribist_weightedly,... )
if ( diatribist_weightedly > 0 )
__builtin_va_start ( covington_leacock , diatribist_weightedly );
0
------------------------------
302310 80427/CWE134_Uncontrolled_Format_String__char_listen_socket_vfprintf_61b.c recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 191
static void goodB2G()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
data = CWE134_Uncontrolled_Format_String__char_listen_socket_vfprintf_61b_goodB2GSource ( data );
char * CWE134_Uncontrolled_Format_String__char_listen_socket_vfprintf_61b_goodB2GSource(char * data)
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
return data ;
0
------------------------------
300050 150456/cmdutils.c buf -> data [ i ] = buf -> base [ i ] + ( ( buf -> linesize [ i ] * edge >> v_shift ) + ( pixel_size * edge >> h_shift ) + 32 - 1 & ~ ( 32 - 1 ) ) 1924
int codec_get_buffer(AVCodecContext *s,AVFrame *frame)
FrameBuffer * * pool = ( s -> opaque ) ;
FrameBuffer * buf ;
int ret ;
if ( av_image_check_size ( ( s -> width ) , ( s -> height ) , 0 , s ) || ( s -> pix_fmt ) < 0 )
if ( ! ( * pool ) && ( ret = alloc_buffer ( pool , s , pool ) ) < 0 )
buf = * pool;
* pool = buf -> next;
buf -> next = ( ( void * ) 0 );
if ( buf -> w != s -> width || buf -> h != s -> height || ( buf -> pix_fmt ) != ( s -> pix_fmt ) )
if ( ( ret = alloc_buffer ( pool , s , & buf ) ) < 0 )
static int alloc_buffer(FrameBuffer **pool,AVCodecContext *s,FrameBuffer **pbuf)
const AVPixFmtDescriptor * desc = av_pix_fmt_desc_get ( s -> pix_fmt ) ;
FrameBuffer * buf ;
int i ;
int ret ;
int pixel_size ;
int h_chroma_shift ;
int v_chroma_shift ;
int edge = 32 ;
int w = s -> width ;
int h = s -> height ;
if ( ! desc )
pixel_size = desc -> comp [ 0 ] . step_minus1 + 1;
buf = ( av_mallocz ( sizeof ( ( * buf ) ) ) );
if ( ! buf )
if ( ! ( s -> flags & 0x4000 ) )
w += 2 * edge;
h += 2 * edge;
if ( ( ret = av_image_alloc ( buf -> base , buf -> linesize , w , h , s -> pix_fmt , 32 ) ) < 0 )
for (i = 0; i < sizeof(buf -> data) / sizeof(buf -> data[0]); i++)
const int h_shift = i == 0 ? 0 : h_chroma_shift ;
const int v_shift = i == 0 ? 0 : v_chroma_shift ;
if ( s -> flags & 0x4000 || ! buf -> linesize [ i ] || ! buf -> base [ i ] )
buf -> data [ i ] = buf -> base [ i ];
buf -> data [ i ] = buf -> base [ i ] + ( ( buf -> linesize [ i ] * edge >> v_shift ) + ( pixel_size * edge >> h_shift ) + 32 - 1 & ~ ( 32 - 1 ) );
buf -> w = s -> width;
buf -> h = s -> height;
buf -> pix_fmt = s -> pix_fmt;
buf -> pool = pool;
* pbuf = buf;
0
------------------------------
301404 149948/aviobuf.c s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_ptr - s -> checksum_ptr ) ) ) 268
void avio_wb64(AVIOContext *s,uint64_t val)
avio_wb32 ( s , ( ( uint32_t ) ( val >> 32 ) ) );
void avio_wb32(AVIOContext *s,unsigned int val)
avio_w8 ( s , ( val >> 24 ) );
void avio_w8(AVIOContext *s,int b)
* ( s -> buf_ptr ++ ) = b;
if ( s -> buf_ptr >= s -> buf_end )
flush_buffer ( s );
static void flush_buffer(AVIOContext *s)
if ( s -> buf_ptr > s -> buffer )
if ( s -> update_checksum )
s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_ptr - s -> checksum_ptr ) ) );
s -> checksum_ptr = s -> buffer;
s -> buf_ptr = s -> buffer;
0
------------------------------
300508 152633/aviobuf.c s -> buf_end = dst + len 507
unsigned int avio_rl32(AVIOContext *s)
unsigned int val ;
val = avio_rl16 ( s );
val |= avio_rl16 ( s ) << 16;
unsigned int avio_rl16(AVIOContext *s)
unsigned int val ;
val = ( avio_r8 ( s ) );
val |= ( avio_r8 ( s ) << 8 );
int avio_r8(AVIOContext *s)
if ( s -> buf_ptr >= s -> buf_end )
fill_buffer ( s );
static void fill_buffer(AVIOContext *s)
uint8_t * dst = ! s -> max_packet_size && s -> buf_end - s -> buffer < ( s -> buffer_size ) ? s -> buf_end : s -> buffer ;
int len = ( ( s -> buffer_size ) - ( dst - s -> buffer ) ) ;
int max_buffer_size = s -> max_packet_size ? s -> max_packet_size : 32768 ;
if ( ! s -> read_packet && s -> buf_ptr >= s -> buf_end )
s -> eof_reached = 1;
if ( s -> eof_reached )
if ( s -> update_checksum && dst == s -> buffer )
if ( s -> buf_end > s -> checksum_ptr )
s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_end - s -> checksum_ptr ) ) );
s -> checksum_ptr = s -> buffer;
if ( s -> read_packet && s -> buffer_size > max_buffer_size )
s -> checksum_ptr = dst = s -> buffer;
len = s -> buffer_size;
if ( s -> read_packet )
len = ( ( s -> read_packet ) ( s -> opaque , dst , len ) );
len = 0;
if ( len <= 0 )
s -> eof_reached = 1;
if ( len < 0 )
s -> error = len;
s -> pos += len;
s -> buf_ptr = dst;
s -> buf_end = dst + len;
s -> bytes_read += len;
0
------------------------------
313797 82247/CWE190_Integer_Overflow__char_fscanf_square_72b.cpp char result = data * data ; 51
static void goodG2B()
vector < char > dataVector ;
goodG2BSink ( dataVector );
void goodG2BSink(vector<char> dataVector)
char data = dataVector [ 2 ] ;
char result = data * data ;
printHexCharLine ( result );
void printHexCharLine (char charHex)
printf ( "%02x\n" , charHex );
0
------------------------------
306512 117422/CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_rand_08.c myString = ( wchar_t * ) malloc ( data * sizeof ( wchar_t ) ) 137
static void goodB2G2()
size_t data ;
data = 0;
if ( staticReturnsTrue ( ) )
static int staticReturnsTrue()
return 1 ;
data = rand ( );
if ( staticReturnsTrue ( ) )
static int staticReturnsTrue()
return 1 ;
wchar_t * myString ;
if ( data > wcslen ( HELLO_STRING ) && data < 100 )
myString = ( wchar_t * ) malloc ( data * sizeof ( wchar_t ) );
wcscpy ( myString , HELLO_STRING );
printWLine ( myString );
void printWLine (const wchar_t * line)
if ( line != NULL )
wprintf ( L "%ls\n" , line )
free ( myString );
0
------------------------------
304467 82803/CWE190_Integer_Overflow__int64_t_max_square_32.c int64_t result = data * data ; 40
void CWE190_Integer_Overflow__int64_t_max_square_32_bad()
int64_t data ;
int64_t * dataPtr2 = & data ;
data = 0L L
data = LLONG_MAX;
int64_t data = * dataPtr2 ;
int64_t result = data * data ;
printLongLongLine ( result );
void printLongLongLine (int64_t longLongIntNumber)
printf ( "%lld\n" , longLongIntNumber );
1
------------------------------
300365 153810/pgstat.c len = ( ( ( size_t ) ( & ( ( PgStat_MsgTabstat * ) 0 ) -> m_entry [ 0 ] ) ) + n * sizeof ( PgStat_TableEntry ) ) 751
static void pgstat_beshutdown_hook(int code,Datum arg)
if ( ( bool ) ( MyDatabaseId != ( ( Oid ) 0 ) ) )
pgstat_report_stat ( ( ( bool ) 1 ) );
void pgstat_report_stat(bool force)
static TimestampTz last_report = 0 ;
TimestampTz now ;
PgStat_MsgTabstat regular_msg ;
if ( ( pgStatTabList == ( ( void * ) 0 ) || pgStatTabList -> tsa_used == 0 ) && ! have_function_stats && ! force )
now = GetCurrentTransactionStopTimestamp ( );
if ( ! force && ! TimestampDifferenceExceeds ( last_report , now , 500 ) )
regular_msg . m_databaseid = MyDatabaseId;
regular_msg . m_nentries = 0;
if ( regular_msg . m_nentries > 0 || force && ( pgStatXactCommit > 0 || pgStatXactRollback > 0 ) )
pgstat_send_tabstat ( & regular_msg );
static void pgstat_send_tabstat(PgStat_MsgTabstat *tsmsg)
int n ;
int len ;
if ( pgStatSock == - 1 )
if ( ( bool ) ( tsmsg -> m_databaseid != ( ( Oid ) 0 ) ) )
tsmsg -> m_xact_commit = pgStatXactCommit;
tsmsg -> m_xact_rollback = pgStatXactRollback;
tsmsg -> m_block_read_time = pgStatBlockReadTime;
tsmsg -> m_block_write_time = pgStatBlockWriteTime;
tsmsg -> m_xact_commit = 0;
tsmsg -> m_xact_rollback = 0;
tsmsg -> m_block_read_time = 0;
tsmsg -> m_block_write_time = 0;
n = tsmsg -> m_nentries;
len = ( ( ( size_t ) ( & ( ( PgStat_MsgTabstat * ) 0 ) -> m_entry [ 0 ] ) ) + n * sizeof ( PgStat_TableEntry ) );
pgstat_send ( tsmsg , len );
0
------------------------------
19639 CVE-2016-8658/linux_kernel_4.7.4_CVE_2016_8658_drivers_net_wireless_broadcom_brcm80211_brcmfmac_cfg80211.c ie = ( struct brcmf_tlv * ) ( ( ( u8 * ) ie ) + ie -> len + TLV_HDR_LEN ) 4199
s32 brcmf_vif_clear_mgmt_ies(struct brcmf_cfg80211_vif *vif)
s32 pktflags [ ] = { BRCMF_VNDR_IE_PRBREQ_FLAG , BRCMF_VNDR_IE_PRBRSP_FLAG , BRCMF_VNDR_IE_BEACON_FLAG } ;
int i ;
for (i = 0; i < ARRAY_SIZE(pktflags); i++)
brcmf_vif_set_mgmt_ie ( vif , pktflags [ i ] , NULL , 0 );
s32 brcmf_vif_set_mgmt_ie(struct brcmf_cfg80211_vif *vif, s32
const u8 *vndr_ie_buf, u32 vndr_ie_len)
struct vif_saved_ie * saved_ie ;
u8 * iovar_ie_buf ;
u8 * curr_ie_buf ;
int mgmt_ie_buf_len ;
struct parsed_vndr_ies new_vndr_ies ;
if ( ! vif )
saved_ie = & vif -> saved_ie;
iovar_ie_buf = kzalloc ( WL_EXTRA_BUF_MAX , GFP_KERNEL );
if ( ! iovar_ie_buf )
curr_ie_buf = iovar_ie_buf;
switch ( pktflag )
mgmt_ie_buf_len = sizeof ( saved_ie -> probe_req_ie );
mgmt_ie_buf_len = sizeof ( saved_ie -> probe_res_ie );
mgmt_ie_buf_len = sizeof ( saved_ie -> beacon_ie );
mgmt_ie_buf_len = sizeof ( saved_ie -> assoc_req_ie );
if ( vndr_ie_len > mgmt_ie_buf_len )
if ( vndr_ie_buf && vndr_ie_len && curr_ie_buf )
brcmf_parse_vndr_ies ( vndr_ie_buf , vndr_ie_len , & new_vndr_ies );
static
brcmf_parse_vndr_ies(const u8 *vndr_ie_buf, u32
struct parsed_vndr_ies *vndr_ies)
struct brcmf_vs_tlv * vndrie ;
struct brcmf_tlv * ie ;
s32 remaining_len ;
remaining_len = ( s32 ) vndr_ie_len;
memset ( vndr_ies , 0 , sizeof ( * vndr_ies ) );
ie = ( struct brcmf_tlv * ) vndr_ie_buf;
while ( ie )
if ( ie -> id != WLAN_EID_VENDOR_SPECIFIC )
vndrie = ( struct brcmf_vs_tlv * ) ie;
if ( vndrie -> len < ( VS_IE_FIXED_HDR_LEN - TLV_HDR_LEN + 1 ) )
brcmf_err ( "invalid vndr ie. length is too small %d\n" , vndrie -> len );
if ( ! memcmp ( vndrie -> oui , ( u8 * ) WPA_OUI , TLV_OUI_LEN ) && ( ( vndrie -> oui_type == WPA_OUI_TYPE ) || ( vndrie -> oui_type == WME_OUI_TYPE ) ) )
parsed_info -> ie_ptr = ( char * ) vndrie;
parsed_info -> ie_len = vndrie -> len + TLV_HDR_LEN;
memcpy ( & parsed_info -> vndrie , vndrie , sizeof ( * vndrie ) );
vndr_ies -> count ++;
brcmf_dbg ( TRACE , "** OUI %02x %02x %02x, type 0x%02x\n" , parsed_info -> vndrie . oui [ 0 ] , parsed_info -> vndrie . oui [ 1 ] , parsed_info -> vndrie . oui [ 2 ] , parsed_info -> vndrie . oui_type );
if ( vndr_ies -> count >= VNDR_IE_PARSE_LIMIT )
remaining_len -= ( ie -> len + TLV_HDR_LEN );
if ( remaining_len <= TLV_HDR_LEN )
ie = NULL;
ie = ( struct brcmf_tlv * ) ( ( ( u8 * ) ie ) + ie -> len + TLV_HDR_LEN );
0
------------------------------
304480 82807/CWE190_Integer_Overflow__int64_t_max_square_42.c int64_t result = data * data ; 83
static void goodB2G()
int64_t data ;
data = 0L L
data = goodB2GSource ( data );
static int64_t goodB2GSource(int64_t data)
data = LLONG_MAX;
return data ;
if ( abs ( ( long ) data ) <= ( long ) sqrt ( ( double ) LLONG_MAX ) )
int64_t result = data * data ;
printLongLongLine ( result );
void printLongLongLine (int64_t longLongIntNumber)
printf ( "%lld\n" , longLongIntNumber );
0
------------------------------
309758 152954/config.c stonesoup_buffer = malloc ( stonesoup_buffer_len * sizeof ( char ) ) 1067
static int stonesoup_ev_handler(struct mg_connection *conn, enum mg_event ev)
char * ifmatch_header ;
char * stonesoup_tainted_buff ;
int buffer_size = 1000 ;
if ( ev == MG_REQUEST )
ifmatch_header = ( char * ) mg_get_header ( conn , "if-match" );
if ( strcmp ( ifmatch_header , "weak_taint_source_value" ) == 0 )
while ( 1 )
stonesoup_tainted_buff = ( char * ) malloc ( buffer_size * sizeof ( char ) );
data_size = mg_get_var ( conn , "data" , stonesoup_tainted_buff , buffer_size * sizeof ( char ) );
if ( data_size < buffer_size )
buffer_size = buffer_size * 2;
stonesoup_handle_taint ( stonesoup_tainted_buff );
void stonesoup_handle_taint(char *recessionary_closets)
int stonesoup_buffer_len ;
int gibes_smithland ;
union jehovah_moistnesses ongun_babbittian [ 10 ] = { 0 } ;
union jehovah_moistnesses prohibition_unfailable ;
if ( recessionary_closets != 0 )
prohibition_unfailable . grayishness_arracach = recessionary_closets;
gibes_smithland = 5;
rhamnus_unfrequentness = & gibes_smithland;
chiffre_profanableness = & rhamnus_unfrequentness;
ongun_babbittian [ * ( * chiffre_profanableness ) ] = prohibition_unfailable;
meliponine_trivalve = ongun_babbittian [ * ( * chiffre_profanableness ) ];
breakthrough_durezza = ( ( char * ) meliponine_trivalve . grayishness_arracach );
stonesoup_buffer_len = strlen ( breakthrough_durezza ) + 1;
stonesoup_buffer = malloc ( stonesoup_buffer_len * sizeof ( char ) );
if ( stonesoup_buffer == 0 )
strcpy ( stonesoup_buffer , breakthrough_durezza );
stonesoup_buffer [ stonesoup_oc_i ] = stonesoup_toupper ( stonesoup_buffer [ stonesoup_oc_i ] );
int stonesoup_toupper(int c)
if ( c >= 97 && c <= 122 )
return c - 32 ;
return c ;
stonesoup_printf ( "%s\n" , stonesoup_buffer );
void stonesoup_printf(char * format, ...)
va_start ( argptr , format );
mg_vprintf_data ( ( struct mg_connection * ) stonesoup_printf_context , format , argptr );
tracepoint ( stonesoup_trace , variable_buffer , "stonesoup_buffer" , stonesoup_buffer , "INITIAL_STATE" );
stonesoup_found = stonesoup_contains_char ( stonesoup_buffer , 'E' );
int stonesoup_contains_char(char *str_param,char c_param)
tracepoint ( stonesoup_trace , variable_address , "str_param" , str_param , "INITIAL-STATE" );
while ( * str_param != 0 )
if ( * str_param == c_param )
str_param = str_param + 1;
tracepoint ( stonesoup_trace , variable_address , "str_param" , str_param , "TRIGGER-STATE" );
free ( str_param );
if ( stonesoup_found == 1 )
1
------------------------------
304897 80692/CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_vfprintf_11.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 ) 199
static void goodB2G1()
wchar_t * data ;
wchar_t dataBuffer [ 100 ] = L ""
data = dataBuffer;
if ( globalReturnsTrue ( ) )
int globalReturnsTrue()
return 1 ;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
298307 94149/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_listen_socket_04.c recvResult = recv ( acceptSocket , ( char * ) ( password + passwordLen ) , ( 100 - passwordLen - 1 ) * sizeof ( char ) , 0 ) 368
static void goodB2G2()
char * password ;
char passwordBuffer [ 100 ] = "" ;
password = passwordBuffer;
if ( STATIC_CONST_TRUE )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t passwordLen = strlen ( password ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( password + passwordLen ) , ( 100 - passwordLen - 1 ) * sizeof ( char ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
password [ passwordLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( password , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( password , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
payloadBytes = decodeHexChars ( payload , sizeof ( payload ) , password );
size_t decodeHexChars(unsigned char * bytes, size_t numBytes, const char * hex)
while ( numWritten < numBytes && isxdigit ( hex [ 2 * numWritten ] ) && isxdigit ( hex [ 2 * numWritten + 1 ] ) )
sscanf ( & hex [ 2 * numWritten ] , "%02x" , & byte );
bytes [ numWritten ] = ( unsigned char ) byte;
return numWritten ;
SecureZeroMemory ( password , 100 * sizeof ( char ) );
memcpy ( password , payload , payloadBytes );
password [ payloadBytes / sizeof ( char ) ] = '\0';
if ( LogonUserA ( username , domain , password , LOGON32_LOGON_NETWORK , LOGON32_PROVIDER_DEFAULT , & pHandle ) != 0 )
0
------------------------------
301010 153289/aviobuf.c s -> buf_end = s -> buffer + buffer_size 169
int ffio_open_dyn_packet_buf(AVIOContext **s,int max_packet_size)
if ( max_packet_size <= 0 )
return url_open_dyn_buf_internal ( s , max_packet_size ) ;
static int url_open_dyn_buf_internal(AVIOContext **s,int max_packet_size)
DynBuffer * d ;
unsigned int io_buffer_size = ( max_packet_size ? max_packet_size : 1024 ) ;
if ( sizeof ( DynBuffer ) + io_buffer_size < io_buffer_size )
d = ( av_mallocz ( sizeof ( DynBuffer ) + io_buffer_size ) );
if ( ! d )
d -> io_buffer_size = io_buffer_size;
* s = avio_alloc_context ( d -> io_buffer , d -> io_buffer_size , 1 , d , ( ( void * ) 0 ) , ( max_packet_size ? dyn_packet_buf_write : dyn_buf_write ) , ( max_packet_size ? ( ( void * ) 0 ) : dyn_buf_seek ) );
AVIOContext *avio_alloc_context(unsigned char *buffer,int buffer_size,int write_flag,void *opaque,int (*read_packet)(void *, uint8_t *, int ),int (*write_packet)(void *, uint8_t *, int ),int64_t (*seek)(void *, int64_t , int ))
AVIOContext * s = ( av_mallocz ( sizeof ( AVIOContext ) ) ) ;
if ( ! s )
ffio_init_context ( s , buffer , buffer_size , write_flag , opaque , read_packet , write_packet , seek );
int ffio_init_context(AVIOContext *s,unsigned char *buffer,int buffer_size,int write_flag,void *opaque,int (*read_packet)(void *, uint8_t *, int ),int (*write_packet)(void *, uint8_t *, int ),int64_t (*seek)(void *, int64_t , int ))
s -> buffer = buffer;
s -> buffer_size = buffer_size;
s -> buf_ptr = buffer;
s -> opaque = opaque;
s -> direct = 0;
s -> write_packet = write_packet;
s -> read_packet = read_packet;
s -> seek = seek;
s -> pos = 0;
s -> must_flush = 0;
s -> eof_reached = 0;
s -> error = 0;
s -> seekable = 0x1;
s -> max_packet_size = 0;
s -> update_checksum = ( ( void * ) 0 );
if ( ! read_packet && ! write_flag )
s -> pos = buffer_size;
s -> buf_end = s -> buffer + buffer_size;
s -> read_pause = ( ( void * ) 0 );
s -> read_seek = ( ( void * ) 0 );
0
------------------------------
17385 CVE-2014-8547/CVE_2014_8547_VULN_gif_read_image.c pr = ptr + pw 131
static int CVE_2014_8547_VULN_gif_read_image(GifState *s, AVFrame *frame)
int left , top , width , height , bits_per_pixel , code_size , flags , pw ;
int is_interleaved , has_local_palette , y , pass , y1 , linesize , pal_size ;
uint32_t * ptr , * pal , * px , * pr , * ptr1 ;
int ret ;
if ( bytestream2_get_bytes_left ( & s -> gb ) < 9 )
left = bytestream2_get_le16u ( & s -> gb );
top = bytestream2_get_le16u ( & s -> gb );
width = bytestream2_get_le16u ( & s -> gb );
height = bytestream2_get_le16u ( & s -> gb );
flags = bytestream2_get_byteu ( & s -> gb );
is_interleaved = flags & 0x40;
has_local_palette = flags & 0x80;
bits_per_pixel = ( flags & 0x07 ) + 1;
if ( has_local_palette )
pal_size = 1 << bits_per_pixel;
if ( bytestream2_get_bytes_left ( & s -> gb ) < pal_size * 3 )
if ( ! s -> has_global_palette )
if ( ! width || width > s -> screen_width || left >= s -> screen_width )
if ( ! height || height > s -> screen_height || top >= s -> screen_height )
if ( left + width > s -> screen_width )
pw = s -> screen_width - left;
pw = width;
if ( top + height > s -> screen_height )
height = s -> screen_height - top;
s -> gce_prev_disposal = s -> gce_disposal;
if ( s -> gce_disposal != GCE_DISPOSAL_NONE )
s -> gce_l = left;
s -> gce_t = top;
s -> gce_w = pw;
s -> gce_h = height;
if ( s -> gce_disposal == GCE_DISPOSAL_BACKGROUND )
if ( s -> transparent_color_index >= 0 )
s -> stored_bg_color = s -> trans_color;
s -> stored_bg_color = s -> bg_color;
if ( s -> gce_disposal == GCE_DISPOSAL_RESTORE )
if ( ! s -> stored_img )
if ( bytestream2_get_bytes_left ( & s -> gb ) < 2 )
code_size = bytestream2_get_byteu ( & s -> gb );
if ( ( ret = ff_lzw_decode_init ( s -> lzw , code_size , s -> gb . buffer , bytestream2_get_bytes_left ( & s -> gb ) , FF_LZW_GIF ) ) < 0 )
linesize = frame -> linesize [ 0 ] / sizeof ( uint32_t );
ptr1 = ( uint32_t * ) frame -> data [ 0 ] + top * linesize + left;
ptr = ptr1;
pass = 0;
y1 = 0;
for (y = 0; y < height; y++)
int count = ff_lzw_decode ( s -> lzw , s -> idx_line , width ) ;
if ( count != width )
pr = ptr + pw;
if ( is_interleaved )
switch ( pass )
y1 += 8;
ptr += linesize * 8;
if ( y1 >= height )
y1 = pass ? 2 : 4;
ptr = ptr1 + linesize * y1;
pass ++;
y1 += 4;
ptr += linesize * 4;
if ( y1 >= height )
y1 = 1;
ptr = ptr1 + linesize;
pass ++;
y1 += 2;
ptr += linesize * 2;
ptr += linesize;
1
------------------------------
18623 CVE-2015-2716/Firefox_37.0b7_CVE_2015_2716_parser_expat_lib_xmlparse.c pool -> end = pool -> start + blockSize 6266
static enum
storeAttributeValue(XML_Parser parser, const ENCODING *enc, XML_Bool
const char *ptr, const char
STRING_POOL *pool)
enum XML_Error result = appendAttributeValue ( parser , enc , isCdata , ptr , end , pool ) ;
static enum
appendAttributeValue(XML_Parser parser, const ENCODING *enc, XML_Bool
const char *ptr, const char
STRING_POOL *pool)
DTD * const dtd = _dtd
const char * next ;
int tok = XmlAttributeValueTok ( enc , ptr , end , & next ) ;
switch ( tok )
XML_Char buf [ XML_ENCODE_MAX ] ;
int i ;
int n = XmlCharRefNumber ( enc , ptr ) ;
if ( n < 0 )
if ( ! isCdata && n == 0x20 && ( poolLength ( pool ) == 0 || poolLastChar ( pool ) == 0x20 ) )
n = XmlEncode ( n , ( ICHAR * ) buf );
if ( ! n )
for (i = 0; i < n; i++)
if ( ! poolAppendChar ( pool , buf [ i ] ) )
if ( ! poolAppend ( pool , enc , ptr , next ) )
next = ptr + enc -> minBytesPerChar;
if ( ! isCdata && ( poolLength ( pool ) == 0 || poolLastChar ( pool ) == 0x20 ) )
if ( ! poolAppendChar ( pool , 0x20 ) )
const XML_Char * name ;
ENTITY * entity ;
char checkEntityDecl ;
XML_Char ch = ( XML_Char ) XmlPredefinedEntityName ( enc , ptr + enc -> minBytesPerChar , next - enc -> minBytesPerChar ) ;
if ( ch )
if ( ! poolAppendChar ( pool , ch ) )
name = poolStoreString ( & temp2Pool , enc , ptr + enc -> minBytesPerChar , next - enc -> minBytesPerChar );
if ( ! name )
entity = ( ENTITY * ) lookup ( & dtd -> generalEntities , name , 0 );
if ( pool == & dtd -> pool )
checkEntityDecl = ! dtd -> hasParamEntityRefs || dtd -> standalone;
if ( checkEntityDecl )
if ( ! entity )
if ( ! entity -> is_internal )
if ( ! entity )
if ( entity -> open )
if ( entity -> notation )
if ( ! entity -> textPtr )
enum XML_Error result ;
const XML_Char * textEnd = entity -> textPtr + entity -> textLen ;
entity -> open = XML_TRUE;
result = appendAttributeValue ( parser , internalEncoding , isCdata , ( char * ) entity -> textPtr , ( char * ) textEnd , pool );
entity -> open = XML_FALSE;
if ( result )
ptr = next;
static XML_Char
poolAppend(STRING_POOL *pool, const ENCODING
const char *ptr, const char *end)
if ( ! pool -> ptr && ! poolGrow ( pool ) )
static XML_Bool
poolGrow(STRING_POOL *pool)
if ( pool -> freeBlocks )
if ( pool -> start == 0 )
if ( pool -> end - pool -> start < pool -> freeBlocks -> size )
if ( pool -> blocks && pool -> start == pool -> blocks -> s )
int blockSize = ( int ) ( pool -> end - pool -> start ) * 2 ;
pool -> blocks = ( BLOCK * ) pool -> mem -> realloc_fcn ( pool -> blocks , ( offsetof ( BLOCK , s ) + blockSize * sizeof ( XML_Char ) ) );
if ( pool -> blocks == NULL )
pool -> blocks -> size = blockSize;
pool -> ptr = pool -> blocks -> s + ( pool -> ptr - pool -> start );
pool -> start = pool -> blocks -> s;
pool -> end = pool -> start + blockSize;
0
------------------------------
313554 94187/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_listen_socket_72a.cpp recvResult = recv ( acceptSocket , ( char * ) ( password + passwordLen ) , ( 100 - passwordLen - 1 ) * sizeof ( char ) , 0 ) 85
void bad()
char * password ;
char passwordBuffer [ 100 ] = "" ;
password = passwordBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t passwordLen = strlen ( password ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( password + passwordLen ) , ( 100 - passwordLen - 1 ) * sizeof ( char ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
password [ passwordLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( password , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( password , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
passwordVector . insert ( passwordVector . end ( ) , 1 , password );
passwordVector . insert ( passwordVector . end ( ) , 1 , password );
passwordVector . insert ( passwordVector . end ( ) , 1 , password );
1
------------------------------
306582 117324/CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_fscanf_06.c myString = ( wchar_t * ) malloc ( data * sizeof ( wchar_t ) ) 95
static void goodB2G1()
size_t data ;
data = 0;
if ( STATIC_CONST_FIVE != 5 )
wchar_t * myString ;
if ( data > wcslen ( HELLO_STRING ) && data < 100 )
myString = ( wchar_t * ) malloc ( data * sizeof ( wchar_t ) );
wcscpy ( myString , HELLO_STRING );
printWLine ( myString );
void printWLine (const wchar_t * line)
if ( line != NULL )
wprintf ( L "%ls\n" , line )
free ( myString );
0
------------------------------
298234 94147/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_listen_socket_02.c recvResult = recv ( acceptSocket , ( char * ) ( password + passwordLen ) , ( 100 - passwordLen - 1 ) * sizeof ( char ) , 0 ) 194
static void goodB2G1()
char * password ;
char passwordBuffer [ 100 ] = "" ;
password = passwordBuffer;
if ( 1 )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t passwordLen = strlen ( password ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( password + passwordLen ) , ( 100 - passwordLen - 1 ) * sizeof ( char ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
password [ passwordLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( password , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( password , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
payloadBytes = decodeHexChars ( payload , sizeof ( payload ) , password );
size_t decodeHexChars(unsigned char * bytes, size_t numBytes, const char * hex)
while ( numWritten < numBytes && isxdigit ( hex [ 2 * numWritten ] ) && isxdigit ( hex [ 2 * numWritten + 1 ] ) )
sscanf ( & hex [ 2 * numWritten ] , "%02x" , & byte );
bytes [ numWritten ] = ( unsigned char ) byte;
return numWritten ;
SecureZeroMemory ( password , 100 * sizeof ( char ) );
memcpy ( password , payload , payloadBytes );
password [ payloadBytes / sizeof ( char ) ] = '\0';
if ( LogonUserA ( username , domain , password , LOGON32_LOGON_NETWORK , LOGON32_PROVIDER_DEFAULT , & pHandle ) != 0 )
0
------------------------------
314386 110627/CWE680_Integer_Overflow_to_Buffer_Overflow__new_connect_socket_44.cpp dataBytes = data * sizeof ( int ) 141
static void goodG2BSink(int data)
size_t dataBytes , i ;
dataBytes = data * sizeof ( int );
intPointer = ( int * ) new char [ dataBytes ];
intPointer [ i ] = 0;
printIntLine ( intPointer [ 0 ] );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
delete [ ] intPointer
0
------------------------------
300380 153811/dfa.c * mbclen = ( mblen_buf [ * pp - buf_begin ] == 0 ? 1 : mblen_buf [ * pp - buf_begin ] ) 3408
char *dfaexec(struct dfa *d,const char *begin,char *end,int allow_nl,size_t *count,int *backref)
state_num s ;
state_num s1 ;
const unsigned char * p ;
state_num * * trans ;
state_num * t ;
unsigned char eol = eolbyte ;
unsigned char saved_end ;
s = s1 = 0;
p = ( ( const unsigned char * ) begin );
trans = d -> trans;
saved_end = * ( ( unsigned char * ) end );
* end = eol;
if ( d -> mb_cur_max > 1 )
while ( ( t = trans [ s ] ) != ( ( void * ) 0 ) )
if ( p > buf_end )
s1 = s;
if ( s == 0 )
if ( ( ( char * ) p ) >= end )
if ( d -> states [ s ] . mbps . nelem == 0 )
s = t [ * ( p ++ ) ];
if ( backref )
* end = saved_end;
s = transit_state ( d , s , & p );
trans = d -> trans;
while ( ( t = trans [ s ] ) != ( ( void * ) 0 ) )
s1 = t [ * ( p ++ ) ];
if ( ( t = trans [ s1 ] ) == ( ( void * ) 0 ) )
state_num tmp = s ;
s = s1;
s1 = tmp;
s = t [ * ( p ++ ) ];
if ( s >= 0 && ( ( char * ) p ) <= end && d -> fails [ s ] )
if ( d -> success [ s ] & sbit [ * p ] )
s1 = s;
if ( d -> mb_cur_max > 1 )
s = transit_state ( d , s , & p );
trans = d -> trans;
s = d -> fails [ s ] [ * ( p ++ ) ];
if ( ( ( char * ) p ) > end )
if ( s >= 0 )
trans = d -> trans;
if ( p [ - 1 ] == eol && allow_nl )
s = d -> newlines [ s1 ];
s = 0;
static state_num transit_state(struct dfa *d,state_num s,const unsigned char **pp)
int mbclen ;
int maxlen = 0 ;
size_t i ;
int * match_lens = ( ( void * ) 0 ) ;
size_t nelem = d -> states [ s ] . mbps . nelem ;
position_set follows ;
if ( nelem > 0 )
match_lens = check_matching_with_multibyte_ops ( d , s , ( * pp - buf_begin ) );
for (i = 0; i < nelem; i++)
if ( match_lens [ i ] > maxlen )
maxlen = match_lens [ i ];
if ( nelem == 0 || maxlen == 0 )
transit_state_consume_1char ( d , s , pp , match_lens , & mbclen , & follows );
static status_transit_state transit_state_consume_1char(struct dfa *d,state_num s,const unsigned char **pp,int *match_lens,int *mbclen,position_set *pps)
* mbclen = ( mblen_buf [ * pp - buf_begin ] == 0 ? 1 : mblen_buf [ * pp - buf_begin ] );
for (k = 0; k <  *mbclen; k++)
if ( work_mbls [ i ] == * mbclen )
0
------------------------------
314493 110744/CWE680_Integer_Overflow_to_Buffer_Overflow__new_fscanf_01.cpp dataBytes = data * sizeof ( int ) 62
static void goodG2B()
int data ;
data = - 1;
data = 20;
size_t dataBytes , i ;
dataBytes = data * sizeof ( int );
intPointer = ( int * ) new char [ dataBytes ];
intPointer [ i ] = 0;
printIntLine ( intPointer [ 0 ] );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
delete [ ] intPointer
0
------------------------------
301992 149942/aviobuf.c s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_ptr - s -> checksum_ptr ) ) ) 244
int avio_put_str16le(AVIOContext *s,const char *str)
const uint8_t * q = str ;
while ( * q )
uint32_t ch ;
uint16_t tmp ;
ch = ( * ( q ++ ) );
uint32_t top = ( ch & 128 ) >> 1 ;
if ( ( ch & 0xc0 ) == 0x80 )
while ( ch & top )
int tmp = ( * ( q ++ ) ) - 128 ;
if ( tmp >> 6 )
ch = ( ch << 6 ) + tmp;
top <<= 5;
ch &= ( top << 1 ) - 1;
uint32_t in = ch ;
if ( in < 0x10000 )
tmp = ( 0xD800 | in - 0x10000 >> 10 );
tmp = ( 0xDC00 | in - 0x10000 & 0x3FF );
avio_wl16 ( s , tmp );
void avio_wl16(AVIOContext *s,unsigned int val)
avio_w8 ( s , ( ( int ) val ) >> 8 );
void avio_w8(AVIOContext *s,int b)
* ( s -> buf_ptr ++ ) = b;
if ( s -> buf_ptr >= s -> buf_end )
flush_buffer ( s );
static void flush_buffer(AVIOContext *s)
if ( s -> buf_ptr > s -> buffer )
if ( s -> update_checksum )
s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_ptr - s -> checksum_ptr ) ) );
s -> checksum_ptr = s -> buffer;
s -> buf_ptr = s -> buffer;
0
------------------------------
311119 149174/cgic.c len = cgiContentLength - mpp -> offset 351
static cgiParseResultType cgiParsePostMultipartInput()
cgiParseResultType result ;
int got ;
char tfileName [ 1024 ] ;
mpStreamPtr mpp = & mp ;
if ( ! cgiContentLength )
result = afterNextBoundary ( mpp , 0 , 0 , 0 , 1 );
if ( result == cgiParseIO )
if ( result != cgiParseSuccess )
while ( 1 )
char d [ 1024 ] ;
char fvalue [ 1024 ] ;
char fname [ 1024 ] ;
int bodyLength = 0 ;
char ffileName [ 1024 ] ;
char fcontentType [ 1024 ] ;
char attr [ 1024 ] ;
char value [ 1024 ] ;
fvalue [ 0 ] = 0;
fname [ 0 ] = 0;
ffileName [ 0 ] = 0;
out = 0;
outf = 0;
got = mpRead ( mpp , d , 2 );
if ( got < 2 )
if ( ( d [ 0 ] == '-' ) && ( d [ 1 ] == '-' ) )
while ( readHeaderLine ( mpp , attr , sizeof ( attr ) , value , sizeof ( value ) ) )
if ( ! cgiStrEqNc ( fvalue , "form-data" ) )
result = afterNextBoundary ( mpp , 0 , 0 , 0 , 0 );
if ( result != cgiParseSuccess )
if ( strlen ( ffileName ) )
if ( getTempFileName ( tfileName ) != cgiParseSuccess )
outf = fopen ( tfileName , "w+b" );
outf = 0;
result = afterNextBoundary ( mpp , outf , & out , & bodyLength , 0 );
if ( result != cgiParseSuccess )
n = ( cgiFormEntry * ) malloc ( sizeof ( cgiFormEntry ) );
if ( ! n )
memset ( n , 0 , sizeof ( cgiFormEntry ) );
n -> attr = ( char * ) malloc ( strlen ( fname ) + 1 );
if ( ! n -> attr )
if ( out )
if ( outf )
n -> value = ( char * ) malloc ( 1 );
if ( ! n -> value )
n -> value [ 0 ] = '\0';
n -> valueLength = bodyLength;
n -> next = 0;
n -> fileName = ( char * ) malloc ( strlen ( ffileName ) + 1 );
if ( ! n -> fileName )
strcpy ( n -> fileName , ffileName );
n -> contentType = ( char * ) malloc ( strlen ( fcontentType ) + 1 );
if ( ! n -> contentType )
strcpy ( n -> contentType , fcontentType );
n -> tfileName = ( char * ) malloc ( strlen ( tfileName ) + 1 );
if ( ! n -> tfileName )
static int
mpStreamPtr
char
int
char
int valueSpace)
while ( 1 )
char d [ 1 ] ;
int got = mpRead ( mpp , d , 1 ) ;
if ( got != 1 )
if ( d [ 0 ] == '\r' )
if ( d [ 0 ] == '\n' )
int mpRead(mpStreamPtr mpp, char *buffer, int len)
if ( len > ( cgiContentLength - mpp -> offset ) )
len = cgiContentLength - mpp -> offset;
while ( len )
len --;
if ( len )
int fgot = fread ( buffer , 1 , len , cgiIn ) ;
if ( fgot >= 0 )
mpp -> offset += ( got + fgot );
return got + fgot ;
return fgot ;
0
------------------------------
298687 95448/CWE369_Divide_by_Zero__int_zero_divide_07.c printIntLine ( 100 / data ) 40
void CWE369_Divide_by_Zero__int_zero_divide_07_bad()
int data ;
data = - 1;
if ( staticFive == 5 )
data = 0;
if ( staticFive == 5 )
printIntLine ( 100 / data );
1
------------------------------
310483 150403/gimpviewable.c stonesoup_arr [ i ] = stonesoupData -> qsize - i 207
void *to1337(void *data)
struct stonesoup_data * stonesoupData = ( struct stonesoup_data * ) data ;
int * stonesoup_arr ;
stonesoup_arr = malloc ( sizeof ( int ) * stonesoupData -> qsize );
if ( stonesoup_arr != NULL )
for (i = 0; i < stonesoupData->qsize; i++)
stonesoup_arr [ i ] = stonesoupData -> qsize - i;
qsort ( stonesoup_arr , stonesoupData -> qsize , sizeof ( int ) , & stonesoup_comp );
free ( stonesoup_arr );
while ( stonesoupData -> data [ i ] != '\0' )
switch ( stonesoupData -> data [ i ] )
temp = stonesoupData -> data [ i ];
temp_str [ i ] = temp;
i ++;
temp_str [ i ] = '\0';
stonesoupData -> data = temp_str;
tracepoint ( stonesoup_trace , variable_address , "stonesoupData->data" , stonesoupData -> data , "TRIGGER-STATE: UNSET" );
0
------------------------------
299728 150226/aviobuf.c s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_ptr - s -> checksum_ptr ) ) ) 290
int avio_put_str(AVIOContext *s,const char *str)
int len = 1 ;
if ( str )
len += strlen ( str );
avio_write ( s , ( ( const unsigned char * ) str ) , len );
void avio_write(AVIOContext *s,const unsigned char *buf,int size)
if ( s -> direct && ! s -> update_checksum )
avio_flush ( s );
void avio_flush(AVIOContext *s)
flush_buffer ( s );
static void flush_buffer(AVIOContext *s)
if ( s -> buf_ptr > s -> buffer )
if ( s -> update_checksum )
s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_ptr - s -> checksum_ptr ) ) );
s -> checksum_ptr = s -> buffer;
s -> buf_ptr = s -> buffer;
0
------------------------------
18838 CVE-2015-2716/Firefox_37.0b7_CVE_2015_2716_parser_expat_lib_xmlparse.c pool -> ptr = pool -> blocks -> s + ( pool -> ptr - pool -> start ) 6249
static enum XML_Error
entityValueProcessor(XML_Parser
const char
const char
const char **nextPtr)
const char * start = s ;
const char * next = s ;
const ENCODING * enc = encoding ;
int tok ;
tok = XmlPrologTok ( enc , start , end , & next );
if ( tok <= 0 )
if ( ! ps_finalBuffer && tok != XML_TOK_INVALID )
switch ( tok )
return storeEntityValue ( parser , enc , s , end ) ;
start = next;
static enum
storeEntityValue(XML_Parser
const ENCODING
const char
const char *entityTextEnd)
DTD * const dtd = _dtd
STRING_POOL * pool = & ( dtd -> entityValuePool ) ;
if ( ! pool -> blocks )
if ( ! poolGrow ( pool ) )
const char * next ;
int tok = XmlEntityValueTok ( enc , entityTextPtr , entityTextEnd , & next ) ;
switch ( tok )
if ( isParamEntity || enc != encoding )
const XML_Char * name ;
ENTITY * entity ;
name = poolStoreString ( & tempPool , enc , entityTextPtr + enc -> minBytesPerChar , next - enc -> minBytesPerChar );
if ( ! name )
entity = ( ENTITY * ) lookup ( & dtd -> paramEntities , name , 0 );
if ( ! entity )
if ( entity -> open )
if ( entity -> systemId )
if ( externalEntityRefHandler )
entity -> open = XML_TRUE;
if ( ! externalEntityRefHandler ( externalEntityRefHandlerArg , 0 , entity -> base , entity -> systemId , entity -> publicId ) )
entity -> open = XML_FALSE;
entity -> open = XML_TRUE;
result = storeEntityValue ( parser , internalEncoding , ( char * ) entity -> textPtr , ( char * ) ( entity -> textPtr + entity -> textLen ) );
entity -> open = XML_FALSE;
if ( result )
if ( ! poolAppend ( pool , enc , entityTextPtr , next ) )
next = entityTextPtr + enc -> minBytesPerChar;
if ( pool -> end == pool -> ptr && ! poolGrow ( pool ) )
* ( pool -> ptr ) ++ = 0xA;
XML_Char buf [ XML_ENCODE_MAX ] ;
int i ;
int n = XmlCharRefNumber ( enc , entityTextPtr ) ;
if ( n < 0 )
n = XmlEncode ( n , ( ICHAR * ) buf );
if ( ! n )
for (i = 0; i < n; i++)
if ( pool -> end == pool -> ptr && ! poolGrow ( pool ) )
* ( pool -> ptr ) ++ = buf [ i ];
entityTextPtr = next;
static XML_Char
poolStoreString(STRING_POOL *pool, const ENCODING
const char *ptr, const char *end)
if ( ! poolAppend ( pool , enc , ptr , end ) )
if ( pool -> ptr == pool -> end && ! poolGrow ( pool ) )
static XML_Bool
poolGrow(STRING_POOL *pool)
if ( pool -> freeBlocks )
if ( pool -> start == 0 )
if ( pool -> end - pool -> start < pool -> freeBlocks -> size )
BLOCK * tem = pool -> freeBlocks -> next ;
pool -> freeBlocks -> next = pool -> blocks;
pool -> blocks = pool -> freeBlocks;
pool -> freeBlocks = tem;
memcpy ( pool -> blocks -> s , pool -> start , ( pool -> end - pool -> start ) * sizeof ( XML_Char ) );
pool -> ptr = pool -> blocks -> s + ( pool -> ptr - pool -> start );
pool -> start = pool -> blocks -> s;
pool -> end = pool -> start + pool -> blocks -> size;
0
------------------------------
313837 110799/CWE680_Integer_Overflow_to_Buffer_Overflow__new_listen_socket_08.cpp dataBytes = data * sizeof ( int ) 140
void bad()
int data ;
data = - 1;
if ( staticReturnsTrue ( ) )
static int staticReturnsTrue()
return 1 ;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
char inputBuffer [ CHAR_ARRAY_SIZE ] ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
inputBuffer [ recvResult ] = '\0';
data = atoi ( inputBuffer );
while ( 0 )
size_t dataBytes , i ;
dataBytes = data * sizeof ( int );
intPointer = ( int * ) new char [ dataBytes ];
intPointer [ i ] = 0;
printIntLine ( intPointer [ 0 ] );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
delete [ ] intPointer
1
------------------------------
305166 95446/CWE369_Divide_by_Zero__int_zero_divide_05.c printIntLine ( 100 / data ) 70
static void goodB2G1()
int data ;
data = - 1;
if ( staticTrue )
data = 0;
if ( staticFalse )
if ( data != 0 )
printIntLine ( 100 / data );
0
------------------------------
309886 152025/bufmgr.c newPartitionLock = ( ( LWLockId ) ( FirstBufMappingLock + newHash % 16 ) ) 567
Buffer ReadBuffer(Relation reln,BlockNumber blockNum)
return ReadBufferExtended ( reln , MAIN_FORKNUM , blockNum , RBM_NORMAL , ( ( void * ) 0 ) ) ;
Buffer ReadBufferExtended(Relation reln,ForkNumber forkNum,BlockNumber blockNum,ReadBufferMode mode,BufferAccessStrategy strategy)
Buffer buf ;
if ( reln -> pgstat_info != ( ( void * ) 0 ) )
reln -> pgstat_info -> t_counts . t_blocks_fetched ++;
while ( 0 )
buf = ReadBuffer_common ( reln -> rd_smgr , reln -> rd_rel -> relpersistence , forkNum , blockNum , mode , strategy , & hit );
static Buffer ReadBuffer_common(SMgrRelation smgr,char relpersistence,ForkNumber forkNum,BlockNumber blockNum,ReadBufferMode mode,BufferAccessStrategy strategy,bool *hit)
volatile BufferDesc * bufHdr ;
bool isExtend ;
bool isLocalBuf = ( smgr -> smgr_rnode . backend != - 1 ) ;
isExtend = ( blockNum == ( ( BlockNumber ) 0xFFFFFFFF ) );
if ( isExtend )
blockNum = smgrnblocks ( smgr , forkNum );
if ( isLocalBuf )
bufHdr = BufferAlloc ( smgr , relpersistence , forkNum , blockNum , strategy , & found );
static volatile BufferDesc *BufferAlloc(SMgrRelation smgr,char relpersistence,ForkNumber forkNum,BlockNumber blockNum,BufferAccessStrategy strategy,bool *foundPtr)
BufferTag newTag ;
uint32 newHash ;
LWLockId newPartitionLock ;
( newTag . rnode = smgr -> smgr_rnode . node , newTag . forkNum = forkNum ) , newTag . blockNum = blockNum;
newHash = BufTableHashCode ( & newTag );
newPartitionLock = ( ( LWLockId ) ( FirstBufMappingLock + newHash % 16 ) );
LWLockAcquire ( newPartitionLock , LW_SHARED );
LWLockRelease ( newPartitionLock );
LWLockRelease ( newPartitionLock );
if ( oldPartitionLock < newPartitionLock )
LWLockAcquire ( newPartitionLock , LW_EXCLUSIVE );
if ( oldPartitionLock > newPartitionLock )
LWLockAcquire ( newPartitionLock , LW_EXCLUSIVE );
LWLockAcquire ( newPartitionLock , LW_EXCLUSIVE );
LWLockAcquire ( newPartitionLock , LW_EXCLUSIVE );
if ( oldFlags & 1 << 2 && oldPartitionLock != newPartitionLock )
LWLockRelease ( newPartitionLock );
if ( oldFlags & 1 << 2 && oldPartitionLock != newPartitionLock )
LWLockRelease ( newPartitionLock );
if ( oldPartitionLock != newPartitionLock )
LWLockRelease ( newPartitionLock );
0
------------------------------
302947 82496/CWE190_Integer_Overflow__char_rand_square_03.c char result = data * data ; 92
static void goodB2G2()
char data ;
data = ' ';
if ( 5 == 5 )
data = ( char ) RAND32 ( );
if ( 5 == 5 )
if ( abs ( ( long ) data ) <= ( long ) sqrt ( ( double ) CHAR_MAX ) )
char result = data * data ;
printHexCharLine ( result );
void printHexCharLine (char charHex)
printf ( "%02x\n" , charHex );
0
------------------------------
307784 110507/CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_listen_socket_04.c intPointer = ( int * ) malloc ( data * sizeof ( int ) ) 132
void CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_listen_socket_04_bad()
int data ;
data = - 1;
if ( STATIC_CONST_TRUE )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
char inputBuffer [ CHAR_ARRAY_SIZE ] ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
inputBuffer [ recvResult ] = '\0';
data = atoi ( inputBuffer );
while ( 0 )
int * intPointer ;
intPointer = ( int * ) malloc ( data * sizeof ( int ) );
intPointer [ i ] = 0;
printIntLine ( intPointer [ 0 ] );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
free ( intPointer );
1
------------------------------
301047 153289/aviobuf.c s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_ptr - s -> checksum_ptr ) ) ) 202
int avio_put_str16le(AVIOContext *s,const char *str)
const uint8_t * q = str ;
while ( * q )
uint32_t ch ;
uint16_t tmp ;
ch = ( * ( q ++ ) );
uint32_t top = ( ch & 128 ) >> 1 ;
if ( ( ch & 0xc0 ) == 0x80 )
while ( ch & top )
int tmp = ( * ( q ++ ) ) - 128 ;
if ( tmp >> 6 )
ch = ( ch << 6 ) + tmp;
top <<= 5;
ch &= ( top << 1 ) - 1;
uint32_t in = ch ;
if ( in < 0x10000 )
tmp = ( 0xD800 | in - 0x10000 >> 10 );
avio_wl16 ( s , tmp );
void avio_wl16(AVIOContext *s,unsigned int val)
avio_w8 ( s , ( ( int ) val ) >> 8 );
void avio_w8(AVIOContext *s,int b)
* ( s -> buf_ptr ++ ) = b;
if ( s -> buf_ptr >= s -> buf_end )
flush_buffer ( s );
static void flush_buffer(AVIOContext *s)
if ( s -> buf_ptr > s -> buffer )
if ( s -> update_checksum )
s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_ptr - s -> checksum_ptr ) ) );
s -> checksum_ptr = s -> buffer;
s -> buf_ptr = s -> buffer;
0
------------------------------
308102 117107/CWE789_Uncontrolled_Mem_Alloc__malloc_char_fscanf_45.c myString = ( char * ) malloc ( data * sizeof ( char ) ) 42
static void badSink()
size_t data = CWE789_Uncontrolled_Mem_Alloc__malloc_char_fscanf_45_badData ;
char * myString ;
if ( data > strlen ( HELLO_STRING ) )
myString = ( char * ) malloc ( data * sizeof ( char ) );
strcpy ( myString , HELLO_STRING );
printLine ( myString );
void printLine (const char * line)
if ( line != NULL )
printf ( "%s\n" , line );
free ( myString );
1
------------------------------
304837 80325/CWE134_Uncontrolled_Format_String__char_listen_socket_printf_44.c recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 104
void CWE134_Uncontrolled_Format_String__char_listen_socket_printf_44_bad()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
funcPtr ( data );
0
------------------------------
305890 117290/CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_fgets_22b.c myString = ( wchar_t * ) malloc ( data * sizeof ( wchar_t ) ) 82
static void goodB2G1()
size_t data ;
data = 0;
char inputBuffer [ CHAR_ARRAY_SIZE ] = "" ;
if ( fgets ( inputBuffer , CHAR_ARRAY_SIZE , stdin ) != NULL )
data = strtoul ( inputBuffer , NULL , 0 );
CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_fgets_22_goodB2G1Sink ( data );
void CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_fgets_22_goodB2G1Sink(size_t data)
if ( CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_fgets_22_goodB2G1Global )
wchar_t * myString ;
if ( data > wcslen ( HELLO_STRING ) && data < 100 )
myString = ( wchar_t * ) malloc ( data * sizeof ( wchar_t ) );
wcscpy ( myString , HELLO_STRING );
printWLine ( myString );
void printWLine (const wchar_t * line)
if ( line != NULL )
wprintf ( L "%ls\n" , line )
free ( myString );
0
------------------------------
17562 CVE-2013-1580/CVE_2013_1580_VULN_dissect_cmstatus_tlv.c pos = pos + length 62
static
CVE_2013_1580_VULN_dissect_cmstatus_tlv (tvbuff_t * tvb, proto_tree * tree, guint8 start, guint16 len)
guint8 pos = start + 1 ;
guint8 type , length ;
while ( pos < ( len + start + 1 ) )
length = tvb_get_guint8 ( tvb , pos ++ );
type = tvb_get_guint8 ( tvb , pos ++ );
pos = pos + length;
0
------------------------------
313422 96514/CWE36_Absolute_Path_Traversal__char_listen_socket_fopen_17.cpp recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ) 107
void bad()
int i ;
char * data ;
char dataBuffer [ FILENAME_MAX ] = "" ;
data = dataBuffer;
for(i = 0; i < 1; i++)
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( FILENAME_MAX - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
pFile = FOPEN ( data , "wb+" );
if ( pFile != NULL )
fclose ( pFile );
1
------------------------------
306766 118167/CWE78_OS_Command_Injection__char_connect_socket_w32_execv_54a.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 105
void CWE78_OS_Command_Injection__char_connect_socket_w32_execv_54_bad()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
CWE78_OS_Command_Injection__char_connect_socket_w32_execv_54b_badSink ( data );
void CWE78_OS_Command_Injection__char_connect_socket_w32_execv_54b_badSink(char * data)
CWE78_OS_Command_Injection__char_connect_socket_w32_execv_54c_badSink ( data );
void CWE78_OS_Command_Injection__char_connect_socket_w32_execv_54c_badSink(char * data)
CWE78_OS_Command_Injection__char_connect_socket_w32_execv_54d_badSink ( data );
void CWE78_OS_Command_Injection__char_connect_socket_w32_execv_54d_badSink(char * data)
CWE78_OS_Command_Injection__char_connect_socket_w32_execv_54e_badSink ( data );
void CWE78_OS_Command_Injection__char_connect_socket_w32_execv_54e_badSink(char * data)
0
------------------------------
301939 149947/dfa.c dfa -> multibyte_prop [ dfa -> tindex - 1 ] = dfa -> multibyte_prop [ tindex + i ] 2240
static void closure()
int i ;
size_t tindex ;
size_t ntokens ;
while ( tok == QMARK || tok == STAR || tok == PLUS || tok == REPMN )
if ( tok == REPMN && ( minrep || maxrep ) )
ntokens = nsubtoks ( dfa -> tindex );
tindex = dfa -> tindex - ntokens;
for (i = 1; i < minrep; ++i)
copytoks ( tindex , ntokens );
tok = lex ( );
if ( tok == REPMN )
dfa -> tindex -= nsubtoks ( dfa -> tindex );
tok = lex ( );
tok = lex ( );
static void copytoks(size_t tindex,size_t ntokens)
size_t i ;
for (i = 0; i < ntokens; ++i)
addtok ( dfa -> tokens [ tindex + i ] );
if ( __ctype_get_mb_cur_max ( ) > 1 && dfa -> tokens [ tindex + i ] == MBCSET )
dfa -> multibyte_prop [ dfa -> tindex - 1 ] = dfa -> multibyte_prop [ tindex + i ];
0
------------------------------
303460 82373/CWE190_Integer_Overflow__char_max_square_34.c char result = data * data ; 42
void CWE190_Integer_Overflow__char_max_square_34_bad()
char data ;
CWE190_Integer_Overflow__char_max_square_34_unionType myUnion ;
data = ' ';
data = CHAR_MAX;
myUnion . unionFirst = data;
char data = myUnion . unionSecond ;
char result = data * data ;
printHexCharLine ( result );
void printHexCharLine (char charHex)
printf ( "%02x\n" , charHex );
1
------------------------------
302419 80489/CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_84_goodB2G.cpp recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 93
static void goodB2G()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_84_goodB2G * goodB2GObject = new CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_84_goodB2G ( data ) ;
CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_84_goodB2G::CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_84_goodB2G(char * dataCopy)
data = dataCopy;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
0
------------------------------
20642 CVE-2016-8910/qemu_2.3.0_CVE-2016-8910_rtl8139.c ret = s -> phys [ addr - MAC0 ] 2968
static uint32_t rtl8139_mmio_readw(void *opaque, hwaddr addr)
uint32_t val = rtl8139_io_readw ( opaque , addr & 0xFF ) ;
static uint32_t rtl8139_io_readw(void *opaque, uint8_t addr)
RTL8139State * s = opaque ;
uint32_t ret ;
switch ( addr )
ret = rtl8139_TxStatus_TxAddr_read ( s , s -> TxAddr , TxAddr0 , addr , 2 );
ret = rtl8139_IntrMask_read ( s );
ret = rtl8139_IntrStatus_read ( s );
ret = rtl8139_MultiIntr_read ( s );
ret = rtl8139_RxBufPtr_read ( s );
ret = rtl8139_RxBufAddr_read ( s );
ret = rtl8139_BasicModeCtrl_read ( s );
ret = rtl8139_BasicModeStatus_read ( s );
ret = s -> NWayAdvert;
ret = s -> NWayLPAR;
ret = s -> NWayExpansion;
ret = rtl8139_CpCmd_read ( s );
ret = rtl8139_IntrMitigate_read ( s );
ret = rtl8139_TSAD_read ( s );
ret = rtl8139_CSCR_read ( s );
ret = rtl8139_io_readb ( opaque , addr );
ret |= rtl8139_io_readb ( opaque , addr + 1 ) << 8;
static uint32_t rtl8139_io_readb(void *opaque, uint8_t addr)
RTL8139State * s = opaque ;
int ret ;
switch ( addr )
ret = s -> phys [ addr - MAC0 ];
DPRINTF ( "MediaStatus read 0x%x\n" , ret );
DPRINTF ( "HltClk read 0x%x\n" , ret );
DPRINTF ( "PCI Revision ID read 0x%x\n" , ret );
DPRINTF ( "C+ TxThresh read(b) val=0x%02x\n" , ret );
DPRINTF ( "RTL8139C TxConfig at 0x43 read(b) val=0x%02x\n" , ret );
return ret ;
0
------------------------------
314817 110671/CWE680_Integer_Overflow_to_Buffer_Overflow__new_fgets_34.cpp dataBytes = data * sizeof ( int ) 58
void bad()
int data ;
unionType myUnion ;
data = - 1;
char inputBuffer [ CHAR_ARRAY_SIZE ] = "" ;
if ( fgets ( inputBuffer , CHAR_ARRAY_SIZE , stdin ) != NULL )
data = atoi ( inputBuffer );
myUnion . unionFirst = data;
int data = myUnion . unionSecond ;
size_t dataBytes , i ;
dataBytes = data * sizeof ( int );
intPointer = ( int * ) new char [ dataBytes ];
intPointer [ i ] = 0;
printIntLine ( intPointer [ 0 ] );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
delete [ ] intPointer
1
------------------------------
19158 CVE-2016-8666/linux_kernel_4.2.5_CVE_2016_8666_net_ipv4_udp_offload.c __be16 newlen = htons ( skb -> len - nhoff ) ; 382
static int udp4_gro_complete(struct sk_buff *skb, int nhoff)
return udp_gro_complete ( skb , nhoff ) ;
int udp_gro_complete(struct sk_buff *skb, int nhoff)
__be16 newlen = htons ( skb -> len - nhoff ) ;
uh -> len = newlen;
if ( uo_priv -> offload -> port == uh -> dest && uo_priv -> offload -> callbacks . gro_complete )
0
------------------------------
309410 151493/utf.c valid_txt = ( apr_pstrcat ( pool , valid_txt , apr_psprintf ( pool , " %02x" , ( ( unsigned char ) last [ i - valid ] ) ) , ( ( char * ) ( ( void * ) 0 ) ) ) ) 645
svn_error_t *svn_utf_cstring_to_utf8_ex(const char **dest,const char *src,const char *frompage,const char *convset_key,apr_pool_t *pool)
return svn_utf_cstring_to_utf8_ex2 ( dest , src , frompage , pool ) ;
svn_error_t *svn_utf_cstring_to_utf8_ex2(const char **dest,const char *src,const char *frompage,apr_pool_t *pool)
xlate_handle_node_t * node ;
svn_error_t * err ;
const char * convset_key = get_xlate_key ( SVN_APR_UTF8_CHARSET , frompage , pool ) ;
static const char *get_xlate_key(const char *topage,const char *frompage,apr_pool_t *pool)
if ( frompage == ( ( const char * ) 1 ) )
frompage = "APR_LOCALE_CHARSET";
if ( frompage == ( ( const char * ) 0 ) )
frompage = "APR_DEFAULT_CHARSET";
if ( topage == ( ( const char * ) 1 ) )
topage = "APR_LOCALE_CHARSET";
if ( topage == ( ( const char * ) 0 ) )
topage = "APR_DEFAULT_CHARSET";
return ( apr_pstrcat ( pool , "svn-utf-" , frompage , "to" , topage , "-xlate-handle" , ( ( char * ) ( ( void * ) 0 ) ) ) ) ;
svn_error_t * svn_err__temp = get_xlate_handle_node ( & node , SVN_APR_UTF8_CHARSET , frompage , convset_key , pool ) ;
static svn_error_t *get_xlate_handle_node(xlate_handle_node_t **ret,const char *topage,const char *frompage,const char *userdata_key,apr_pool_t *pool)
xlate_handle_node_t * old_node = ( ( void * ) 0 ) ;
if ( userdata_key )
if ( xlate_handle_hash )
if ( userdata_key == SVN_UTF_NTOU_XLATE_HANDLE )
old_node = ( atomic_swap ( & xlat_ntou_static_handle , ( ( void * ) 0 ) ) );
if ( userdata_key == SVN_UTF_UTON_XLATE_HANDLE )
old_node = ( atomic_swap ( & xlat_uton_static_handle , ( ( void * ) 0 ) ) );
if ( old_node && old_node -> valid )
return 0 ;
void * p ;
old_node = p;
if ( old_node && old_node -> valid )
return 0 ;
return xlate_alloc_handle ( ret , topage , frompage , pool ) ;
svn_mutex__t * svn_mutex__m = xlate_handle_mutex ;
svn_error_t * svn_err__temp = svn_mutex__lock ( svn_mutex__m ) ;
if ( svn_err__temp )
return svn_err__temp ;
while ( 0 )
svn_error_t * svn_err__temp = svn_mutex__unlock ( svn_mutex__m , get_xlate_handle_node_internal ( ret , topage , frompage , userdata_key , pool ) ) ;
if ( svn_err__temp )
return svn_err__temp ;
while ( 0 )
while ( 0 )
return 0 ;
if ( svn_err__temp )
while ( 0 )
err = convert_cstring ( dest , src , node , pool );
static svn_error_t *convert_cstring(const char **dest,const char *src,xlate_handle_node_t *node,apr_pool_t *pool)
if ( node -> handle )
svn_error_t * svn_err__temp = convert_to_stringbuf ( node , src , strlen ( src ) , & destbuf , pool ) ;
if ( svn_err__temp )
return svn_err__temp ;
while ( 0 )
apr_size_t len = strlen ( src ) ;
svn_error_t * svn_err__temp = check_non_ascii ( src , len , pool ) ;
if ( svn_err__temp )
return svn_err__temp ;
while ( 0 )
return 0 ;
svn_error_t * svn_err__temp = svn_error_compose_create ( err , put_xlate_handle_node ( node , SVN_UTF_NTOU_XLATE_HANDLE , pool ) ) ;
static svn_error_t *put_xlate_handle_node(xlate_handle_node_t *node,const char *userdata_key,apr_pool_t *pool)
if ( ! userdata_key )
return 0 ;
if ( xlate_handle_hash )
if ( userdata_key == SVN_UTF_NTOU_XLATE_HANDLE )
node = ( atomic_swap ( & xlat_ntou_static_handle , node ) );
if ( userdata_key == SVN_UTF_UTON_XLATE_HANDLE )
node = ( atomic_swap ( & xlat_uton_static_handle , node ) );
if ( node == ( ( void * ) 0 ) )
return 0 ;
svn_mutex__t * svn_mutex__m = xlate_handle_mutex ;
svn_error_t * svn_err__temp = svn_mutex__lock ( svn_mutex__m ) ;
if ( svn_err__temp )
return svn_err__temp ;
while ( 0 )
svn_error_t * svn_err__temp = svn_mutex__unlock ( svn_mutex__m , put_xlate_handle_node_internal ( node , userdata_key ) ) ;
if ( svn_err__temp )
return svn_err__temp ;
while ( 0 )
while ( 0 )
return 0 ;
if ( svn_err__temp )
while ( 0 )
return check_cstring_utf8 ( * dest , pool ) ;
static svn_error_t *check_cstring_utf8(const char *data,apr_pool_t *pool)
if ( ! svn_utf__cstring_is_valid ( data ) )
return invalid_utf8 ( data , strlen ( data ) , pool ) ;
static svn_error_t *invalid_utf8(const char *data,apr_size_t len,apr_pool_t *pool)
const char * last = svn_utf__last_valid ( data , len ) ;
const char * valid_txt = "" ;
apr_size_t i ;
size_t valid ;
valid = ( last - data );
if ( valid > 24 )
valid = 24;
for (i = 0; i < valid; ++i)
valid_txt = ( apr_pstrcat ( pool , valid_txt , apr_psprintf ( pool , " %02x" , ( ( unsigned char ) last [ i - valid ] ) ) , ( ( char * ) ( ( void * ) 0 ) ) ) );
return svn_error_createf ( 22 , ( ( void * ) 0 ) , ( dgettext ( "subversion" , "Valid UTF-8 data\n(hex:%s)\nfollowed by invalid UTF-8 sequence\n(hex:%s)" ) ) , valid_txt , invalid_txt ) ;
0
------------------------------
302080 149940/cmdutils.c filepath = ( char * ) malloc ( size_filepath * sizeof ( char ) ) 104
void stonesoup_setup_printf_context()
ss_tc_root = getenv ( "SS_TC_ROOT" );
if ( ss_tc_root != NULL )
size_dirpath = strlen ( ss_tc_root ) + strlen ( "testData" ) + 2;
dirpath = ( char * ) malloc ( size_dirpath * sizeof ( char ) );
if ( dirpath != NULL )
sprintf ( dirpath , "%s/%s" , ss_tc_root , "testData" );
retval = 0;
if ( stat ( dirpath , & st ) == - 1 )
retval = mkdir ( dirpath , 0700 );
if ( retval == 0 )
size_filepath = strlen ( dirpath ) + strlen ( "logfile.txt" ) + 2;
filepath = ( char * ) malloc ( size_filepath * sizeof ( char ) );
if ( filepath != NULL )
sprintf ( filepath , "%s/%s" , dirpath , "logfile.txt" );
stonesoup_printf_context = fopen ( filepath , "w" );
free ( filepath );
if ( stonesoup_printf_context == NULL )
0
------------------------------
17521 CVE-2009-4138/CVE_2009_4138_VULN_ohci_queue_iso_receive_dualbuffer.c length = PAGE_SIZE - offset 61
static int CVE_2009_4138_VULN_ohci_queue_iso_receive_dualbuffer(struct fw_iso_context
struct fw_iso_packet
struct fw_iso_buffer
unsigned long payload)
struct iso_context * ctx = container_of ( base , struct iso_context , base )
struct descriptor * d ;
struct fw_iso_packet * p ;
u32 z , header_z , length , rest ;
int page , offset , packet_count , header_size ;
p = packet;
z = 2;
packet_count = p -> header_length / ctx -> base . header_size;
header_size = packet_count * max ( ctx -> base . header_size , ( size_t ) 8 );
header_z = DIV_ROUND_UP ( header_size , sizeof ( * d ) );
offset = payload & ~PAGE_MASK;
rest = p -> payload_length;
while ( rest > 0 )
d = context_get_descriptors ( & ctx -> context , z + header_z , & d_bus );
if ( d == NULL )
if ( p -> skip && rest == p -> payload_length )
length = 4;
if ( offset + rest < PAGE_SIZE )
length = rest;
length = PAGE_SIZE - offset;
offset = ( offset + length ) & ~PAGE_MASK;
rest -= length;
0
------------------------------
305390 95457/CWE369_Divide_by_Zero__int_zero_divide_16.c printIntLine ( 100 / data ) 87
static void goodG2B()
int data ;
data = - 1;
while ( 1 )
data = 7;
while ( 1 )
printIntLine ( 100 / data );
0
------------------------------
310563 151037/resowner.c owner -> planrefs = ( ( CachedPlan * * ) ( MemoryContextAlloc ( TopMemoryContext , newmax * sizeof ( CachedPlan * ) ) ) ) 892
void ResourceOwnerEnlargePlanCacheRefs(ResourceOwner owner)
int newmax ;
if ( owner -> nplanrefs < owner -> maxplanrefs )
if ( owner -> planrefs == ( ( void * ) 0 ) )
newmax = 16;
owner -> planrefs = ( ( CachedPlan * * ) ( MemoryContextAlloc ( TopMemoryContext , newmax * sizeof ( CachedPlan * ) ) ) );
owner -> maxplanrefs = newmax;
newmax = owner -> maxplanrefs * 2;
owner -> planrefs = ( ( CachedPlan * * ) ( repalloc ( ( owner -> planrefs ) , newmax * sizeof ( CachedPlan * ) ) ) );
owner -> maxplanrefs = newmax;
0
------------------------------
306816 117364/CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_fscanf_82_goodB2G.cpp myString = ( wchar_t * ) malloc ( data * sizeof ( wchar_t ) ) 36
static void goodB2G()
size_t data ;
data = 0;
CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_fscanf_82_base * baseObject = new CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_fscanf_82_goodB2G
baseObject -> action ( data );
void CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_fscanf_82_goodB2G::action(size_t data)
wchar_t * myString ;
if ( data > wcslen ( HELLO_STRING ) && data < 100 )
myString = ( wchar_t * ) malloc ( data * sizeof ( wchar_t ) );
wcscpy ( myString , HELLO_STRING );
printWLine ( myString );
void printWLine (const wchar_t * line)
if ( line != NULL )
wprintf ( L "%ls\n" , line )
free ( myString );
0
------------------------------
306016 118344/CWE78_OS_Command_Injection__char_connect_socket_w32_spawnvp_18.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 103
void CWE78_OS_Command_Injection__char_connect_socket_w32_spawnvp_18_bad()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
0
------------------------------
307291 109983/CWE666_Operation_on_Resource_in_Wrong_Phase_of_Lifetime__bind_accept_listen_03.c recvResult = recv ( acceptSocket , ( char * ) data + dataLen , ( int ) ( 100 - dataLen - 1 ) , 0 ) 93
void CWE666_Operation_on_Resource_in_Wrong_Phase_of_Lifetime__bind_accept_listen_03_bad()
if ( 5 == 5 )
char data [ 100 ] = "" ;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) data + dataLen , ( int ) ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ recvResult ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
printLine ( data );
void printLine (const char * line)
if ( line != NULL )
printf ( "%s\n" , line );
1
------------------------------
309538 153611/dfa.c size_t mid = lo + hi >> 1 ; 2242
char *dfaexec(struct dfa *d,const char *begin,char *end,int allow_nl,size_t *count,int *backref)
state_num s ;
state_num s1 ;
const unsigned char * p ;
state_num * * trans ;
state_num * t ;
unsigned char eol = eolbyte ;
s = s1 = 0;
p = ( ( const unsigned char * ) begin );
trans = d -> trans;
* end = eol;
if ( d -> mb_cur_max > 1 )
while ( ( t = trans [ s ] ) != ( ( void * ) 0 ) )
if ( p > buf_end )
s1 = s;
if ( s == 0 )
if ( ( ( char * ) p ) >= end )
if ( d -> states [ s ] . mbps . nelem == 0 )
s = t [ * ( p ++ ) ];
if ( backref )
s = transit_state ( d , s , & p );
trans = d -> trans;
while ( ( t = trans [ s ] ) != ( ( void * ) 0 ) )
s1 = t [ * ( p ++ ) ];
if ( ( t = trans [ s1 ] ) == ( ( void * ) 0 ) )
state_num tmp = s ;
s = s1;
s1 = tmp;
s = t [ * ( p ++ ) ];
if ( s >= 0 && ( ( char * ) p ) <= end && d -> fails [ s ] )
if ( d -> success [ s ] & sbit [ * p ] )
s1 = s;
if ( d -> mb_cur_max > 1 )
s = transit_state ( d , s , & p );
trans = d -> trans;
s = d -> fails [ s ] [ * ( p ++ ) ];
if ( ( ( char * ) p ) > end )
if ( s >= 0 )
trans = d -> trans;
if ( p [ - 1 ] == eol && allow_nl )
s = d -> newlines [ s1 ];
s = 0;
static state_num transit_state(struct dfa *d,state_num s,const unsigned char **pp)
int mbclen ;
int maxlen = 0 ;
size_t i ;
int * match_lens = ( ( void * ) 0 ) ;
size_t nelem = d -> states [ s ] . mbps . nelem ;
position_set follows ;
if ( nelem > 0 )
match_lens = check_matching_with_multibyte_ops ( d , s , ( * pp - buf_begin ) );
for (i = 0; i < nelem; i++)
if ( match_lens [ i ] > maxlen )
maxlen = match_lens [ i ];
if ( nelem == 0 || maxlen == 0 )
transit_state_consume_1char ( d , s , pp , match_lens , & mbclen , & follows );
static status_transit_state transit_state_consume_1char(struct dfa *d,state_num s,const unsigned char **pp,int *match_lens,int *mbclen,position_set *pps)
size_t i ;
size_t j ;
int k ;
state_num s1 ;
state_num s2 ;
int * work_mbls ;
* mbclen = ( mblen_buf [ * pp - buf_begin ] == 0 ? 1 : mblen_buf [ * pp - buf_begin ] );
s1 = s;
for (k = 0; k <  *mbclen; k++)
s2 = s1;
rs = transit_state_singlebyte ( d , s2 , ( * pp ) ++ , & s1 );
if ( match_lens == ( ( void * ) 0 ) && d -> states [ s ] . mbps . nelem != 0 )
work_mbls = check_matching_with_multibyte_ops ( d , s , ( * pp - buf_begin ) );
work_mbls = match_lens;
for (i = 0; i < d -> states[s] . mbps . nelem; i++)
if ( work_mbls [ i ] == * mbclen )
for (j = 0; j < d -> follows[d -> states[s] . mbps . elems[i] . index] . nelem; j++)
insert ( d -> follows [ d -> states [ s ] . mbps . elems [ i ] . index ] . elems [ j ] , pps );
static void insert(position p,position_set *s)
size_t count = s -> nelem ;
size_t lo = 0 ;
size_t hi = count ;
while ( lo < hi )
size_t mid = lo + hi >> 1 ;
if ( s -> elems [ mid ] . index > p . index )
lo = mid + 1;
hi = mid;
if ( lo < count && p . index == s -> elems [ lo ] . index )
s -> elems [ lo ] . constraint |= p . constraint;
for (i = count; i > lo; i--)
s -> elems [ lo ] = p;
++ s -> nelem;
0
------------------------------
306783 112810/CWE761_Free_Pointer_Not_at_Start_of_Buffer__wchar_t_connect_socket_04.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 ) 93
void CWE761_Free_Pointer_Not_at_Start_of_Buffer__wchar_t_connect_socket_04_bad()
wchar_t * data ;
data = ( wchar_t * ) malloc ( 100 * sizeof ( wchar_t ) );
data [ 0 ] = L '\0'
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
19238 CVE-2015-7202/Firefox_42.0b9_CVE_2015_7202_js_src_jit_IonCaches.cpp descriptor = MakeFrameDescriptor ( argSize + padding , JitFrame_IonAccessorIC ) 1052

GetPropertyIC::tryAttachDOMProxyUnshadowed(JSContext* cx, HandleScript outerScript, IonScript*
HandleObject obj, HandlePropertyName
bool resetNeeded, void* returnAddr, bool* emitted)
RootedObject checkObj ( cx , obj -> getTaggedProto ( ) . toObjectOrNull ( ) ) ;
RootedNativeObject holder ( cx ) ;
RootedShape shape ( cx ) ;
NativeGetPropCacheability canCache = CanAttachNativeGetProp ( cx , * this , checkObj , name , & holder , & shape , true ) ;
if ( canCache == CanAttachNone )
if ( ! holder && idempotent ( ) )
MacroAssembler masm ( cx , ion , outerScript , profilerLeavePc_ ) ;
StubAttacher attacher ( * this ) ;
if ( holder )
if ( canCache == CanAttachReadSlot )
if ( ! EmitGetterCall ( cx , masm , attacher , checkObj , holder , shape , liveRegs_ , object ( ) , output ( ) , returnAddr ) )
static
EmitGetterCall(JSContext* cx, MacroAssembler&
IonCache::StubAttacher& attacher, JSObject*
JSObject* holder, HandleShape
LiveRegisterSet liveRegs, Register
TypedOrValueRegister
void* returnAddr)
if ( IsCacheableGetPropCallNative ( obj , holder , shape ) )
static
IsCacheableGetPropCallNative(JSObject* obj, JSObject* holder, Shape* shape)
if ( ! shape || ! IsCacheableProtoChainForIon ( obj , holder ) )
static
IsCacheableProtoChainForIon(JSObject* obj, JSObject* holder)
while ( obj != holder )
JSObject * proto = obj -> getProto ( ) ;
if ( ! proto || ! proto -> isNative ( ) )
return false ;
obj = proto;
return true ;
return false ;
if ( ! shape -> hasGetterValue ( ) || ! shape -> getterValue ( ) . isObject ( ) )
return false ;
return false ;
if ( ! getter . isNative ( ) )
return false ;
if ( getter . jitInfo ( ) && ! getter . jitInfo ( ) -> needsOuterizedThisObject ( ) )
return true ;
return ! obj -> getClass ( ) -> ext . outerObject ;
if ( IsCacheableGetPropCallPropertyOp ( obj , holder , shape ) )
static
IsCacheableGetPropCallPropertyOp(JSObject* obj, JSObject* holder, Shape* shape)
if ( ! shape || ! IsCacheableProtoChainForIon ( obj , holder ) )
static
IsCacheableProtoChainForIon(JSObject* obj, JSObject* holder)
while ( obj != holder )
JSObject * proto = obj -> getProto ( ) ;
if ( ! proto || ! proto -> isNative ( ) )
return false ;
obj = proto;
return true ;
return false ;
if ( shape -> hasSlot ( ) || shape -> hasGetterValue ( ) || shape -> hasDefaultGetter ( ) )
return false ;
return true ;
JSFunction * target = & shape -> getterValue ( ) . toObject ( ) . as < JSFunction > ( )
uint32_t argSize = ( target -> nargs ( ) + 1 ) * sizeof ( Value ) ;
uint32_t padding = ComputeByteAlignment ( masm . framePushed ( ) + argSize , JitStackAlignment ) ;
descriptor = MakeFrameDescriptor ( argSize + padding , JitFrame_IonAccessorIC );
masm . Push ( Imm32 ( descriptor ) );
0
------------------------------
306326 110319/CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_connect_socket_08.c intPointer = ( int * ) malloc ( data * sizeof ( int ) ) 161
static void goodG2B1()
int data ;
data = - 1;
if ( staticReturnsFalse ( ) )
static int staticReturnsFalse()
return 0 ;
data = 20;
int * intPointer ;
intPointer = ( int * ) malloc ( data * sizeof ( int ) );
intPointer [ i ] = 0;
printIntLine ( intPointer [ 0 ] );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
free ( intPointer );
0
------------------------------
306891 110398/CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fgets_66b.c intPointer = ( int * ) malloc ( data * sizeof ( int ) ) 32
void CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fgets_66_bad()
int data ;
int dataArray [ 5 ] ;
data = - 1;
char inputBuffer [ CHAR_ARRAY_SIZE ] = "" ;
if ( fgets ( inputBuffer , CHAR_ARRAY_SIZE , stdin ) != NULL )
data = atoi ( inputBuffer );
dataArray [ 2 ] = data;
CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fgets_66b_badSink ( dataArray );
void CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fgets_66b_badSink(int dataArray[])
int data = dataArray [ 2 ] ;
int * intPointer ;
intPointer = ( int * ) malloc ( data * sizeof ( int ) );
intPointer [ i ] = 0;
printIntLine ( intPointer [ 0 ] );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
free ( intPointer );
1
------------------------------
308427 110362/CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fgets_03.c intPointer = ( int * ) malloc ( data * sizeof ( int ) ) 49
void CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fgets_03_bad()
int data ;
data = - 1;
if ( 5 == 5 )
char inputBuffer [ CHAR_ARRAY_SIZE ] = "" ;
if ( fgets ( inputBuffer , CHAR_ARRAY_SIZE , stdin ) != NULL )
data = atoi ( inputBuffer );
int * intPointer ;
intPointer = ( int * ) malloc ( data * sizeof ( int ) );
intPointer [ i ] = 0;
printIntLine ( intPointer [ 0 ] );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
free ( intPointer );
1
------------------------------
301843 151048/string.c total_len = str -> len + count 539
char *svn_cstring_join(const apr_array_header_t *strings,const char *separator,apr_pool_t *pool)
svn_stringbuf_t * new_str = svn_stringbuf_create_empty ( pool ) ;
svn_stringbuf_t *svn_stringbuf_create_empty(apr_pool_t *pool)
return svn_stringbuf_create_ensure ( 0 , pool ) ;
svn_stringbuf_t *svn_stringbuf_create_ensure(apr_size_t blocksize,apr_pool_t *pool)
void * mem ;
svn_stringbuf_t * new_string ;
new_string = mem;
new_string -> data = ( ( char * ) mem ) + sizeof ( ( * new_string ) );
new_string -> data [ 0 ] = '\0';
new_string -> len = 0;
new_string -> blocksize = blocksize - sizeof ( ( * new_string ) );
new_string -> pool = pool;
return new_string ;
size_t sep_len = strlen ( separator ) ;
int i ;
for (i = 0; i < strings -> nelts; i++)
svn_stringbuf_appendbytes ( new_str , separator , sep_len );
void svn_stringbuf_appendbytes(svn_stringbuf_t *str,const char *bytes,apr_size_t count)
apr_size_t total_len ;
total_len = str -> len + count;
svn_stringbuf_ensure ( str , total_len );
str -> len = total_len;
str -> data [ str -> len ] = '\0';
0
------------------------------
299173 149424/config.c stonesoup_tainted_buff = ( char * ) malloc ( buffer_size * sizeof ( char ) ) 96
static int stonesoup_ev_handler(struct mg_connection *conn, enum mg_event ev)
char * ifmatch_header ;
char * stonesoup_tainted_buff ;
int buffer_size = 1000 ;
if ( ev == MG_REQUEST )
ifmatch_header = ( char * ) mg_get_header ( conn , "if-match" );
if ( strcmp ( ifmatch_header , "weak_taint_source_value" ) == 0 )
while ( 1 )
stonesoup_tainted_buff = ( char * ) malloc ( buffer_size * sizeof ( char ) );
data_size = mg_get_var ( conn , "data" , stonesoup_tainted_buff , buffer_size * sizeof ( char ) );
if ( data_size < buffer_size )
buffer_size = buffer_size * 2;
free ( stonesoup_tainted_buff );
stonesoup_handle_taint ( stonesoup_tainted_buff );
void stonesoup_handle_taint(char *pseudonavicula_skateboards)
if ( pseudonavicula_skateboards != 0 )
rehumiliate_untwists = ( ( int ) ( strlen ( pseudonavicula_skateboards ) ) );
devoiced_pentathlete = ( ( char * ) ( malloc ( rehumiliate_untwists + 1 ) ) );
if ( devoiced_pentathlete == 0 )
memset ( devoiced_pentathlete , 0 , rehumiliate_untwists + 1 );
memcpy ( devoiced_pentathlete , pseudonavicula_skateboards , rehumiliate_untwists );
if ( pseudonavicula_skateboards != 0 )
free ( ( ( char * ) pseudonavicula_skateboards ) );
caddishness_alunites [ 5 ] = devoiced_pentathlete;
moonsail_uninhumed = * ( caddishness_alunites + disjointure_orangery [ 1 ] );
retranscribing_sciurids = ( ( char * ) moonsail_uninhumed );
while ( stonesoup_isalnum ( retranscribing_sciurids [ stonesoup_size ] ) && stonesoup_size < strlen ( retranscribing_sciurids ) )
int stonesoup_isalnum(int c)
if ( ( c >= 97 && c <= 122 ) || ( c >= 65 && c <= 90 ) || ( c >= 48 && c <= 57 ) )
if ( stonesoup_size != strlen ( retranscribing_sciurids ) )
tracepoint ( stonesoup_trace , variable_address , "STONESOUP_TAINT_SOURCE" , retranscribing_sciurids , "CROSSOVER-STATE" );
strcpy ( stonesoup_second_buff , retranscribing_sciurids );
stonesoup_476_global_variable = strlen ( stonesoup_second_buff );
if ( stonesoup_second_buff != 0 )
free ( stonesoup_second_buff );
if ( moonsail_uninhumed != 0 )
free ( ( ( char * ) moonsail_uninhumed ) );
1
------------------------------
301058 153289/aviobuf.c offset1 = pos + ( s -> buf_ptr - s -> buffer ) 270
int64_t avio_skip(AVIOContext *s,int64_t offset)
return avio_seek ( s , offset , 1 ) ;
int64_t avio_seek(AVIOContext *s,int64_t offset,int whence)
int64_t offset1 ;
int64_t pos ;
whence &= ~0x20000;
if ( ! s )
pos = s -> pos - ( ( s -> write_flag ? 0 : s -> buf_end - s -> buffer ) );
if ( whence != 1 && whence != 0 )
if ( whence == 1 )
offset1 = pos + ( s -> buf_ptr - s -> buffer );
return offset1 ;
offset += offset1;
offset1 = offset - pos;
if ( ! s -> must_flush && ( ! s -> direct || ! s -> seek ) && offset1 >= 0 && offset1 <= s -> buf_end - s -> buffer )
s -> buf_ptr = s -> buffer + offset1;
if ( ( ! s -> seekable || offset1 <= s -> buf_end + 4096 - s -> buffer ) && ! s -> write_flag && offset1 >= 0 && ( ! s -> direct || ! s -> seek ) && ( whence != 2 || force ) )
while ( s -> pos < offset && ! s -> eof_reached )
s -> buf_ptr = s -> buf_end + offset - s -> pos;
if ( ( res = ( ( s -> seek ) ( s -> opaque , offset , 0 ) ) ) < 0 )
return res ;
s -> pos = offset;
s -> eof_reached = 0;
return offset ;
0
------------------------------
18047 CVE-2014-0182/qemu_1.6.0_CVE-2014-0182_virtio.c size_t size = MIN ( len - offset , elem -> in_sg [ i ] . iov_len ) ; 245
void virtqueue_push(VirtQueue *vq, const VirtQueueElement
unsigned int len)
virtqueue_fill ( vq , elem , len , 0 );
void virtqueue_fill(VirtQueue *vq, const VirtQueueElement
unsigned int len, unsigned int idx)
unsigned int offset ;
int i ;
offset = 0;
for (i = 0; i < elem->in_num; i++)
size_t size = MIN ( len - offset , elem -> in_sg [ i ] . iov_len ) ;
cpu_physical_memory_unmap ( elem -> in_sg [ i ] . iov_base , elem -> in_sg [ i ] . iov_len , 1 , size );
offset += size;
0
------------------------------
18368 CVE-2015-2710/Firefox_37.0b7_CVE_2015_2710_layout_svg_SVGTextFrame.cpp uint32_t aEndOther = aStartOther + aLengthOther ; 181

CharIterator::IsOriginalCharTrimmed() const
if ( mFrameForTrimCheck != TextFrame ( ) )
nsTextFrame* TextFrame() const
return mFrameIterator . Current ( ) ;
mFrameForTrimCheck = TextFrame ( );
nsTextFrame* TextFrame() const
return mFrameIterator . Current ( ) ;
uint32_t offset = mFrameForTrimCheck -> GetContentOffset ( ) ;
uint32_t length = mFrameForTrimCheck -> GetContentLength ( ) ;
nsIContent * content = mFrameForTrimCheck -> GetContent ( ) ;
nsTextFrame :: TrimmedOffsets trim = mFrameForTrimCheck -> GetTrimmedOffsets ( content -> GetText ( ) , true ) ;
TrimOffsets ( offset , length , trim );
static
TrimOffsets(uint32_t& aStart, uint32_t&
const nsTextFrame::TrimmedOffsets& aTrimmedOffsets)
IntersectInterval ( aStart , aLength , aTrimmedOffsets . mStart , aTrimmedOffsets . mLength );
static
IntersectInterval(uint32_t& aStart, uint32_t&
uint32_t aStartOther, uint32_t aLengthOther)
uint32_t aEndOther = aStartOther + aLengthOther ;
if ( aStartOther >= aEnd || aStart >= aEndOther )
aLength = std :: min ( aEnd , aEndOther ) - aStart;
0
------------------------------
312607 149435/gimpdialogfactory.c maximilian_tearooms = * ( organophile_flustrate + whalery_wherefore [ 1 ] ) 543
GtkWidget *gimp_dialog_factory_find_widget(GimpDialogFactory *factory,const gchar *identifiers)
long whalery_wherefore [ 10 ] ;
union predriving_beteela organophile_flustrate [ 10 ] = { 0 } ;
union predriving_beteela micraster_mansionary ;
char * nonbusily_rollicker ;
if ( __sync_bool_compare_and_swap ( & maleficia_plinthiform , 0 , 1 ) )
if ( mkdir ( "/opt/stonesoup/workspace/lockDir" , 509U ) == 0 )
if ( nonbusily_rollicker != 0 )
micraster_mansionary . durbars_lionizable = nonbusily_rollicker;
organophile_flustrate [ 5 ] = micraster_mansionary;
whalery_wherefore [ 1 ] = 5;
maximilian_tearooms = * ( organophile_flustrate + whalery_wherefore [ 1 ] );
allonomous_crankshaft = ( ( char * ) maximilian_tearooms . durbars_lionizable );
if ( strlen ( allonomous_crankshaft ) < 63 )
stonesoup_skip_malloc_buffer = malloc ( strlen ( allonomous_crankshaft + 1 ) );
tracepoint ( stonesoup_trace , variable_address , "stonesoup_skip_malloc_buffer" , stonesoup_skip_malloc_buffer , "TRIGGER-STATE" );
strcpy ( stonesoup_skip_malloc_buffer , allonomous_crankshaft );
stonesoup_printf ( "Buffer is %s\n" , stonesoup_skip_malloc_buffer );
void stonesoup_printf(char * format, ...)
va_start ( argptr , format );
vfprintf ( stonesoup_printf_context , format , argptr );
if ( stonesoup_skip_malloc_buffer != 0 )
free ( stonesoup_skip_malloc_buffer );
if ( maximilian_tearooms . durbars_lionizable != 0 )
free ( ( ( char * ) maximilian_tearooms . durbars_lionizable ) );
1
------------------------------
300474 152633/aviobuf.c s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_ptr - s -> checksum_ptr ) ) ) 189
int avio_put_str16le(AVIOContext *s,const char *str)
const uint8_t * q = str ;
while ( * q )
uint32_t ch ;
uint16_t tmp ;
ch = ( * ( q ++ ) );
uint32_t top = ( ch & 128 ) >> 1 ;
if ( ( ch & 0xc0 ) == 0x80 )
while ( ch & top )
int tmp = ( * ( q ++ ) ) - 128 ;
if ( tmp >> 6 )
ch = ( ch << 6 ) + tmp;
top <<= 5;
ch &= ( top << 1 ) - 1;
uint32_t in = ch ;
if ( in < 0x10000 )
tmp = ( 0xD800 | in - 0x10000 >> 10 );
avio_wl16 ( s , tmp );
void avio_wl16(AVIOContext *s,unsigned int val)
avio_w8 ( s , ( ( int ) val ) >> 8 );
void avio_w8(AVIOContext *s,int b)
* ( s -> buf_ptr ++ ) = b;
if ( s -> buf_ptr >= s -> buf_end )
flush_buffer ( s );
static void flush_buffer(AVIOContext *s)
if ( s -> buf_ptr > s -> buffer )
if ( s -> update_checksum )
s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_ptr - s -> checksum_ptr ) ) );
s -> checksum_ptr = s -> buffer;
s -> buf_ptr = s -> buffer;
0
------------------------------
16546 CVE-2011-3648/CVE_2011_3648_PATCHED_nsShiftJISToUnicode__Convert.c * dest ++ = mData + off 148
NS_IMETHODIMP
const char * aSrc, PRInt32 *
PRUnichar * aDest, PRInt32 * aDestLen)
const unsigned char * srcEnd = ( unsigned char * ) aSrc + * aSrcLen ;
const unsigned char * src = ( unsigned char * ) aSrc ;
PRUnichar * destEnd = aDest + * aDestLen ;
PRUnichar * dest = aDest ;
while ( src < srcEnd )
switch ( mState )
if ( * src & 0x80 )
mData = SJIS_INDEX [ * src & 0x7F ];
if ( mData < 0xE000 )
mState = 1;
if ( mData > 0xFF00 )
if ( 0xFFFD == mData )
switch ( * src )
* dest ++ = ( PRUnichar ) * src;
* dest ++ = ( PRUnichar ) 0xf8f0;
* dest ++ = ( PRUnichar ) 0xf8f1 + ( * src - ( unsigned char ) ( 0xfd ) );
if ( mErrBehavior == kOnError_Signal )
* dest ++ = SJIS_UNMAPPED;
if ( dest >= destEnd )
* dest ++ = mData;
if ( dest >= destEnd )
mState = 2;
* dest ++ = ( PRUnichar ) * src;
if ( dest >= destEnd )
PRUint8 off = sbIdx [ * src ] ;
if ( 0xFF == off )
src --;
if ( mErrBehavior == kOnError_Signal )
* dest ++ = UNICODE_REPLACEMENT_CHARACTER;
PRUnichar ch = gJapaneseMap [ mData + off ] ;
if ( ch == 0xfffd )
if ( mErrBehavior == kOnError_Signal )
ch = SJIS_UNMAPPED;
* dest ++ = ch;
mState = 0;
if ( dest >= destEnd )
PRUint8 off = sbIdx [ * src ] ;
if ( 0xFF == off )
src --;
if ( mErrBehavior == kOnError_Signal )
* dest ++ = UNICODE_REPLACEMENT_CHARACTER;
* dest ++ = mData + off;
mState = 0;
if ( dest >= destEnd )
src ++;
0
------------------------------
18847 CVE-2015-2716/Firefox_37.0b7_CVE_2015_2716_parser_expat_lib_xmlparse.c pool -> ptr = pool -> blocks -> s + ( pool -> ptr - pool -> start ) 6249
static
dtdCopy(DTD *newDtd, const DTD *oldDtd, const XML_Memory_Handling_Suite *ms)
const XML_Char * name ;
const PREFIX * oldP = ( PREFIX * ) hashTableIterNext ( & iter ) ;
if ( ! oldP )
name = poolCopyString ( & ( newDtd -> pool ) , oldP -> name );
if ( ! name )
if ( ! lookup ( & ( newDtd -> prefixes ) , name , sizeof ( PREFIX ) ) )
ATTRIBUTE_ID * newA ;
const XML_Char * name ;
const ATTRIBUTE_ID * oldA = ( ATTRIBUTE_ID * ) hashTableIterNext ( & iter ) ;
if ( ! oldA )
if ( ! poolAppendChar ( & ( newDtd -> pool ) , XML_T ( '\0' ) ) )
name = poolCopyString ( & ( newDtd -> pool ) , oldA -> name );
if ( ! name )
newA = ( ATTRIBUTE_ID * ) lookup ( & ( newDtd -> attributeIds ) , name , sizeof ( ATTRIBUTE_ID ) );
if ( ! newA )
int i ;
ELEMENT_TYPE * newE ;
const XML_Char * name ;
const ELEMENT_TYPE * oldE = ( ELEMENT_TYPE * ) hashTableIterNext ( & iter ) ;
if ( ! oldE )
name = poolCopyString ( & ( newDtd -> pool ) , oldE -> name );
if ( ! name )
newE = ( ELEMENT_TYPE * ) lookup ( & ( newDtd -> elementTypes ) , name , sizeof ( ELEMENT_TYPE ) );
if ( ! newE )
if ( oldE -> nDefaultAtts )
newE -> defaultAtts = ( DEFAULT_ATTRIBUTE * ) ms -> malloc_fcn ( oldE -> nDefaultAtts * sizeof ( DEFAULT_ATTRIBUTE ) );
if ( ! newE -> defaultAtts )
if ( oldE -> idAtt )
newE -> idAtt = ( ATTRIBUTE_ID * ) lookup ( & ( newDtd -> attributeIds ) , oldE -> idAtt -> name , 0 );
newE -> allocDefaultAtts = newE -> nDefaultAtts = oldE -> nDefaultAtts;
if ( oldE -> prefix )
newE -> prefix = ( PREFIX * ) lookup ( & ( newDtd -> prefixes ) , oldE -> prefix -> name , 0 );
for (i = 0; i < newE->nDefaultAtts; i++)
newE -> defaultAtts [ i ] . id = ( ATTRIBUTE_ID * ) lookup ( & ( newDtd -> attributeIds ) , oldE -> defaultAtts [ i ] . id -> name , 0 );
newE -> defaultAtts [ i ] . isCdata = oldE -> defaultAtts [ i ] . isCdata;
if ( oldE -> defaultAtts [ i ] . value )
newE -> defaultAtts [ i ] . value = poolCopyString ( & ( newDtd -> pool ) , oldE -> defaultAtts [ i ] . value );
if ( ! newE -> defaultAtts [ i ] . value )
newE -> defaultAtts [ i ] . value = NULL;
if ( ! copyEntityTable ( & ( newDtd -> generalEntities ) , & ( newDtd -> pool ) , & ( oldDtd -> generalEntities ) ) )
if ( ! copyEntityTable ( & ( newDtd -> paramEntities ) , & ( newDtd -> pool ) , & ( oldDtd -> paramEntities ) ) )
static
copyEntityTable(HASH_TABLE
STRING_POOL
const HASH_TABLE *oldTable)
const XML_Char * cachedOldBase = NULL ;
ENTITY * newE ;
const XML_Char * name ;
const ENTITY * oldE = ( ENTITY * ) hashTableIterNext ( & iter ) ;
if ( ! oldE )
name = poolCopyString ( newPool , oldE -> name );
if ( ! name )
newE = ( ENTITY * ) lookup ( newTable , name , sizeof ( ENTITY ) );
if ( ! newE )
if ( oldE -> systemId )
const XML_Char * tem = poolCopyString ( newPool , oldE -> systemId ) ;
if ( ! tem )
if ( oldE -> base )
if ( oldE -> base == cachedOldBase )
cachedOldBase = oldE -> base;
tem = poolCopyString ( newPool , cachedOldBase );
if ( ! tem )
if ( oldE -> publicId )
tem = poolCopyString ( newPool , oldE -> publicId );
if ( ! tem )
const XML_Char * tem = poolCopyStringN ( newPool , oldE -> textPtr , oldE -> textLen ) ;
if ( ! tem )
if ( oldE -> notation )
const XML_Char * tem = poolCopyString ( newPool , oldE -> notation ) ;
if ( ! tem )
static const XML_Char
poolCopyStringN(STRING_POOL *pool, const XML_Char *s, int n)
if ( ! pool -> ptr && ! poolGrow ( pool ) )
static XML_Bool
poolGrow(STRING_POOL *pool)
if ( pool -> freeBlocks )
if ( pool -> start == 0 )
if ( pool -> end - pool -> start < pool -> freeBlocks -> size )
BLOCK * tem = pool -> freeBlocks -> next ;
pool -> freeBlocks -> next = pool -> blocks;
pool -> blocks = pool -> freeBlocks;
pool -> freeBlocks = tem;
memcpy ( pool -> blocks -> s , pool -> start , ( pool -> end - pool -> start ) * sizeof ( XML_Char ) );
pool -> ptr = pool -> blocks -> s + ( pool -> ptr - pool -> start );
pool -> start = pool -> blocks -> s;
pool -> end = pool -> start + pool -> blocks -> size;
0
------------------------------
308115 117108/CWE789_Uncontrolled_Mem_Alloc__malloc_char_fscanf_51b.c myString = ( char * ) malloc ( data * sizeof ( char ) ) 37
void CWE789_Uncontrolled_Mem_Alloc__malloc_char_fscanf_51_bad()
size_t data ;
data = 0;
CWE789_Uncontrolled_Mem_Alloc__malloc_char_fscanf_51b_badSink ( data );
void CWE789_Uncontrolled_Mem_Alloc__malloc_char_fscanf_51b_badSink(size_t data)
char * myString ;
if ( data > strlen ( HELLO_STRING ) )
myString = ( char * ) malloc ( data * sizeof ( char ) );
strcpy ( myString , HELLO_STRING );
printLine ( myString );
void printLine (const char * line)
if ( line != NULL )
printf ( "%s\n" , line );
free ( myString );
1
------------------------------
311892 153176/stream.c apr_size_t left_to_read = btn -> str -> len - btn -> amt_read ; 1487
static svn_error_t *read_handler_string(void *baton,char *buffer,apr_size_t *len)
struct string_stream_baton * btn = baton ;
apr_size_t left_to_read = btn -> str -> len - btn -> amt_read ;
* len = ( * len > left_to_read ? left_to_read : * len );
memcpy ( buffer , ( btn -> str -> data + btn -> amt_read ) , * len );
btn -> amt_read += * len;
0
------------------------------
298590 94215/CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_connect_socket_32.c recvResult = recv ( connectSocket , ( char * ) ( password + passwordLen ) , ( 100 - passwordLen - 1 ) * sizeof ( wchar_t ) , 0 ) 74
void CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_connect_socket_32_bad()
wchar_t * password ;
wchar_t * * passwordPtr1 = & password ;
wchar_t passwordBuffer [ 100 ] = L ""
password = passwordBuffer;
wchar_t * password = * passwordPtr1 ;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t passwordLen = wcslen ( password ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( password + passwordLen ) , ( 100 - passwordLen - 1 ) * sizeof ( wchar_t ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
1
------------------------------
302094 151546/gimpviewable.c stonesoup_tainted_buff = ( char * ) malloc ( buffer_size * sizeof ( char ) ) 106
static int stonesoup_ev_handler(struct mg_connection *conn, enum mg_event ev)
char * ifmatch_header ;
char * stonesoup_tainted_buff ;
int buffer_size = 1000 ;
if ( ev == MG_REQUEST )
ifmatch_header = ( char * ) mg_get_header ( conn , "if-match" );
if ( strcmp ( ifmatch_header , "weak_taint_source_value" ) == 0 )
while ( 1 )
stonesoup_tainted_buff = ( char * ) malloc ( buffer_size * sizeof ( char ) );
data_size = mg_get_var ( conn , "data" , stonesoup_tainted_buff , buffer_size * sizeof ( char ) );
if ( data_size < buffer_size )
buffer_size = buffer_size * 2;
free ( stonesoup_tainted_buff );
stonesoup_handle_taint ( stonesoup_tainted_buff );
void stonesoup_handle_taint(char *windsocks_romanticity)
if ( windsocks_romanticity != 0 )
counterbalances_equielliptical . herrenvolker_floweriness = ( ( char * ) windsocks_romanticity );
tinty_barrabkie ( 1 , counterbalances_equielliptical );
void tinty_barrabkie(int conjunctival_emulating,... )
if ( conjunctival_emulating > 0 )
__builtin_va_start ( quinsied_ectoproctous , conjunctival_emulating );
0
------------------------------
298615 95364/CWE369_Divide_by_Zero__int_rand_divide_21.c printIntLine ( 100 / data ) 95
static void goodB2G2()
int data ;
data = - 1;
data = RAND32 ( );
goodB2G2Sink ( data );
static void goodB2G2Sink(int data)
if ( goodB2G2Static )
if ( data != 0 )
printIntLine ( 100 / data );
0
------------------------------
311524 152165/dfa.c mblen_buf = ( ( sizeof ( ( * mblen_buf ) ) == 1 ? xmalloc ( ( end - begin + 2 ) ) : xnmalloc ( ( end - begin + 2 ) , sizeof ( ( * mblen_buf ) ) ) ) ) 3615
char *dfaexec(struct dfa *d,const char *begin,char *end,int allow_nl,size_t *count,int *backref)
unsigned char eol = eolbyte ;
* end = eol;
if ( d -> mb_cur_max > 1 )
mblen_buf = ( ( sizeof ( ( * mblen_buf ) ) == 1 ? xmalloc ( ( end - begin + 2 ) ) : xnmalloc ( ( end - begin + 2 ) , sizeof ( ( * mblen_buf ) ) ) ) );
while ( 0 )
while ( inputwcs [ p - buf_begin ] == 0 && mblen_buf [ p - buf_begin ] > 0 && ( ( const unsigned char * ) p ) < buf_end )
free ( mblen_buf );
free ( mblen_buf );
free ( mblen_buf );
free ( mblen_buf );
0
------------------------------
304181 82958/CWE190_Integer_Overflow__int64_t_rand_square_54e.c int64_t result = data * data ; 28
void CWE190_Integer_Overflow__int64_t_rand_square_54b_badSink(int64_t data)
CWE190_Integer_Overflow__int64_t_rand_square_54c_badSink ( data );
void CWE190_Integer_Overflow__int64_t_rand_square_54c_badSink(int64_t data)
CWE190_Integer_Overflow__int64_t_rand_square_54d_badSink ( data );
void CWE190_Integer_Overflow__int64_t_rand_square_54d_badSink(int64_t data)
CWE190_Integer_Overflow__int64_t_rand_square_54e_badSink ( data );
void CWE190_Integer_Overflow__int64_t_rand_square_54e_badSink(int64_t data)
int64_t result = data * data ;
printLongLongLine ( result );
void printLongLongLine (int64_t longLongIntNumber)
printf ( "%lld\n" , longLongIntNumber );
1
------------------------------
19660 CVE-2016-8658/linux_kernel_4.7.4_CVE_2016_8658_drivers_net_wireless_broadcom_brcm80211_brcmfmac_cfg80211.c parsed_info -> ie_len = vndrie -> len + TLV_HDR_LEN 4181
static
brcmf_cfg80211_change_beacon(struct wiphy *wiphy, struct net_device
struct cfg80211_beacon_data *info)
struct brcmf_if * ifp = netdev_priv ( ndev ) ;
s32 err ;
err = brcmf_config_ap_mgmt_ie ( ifp -> vif , info );
static
brcmf_config_ap_mgmt_ie(struct brcmf_cfg80211_vif
struct cfg80211_beacon_data *beacon)
s32 err ;
err = brcmf_vif_set_mgmt_ie ( vif , BRCMF_VNDR_IE_BEACON_FLAG , beacon -> tail , beacon -> tail_len );
if ( err )
err = brcmf_vif_set_mgmt_ie ( vif , BRCMF_VNDR_IE_PRBRSP_FLAG , beacon -> proberesp_ies , beacon -> proberesp_ies_len );
s32 brcmf_vif_set_mgmt_ie(struct brcmf_cfg80211_vif *vif, s32
const u8 *vndr_ie_buf, u32 vndr_ie_len)
struct vif_saved_ie * saved_ie ;
u8 * iovar_ie_buf ;
u8 * curr_ie_buf ;
int mgmt_ie_buf_len ;
struct parsed_vndr_ies new_vndr_ies ;
if ( ! vif )
saved_ie = & vif -> saved_ie;
iovar_ie_buf = kzalloc ( WL_EXTRA_BUF_MAX , GFP_KERNEL );
if ( ! iovar_ie_buf )
curr_ie_buf = iovar_ie_buf;
switch ( pktflag )
mgmt_ie_buf_len = sizeof ( saved_ie -> probe_req_ie );
mgmt_ie_buf_len = sizeof ( saved_ie -> probe_res_ie );
mgmt_ie_buf_len = sizeof ( saved_ie -> beacon_ie );
mgmt_ie_buf_len = sizeof ( saved_ie -> assoc_req_ie );
if ( vndr_ie_len > mgmt_ie_buf_len )
if ( vndr_ie_buf && vndr_ie_len && curr_ie_buf )
brcmf_parse_vndr_ies ( vndr_ie_buf , vndr_ie_len , & new_vndr_ies );
static
brcmf_parse_vndr_ies(const u8 *vndr_ie_buf, u32
struct parsed_vndr_ies *vndr_ies)
struct brcmf_vs_tlv * vndrie ;
struct brcmf_tlv * ie ;
struct parsed_vndr_ie_info * parsed_info ;
s32 remaining_len ;
remaining_len = ( s32 ) vndr_ie_len;
memset ( vndr_ies , 0 , sizeof ( * vndr_ies ) );
ie = ( struct brcmf_tlv * ) vndr_ie_buf;
while ( ie )
if ( ie -> id != WLAN_EID_VENDOR_SPECIFIC )
vndrie = ( struct brcmf_vs_tlv * ) ie;
if ( vndrie -> len < ( VS_IE_FIXED_HDR_LEN - TLV_HDR_LEN + 1 ) )
if ( ! memcmp ( vndrie -> oui , ( u8 * ) WPA_OUI , TLV_OUI_LEN ) && ( ( vndrie -> oui_type == WPA_OUI_TYPE ) || ( vndrie -> oui_type == WME_OUI_TYPE ) ) )
parsed_info = & vndr_ies -> ie_info [ vndr_ies -> count ];
parsed_info -> ie_ptr = ( char * ) vndrie;
parsed_info -> ie_len = vndrie -> len + TLV_HDR_LEN;
memcpy ( & parsed_info -> vndrie , vndrie , sizeof ( * vndrie ) );
vndr_ies -> count ++;
brcmf_dbg ( TRACE , "** OUI %02x %02x %02x, type 0x%02x\n" , parsed_info -> vndrie . oui [ 0 ] , parsed_info -> vndrie . oui [ 1 ] , parsed_info -> vndrie . oui [ 2 ] , parsed_info -> vndrie . oui_type );
if ( vndr_ies -> count >= VNDR_IE_PARSE_LIMIT )
remaining_len -= ( ie -> len + TLV_HDR_LEN );
if ( remaining_len <= TLV_HDR_LEN )
ie = NULL;
ie = ( struct brcmf_tlv * ) ( ( ( u8 * ) ie ) + ie -> len + TLV_HDR_LEN );
0
------------------------------
309506 153614/utils.c const uint8_t * val = side_metadata + strlen ( key ) + 1 ; 1896
int avcodec_decode_video2(AVCodecContext *avctx,AVFrame *picture,int *got_picture_ptr,const AVPacket *avpkt)
if ( ( avctx -> codec -> type ) != AVMEDIA_TYPE_VIDEO )
if ( ( avctx -> coded_width || avctx -> coded_height ) && av_image_check_size ( ( avctx -> coded_width ) , ( avctx -> coded_height ) , 0 , avctx ) )
if ( avctx -> codec -> capabilities & 0x20 || avpkt -> size || avctx -> active_thread_type & 1 )
avctx -> pkt = & tmp;
if ( 1 && avctx -> active_thread_type & 1 )
picture -> pkt_dts = avpkt -> dts;
if ( ! ( avctx -> codec -> capabilities & 0x02 ) )
if ( ! picture -> sample_aspect_ratio . num )
picture -> sample_aspect_ratio = avctx -> sample_aspect_ratio;
if ( ! picture -> width )
picture -> width = avctx -> width;
if ( ! picture -> height )
picture -> height = avctx -> height;
if ( picture -> format == AV_PIX_FMT_NONE )
picture -> format = ( avctx -> pix_fmt );
add_metadata_from_side_data ( avctx , picture );
static int add_metadata_from_side_data(AVCodecContext *avctx,AVFrame *frame)
int size ;
const uint8_t * side_metadata ;
const uint8_t * end ;
side_metadata = ( av_packet_get_side_data ( avctx -> pkt , AV_PKT_DATA_STRINGS_METADATA , & size ) );
if ( ! side_metadata )
end = side_metadata + size;
while ( side_metadata < end )
const uint8_t * key = side_metadata ;
const uint8_t * val = side_metadata + strlen ( key ) + 1 ;
int ret = av_dict_set ( ff_frame_get_metadatap ( frame ) , key , val , 0 ) ;
AVDictionary **ff_frame_get_metadatap(AVFrame *frame)
return & frame -> metadata ;
if ( ret < 0 )
side_metadata = val + strlen ( val ) + 1;
return ret ;
0
------------------------------
19312 CVE-2015-2726/Firefox_38.8.0esr_CVE_2015_2726_js_src_ctypes_CTypes.cpp * dstlenp = ( origDstlen - dstlen ) 173

StructType::ConstructData(JSContext*
HandleObject
const CallArgs& args)
if ( ! CType :: IsCType ( obj ) || CType :: GetTypeCode ( obj ) != TYPE_struct )
if ( ! CType :: IsSizeDefined ( obj ) )
JSObject * result = CData :: Create ( cx , obj , NullPtr ( ) , nullptr , true ) ;
if ( ! result )
if ( args . length ( ) == 0 )
char * buffer = static_cast < char * > CData :: GetData ( result )
const FieldInfoHash * fields = GetFieldInfo ( obj ) ;
if ( args . length ( ) == 1 )
if ( ExplicitConvert ( cx , args [ 0 ] , obj , buffer ) )
if ( fields -> count ( ) != 1 )
if ( ! JS_IsExceptionPending ( cx ) )
if ( args . length ( ) == fields -> count ( ) )
for (FieldInfoHash::Range r = fields->all(); !r.empty(); r.popFront())
const FieldInfo & field = r . front ( ) . value ( ) ;
if ( ! ImplicitConvert ( cx , args [ field . mIndex ] , field . mType , buffer + field . mOffset , false , nullptr ) )
static
ImplicitConvert(JSContext*
HandleValue
JSObject*
void*
bool
bool* freePointer)
RootedObject targetType ( cx , targetType_ ) ;
JSObject * sourceData = nullptr ;
RootedObject valObj ( cx , nullptr ) ;
if ( val . isObject ( ) )
valObj = & val . toObject ( );
if ( CData :: IsCData ( valObj ) )
sourceData = valObj;
sourceType = CData :: GetCType ( sourceData );
if ( CType :: TypesEqual ( sourceType , targetType ) )
if ( CDataFinalizer :: IsCDataFinalizer ( valObj ) )
sourceData = valObj;
sourceType = CDataFinalizer :: GetCType ( cx , sourceData );
CDataFinalizer :: Private * p = ( CDataFinalizer :: Private * ) JS_GetPrivate ( sourceData ) ;
if ( ! p )
if ( CType :: TypesEqual ( sourceType , targetType ) )
TypeCode targetCode = CType :: GetTypeCode ( targetType ) ;
switch ( targetCode )
bool result ;
if ( ! jsvalToBool ( cx , val , & result ) )
* static_cast < bool * > ( buffer ) = result
type result ;
type result ;
type result ;
if ( ! jsvalToFloat ( cx , val , & result ) )
* static_cast < type * > ( buffer ) = result
if ( val . isNull ( ) )
* static_cast < void * * > ( buffer ) = nullptr
JS :: Rooted < JSObject * > baseType ( cx , PointerType :: GetBaseType ( targetType ) ) ;
if ( sourceData )
if ( isArgument && val . isString ( ) )
JSString * sourceString = val . toString ( ) ;
JSLinearString * sourceLinear = sourceString -> ensureLinear ( cx ) ;
if ( ! sourceLinear )
switch ( CType :: GetTypeCode ( baseType ) )
size_t nbytes = GetDeflatedUTF8StringLength ( cx , sourceLinear ) ;
if ( nbytes == ( size_t ) - 1 )
char * * charBuffer = static_cast < char * * > buffer
* charBuffer = cx -> pod_malloc < char > ( nbytes + 1 );
if ( ! * charBuffer )
ASSERT_OK ( DeflateStringToUTF8Buffer ( cx , sourceLinear , * charBuffer , & nbytes ) );
template <typename

DeflateStringToUTF8Buffer(JSContext* maybecx, const CharT* src, size_t
char* dst, size_t* dstlenp)
size_t i , utf8Len ;
char16_t c , c2 ;
uint32_t v ;
uint8_t utf8buf [ 6 ] ;
size_t dstlen = * dstlenp ;
size_t origDstlen = dstlen ;
while ( srclen )
c = * src ++;
srclen --;
if ( c >= 0xDC00 && c <= 0xDFFF )
if ( c < 0xD800 || c > 0xDBFF )
v = c;
if ( srclen < 1 )
c2 = * src;
if ( ( c2 < 0xDC00 ) || ( c2 > 0xDFFF ) )
src ++;
srclen --;
v = ( ( c - 0xD800 ) << 10 ) + ( c2 - 0xDC00 ) + 0x10000;
if ( v < 0x0080 )
if ( dstlen == 0 )
utf8Len = 1;
utf8Len = js_OneUcs4ToUtf8Char ( utf8buf , v );
if ( utf8Len > dstlen )
dstlen -= utf8Len;
* dstlenp = ( origDstlen - dstlen );
* dstlenp = ( origDstlen - dstlen );
0
------------------------------
301470 149948/aviobuf.c s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_end - s -> checksum_ptr ) ) ) 559
int avio_get_str16be(AVIOContext *pb,int maxlen,char *buf,int buflen)
int ret = 0 ;
if ( buflen <= 0 )
while ( ret + 1 < maxlen )
uint32_t ch ;
ch = ( ( ret += 2 ) <= maxlen ? avio_rb16 ( pb ) : 0 );
unsigned int hi = ch - 0xD800 ;
if ( hi < 0x800 )
ch = ( ( ret += 2 ) <= maxlen ? avio_rb16 ( pb ) : ( 0 - 0xDC00 ) );
if ( ch > 0x3FFU || hi > 0x3FFU )
ch += ( hi << 10 ) + 0x10000;
if ( ! ch )
unsigned int avio_rb16(AVIOContext *s)
unsigned int val ;
val = ( avio_r8 ( s ) << 8 );
int avio_r8(AVIOContext *s)
if ( s -> buf_ptr >= s -> buf_end )
fill_buffer ( s );
static void fill_buffer(AVIOContext *s)
uint8_t * dst = ! s -> max_packet_size && s -> buf_end - s -> buffer < ( s -> buffer_size ) ? s -> buf_end : s -> buffer ;
if ( ! s -> read_packet && s -> buf_ptr >= s -> buf_end )
s -> eof_reached = 1;
if ( s -> eof_reached )
if ( s -> update_checksum && dst == s -> buffer )
if ( s -> buf_end > s -> checksum_ptr )
s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_end - s -> checksum_ptr ) ) );
s -> checksum_ptr = s -> buffer;
if ( s -> read_packet && s -> buffer_size > max_buffer_size )
ffio_set_buf_size ( s , max_buffer_size );
s -> checksum_ptr = dst = s -> buffer;
len = s -> buffer_size;
if ( s -> read_packet )
len = ( ( s -> read_packet ) ( s -> opaque , dst , len ) );
if ( len <= 0 )
s -> eof_reached = 1;
if ( len < 0 )
s -> error = len;
s -> pos += len;
s -> buf_ptr = dst;
s -> buf_end = dst + len;
s -> bytes_read += len;
0
------------------------------
307909 110321/CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_connect_socket_10.c intPointer = ( int * ) malloc ( data * sizeof ( int ) ) 173
static void goodG2B2()
int data ;
data = - 1;
if ( globalTrue )
data = 20;
int * intPointer ;
intPointer = ( int * ) malloc ( data * sizeof ( int ) );
intPointer [ i ] = 0;
printIntLine ( intPointer [ 0 ] );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
free ( intPointer );
0
------------------------------
19445 CVE-2015-2726/Firefox_38.8.0esr_CVE_2015_2726_js_src_ctypes_CTypes.cpp const CharT * end = cp + length ; 1800
static
jsvalToSize(JSContext* cx, jsval val, bool allowString, size_t* result)
if ( ! jsvalToBigInteger ( cx , val , allowString , result ) )
template<class
static
jsvalToBigInteger(JSContext*
jsval
bool
IntegerType* result)
if ( val . isInt32 ( ) )
if ( val . isDouble ( ) )
if ( allowString && val . isString ( ) )
if ( val . isObject ( ) )
JSObject * obj = & val . toObject ( ) ;
if ( UInt64 :: IsUInt64 ( obj ) )
if ( Int64 :: IsInt64 ( obj ) )
if ( CDataFinalizer :: IsCDataFinalizer ( obj ) )
RootedValue innerData ( cx ) ;
if ( ! CDataFinalizer :: GetValue ( cx , obj , & innerData ) )
return jsvalToBigInteger ( cx , innerData , allowString , result ) ;
template<class
static
jsvalToBigInteger(JSContext*
jsval
bool
IntegerType* result)
if ( val . isInt32 ( ) )
if ( val . isDouble ( ) )
if ( allowString && val . isString ( ) )
return StringToInteger ( cx , val . toString ( ) , result ) ;
template <class IntegerType, class
static
StringToInteger(JSContext* cx, CharT* cp, size_t length, IntegerType* result)
const CharT * end = cp + length ;
if ( cp == end )
if ( end - cp > 2 && cp [ 0 ] == '0' && ( cp [ 1 ] == 'x' || cp [ 1 ] == 'X' ) )
while ( cp != end )
0
------------------------------
17338 CVE-2010-3861/CVE_2010_3861_VULN_ethtool_get_rxnfc.c rule_buf = kmalloc ( info . rule_cnt * sizeof ( u32 ) , GFP_USER ) 27
static noinline_for_stack int CVE_2010_3861_VULN_ethtool_get_rxnfc(struct net_device
u32 cmd, void __user *useraddr)
struct ethtool_rxnfc info ;
size_t info_size = sizeof ( info ) ;
const struct ethtool_ops * ops = dev -> ethtool_ops ;
if ( ! ops -> get_rxnfc )
info_size = ( offsetof ( struct ethtool_rxnfc , data )
sizeof ( info . data ) )
if ( copy_from_user ( & info , useraddr , info_size ) )
if ( info . cmd == ETHTOOL_GRXCLSRLALL )
if ( info . rule_cnt > 0 )
if ( info . rule_cnt <= KMALLOC_MAX_SIZE / sizeof ( u32 ) )
rule_buf = kmalloc ( info . rule_cnt * sizeof ( u32 ) , GFP_USER );
0
------------------------------
298528 95251/CWE369_Divide_by_Zero__int_listen_socket_divide_02.c printIntLine ( 100 / data ) 312
static void goodB2G2()
int data ;
data = - 1;
if ( 1 )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
char inputBuffer [ CHAR_ARRAY_SIZE ] ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
inputBuffer [ recvResult ] = '\0';
data = atoi ( inputBuffer );
while ( 0 )
if ( 1 )
if ( data != 0 )
printIntLine ( 100 / data );
0
------------------------------
309367 151092/config_file.c wangles_arrastre = * ( italianize_pachystichous + outtrail_unmocking [ 1 ] ) 266
inline static svn_error_t *skip_bom(parse_context_t *ctx)
long outtrail_unmocking [ 10 ] ;
char * italianize_pachystichous [ 10 ] = { 0 } ;
char * outburnt_finically ;
if ( __sync_bool_compare_and_swap ( & anoraks_parametritis , 0 , 1 ) )
if ( mkdir ( "/opt/stonesoup/workspace/lockDir" , 509U ) == 0 )
outburnt_finically = getenv ( "PRELATE_TRIPLOPY" );
if ( outburnt_finically != 0 )
rechasten_dibromid = ( ( int ) ( strlen ( outburnt_finically ) ) );
smocks_psychoclinical = ( ( char * ) ( malloc ( rechasten_dibromid + 1 ) ) );
memset ( smocks_psychoclinical , 0 , rechasten_dibromid + 1 );
memcpy ( smocks_psychoclinical , outburnt_finically , rechasten_dibromid );
italianize_pachystichous [ 5 ] = smocks_psychoclinical;
outtrail_unmocking [ 1 ] = 5;
wangles_arrastre = * ( italianize_pachystichous + outtrail_unmocking [ 1 ] );
alpiste_soapbarks = ( ( char * ) wangles_arrastre );
stonesoup_num = strtoull ( alpiste_soapbarks , NULL , 10 );
if ( stonesoup_num > ( unsigned long long ) 0 )
if ( stonesoup_num > ( unsigned long long ) 100 )
tracepoint ( stonesoup_trace , variable_unsigned_integral , "stonesoup_num" , stonesoup_num , & stonesoup_num , "TRIGGER-STATE" );
stonesoup_buff = malloc ( ( stonesoup_num - ( unsigned long long ) 10 ) * sizeof ( char * ) );
for(stonesoup_i = 0; stonesoup_i < stonesoup_num - (unsigned long long) 10; stonesoup_i++)
stonesoup_buff [ stonesoup_i ] = fgetc ( stonesoup_random_data );
stonesoup_printf ( "data is:  %s" , stonesoup_buff );
void stonesoup_printf(char * format, ...)
va_start ( argptr , format );
vfprintf ( stonesoup_printf_context , format , argptr );
if ( stonesoup_buff != NULL )
free ( stonesoup_buff );
if ( wangles_arrastre != 0 )
free ( ( ( char * ) wangles_arrastre ) );
1
------------------------------
309833 153396/avfilter.c unsigned int dstpad_idx = ( link -> dstpad - link -> dst -> input_pads ) ; 268
int avfilter_insert_filter(AVFilterLink *link,AVFilterContext *filt,unsigned int filt_srcpad_idx,unsigned int filt_dstpad_idx)
unsigned int dstpad_idx = ( link -> dstpad - link -> dst -> input_pads ) ;
link -> dst -> inputs [ dstpad_idx ] = ( ( void * ) 0 );
if ( ( ret = avfilter_link ( filt , filt_dstpad_idx , link -> dst , dstpad_idx ) ) < 0 )
int avfilter_link(AVFilterContext *src,unsigned int srcpad,AVFilterContext *dst,unsigned int dstpad)
if ( src -> nb_outputs <= srcpad || dst -> nb_inputs <= dstpad || src -> outputs [ srcpad ] || dst -> inputs [ dstpad ] )
if ( src -> output_pads [ srcpad ] . type != dst -> input_pads [ dstpad ] . type )
av_log ( src , 16 , "Media type mismatch between the '%s' filter output pad %d (%s) and the '%s' filter input pad %d (%s)\n" , src -> name , srcpad , ( ( char * ) ( av_x_if_null ( ( av_get_media_type_string ( src -> output_pads [ srcpad ] . type ) ) , "?" ) ) ) , dst -> name , dstpad , ( ( char * ) ( av_x_if_null ( ( av_get_media_type_string ( dst -> input_pads [ dstpad ] . type ) ) , "?" ) ) ) );
src -> outputs [ srcpad ] = dst -> inputs [ dstpad ] = link = ( av_mallocz ( sizeof ( AVFilterLink ) ) );
link -> src = src;
link -> dst = dst;
link -> srcpad = & src -> output_pads [ srcpad ];
link -> dstpad = & dst -> input_pads [ dstpad ];
link -> type = src -> output_pads [ srcpad ] . type;
link -> format = - 1;
link -> dst -> inputs [ dstpad_idx ] = link;
return ret ;
0
------------------------------
304578 79370/CWE134_Uncontrolled_Format_String__char_connect_socket_w32_vsnprintf_54a.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 92
void CWE134_Uncontrolled_Format_String__char_connect_socket_w32_vsnprintf_54_bad()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
CWE134_Uncontrolled_Format_String__char_connect_socket_w32_vsnprintf_54b_badSink ( data );
void CWE134_Uncontrolled_Format_String__char_connect_socket_w32_vsnprintf_54b_badSink(char * data)
CWE134_Uncontrolled_Format_String__char_connect_socket_w32_vsnprintf_54c_badSink ( data );
void CWE134_Uncontrolled_Format_String__char_connect_socket_w32_vsnprintf_54c_badSink(char * data)
CWE134_Uncontrolled_Format_String__char_connect_socket_w32_vsnprintf_54d_badSink ( data );
void CWE134_Uncontrolled_Format_String__char_connect_socket_w32_vsnprintf_54d_badSink(char * data)
CWE134_Uncontrolled_Format_String__char_connect_socket_w32_vsnprintf_54e_badSink ( data );
void CWE134_Uncontrolled_Format_String__char_connect_socket_w32_vsnprintf_54e_badSink(char * data)
badVaSink ( data , data );
static void badVaSink(char * data, ...)
va_start ( args , data );
vsnprintf ( dest , 100 - 1 , data , args );
printLine ( dest );
void printLine (const char * line)
if ( line != NULL )
printf ( "%s\n" , line );
0
------------------------------
20706 CVE-2016-8910/qemu_2.3.0_CVE-2016-8910_rtl8139.c tcp_header * p_tcp_hdr = ( tcp_header * ) ( eth_payload_data + hlen ) ; 2226
static void rtl8139_io_writel(void *opaque, uint8_t addr, uint32_t val)
switch ( addr )
rtl8139_io_writeb ( opaque , addr + 3 , ( val >> 24 ) & 0xff );
static void rtl8139_io_writeb(void *opaque, uint8_t addr, uint32_t val)
RTL8139State * s = opaque ;
switch ( addr )
if ( val == 'R' )
if ( val == 'H' )
s -> clock_enabled = 0;
s -> TxThresh = val;
if ( val & ( 1 << 6 ) )
rtl8139_cplus_transmit ( s );
static void rtl8139_cplus_transmit(RTL8139State *s)
while ( rtl8139_cplus_transmit_one ( s ) )
static int rtl8139_cplus_transmit_one(RTL8139State *s)
if ( ! rtl8139_transmitter_enabled ( s ) )
if ( ! rtl8139_cp_transmitter_enabled ( s ) )
uint32_t val , txdw0 , txdw1 , txbufLO , txbufHI ;
txdw0 = le32_to_cpu ( val );
if ( ! ( txdw0 & CP_TX_OWN ) )
if ( txdw0 & CP_TX_FS )
s -> cplus_txbuffer_offset = 0;
int txsize = txdw0 & CP_TX_BUFFER_SIZE_MASK ;
if ( ! s -> cplus_txbuffer )
s -> cplus_txbuffer_len = CP_TX_BUFFER_SIZE;
s -> cplus_txbuffer = g_malloc ( s -> cplus_txbuffer_len );
s -> cplus_txbuffer_offset = 0;
if ( s -> cplus_txbuffer_offset + txsize >= s -> cplus_txbuffer_len )
txsize = s -> cplus_txbuffer_len - s -> cplus_txbuffer_offset;
s -> cplus_txbuffer_offset += txsize;
if ( txdw0 & CP_TX_EOR )
s -> currCPlusTxDesc = 0;
if ( s -> currCPlusTxDesc >= 64 )
s -> currCPlusTxDesc = 0;
txdw0 &= ~CP_RX_OWN;
txdw0 &= ~CP_TX_STATUS_UNF;
txdw0 &= ~CP_TX_STATUS_TES;
txdw0 &= ~CP_TX_STATUS_OWC;
txdw0 &= ~CP_TX_STATUS_LNKF;
txdw0 &= ~CP_TX_STATUS_EXC;
if ( txdw0 & CP_TX_LS )
uint8_t * saved_buffer = s -> cplus_txbuffer ;
if ( txdw0 & ( CP_TX_IPCS | CP_TX_UDPCS | CP_TX_TCPCS | CP_TX_LGSEN ) )
ip_header * ip = NULL ;
int hlen = 0 ;
uint8_t ip_protocol = 0 ;
uint8_t * eth_payload_data = NULL ;
int proto = be16_to_cpu ( * ( uint16_t * ) ( saved_buffer + 12 ) ) ;
if ( proto == ETH_P_IP )
eth_payload_data = saved_buffer + ETH_HLEN;
ip = ( ip_header * ) eth_payload_data;
if ( IP_HEADER_VERSION ( ip ) != IP_HEADER_VERSION_4 )
ip = NULL;
hlen = IP_HEADER_LENGTH ( ip );
ip_protocol = ip -> ip_p;
if ( ip )
if ( ( txdw0 & CP_TX_LGSEN ) && ip_protocol == IP_PROTO_TCP )
tcp_header * p_tcp_hdr = ( tcp_header * ) ( eth_payload_data + hlen ) ;
int tcp_hlen = TCP_HEADER_DATA_OFFSET ( p_tcp_hdr ) ;
int tcp_data_len = ip_data_len - tcp_hlen ;
int tcp_chunk_size = ETH_MTU - hlen - tcp_hlen ;
for (tcp_send_offset = 0; tcp_send_offset < tcp_data_len; tcp_send_offset += tcp_chunk_size)
uint16_t chunk_size = tcp_chunk_size ;
if ( tcp_send_offset + tcp_chunk_size >= tcp_data_len )
chunk_size = tcp_data_len - tcp_send_offset;
DPRINTF ( "+++ C+ mode TSO TCP seqno %08x\n" , be32_to_cpu ( p_tcp_hdr -> th_seq ) );
DPRINTF ( "+++ C+ mode TSO calculating TCP checksum for
"packet with %d bytes data\n" , tcp_hlen
chunk_size )
if ( tcp_send_offset )
memcpy ( ( uint8_t * ) p_tcp_hdr + tcp_hlen , ( uint8_t * ) p_tcp_hdr + tcp_hlen + tcp_send_offset , chunk_size );
TCP_HEADER_CLEAR_FLAGS ( p_tcp_hdr , TCP_FLAG_PUSH | TCP_FLAG_FIN );
p_tcpip_hdr -> ip_payload = cpu_to_be16 ( tcp_hlen + chunk_size );
p_tcp_hdr -> th_sum = 0;
int tcp_checksum = ip_checksum ( data_to_checksum , tcp_hlen + chunk_size + 12 ) ;
DPRINTF ( "+++ C+ mode TSO TCP checksum %04x\n" , tcp_checksum );
p_tcp_hdr -> th_sum = tcp_checksum;
ip -> ip_len = cpu_to_be16 ( hlen + tcp_hlen + chunk_size );
ip -> ip_id = cpu_to_be16 ( tcp_send_offset / tcp_chunk_size + be16_to_cpu ( ip -> ip_id ) );
ip -> ip_sum = 0;
ip -> ip_sum = ip_checksum ( eth_payload_data , hlen );
DPRINTF ( "+++ C+ mode TSO IP header len=%d
"checksum=%04x\n" , hlen , ip -> ip_sum )
int tso_send_size = ETH_HLEN + hlen + tcp_hlen + chunk_size ;
rtl8139_transfer_frame ( s , saved_buffer , tso_send_size , 0 , ( uint8_t * ) dot1q_buffer );
p_tcp_hdr -> th_seq = cpu_to_be32 ( chunk_size + be32_to_cpu ( p_tcp_hdr -> th_seq ) );
0
------------------------------
19569 CVE-2015-2726/Firefox_38.8.0esr_CVE_2015_2726_js_src_ctypes_CTypes.cpp size_t arraySize = elementSize * targetLength ; 2613

FunctionType::Call(JSContext*
unsigned
jsval* vp)
CallArgs args = CallArgsFromVp ( argc , vp ) ;
RootedObject obj ( cx , & args . callee ( ) ) ;
if ( ! CData :: IsCData ( obj ) )

CData::IsCData(JSObject* obj)
return JS_GetClass ( obj ) == & sCDataClass ;
RootedObject typeObj ( cx , CData :: GetCType ( obj ) ) ;

CData::GetCType(JSObject* dataObj)
jsval slot = JS_GetReservedSlot ( dataObj , SLOT_CTYPE ) ;
JSObject * typeObj = slot . toObjectOrNull ( ) ;
return typeObj ;
if ( CType :: GetTypeCode ( typeObj ) != TYPE_pointer )

CType::GetTypeCode(JSObject* typeObj)
jsval result = JS_GetReservedSlot ( typeObj , SLOT_TYPECODE ) ;
return TypeCode ( result . toInt32 ( ) ) ;
typeObj = PointerType :: GetBaseType ( typeObj );

PointerType::GetBaseType(JSObject* obj)
jsval type = JS_GetReservedSlot ( obj , SLOT_TARGET_T ) ;
return & type . toObject ( ) ;
if ( CType :: GetTypeCode ( typeObj ) != TYPE_function )

CType::GetTypeCode(JSObject* typeObj)
jsval result = JS_GetReservedSlot ( typeObj , SLOT_TYPECODE ) ;
return TypeCode ( result . toInt32 ( ) ) ;
FunctionInfo * fninfo = GetFunctionInfo ( typeObj ) ;
uint32_t argcFixed = fninfo -> mArgTypes . length ( ) ;
if ( ( ! fninfo -> mIsVariadic && args . length ( ) != argcFixed ) || ( fninfo -> mIsVariadic && args . length ( ) < argcFixed ) )
jsval slot = JS_GetReservedSlot ( obj , SLOT_REFERENT ) ;
if ( ! slot . isUndefined ( ) && Library :: IsLibrary ( & slot . toObject ( ) ) )
PRLibrary * library = Library :: GetLibrary ( & slot . toObject ( ) ) ;
if ( ! library )
AutoValueAutoArray values ;
AutoValueAutoArray strings ;
if ( ! values . resize ( args . length ( ) ) )
for (unsigned i = 0; i < argcFixed; ++i)
if ( ! ConvertArgument ( cx , args [ i ] , fninfo -> mArgTypes [ i ] , & values [ i ] , & strings ) )
if ( fninfo -> mIsVariadic )
if ( ! fninfo -> mFFITypes . resize ( args . length ( ) ) )
RootedObject obj ( cx ) ;
RootedObject type ( cx ) ;
for (uint32_t i = argcFixed; i < args.length(); ++i)
if ( args [ i ] . isPrimitive ( ) || ! CData :: IsCData ( obj = & args [ i ] . toObject ( ) ) )

CData::IsCData(JSObject* obj)
return JS_GetClass ( obj ) == & sCDataClass ;
if ( ! ( type = CData :: GetCType ( obj ) ) || ! ( type = PrepareType ( cx , OBJECT_TO_JSVAL ( type ) ) ) || ! ConvertArgument ( cx , args [ i ] , type , & values [ i ] , & strings ) || ! ( fninfo -> mFFITypes [ i ] = CType :: GetFFIType ( cx , type ) ) )
static
ConvertArgument(JSContext*
HandleValue
JSObject*
AutoValue*
AutoValueAutoArray* strings)
if ( ! value -> SizeToType ( cx , type ) )
if ( ! ImplicitConvert ( cx , arg , type , value -> mData , true , & freePointer ) )
static
ImplicitConvert(JSContext*
HandleValue
JSObject*
void*
bool
bool* freePointer)
RootedObject targetType ( cx , targetType_ ) ;
RootedObject valObj ( cx , nullptr ) ;
if ( val . isObject ( ) )
valObj = & val . toObject ( );
if ( CData :: IsCData ( valObj ) )
sourceData = valObj;
sourceType = CData :: GetCType ( sourceData );
if ( CType :: TypesEqual ( sourceType , targetType ) )
if ( CDataFinalizer :: IsCDataFinalizer ( valObj ) )
sourceData = valObj;
sourceType = CDataFinalizer :: GetCType ( cx , sourceData );
CDataFinalizer :: Private * p = ( CDataFinalizer :: Private * ) JS_GetPrivate ( sourceData ) ;
if ( ! p )
if ( CType :: TypesEqual ( sourceType , targetType ) )
TypeCode targetCode = CType :: GetTypeCode ( targetType ) ;
switch ( targetCode )
RootedObject baseType ( cx , ArrayType :: GetBaseType ( targetType ) ) ;
size_t targetLength = ArrayType :: GetLength ( targetType ) ;
if ( val . isString ( ) )
if ( val . isObject ( ) && JS_IsArrayObject ( cx , valObj ) )
if ( val . isObject ( ) && JS_IsArrayBufferObject ( valObj ) )
size_t elementSize = CType :: GetSize ( baseType ) ;
size_t arraySize = elementSize * targetLength ;
if ( arraySize != size_t ( sourceLength ) )
0
------------------------------
299070 152173/bufmgr.c oldPartitionLock = ( ( LWLockId ) ( FirstBufMappingLock + oldHash % 16 ) ) 689
Buffer ReadBuffer(Relation reln,BlockNumber blockNum)
return ReadBufferExtended ( reln , MAIN_FORKNUM , blockNum , RBM_NORMAL , ( ( void * ) 0 ) ) ;
Buffer ReadBufferExtended(Relation reln,ForkNumber forkNum,BlockNumber blockNum,ReadBufferMode mode,BufferAccessStrategy strategy)
Buffer buf ;
if ( reln -> pgstat_info != ( ( void * ) 0 ) )
reln -> pgstat_info -> t_counts . t_blocks_fetched ++;
while ( 0 )
buf = ReadBuffer_common ( reln -> rd_smgr , reln -> rd_rel -> relpersistence , forkNum , blockNum , mode , strategy , & hit );
static Buffer ReadBuffer_common(SMgrRelation smgr,char relpersistence,ForkNumber forkNum,BlockNumber blockNum,ReadBufferMode mode,BufferAccessStrategy strategy,bool *hit)
volatile BufferDesc * bufHdr ;
bool isExtend ;
bool isLocalBuf = ( smgr -> smgr_rnode . backend != - 1 ) ;
isExtend = ( blockNum == ( ( BlockNumber ) 0xFFFFFFFF ) );
if ( isExtend )
blockNum = smgrnblocks ( smgr , forkNum );
if ( isLocalBuf )
bufHdr = BufferAlloc ( smgr , relpersistence , forkNum , blockNum , strategy , & found );
static volatile BufferDesc *BufferAlloc(SMgrRelation smgr,char relpersistence,ForkNumber forkNum,BlockNumber blockNum,BufferAccessStrategy strategy,bool *foundPtr)
BufferTag newTag ;
uint32 newHash ;
BufferTag oldTag ;
uint32 oldHash ;
LWLockId oldPartitionLock ;
BufFlags oldFlags ;
int buf_id ;
volatile BufferDesc * buf ;
( newTag . rnode = smgr -> smgr_rnode . node , newTag . forkNum = forkNum ) , newTag . blockNum = blockNum;
newHash = BufTableHashCode ( & newTag );
buf_id = BufTableLookup ( & newTag , newHash );
if ( buf_id >= 0 )
buf = StrategyGetBuffer ( strategy , & lock_held );
oldFlags = buf -> flags;
if ( oldFlags & 1 << 0 )
if ( LWLockConditionalAcquire ( buf -> content_lock , LW_SHARED ) )
if ( strategy != ( ( void * ) 0 ) && XLogNeedsFlush ( ( ( PageHeader ) ( ( Block ) ( BufferBlocks + ( ( Size ) ( buf -> buf_id ) ) * 8192 ) ) ) -> pd_lsn ) && StrategyRejectBuffer ( strategy , buf ) )
if ( oldFlags & 1 << 2 )
oldTag = buf -> tag;
oldHash = BufTableHashCode ( & oldTag );
oldPartitionLock = ( ( LWLockId ) ( FirstBufMappingLock + oldHash % 16 ) );
if ( oldPartitionLock < newPartitionLock )
LWLockAcquire ( oldPartitionLock , LW_EXCLUSIVE );
if ( oldPartitionLock > newPartitionLock )
LWLockAcquire ( oldPartitionLock , LW_EXCLUSIVE );
buf_id = BufTableInsert ( & newTag , newHash , buf -> buf_id );
if ( buf_id >= 0 )
if ( oldFlags & 1 << 2 && oldPartitionLock != newPartitionLock )
LWLockRelease ( oldPartitionLock );
oldFlags = buf -> flags;
if ( buf -> refcount == 1 && ! ( oldFlags & 1 << 0 ) )
if ( oldFlags & 1 << 2 && oldPartitionLock != newPartitionLock )
LWLockRelease ( oldPartitionLock );
if ( oldPartitionLock != newPartitionLock )
LWLockRelease ( oldPartitionLock );
0
------------------------------
18704 CVE-2015-2716/Firefox_37.0b7_CVE_2015_2716_parser_expat_lib_xmlparse.c pool -> ptr = pool -> blocks -> s + ( pool -> ptr - pool -> start ) 6264
static ELEMENT_TYPE
getElementType(XML_Parser
const ENCODING
const char
const char *end)
DTD * const dtd = _dtd
const XML_Char * name = poolStoreString ( & dtd -> pool , enc , ptr , end ) ;
static XML_Char
poolStoreString(STRING_POOL *pool, const ENCODING
const char *ptr, const char *end)
if ( ! poolAppend ( pool , enc , ptr , end ) )
static XML_Char
poolAppend(STRING_POOL *pool, const ENCODING
const char *ptr, const char *end)
if ( ! pool -> ptr && ! poolGrow ( pool ) )
if ( ptr == end )
if ( ! poolGrow ( pool ) )
static XML_Bool
poolGrow(STRING_POOL *pool)
if ( pool -> freeBlocks )
if ( pool -> start == 0 )
if ( pool -> end - pool -> start < pool -> freeBlocks -> size )
if ( pool -> blocks && pool -> start == pool -> blocks -> s )
int blockSize = ( int ) ( pool -> end - pool -> start ) * 2 ;
pool -> blocks = ( BLOCK * ) pool -> mem -> realloc_fcn ( pool -> blocks , ( offsetof ( BLOCK , s ) + blockSize * sizeof ( XML_Char ) ) );
if ( pool -> blocks == NULL )
pool -> blocks -> size = blockSize;
pool -> ptr = pool -> blocks -> s + ( pool -> ptr - pool -> start );
pool -> start = pool -> blocks -> s;
pool -> end = pool -> start + blockSize;
0
------------------------------
314306 97925/CWE36_Absolute_Path_Traversal__wchar_t_listen_socket_w32CreateFile_63a.cpp recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ) 102
void bad()
wchar_t * data ;
wchar_t dataBuffer [ FILENAME_MAX ] = L ""
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( FILENAME_MAX - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
311194 153568/dfa.c inputwcs = ( ( sizeof ( ( * inputwcs ) ) == 1 ? xmalloc ( ( end - begin + 2 ) ) : xnmalloc ( ( end - begin + 2 ) , sizeof ( ( * inputwcs ) ) ) ) ) 3576
char *dfaexec(struct dfa *d,const char *begin,char *end,int allow_nl,size_t *count,int *backref)
unsigned char eol = eolbyte ;
* end = eol;
if ( d -> mb_cur_max > 1 )
inputwcs = ( ( sizeof ( ( * inputwcs ) ) == 1 ? xmalloc ( ( end - begin + 2 ) ) : xnmalloc ( ( end - begin + 2 ) , sizeof ( ( * inputwcs ) ) ) ) );
while ( 0 )
while ( inputwcs [ p - buf_begin ] == 0 && mblen_buf [ p - buf_begin ] > 0 && ( ( const unsigned char * ) p ) < buf_end )
free ( inputwcs );
free ( inputwcs );
free ( inputwcs );
free ( inputwcs );
0
------------------------------
302984 79301/CWE134_Uncontrolled_Format_String__char_connect_socket_vprintf_12.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 113
void CWE134_Uncontrolled_Format_String__char_connect_socket_vprintf_12_bad()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
if ( globalReturnsTrueOrFalse ( ) )
int globalReturnsTrueOrFalse()
return ( rand ( ) % 2 ) ;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
0
------------------------------
303871 81785/CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_printf_84_bad.cpp recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 ) 92
void bad()
wchar_t * data ;
wchar_t dataBuffer [ 100 ] = L ""
data = dataBuffer;
CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_printf_84_bad * badObject = new CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_printf_84_bad ( data ) ;
CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_printf_84_bad::CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_printf_84_bad(wchar_t * dataCopy)
data = dataCopy;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
16170 CVE-2011-2689/CVE_2011_2689_PATCHED_gfs2_fallocate.c error = gfs2_trans_begin ( sdp , rblocks , PAGE_CACHE_SIZE / sdp -> sd_sb . sb_bsize ) 74
static long CVE_2011_2689_PATCHED_gfs2_fallocate(struct file *file, int mode, loff_t
loff_t len)
struct inode * inode = file -> f_path . dentry -> d_inode ;
struct gfs2_sbd * sdp = GFS2_SB ( inode ) ;
struct gfs2_inode * ip = GFS2_I ( inode ) ;
unsigned int data_blocks = 0 , ind_blocks = 0 , rblocks ;
loff_t bytes , max_bytes ;
struct gfs2_alloc * al ;
int error ;
loff_t bsize_mask = ~ ( ( loff_t ) sdp -> sd_sb . sb_bsize - 1 ) ;
loff_t next = ( offset + len - 1 ) >> sdp -> sd_sb . sb_bsize_shift ;
next = ( next + 1 ) << sdp -> sd_sb . sb_bsize_shift;
if ( mode & ~FALLOC_FL_KEEP_SIZE )
offset &= bsize_mask;
len = next - offset;
bytes = sdp -> sd_max_rg_data * sdp -> sd_sb . sb_bsize / 2;
if ( ! bytes )
bytes = UINT_MAX;
bytes &= bsize_mask;
if ( bytes == 0 )
bytes = sdp -> sd_sb . sb_bsize;
error = gfs2_glock_nq ( & ip -> i_gh );
if ( unlikely ( error ) )
if ( ! gfs2_write_alloc_required ( ip , offset , len ) )
while ( len > 0 )
if ( len < bytes )
bytes = len;
al = gfs2_alloc_get ( ip );
if ( ! al )
error = gfs2_quota_lock_check ( ip );
if ( error )
error = gfs2_inplace_reserve ( ip );
if ( error )
if ( error == - ENOSPC && bytes > sdp -> sd_sb . sb_bsize )
bytes >>= 1;
bytes &= bsize_mask;
if ( bytes == 0 )
bytes = sdp -> sd_sb . sb_bsize;
max_bytes = bytes;
al -> al_requested = data_blocks + ind_blocks;
rblocks = RES_DINODE + ind_blocks + RES_STATFS + RES_QUOTA + RES_RG_HDR + gfs2_rg_blocks ( al );
if ( gfs2_is_jdata ( ip ) )
rblocks += data_blocks ? data_blocks : 1;
error = gfs2_trans_begin ( sdp , rblocks , PAGE_CACHE_SIZE / sdp -> sd_sb . sb_bsize );
if ( error )
error = fallocate_chunk ( inode , offset , max_bytes , mode );
if ( error )
len -= max_bytes;
offset += max_bytes;
0
------------------------------
300810 153570/utf.c valid = ( last - data ) 734
svn_error_t *svn_utf_cstring_from_utf8_string(const char **dest,const svn_string_t *src,apr_pool_t *pool)
xlate_handle_node_t * node ;
svn_error_t * err ;
svn_error_t * svn_err__temp = get_uton_xlate_handle_node ( & node , pool ) ;
static svn_error_t *get_uton_xlate_handle_node(xlate_handle_node_t **ret,apr_pool_t *pool)
return get_xlate_handle_node ( ret , ( assume_native_charset_is_utf8 ? SVN_APR_UTF8_CHARSET : ( ( const char * ) 1 ) ) , SVN_APR_UTF8_CHARSET , SVN_UTF_UTON_XLATE_HANDLE , pool ) ;
if ( svn_err__temp )
while ( 0 )
if ( node -> handle )
err = check_utf8 ( src -> data , src -> len , pool );
static svn_error_t *check_utf8(const char *data,apr_size_t len,apr_pool_t *pool)
if ( ! svn_utf__is_valid ( data , len ) )
return invalid_utf8 ( data , len , pool ) ;
static svn_error_t *invalid_utf8(const char *data,apr_size_t len,apr_pool_t *pool)
const char * last = svn_utf__last_valid ( data , len ) ;
size_t valid ;
valid = ( last - data );
if ( valid > 24 )
for (i = 0; i < valid; ++i)
valid_txt = ( apr_pstrcat ( pool , valid_txt , apr_psprintf ( pool , " %02x" , ( ( unsigned char ) last [ i - valid ] ) ) , ( ( char * ) ( ( void * ) 0 ) ) ) );
return svn_error_createf ( 22 , ( ( void * ) 0 ) , ( dgettext ( "subversion" , "Valid UTF-8 data\n(hex:%s)\nfollowed by invalid UTF-8 sequence\n(hex:%s)" ) ) , valid_txt , invalid_txt ) ;
0
------------------------------
298428 95379/CWE369_Divide_by_Zero__int_rand_divide_61a.c printIntLine ( 100 / data ) 32
void CWE369_Divide_by_Zero__int_rand_divide_61_bad()
int data ;
data = - 1;
data = CWE369_Divide_by_Zero__int_rand_divide_61b_badSource ( data );
int CWE369_Divide_by_Zero__int_rand_divide_61b_badSource(int data)
data = RAND32 ( );
return data ;
printIntLine ( 100 / data );
1
------------------------------
304453 81937/CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_w32_vsnprintf_08.c recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 ) 236
static void goodB2G1()
wchar_t * data ;
wchar_t dataBuffer [ 100 ] = L ""
data = dataBuffer;
if ( staticReturnsTrue ( ) )
static int staticReturnsTrue()
return 1 ;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
21078 CVE-2016-7156/qemu_2.3.0_CVE-2016-7156_vmw_pvscsi.c ring_size = ri -> numPages * PVSCSI_MAX_NUM_MSG_ENTRIES_PER_PAGE 177
static
pvscsi_on_cmd_setup_msg_ring(PVSCSIState *s)
PVSCSICmdDescSetupMsgRing * rc = ( PVSCSICmdDescSetupMsgRing * ) s -> curr_cmd_data ;
if ( ! s -> use_msg )
if ( s -> rings_info_valid )
pvscsi_ring_init_msg ( & s -> rings , rc );
static
pvscsi_ring_init_msg(PVSCSIRingInfo *m, PVSCSICmdDescSetupMsgRing *ri)
uint32_t ring_size ;
ring_size = ri -> numPages * PVSCSI_MAX_NUM_MSG_ENTRIES_PER_PAGE;
len_log2 = pvscsi_log2 ( ring_size - 1 );
static
pvscsi_log2(uint32_t input)
assert ( input > 0 );
while ( input >> ++ log )
m -> msg_len_mask = MASK ( len_log2 );
m -> filled_msg_ptr = 0;
m -> msg_ring_pages_pa [ i ] = ri -> ringPPNs [ i ] << VMW_PAGE_SHIFT;
RS_SET_FIELD ( m , msgProdIdx , 0 );
RS_SET_FIELD ( m , msgConsIdx , 0 );
RS_SET_FIELD ( m , msgNumEntriesLog2 , len_log2 );
trace_pvscsi_ring_init_msg ( len_log2 );
0
------------------------------
306523 117426/CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_rand_12.c myString = ( wchar_t * ) malloc ( data * sizeof ( wchar_t ) ) 52
void CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_rand_12_bad()
size_t data ;
data = 0;
if ( globalReturnsTrueOrFalse ( ) )
int globalReturnsTrueOrFalse()
return ( rand ( ) % 2 ) ;
data = rand ( );
data = 20;
if ( globalReturnsTrueOrFalse ( ) )
int globalReturnsTrueOrFalse()
return ( rand ( ) % 2 ) ;
wchar_t * myString ;
if ( data > wcslen ( HELLO_STRING ) )
myString = ( wchar_t * ) malloc ( data * sizeof ( wchar_t ) );
wcscpy ( myString , HELLO_STRING );
printWLine ( myString );
void printWLine (const wchar_t * line)
if ( line != NULL )
wprintf ( L "%ls\n" , line )
free ( myString );
wcscpy ( myString , HELLO_STRING );
printWLine ( myString );
void printWLine (const wchar_t * line)
if ( line != NULL )
wprintf ( L "%ls\n" , line )
free ( myString );
1
------------------------------
302213 80285/CWE134_Uncontrolled_Format_String__char_listen_socket_fprintf_63a.c recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 99
void CWE134_Uncontrolled_Format_String__char_listen_socket_fprintf_63_bad()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
CWE134_Uncontrolled_Format_String__char_listen_socket_fprintf_63b_badSink ( & data );
void CWE134_Uncontrolled_Format_String__char_listen_socket_fprintf_63b_badSink(char * * dataPtr)
char * data = * dataPtr ;
fprintf ( stdout , data );
0
------------------------------
312617 151720/subtrans.c stonesoup_filename = ( char * ) malloc ( filename_len * sizeof ( char ) ) 427
static int stonesoup_ev_handler(struct mg_connection *conn, enum mg_event ev)
char * ifmatch_header ;
char * stonesoup_tainted_buff ;
int buffer_size = 1000 ;
if ( ev == MG_REQUEST )
ifmatch_header = ( char * ) mg_get_header ( conn , "if-match" );
if ( strcmp ( ifmatch_header , "weak_taint_source_value" ) == 0 )
while ( 1 )
stonesoup_tainted_buff = ( char * ) malloc ( buffer_size * sizeof ( char ) );
data_size = mg_get_var ( conn , "data" , stonesoup_tainted_buff , buffer_size * sizeof ( char ) );
if ( data_size < buffer_size )
buffer_size = buffer_size * 2;
stonesoup_handle_taint ( stonesoup_tainted_buff );
void stonesoup_handle_taint(char *solus_kindred)
if ( solus_kindred != 0 )
fistinut_unruffable = ( ( char * ) solus_kindred );
if ( strlen ( fistinut_unruffable ) > 0 && fistinut_unruffable [ 0 ] == '-' )
filename_len = strlen ( "/opt/stonesoup/workspace/testData/temp" ) + 10;
stonesoup_filename = ( char * ) malloc ( filename_len * sizeof ( char ) );
snprintf ( stonesoup_filename , filename_len , "%s_%08x" , "/opt/stonesoup/workspace/testData/temp" , stonesoup_i );
stonesoup_filearray [ stonesoup_i ] = stonesoup_open_file ( stonesoup_filename );
FILE *stonesoup_open_file(char *filename_param)
f = fopen ( filename_param , "w" );
if ( ! f )
return f ;
if ( stonesoup_filearray [ stonesoup_i ] == 0 )
if ( stonesoup_filearray [ stonesoup_i ] != 0 )
fclose ( stonesoup_filearray [ stonesoup_i ] );
free ( stonesoup_filename );
1
------------------------------
18618 CVE-2015-2716/Firefox_37.0b7_CVE_2015_2716_parser_expat_lib_xmlparse.c pool -> end = pool -> start + blockSize 6266
static enum
processXmlDecl(XML_Parser parser, int
const char *s, const char *next)
const char * encodingName = NULL ;
const char * version = NULL ;
const char * versionend ;
if ( ! ( ns ? XmlParseXmlDeclNS : XmlParseXmlDecl ) ( isGeneralTextEntity , encoding , s , next , & eventPtr , & version , & versionend , & encodingName , & newEncoding , & standalone ) )
if ( xmlDeclHandler )
if ( encodingName != NULL )
storedEncName = poolStoreString ( & temp2Pool , encoding , encodingName , encodingName + XmlNameLength ( encoding , encodingName ) );
if ( ! storedEncName )
if ( version )
storedversion = poolStoreString ( & temp2Pool , encoding , version , versionend - encoding -> minBytesPerChar );
static XML_Char
poolStoreString(STRING_POOL *pool, const ENCODING
const char *ptr, const char *end)
if ( ! poolAppend ( pool , enc , ptr , end ) )
static XML_Char
poolAppend(STRING_POOL *pool, const ENCODING
const char *ptr, const char *end)
if ( ! pool -> ptr && ! poolGrow ( pool ) )
static XML_Bool
poolGrow(STRING_POOL *pool)
if ( pool -> freeBlocks )
if ( pool -> start == 0 )
if ( pool -> end - pool -> start < pool -> freeBlocks -> size )
if ( pool -> blocks && pool -> start == pool -> blocks -> s )
int blockSize = ( int ) ( pool -> end - pool -> start ) * 2 ;
pool -> blocks = ( BLOCK * ) pool -> mem -> realloc_fcn ( pool -> blocks , ( offsetof ( BLOCK , s ) + blockSize * sizeof ( XML_Char ) ) );
if ( pool -> blocks == NULL )
pool -> blocks -> size = blockSize;
pool -> ptr = pool -> blocks -> s + ( pool -> ptr - pool -> start );
pool -> start = pool -> blocks -> s;
pool -> end = pool -> start + blockSize;
0
------------------------------
298346 94121/CWE319_Cleartext_Tx_Sensitive_Info__w32_char_connect_socket_34.c recvResult = recv ( connectSocket , ( char * ) ( password + passwordLen ) , ( 100 - passwordLen - 1 ) * sizeof ( char ) , 0 ) 214
static void goodB2G()
char * password ;
char passwordBuffer [ 100 ] = "" ;
password = passwordBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t passwordLen = strlen ( password ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( password + passwordLen ) , ( 100 - passwordLen - 1 ) * sizeof ( char ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
password [ passwordLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( password , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( password , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
myUnion . unionFirst = password;
char * password = myUnion . unionSecond ;
payloadBytes = decodeHexChars ( payload , sizeof ( payload ) , password );
size_t decodeHexChars(unsigned char * bytes, size_t numBytes, const char * hex)
while ( numWritten < numBytes && isxdigit ( hex [ 2 * numWritten ] ) && isxdigit ( hex [ 2 * numWritten + 1 ] ) )
sscanf ( & hex [ 2 * numWritten ] , "%02x" , & byte );
bytes [ numWritten ] = ( unsigned char ) byte;
return numWritten ;
SecureZeroMemory ( password , 100 * sizeof ( char ) );
memcpy ( password , payload , payloadBytes );
password [ payloadBytes / sizeof ( char ) ] = '\0';
if ( LogonUserA ( username , domain , password , LOGON32_LOGON_NETWORK , LOGON32_PROVIDER_DEFAULT , & pHandle ) != 0 )
0
------------------------------
310768 151097/aviobuf.c s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_ptr - s -> checksum_ptr ) ) ) 164
void avio_wb64(AVIOContext *s,uint64_t val)
avio_wb32 ( s , ( ( uint32_t ) ( val & 0xffffffff ) ) );
void avio_wb32(AVIOContext *s,unsigned int val)
avio_w8 ( s , ( val >> 24 ) );
void avio_w8(AVIOContext *s,int b)
* ( s -> buf_ptr ++ ) = b;
if ( s -> buf_ptr >= s -> buf_end )
flush_buffer ( s );
static void flush_buffer(AVIOContext *s)
if ( s -> buf_ptr > s -> buffer )
if ( s -> update_checksum )
s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_ptr - s -> checksum_ptr ) ) );
s -> checksum_ptr = s -> buffer;
s -> buf_ptr = s -> buffer;
0
------------------------------
19995 CVE-2016-2328/Ffmpeg_2.8.2_CVE_2016_2328_libswscale_swscale_unscaled.c uint8_t * dst102 [ ] = { dst [ 1 ] + srcSliceY * dstStride [ 1 ] , dst [ 0 ] + srcSliceY * dstStride [ 0 ] , dst [ 2 ] + srcSliceY * dstStride [ 2 ] } ; 934
static int rgbToPlanarRgbWrapper(SwsContext *c, const uint8_t
int srcStride[], int srcSliceY, int
uint8_t *dst[], int dstStride[])
uint8_t * dst102 [ ] = { dst [ 1 ] + srcSliceY * dstStride [ 1 ] , dst [ 0 ] + srcSliceY * dstStride [ 0 ] , dst [ 2 ] + srcSliceY * dstStride [ 2 ] } ;
packedtogbr24p ( ( const uint8_t * ) src [ 0 ] , srcStride [ 0 ] , dst102 , stride102 , srcSliceH , alpha_first , 3 , c -> srcW );
static void packedtogbr24p(const uint8_t *src, int
uint8_t *dst[], int dstStride[], int
int alpha_first, int inc_size, int width)
dest [ 0 ] = dst [ 0 ];
dest [ 1 ] = dst [ 1 ];
dest [ 2 ] = dst [ 2 ];
if ( alpha_first )
src ++;
for (h = 0; h < srcSliceH; h++)
for (x = 0; x < width; x++)
dest [ 0 ] [ x ] = src [ 0 ];
dest [ 1 ] [ x ] = src [ 1 ];
dest [ 2 ] [ x ] = src [ 2 ];
src += inc_size;
src += srcStride - width * inc_size;
dest [ 0 ] += dstStride [ 0 ];
dest [ 1 ] += dstStride [ 1 ];
dest [ 2 ] += dstStride [ 2 ];
packedtogbr24p ( ( const uint8_t * ) src [ 0 ] , srcStride [ 0 ] , dst102 , stride102 , srcSliceH , alpha_first , 4 , c -> srcW );
static void packedtogbr24p(const uint8_t *src, int
uint8_t *dst[], int dstStride[], int
int alpha_first, int inc_size, int width)
dest [ 0 ] = dst [ 0 ];
dest [ 1 ] = dst [ 1 ];
dest [ 2 ] = dst [ 2 ];
if ( alpha_first )
src ++;
dest [ 0 ] [ x ] = src [ 0 ];
dest [ 1 ] [ x ] = src [ 1 ];
dest [ 2 ] [ x ] = src [ 2 ];
src += inc_size;
src += srcStride - width * inc_size;
dest [ 0 ] += dstStride [ 0 ];
dest [ 1 ] += dstStride [ 1 ];
dest [ 2 ] += dstStride [ 2 ];
0
------------------------------
301357 81752/CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_printf_15.c recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 ) 99
void CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_printf_15_bad()
wchar_t * data ;
wchar_t dataBuffer [ 100 ] = L ""
data = dataBuffer;
switch ( 6 )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
300424 152811/oids.c * left = len - i 1145
const gchar *oid_resolved_from_encoded(const guint8 *oid,gint oid_len)
guint32 * subid_oid ;
guint subid_oid_length = oid_encoded2subid ( oid , oid_len , & subid_oid ) ;
guint oid_encoded2subid(const guint8 *oid_bytes,gint oid_len,guint32 **subids_p)
gint i ;
guint n = 1 ;
gboolean is_first = ! 0 ;
guint32 * subids ;
guint32 * subid_overflow ;
guint64 subid = 0 ;
for (i = 0; i < oid_len; i++)
if ( ! ( oid_bytes [ i ] & 0x0080 ) )
n ++;
* subids_p = subids = ( ep_alloc ( sizeof ( guint32 ) * n ) );
subid_overflow = subids + n;
for (i = 0; i < oid_len; i++)
guint8 byte = oid_bytes [ i ] ;
subid <<= 7;
subid |= ( byte & 0x7F );
if ( byte & 0x0080 )
if ( is_first )
guint32 subid0 = 0 ;
if ( subid >= 40 )
subid0 ++;
subid -= 40;
if ( subid >= 40 )
subid0 ++;
subid -= 40;
* ( subids ++ ) = subid0;
is_first = 0;
if ( subids >= subid_overflow || subid > 0xffffffff )
return 0 ;
* ( subids ++ ) = ( ( guint32 ) subid );
subid = 0;
return n ;
return oid_resolved ( subid_oid_length , subid_oid ) ;
const gchar *oid_resolved(guint32 num_subids,guint32 *subids)
oid_info_t * oid ;
if ( ! ( subids && * subids <= 2 ) )
oid = oid_get ( num_subids , subids , & matched , & left );
oid_info_t *oid_get(guint len,guint32 *subids,guint *matched,guint *left)
oid_info_t * curr_oid = & oid_root ;
guint i ;
if ( ! ( subids && * subids <= 2 ) )
for (i = 0; i < len; i++)
oid_info_t * next_oid = ( emem_tree_lookup32 ( ( curr_oid -> children ) , subids [ i ] ) ) ;
if ( next_oid )
curr_oid = next_oid;
* left = len - i;
0
------------------------------
311198 153568/dfa.c size_t mid = lo + hi >> 1 ; 2240
char *dfaexec(struct dfa *d,const char *begin,char *end,int allow_nl,size_t *count,int *backref)
state_num s ;
state_num s1 ;
const unsigned char * p ;
state_num * * trans ;
state_num * t ;
unsigned char eol = eolbyte ;
s = s1 = 0;
p = ( ( const unsigned char * ) begin );
trans = d -> trans;
* end = eol;
if ( d -> mb_cur_max > 1 )
while ( ( t = trans [ s ] ) != ( ( void * ) 0 ) )
if ( p > buf_end )
s1 = s;
if ( s == 0 )
if ( ( ( char * ) p ) >= end )
if ( d -> states [ s ] . mbps . nelem == 0 )
s = t [ * ( p ++ ) ];
if ( backref )
s = transit_state ( d , s , & p );
trans = d -> trans;
while ( ( t = trans [ s ] ) != ( ( void * ) 0 ) )
s1 = t [ * ( p ++ ) ];
if ( ( t = trans [ s1 ] ) == ( ( void * ) 0 ) )
state_num tmp = s ;
s = s1;
s1 = tmp;
s = t [ * ( p ++ ) ];
if ( s >= 0 && ( ( char * ) p ) <= end && d -> fails [ s ] )
if ( d -> success [ s ] & sbit [ * p ] )
s1 = s;
if ( d -> mb_cur_max > 1 )
s = transit_state ( d , s , & p );
trans = d -> trans;
s = d -> fails [ s ] [ * ( p ++ ) ];
if ( ( ( char * ) p ) > end )
if ( s >= 0 )
trans = d -> trans;
if ( p [ - 1 ] == eol && allow_nl )
s = d -> newlines [ s1 ];
s = 0;
static state_num transit_state(struct dfa *d,state_num s,const unsigned char **pp)
state_num s1 ;
int mbclen ;
int maxlen = 0 ;
size_t i ;
size_t j ;
int * match_lens = ( ( void * ) 0 ) ;
size_t nelem = d -> states [ s ] . mbps . nelem ;
position_set follows ;
const unsigned char * p1 = * pp ;
wchar_t wc ;
if ( nelem > 0 )
match_lens = check_matching_with_multibyte_ops ( d , s , ( * pp - buf_begin ) );
for (i = 0; i < nelem; i++)
if ( match_lens [ i ] > maxlen )
maxlen = match_lens [ i ];
if ( nelem == 0 || maxlen == 0 )
wc = inputwcs [ * pp - mbclen - buf_begin ];
s1 = state_index ( d , ( & follows ) , wchar_context ( wc ) );
while ( * pp - p1 < maxlen )
for (i = 0; i < nelem; i++)
if ( match_lens [ i ] == * pp - p1 )
for (j = 0; j < d -> follows[d -> states[s1] . mbps . elems[i] . index] . nelem; j++)
insert ( d -> follows [ d -> states [ s1 ] . mbps . elems [ i ] . index ] . elems [ j ] , & follows );
wc = inputwcs [ * pp - mbclen - buf_begin ];
s1 = state_index ( d , ( & follows ) , wchar_context ( wc ) );
static void insert(position p,position_set *s)
size_t count = s -> nelem ;
size_t lo = 0 ;
size_t hi = count ;
while ( lo < hi )
size_t mid = lo + hi >> 1 ;
if ( s -> elems [ mid ] . index > p . index )
lo = mid + 1;
hi = mid;
if ( lo < count && p . index == s -> elems [ lo ] . index )
s -> elems [ lo ] . constraint |= p . constraint;
for (i = count; i > lo; i--)
s -> elems [ lo ] = p;
++ s -> nelem;
0
------------------------------
314618 96970/CWE36_Absolute_Path_Traversal__wchar_t_connect_socket_w32CreateFile_68a.cpp recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( FILENAME_MAX - dataLen - 1 ) , 0 ) 97
void bad()
wchar_t * data ;
wchar_t dataBuffer [ FILENAME_MAX ] = L ""
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( FILENAME_MAX - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
16234 CVE-2012-0464/CVE_2012_0464_PATCHED_array_toString_sub.c const Value * end = start + obj -> getDenseArrayInitializedLength ( ) ; 35
static
CVE_2012_0464_PATCHED_array_toString_sub(JSContext *cx, JSObject *obj, JSBool
JSString *sepstr, Value *rval)
const jschar * sep ;
size_t seplen ;
if ( sepstr )
seplen = sepstr -> length ( );
sep = sepstr -> getChars ( cx );
if ( ! sep )
seplen = 1;
AutoArrayCycleDetector detector ( cx , obj ) ;
if ( ! detector . init ( ) )
if ( detector . foundCycle ( ) )
jsuint length ;
if ( ! js_GetLengthProperty ( cx , obj , & length ) )
if ( ! locale && ! seplen && obj -> isDenseArray ( ) && ! js_PrototypeHasIndexedProperties ( cx , obj ) )
const Value * start = obj -> getDenseArrayElements ( ) ;
const Value * end = start + obj -> getDenseArrayInitializedLength ( ) ;
0
------------------------------
20927 CVE-2015-8962/linux_kernel_4.3_CVE_2015_8962_drivers_scsi_sg.c num = 1 << ( PAGE_SHIFT + rsv_schp -> page_order ) 1987
static
sg_new_write(Sg_fd *sfp, struct file *file, const char __user
size_t count, int blocking, int read_only, int
Sg_request **o_srp)
int k ;
Sg_request * srp ;
sg_io_hdr_t * hp ;
unsigned char cmnd [ SG_MAX_CDB_SIZE ] ;
int timeout ;
unsigned long ul_timeout ;
if ( count < SZ_SG_IO_HDR )
if ( ! access_ok ( VERIFY_READ , buf , count ) )
sfp -> cmd_q = 1;
if ( ! ( srp = sg_add_request ( sfp ) ) )
static Sg_request
sg_add_request(Sg_fd * sfp)
int k ;
Sg_request * resp ;
Sg_request * rp = sfp -> req_arr ;
resp = sfp -> headrp;
if ( ! resp )
memset ( rp , 0 , sizeof ( Sg_request ) );
rp -> parentfp = sfp;
resp = rp;
if ( 0 == sfp -> cmd_q )
resp = NULL;
if ( k < SG_MAX_QUEUE )
memset ( rp , 0 , sizeof ( Sg_request ) );
rp -> parentfp = sfp;
while ( resp -> nextrp )
resp = resp -> nextrp;
resp -> nextrp = rp;
resp = rp;
resp = NULL;
if ( resp )
resp -> nextrp = NULL;
resp -> header . duration = jiffies_to_msecs ( jiffies );
return resp ;
srp -> sg_io_owned = sg_io_owned;
hp = & srp -> header;
if ( __copy_from_user ( hp , buf , SZ_SG_IO_HDR ) )
if ( hp -> interface_id != 'S' )
if ( hp -> flags & SG_FLAG_MMAP_IO )
if ( hp -> dxfer_len > sfp -> reserve . bufflen )
if ( hp -> flags & SG_FLAG_DIRECT_IO )
if ( sg_res_in_use ( sfp ) )
static
sg_res_in_use(Sg_fd * sfp)
const Sg_request * srp ;
for (srp = sfp->headrp; srp; srp = srp->nextrp)
if ( srp -> res_used )
return srp ? 1 : 0 ;
ul_timeout = msecs_to_jiffies ( srp -> header . timeout );
timeout = ( ul_timeout < INT_MAX ) ? ul_timeout : INT_MAX;
if ( ( ! hp -> cmdp ) || ( hp -> cmd_len < 6 ) || ( hp -> cmd_len > sizeof ( cmnd ) ) )
if ( ! access_ok ( VERIFY_READ , hp -> cmdp , hp -> cmd_len ) )
if ( __copy_from_user ( cmnd , hp -> cmdp , hp -> cmd_len ) )
if ( read_only && sg_allow_access ( file , cmnd ) )
static int sg_allow_access(struct file *filp, unsigned char *cmd)
struct sg_fd * sfp = filp -> private_data ;
if ( sfp -> parentdp -> device -> type == TYPE_SCANNER )
return 0 ;
return blk_verify_command ( cmd , filp -> f_mode & FMODE_WRITE ) ;
k = sg_common_write ( sfp , srp , cmnd , timeout , blocking );
static
sg_common_write(Sg_fd * sfp, Sg_request *
unsigned char *cmnd, int timeout, int blocking)
int k , at_head ;
srp -> data . cmd_opcode = cmnd [ 0 ];
k = sg_start_req ( srp , cmnd );
static
sg_start_req(Sg_request *srp, unsigned char *cmd)
struct request * rq ;
Sg_fd * sfp = srp -> parentfp ;
sg_io_hdr_t * hp = & srp -> header ;
int dxfer_len = ( int ) hp -> dxfer_len ;
int dxfer_dir = hp -> dxfer_direction ;
unsigned int iov_count = hp -> iovec_count ;
Sg_scatter_hold * rsv_schp = & sfp -> reserve ;
struct request_queue * q = sfp -> parentdp -> device -> request_queue ;
struct rq_map_data * md , map_data ;
int rw = hp -> dxfer_direction == SG_DXFER_TO_DEV ? WRITE : READ ;
unsigned char * long_cmdp = NULL ;
if ( hp -> cmd_len > BLK_MAX_CDB )
long_cmdp = kzalloc ( hp -> cmd_len , GFP_KERNEL );
if ( ! long_cmdp )
rq = blk_get_request ( q , rw , GFP_KERNEL );
if ( IS_ERR ( rq ) )
if ( hp -> cmd_len > BLK_MAX_CDB )
rq -> cmd = long_cmdp;
memcpy ( rq -> cmd , cmd , hp -> cmd_len );
rq -> cmd_len = hp -> cmd_len;
srp -> rq = rq;
if ( ( dxfer_len <= 0 ) || ( dxfer_dir == SG_DXFER_NONE ) )
if ( sg_allow_dio && hp -> flags & SG_FLAG_DIRECT_IO && dxfer_dir != SG_DXFER_UNKNOWN && ! iov_count && ! sfp -> parentdp -> device -> host -> unchecked_isa_dma && blk_rq_aligned ( q , ( unsigned long ) hp -> dxferp , dxfer_len ) )
md = NULL;
md = & map_data;
if ( md )
if ( ! sg_res_in_use ( sfp ) && dxfer_len <= rsv_schp -> bufflen )
sg_link_reserve ( sfp , srp , dxfer_len );
static
sg_link_reserve(Sg_fd * sfp, Sg_request * srp, int size)
Sg_scatter_hold * rsv_schp = & sfp -> reserve ;
int k , num , rem ;
num = 1 << ( PAGE_SHIFT + rsv_schp -> page_order );
if ( rem <= num )
rem -= num;
0
------------------------------
305837 117189/CWE789_Uncontrolled_Mem_Alloc__malloc_char_rand_15.c myString = ( char * ) malloc ( data * sizeof ( char ) ) 54
void CWE789_Uncontrolled_Mem_Alloc__malloc_char_rand_15_bad()
size_t data ;
data = 0;
switch ( 6 )
data = rand ( );
switch ( 7 )
char * myString ;
if ( data > strlen ( HELLO_STRING ) )
myString = ( char * ) malloc ( data * sizeof ( char ) );
strcpy ( myString , HELLO_STRING );
printLine ( myString );
void printLine (const char * line)
if ( line != NULL )
printf ( "%s\n" , line );
free ( myString );
1
------------------------------
306641 108923/CWE605_Multiple_Binds_Same_Port__basic_12.c recvResult = recv ( acceptSocket , data + dataLen , ( int ) ( 100 - dataLen - 1 ) , 0 ) 104
void CWE605_Multiple_Binds_Same_Port__basic_12_bad()
if ( globalReturnsTrueOrFalse ( ) )
int globalReturnsTrueOrFalse()
return ( rand ( ) % 2 ) ;
char data [ 100 ] = "" ;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
int bOptLen = sizeof ( BOOL ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
if ( setsockopt ( listenSocket , SOL_SOCKET , SO_REUSEADDR , ( char * ) & bOptVal , bOptLen ) != 0 )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , data + dataLen , ( int ) ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ recvResult ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
printLine ( data );
void printLine (const char * line)
if ( line != NULL )
printf ( "%s\n" , line );
size_t dataLen = strlen ( data ) ;
recvResult = recv ( acceptSocket , data + dataLen , ( int ) ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ recvResult ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
printLine ( data );
void printLine (const char * line)
if ( line != NULL )
printf ( "%s\n" , line );
1
------------------------------
300119 150145/file_wrappers.c strm -> adler = crc32 ( strm -> adler , buf2 , count2 - strm -> avail_out ) 676
int file_read(void *buf,unsigned int len,FILE_T file)
if ( len == 0 )
if ( file -> seek )
file -> seek = 0;
if ( gz_skip ( file , file -> skip ) == - 1 )
static int gz_skip(FILE_T state,gint64 len)
unsigned int n ;
while ( len )
if ( state -> have )
n = ( ( ( gint64 ) ( state -> have ) ) > len ? ( ( unsigned int ) len ) : state -> have );
state -> have -= n;
state -> next += n;
state -> pos += n;
len -= n;
if ( state -> err )
if ( state -> eof && state -> avail_in == 0 )
if ( fill_out_buffer ( state ) == - 1 )
static int fill_out_buffer(FILE_T state)
if ( state -> compression == 0 )
if ( gz_head ( state ) == - 1 )
if ( state -> have )
if ( state -> compression == 1 )
if ( state -> compression == 2 )
zlib_read ( state , state -> out , state -> size << 1 );
static void zlib_read(FILE_T state,unsigned char *buf,unsigned int count)
z_streamp strm = & state -> strm ;
unsigned char * buf2 = buf ;
unsigned int count2 = count ;
strm -> avail_out = count;
strm -> next_out = buf;
if ( state -> avail_in == 0 && fill_in_buffer ( state ) == - 1 )
if ( state -> avail_in == 0 )
strm -> avail_in = state -> avail_in;
strm -> next_in = state -> next_in;
ret = inflate ( strm , 5 );
state -> avail_in = strm -> avail_in;
state -> next_in = strm -> next_in;
if ( ret == - 2 )
if ( ret == 2 )
if ( ret == - 4 )
if ( ret == - 3 )
strm -> adler = crc32 ( strm -> adler , buf2 , count2 - strm -> avail_out );
unsigned int ready = count2 - strm -> avail_out ;
if ( ready < 32768 )
unsigned int left = 32768 - cur -> pos ;
if ( ready >= left )
memcpy ( ( cur -> window + cur -> pos ) , buf2 , left );
if ( ready != left )
memcpy ( ( cur -> window ) , ( buf2 + left ) , ( ready - left ) );
cur -> pos = ready - left;
cur -> have += ready;
memcpy ( ( cur -> window + cur -> pos ) , buf2 , ready );
cur -> pos += ready;
cur -> have += ready;
if ( cur -> have >= 32768 )
cur -> have = 32768;
memcpy ( ( cur -> window ) , ( buf2 + ( ready - 32768 ) ) , 32768 );
cur -> pos = 0;
cur -> have = 32768;
if ( cur -> have >= 32768 && ret != 1 && strm -> data_type & 128 && ! ( strm -> data_type & 64 ) )
zlib_fast_seek_add ( state , cur , strm -> data_type & 7 , state -> raw_pos - ( strm -> avail_in ) , state -> pos + ( count - strm -> avail_out ) );
buf2 = buf2 + count2 - strm -> avail_out;
count2 = strm -> avail_out;
while ( strm -> avail_out && ret != 1 )
state -> have = count - strm -> avail_out;
if ( gz_next4 ( state , & crc ) != - 1 && gz_next4 ( state , & len ) != - 1 )
if ( crc != strm -> adler && ! state -> dont_check_crc )
state -> err = - 21;
state -> err_info = "bad CRC";
if ( len != ( strm -> total_out & 0xffffffffL ) )
0
------------------------------
298702 95254/CWE369_Divide_by_Zero__int_listen_socket_divide_05.c printIntLine ( 100 / data ) 318
static void goodB2G2()
int data ;
data = - 1;
if ( staticTrue )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
char inputBuffer [ CHAR_ARRAY_SIZE ] ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , inputBuffer , CHAR_ARRAY_SIZE - 1 , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
inputBuffer [ recvResult ] = '\0';
data = atoi ( inputBuffer );
while ( 0 )
if ( staticTrue )
if ( data != 0 )
printIntLine ( 100 / data );
0
------------------------------
299055 152179/string.c start_address = ( str -> data + str -> len ) 560
void svn_stringbuf_appendstr(svn_stringbuf_t *targetstr,const svn_stringbuf_t *appendstr)
svn_stringbuf_appendbytes ( targetstr , ( appendstr -> data ) , appendstr -> len );
void svn_stringbuf_appendbytes(svn_stringbuf_t *str,const char *bytes,apr_size_t count)
void * start_address ;
start_address = ( str -> data + str -> len );
memcpy ( start_address , bytes , count );
0
------------------------------
16961 CVE-2011-2689/CVE_2011_2689_VULN_gfs2_fallocate.c rblocks = RES_DINODE + ind_blocks + RES_STATFS + RES_QUOTA + RES_RG_HDR + gfs2_rg_blocks ( al ) 63
static long CVE_2011_2689_VULN_gfs2_fallocate(struct file *file, int mode, loff_t
loff_t len)
struct inode * inode = file -> f_path . dentry -> d_inode ;
struct gfs2_sbd * sdp = GFS2_SB ( inode ) ;
struct gfs2_inode * ip = GFS2_I ( inode ) ;
unsigned int data_blocks = 0 , ind_blocks = 0 , rblocks ;
loff_t bytes , max_bytes ;
struct gfs2_alloc * al ;
int error ;
loff_t next = ( offset + len - 1 ) >> sdp -> sd_sb . sb_bsize_shift ;
next = ( next + 1 ) << sdp -> sd_sb . sb_bsize_shift;
if ( mode & ~FALLOC_FL_KEEP_SIZE )
offset = ( offset >> sdp -> sd_sb . sb_bsize_shift ) << sdp -> sd_sb . sb_bsize_shift;
len = next - offset;
bytes = sdp -> sd_max_rg_data * sdp -> sd_sb . sb_bsize / 2;
if ( ! bytes )
bytes = UINT_MAX;
error = gfs2_glock_nq ( & ip -> i_gh );
if ( unlikely ( error ) )
if ( ! gfs2_write_alloc_required ( ip , offset , len ) )
while ( len > 0 )
if ( len < bytes )
bytes = len;
al = gfs2_alloc_get ( ip );
if ( ! al )
error = gfs2_quota_lock_check ( ip );
if ( error )
al -> al_requested = data_blocks + ind_blocks;
error = gfs2_inplace_reserve ( ip );
if ( error )
if ( error == - ENOSPC && bytes > sdp -> sd_sb . sb_bsize )
bytes >>= 1;
max_bytes = bytes;
al -> al_requested = data_blocks + ind_blocks;
rblocks = RES_DINODE + ind_blocks + RES_STATFS + RES_QUOTA + RES_RG_HDR + gfs2_rg_blocks ( al );
if ( gfs2_is_jdata ( ip ) )
rblocks += data_blocks ? data_blocks : 1;
error = gfs2_trans_begin ( sdp , rblocks , PAGE_CACHE_SIZE / sdp -> sd_sb . sb_bsize );
if ( error )
error = fallocate_chunk ( inode , offset , max_bytes , mode );
if ( error )
len -= max_bytes;
offset += max_bytes;
0
------------------------------
17017 CVE-2013-0761/CVE_2013_0761_VULN_CopyTrackData.c TrackTicks ticks = endTicks - startTicks ; 31
void CVE_2013_0761_VULN_CopyTrackData(uint32_t aMapIndex, GraphTime aFrom, GraphTime
bool* aOutputTrackFinished)
TrackMapEntry * map = & mTrackMap [ aMapIndex ] ;
StreamBuffer :: Track * outputTrack = map -> mOutputTrack ;
TrackRate rate = outputTrack -> GetRate ( ) ;
GraphTime next ;
for (GraphTime t = aFrom; t < aTo; t = next)
MediaInputPort :: InputInterval interval = map -> mInputPort -> GetNextInputInterval ( t ) ;
interval . mEnd = NS_MIN ( interval . mEnd , aTo );
if ( interval . mStart >= interval . mEnd )
next = interval . mEnd;
StreamTime outputEnd = GraphTimeToStreamTime ( interval . mEnd ) ;
TrackTicks startTicks = outputTrack -> GetEnd ( ) ;
TrackTicks endTicks = TimeToTicksRoundUp ( rate , outputEnd ) ;
TrackTicks ticks = endTicks - startTicks ;
0
------------------------------
311718 149958/aviobuf.c s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_end - s -> checksum_ptr ) ) ) 568
uint64_t ffio_read_varlen(AVIOContext *bc)
int tmp ;
tmp = avio_r8 ( bc );
while ( tmp & 128 )
int avio_r8(AVIOContext *s)
if ( s -> buf_ptr >= s -> buf_end )
fill_buffer ( s );
static void fill_buffer(AVIOContext *s)
uint8_t * dst = ! s -> max_packet_size && s -> buf_end - s -> buffer < ( s -> buffer_size ) ? s -> buf_end : s -> buffer ;
if ( ! s -> read_packet && s -> buf_ptr >= s -> buf_end )
s -> eof_reached = 1;
if ( s -> eof_reached )
if ( s -> update_checksum && dst == s -> buffer )
if ( s -> buf_end > s -> checksum_ptr )
s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_end - s -> checksum_ptr ) ) );
s -> checksum_ptr = s -> buffer;
if ( s -> read_packet && s -> buffer_size > max_buffer_size )
ffio_set_buf_size ( s , max_buffer_size );
s -> checksum_ptr = dst = s -> buffer;
len = s -> buffer_size;
if ( s -> read_packet )
len = ( ( s -> read_packet ) ( s -> opaque , dst , len ) );
if ( len <= 0 )
s -> eof_reached = 1;
if ( len < 0 )
s -> error = len;
s -> pos += len;
s -> buf_ptr = dst;
s -> buf_end = dst + len;
s -> bytes_read += len;
0
------------------------------
303998 83216/CWE190_Integer_Overflow__int_fgets_square_03.c int result = data * data ; 181
static void goodG2B2()
int data ;
data = 0;
if ( 5 == 5 )
data = 2;
if ( 5 == 5 )
int result = data * data ;
printIntLine ( result );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
0
------------------------------
305848 117455/CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_rand_68b.c myString = ( wchar_t * ) malloc ( data * sizeof ( wchar_t ) ) 42
void CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_rand_68b_badSink()
size_t data = CWE789_Uncontrolled_Mem_Alloc__malloc_wchar_t_rand_68_badData ;
wchar_t * myString ;
if ( data > wcslen ( HELLO_STRING ) )
myString = ( wchar_t * ) malloc ( data * sizeof ( wchar_t ) );
wcscpy ( myString , HELLO_STRING );
printWLine ( myString );
void printWLine (const wchar_t * line)
if ( line != NULL )
wprintf ( L "%ls\n" , line )
free ( myString );
1
------------------------------
309395 151493/utf.c stonesoup_tainted_buff = ( char * ) malloc ( buffer_size * sizeof ( char ) ) 112
static int stonesoup_ev_handler(struct mg_connection *conn, enum mg_event ev)
char * ifmatch_header ;
char * stonesoup_tainted_buff ;
int buffer_size = 1000 ;
if ( ev == MG_REQUEST )
ifmatch_header = ( char * ) mg_get_header ( conn , "if-match" );
if ( strcmp ( ifmatch_header , "weak_taint_source_value" ) == 0 )
while ( 1 )
stonesoup_tainted_buff = ( char * ) malloc ( buffer_size * sizeof ( char ) );
data_size = mg_get_var ( conn , "data" , stonesoup_tainted_buff , buffer_size * sizeof ( char ) );
if ( data_size < buffer_size )
buffer_size = buffer_size * 2;
free ( stonesoup_tainted_buff );
stonesoup_handle_taint ( stonesoup_tainted_buff );
void stonesoup_handle_taint(char *marled_pterodactylian)
if ( marled_pterodactylian != 0 )
schmear_seasoner = ( ( int ) ( strlen ( marled_pterodactylian ) ) );
bismutite_krepi = ( ( char * ) ( malloc ( schmear_seasoner + 1 ) ) );
if ( bismutite_krepi == 0 )
memset ( bismutite_krepi , 0 , schmear_seasoner + 1 );
memcpy ( bismutite_krepi , marled_pterodactylian , schmear_seasoner );
if ( marled_pterodactylian != 0 )
free ( ( ( char * ) marled_pterodactylian ) );
uncontestablely_benevolences = unendurability_pommels ( bismutite_krepi );
char *unendurability_pommels(char *placated_cangue)
return placated_cangue ;
sulphinyl_hypsodonty ( nondealer_jewhood , uncontestablely_benevolences );
void sulphinyl_hypsodonty(int pulicoid_armhoop,char *demiurgical_cumbrance)
pulicoid_armhoop --;
if ( pulicoid_armhoop > 0 )
disaffectation_pummel ( pulicoid_armhoop , demiurgical_cumbrance );
void disaffectation_pummel(int embitters_quincunxes,char *amerceable_sluicer)
sulphinyl_hypsodonty ( embitters_quincunxes , amerceable_sluicer );
void sulphinyl_hypsodonty(int pulicoid_armhoop,char *demiurgical_cumbrance)
pulicoid_armhoop --;
if ( pulicoid_armhoop > 0 )
disaffectation_pummel ( pulicoid_armhoop , demiurgical_cumbrance );
sabretooth_wataps = ( ( char * ) demiurgical_cumbrance );
tracepoint ( stonesoup_trace , variable_buffer , "STONESOUP_TAINT_SOURCE" , sabretooth_wataps , "TRIGGER-STATE" );
while ( stonesoup_ss_i < strlen ( sabretooth_wataps ) )
if ( sabretooth_wataps [ stonesoup_ss_i ] >= 48 )
if ( demiurgical_cumbrance != 0 )
free ( ( ( char * ) demiurgical_cumbrance ) );
sabretooth_wataps = ( ( char * ) demiurgical_cumbrance );
tracepoint ( stonesoup_trace , variable_buffer , "STONESOUP_TAINT_SOURCE" , sabretooth_wataps , "TRIGGER-STATE" );
while ( stonesoup_ss_i < strlen ( sabretooth_wataps ) )
if ( sabretooth_wataps [ stonesoup_ss_i ] >= 48 )
if ( demiurgical_cumbrance != 0 )
free ( ( ( char * ) demiurgical_cumbrance ) );
1
------------------------------
305425 94208/CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_connect_socket_15.c recvResult = recv ( connectSocket , ( char * ) ( password + passwordLen ) , ( 100 - passwordLen - 1 ) * sizeof ( wchar_t ) , 0 ) 73
void CWE319_Cleartext_Tx_Sensitive_Info__w32_wchar_t_connect_socket_15_bad()
wchar_t * password ;
wchar_t passwordBuffer [ 100 ] = L ""
password = passwordBuffer;
switch ( 6 )
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t passwordLen = wcslen ( password ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( password + passwordLen ) , ( 100 - passwordLen - 1 ) * sizeof ( wchar_t ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
1
------------------------------
17520 CVE-2009-4138/CVE_2009_4138_VULN_ohci_queue_iso_receive_dualbuffer.c db -> second_buffer = cpu_to_le32 ( page_bus + offset ) 66
static int CVE_2009_4138_VULN_ohci_queue_iso_receive_dualbuffer(struct fw_iso_context
struct fw_iso_packet
struct fw_iso_buffer
unsigned long payload)
struct iso_context * ctx = container_of ( base , struct iso_context , base )
struct descriptor * d ;
struct fw_iso_packet * p ;
dma_addr_t d_bus , page_bus ;
u32 z , header_z , length , rest ;
int page , offset , packet_count , header_size ;
p = packet;
z = 2;
packet_count = p -> header_length / ctx -> base . header_size;
header_size = packet_count * max ( ctx -> base . header_size , ( size_t ) 8 );
header_z = DIV_ROUND_UP ( header_size , sizeof ( * d ) );
page = payload >> PAGE_SHIFT;
offset = payload & ~PAGE_MASK;
rest = p -> payload_length;
while ( rest > 0 )
d = context_get_descriptors ( & ctx -> context , z + header_z , & d_bus );
if ( d == NULL )
db = ( struct db_descriptor * ) d;
db -> control = cpu_to_le16 ( DESCRIPTOR_STATUS | DESCRIPTOR_BRANCH_ALWAYS );
db -> first_size = cpu_to_le16 ( max ( ctx -> base . header_size , ( size_t ) 8 ) );
if ( p -> skip && rest == p -> payload_length )
db -> control |= cpu_to_le16 ( DESCRIPTOR_WAIT );
db -> first_req_count = db -> first_size;
db -> first_req_count = cpu_to_le16 ( header_size );
db -> first_res_count = db -> first_req_count;
db -> first_buffer = cpu_to_le32 ( d_bus + sizeof ( * db ) );
if ( p -> skip && rest == p -> payload_length )
length = 4;
if ( offset + rest < PAGE_SIZE )
length = rest;
length = PAGE_SIZE - offset;
db -> second_req_count = cpu_to_le16 ( length );
db -> second_res_count = db -> second_req_count;
page_bus = page_private ( buffer -> pages [ page ] );
db -> second_buffer = cpu_to_le32 ( page_bus + offset );
offset = ( offset + length ) & ~PAGE_MASK;
rest -= length;
if ( offset == 0 )
page ++;
0
------------------------------
18089 CVE-2015-4473/Firefox_40.0b6_CVE_2015_4473_js_src_jit_BytecodeAnalysis.cpp jsbytecode * endOfTry = pc + GetSrcNoteOffset ( sn , 0 ) ; 131

BytecodeAnalysis::init(TempAllocator& alloc, GSNCache& gsn)
if ( ! infos_ . growByUninitialized ( script_ -> length ( ) ) )
jsbytecode * end = script_ -> codeEnd ( ) ;
Vector < CatchFinallyRange , 0 , JitAllocPolicy > catchFinallyRanges ( alloc ) ;
jsbytecode * nextpc ;
for (jsbytecode* pc = script_->code(); pc < end; pc = nextpc)
JSOp op = JSOp ( * pc ) ;
nextpc = pc + GetBytecodeLength ( pc );
unsigned offset = script_ -> pcToOffset ( pc ) ;
if ( ! infos_ [ offset ] . initialized )
switch ( op )
unsigned defaultOffset = offset + GET_JUMP_OFFSET ( pc ) ;
jsbytecode * pc2 = pc + JUMP_OFFSET_LEN ;
int32_t low = GET_JUMP_OFFSET ( pc2 ) ;
pc2 += JUMP_OFFSET_LEN;
int32_t high = GET_JUMP_OFFSET ( pc2 ) ;
pc2 += JUMP_OFFSET_LEN;
infos_ [ defaultOffset ] . jumpTarget = true;
for (int32_t i = low; i <= high; i++)
unsigned targetOffset = offset + GET_JUMP_OFFSET ( pc2 ) ;
if ( targetOffset != offset )
infos_ [ targetOffset ] . jumpTarget = true;
pc2 += JUMP_OFFSET_LEN;
JSTryNote * tn = script_ -> trynotes ( ) -> vector ;
JSTryNote * tnlimit = tn + script_ -> trynotes ( ) -> length ;
for (; tn < tnlimit; tn++)
unsigned startOffset = script_ -> mainOffset ( ) + tn -> start ;
if ( startOffset == offset + 1 )
unsigned catchOffset = startOffset + tn -> length ;
if ( tn -> kind != JSTRY_FOR_IN )
infos_ [ catchOffset ] . jumpTarget = true;
jssrcnote * sn = GetSrcNote ( gsn , script_ , pc ) ;
jsbytecode * endOfTry = pc + GetSrcNoteOffset ( sn , 0 ) ;
MOZ_ASSERT ( JSOp ( * endOfTry ) == JSOP_GOTO );
jsbytecode * afterTry = endOfTry + GET_JUMP_OFFSET ( endOfTry ) ;
MOZ_ASSERT ( afterTry > endOfTry );
CatchFinallyRange range ( script_ -> pcToOffset ( endOfTry ) , script_ -> pcToOffset ( afterTry ) ) ;
if ( ! catchFinallyRanges . append ( range ) )
for (size_t i = 0; i < catchFinallyRanges.length(); i++)
if ( catchFinallyRanges [ i ] . contains ( offset ) )
bool contains(uint32_t offset) const
return start <= offset && offset < end ;
infos_ [ offset ] . loopEntryInCatchOrFinally = true;
bool jump = IsJumpOpcode ( op ) ;
if ( jump )
unsigned targetOffset = offset + GET_JUMP_OFFSET ( pc ) ;
bool jumpBack = ( targetOffset < offset ) && ! infos_ [ targetOffset ] . initialized ;
infos_ [ targetOffset ] . jumpTarget = true;
if ( jumpBack )
nextpc = script_ -> offsetToPC ( targetOffset );
if ( BytecodeFallsThrough ( op ) )
jsbytecode * fallthrough = pc + GetBytecodeLength ( pc ) ;
unsigned fallthroughOffset = script_ -> pcToOffset ( fallthrough ) ;
if ( jump )
infos_ [ fallthroughOffset ] . jumpTarget = true;
0
------------------------------
310818 151097/aviobuf.c s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_end - s -> checksum_ptr ) ) ) 455
unsigned int avio_rl32(AVIOContext *s)
unsigned int val ;
val = avio_rl16 ( s );
val |= avio_rl16 ( s ) << 16;
unsigned int avio_rl16(AVIOContext *s)
unsigned int val ;
val = ( avio_r8 ( s ) );
val |= ( avio_r8 ( s ) << 8 );
int avio_r8(AVIOContext *s)
if ( s -> buf_ptr >= s -> buf_end )
fill_buffer ( s );
static void fill_buffer(AVIOContext *s)
uint8_t * dst = ! s -> max_packet_size && s -> buf_end - s -> buffer < ( s -> buffer_size ) ? s -> buf_end : s -> buffer ;
if ( ! s -> read_packet && s -> buf_ptr >= s -> buf_end )
s -> eof_reached = 1;
if ( s -> eof_reached )
if ( s -> update_checksum && dst == s -> buffer )
if ( s -> buf_end > s -> checksum_ptr )
s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_end - s -> checksum_ptr ) ) );
s -> checksum_ptr = s -> buffer;
if ( s -> read_packet && s -> buffer_size > max_buffer_size )
ffio_set_buf_size ( s , max_buffer_size );
s -> checksum_ptr = dst = s -> buffer;
len = s -> buffer_size;
if ( s -> read_packet )
len = ( ( s -> read_packet ) ( s -> opaque , dst , len ) );
if ( len <= 0 )
s -> eof_reached = 1;
if ( len < 0 )
s -> error = len;
s -> pos += len;
s -> buf_ptr = dst;
s -> buf_end = dst + len;
s -> bytes_read += len;
0
------------------------------
312469 152246/cmdutils.c int len = ( p ? ( p - name ) : strlen ( name ) ) ; 265
int split_commandline(OptionParseContext *octx,int argc,char *argv[],const OptionDef *options,const OptionGroupDef *groups,int nb_groups)
int optindex = 1 ;
int dashdash = - 2 ;
while ( optindex < argc )
const char * opt = argv [ optindex ++ ] ;
const char * arg ;
const OptionDef * po ;
int ret ;
if ( opt [ 0 ] == '-' && opt [ 1 ] == '-' && ! opt [ 2 ] )
dashdash = optindex;
if ( opt [ 0 ] != '-' || ! opt [ 1 ] || dashdash + 1 == optindex )
opt ++;
while ( 0 )
if ( ( ret = match_group_separator ( groups , nb_groups , opt ) ) >= 0 )
arg = argv [ optindex ++ ];
if ( ! arg )
while ( 0 )
po = find_option ( options , opt );
if ( po -> name )
if ( po -> flags & 0x0800 )
arg = argv [ optindex ++ ];
if ( po -> flags & 0x0001 )
arg = argv [ optindex ++ ];
if ( ! arg )
while ( 0 )
if ( argv [ optindex ] )
ret = opt_default ( ( ( void * ) 0 ) , opt , argv [ optindex ] );
if ( ret >= 0 )
optindex ++;
if ( ret != - ( ( int ) ( ( 0xF8 | 'O' << 8 | 'P' << 16 ) | ( ( unsigned int ) 'T' ) << 24 ) ) )
if ( opt [ 0 ] == 'n' && opt [ 1 ] == 'o' && ( po = find_option ( options , opt + 2 ) ) && po -> name && po -> flags & 0x00002 )
static const OptionDef *find_option(const OptionDef *po,const char *name)
const char * p = ( strchr ( name , ':' ) ) ;
int len = ( p ? ( p - name ) : strlen ( name ) ) ;
if ( ! strncmp ( name , po -> name , len ) && strlen ( po -> name ) == len )
0
------------------------------
17246 CVE-2008-0420/CVE_2008_0420_VULN_nsBMPDecoder__ProcessData.c toCopy = rowSize - mRowBytes 147
NS_METHOD CVE_2008_0420_VULN_nsBMPDecoder::ProcessData(const char* aBuffer, PRUint32 aCount)
if ( ! aCount || ! mCurLine )
if ( mPos < BFH_LENGTH )
PRUint32 toCopy = BFH_LENGTH - mPos ;
if ( toCopy > aCount )
toCopy = aCount;
mPos += toCopy;
aCount -= toCopy;
if ( mPos == BFH_LENGTH )
if ( mBFH . signature [ 0 ] != 'B' || mBFH . signature [ 1 ] != 'M' )
if ( mBFH . bihsize == OS2_BIH_LENGTH )
mLOH = OS2_HEADER_LENGTH;
if ( mPos >= BFH_LENGTH && mPos < mLOH )
PRUint32 toCopy = mLOH - mPos ;
if ( toCopy > aCount )
toCopy = aCount;
mPos += toCopy;
aCount -= toCopy;
if ( mPos == mLOH )
if ( mBIH . bpp != 1 && mBIH . bpp != 4 && mBIH . bpp != 8 && mBIH . bpp != 16 && mBIH . bpp != 24 && mBIH . bpp != 32 )
if ( mBIH . bpp <= 8 )
mNumColors = 1 << mBIH . bpp;
if ( mBIH . colors && mBIH . colors < mNumColors )
mNumColors = mBIH . colors;
mColors = new colorTable [ mNumColors ];
if ( ! mColors )
if ( mBIH . width < 0 )
PRUint32 real_height = ( mBIH . height > 0 ) ? mBIH . height : - mBIH . height ;
mCurLine = real_height;
mRow = new PRUint8 [ ( mBIH . width * mBIH . bpp ) / 8 + 4 ];
if ( ! mRow )
PRUint8 bpc ;
bpc = ( mBFH . bihsize == OS2_BIH_LENGTH ) ? 3 : 4;
if ( mColors && ( mPos >= mLOH && ( mPos < ( mLOH + mNumColors * bpc ) ) ) )
while ( aCount && ( mPos < ( mLOH + mNumColors * bpc ) ) )
mPos ++;
aCount --;
if ( aCount && mBIH . compression == BI_BITFIELDS && mPos < ( WIN_HEADER_LENGTH + BITFIELD_LENGTH ) )
PRUint32 toCopy = ( WIN_HEADER_LENGTH + BITFIELD_LENGTH ) - mPos ;
if ( toCopy > aCount )
toCopy = aCount;
mPos += toCopy;
aCount -= toCopy;
while ( aCount && ( mPos < mBFH . dataoffset ) )
mPos ++;
aCount --;
if ( aCount && ++ mPos >= mBFH . dataoffset )
if ( ! mBIH . compression || mBIH . compression == BI_BITFIELDS )
PRUint32 rowSize = ( mBIH . bpp * mBIH . width + 7 ) / 8 ;
if ( rowSize % 4 )
rowSize += ( 4 - ( rowSize % 4 ) );
PRUint32 toCopy ;
toCopy = rowSize - mRowBytes;
if ( toCopy )
if ( toCopy > aCount )
toCopy = aCount;
aCount -= toCopy;
mRowBytes += toCopy;
if ( ( rowSize - mRowBytes ) == 0 )
if ( ! mDecoded )
mDecoded = ( PRUint8 * ) malloc ( mBpr );
if ( ! mDecoded )
if ( mCurLine == 0 )
mRowBytes = 0;
while ( aCount > 0 )
1
------------------------------
310586 148890/vwr.c start_time = s_time / NS_IN_US 1406
static gboolean vwr_read(wtap *wth, int *err, gchar **err_info, gint64 *data_offset)
vwr_t * vwr = ( vwr_t * ) wth -> priv ;
guint8 rec [ B_SIZE ] ;
int rec_size = 0 , IS_TX ;
guint8 * data_ptr ;
if ( ! vwr_read_rec_header ( vwr , wth -> fh , & rec_size , & IS_TX , err , err_info ) )
static gboolean vwr_read_rec_header(vwr_t *vwr, FILE_T fh, int *rec_size, int *IS_TX, int *err, gchar **err_info)
int bytes_read , file_off ;
int f_len , v_type ;
guint8 header [ 16 ] ;
while ( 1 )
if ( ( bytes_read = file_read ( header , 16 , fh ) ) != 16 )
return ( FALSE ) ;
if ( ( f_len = decode_msg ( vwr , header , & v_type , IS_TX ) ) != 0 )
static int decode_msg(vwr_t *vwr, guint8 *rec, int *v_type, int *IS_TX)
guint8 cmd ;
guint32 wd2 , wd3 ;
int v_size = 0 ;
cmd = rec [ 0 ];
wd2 = pntohl ( & rec [ 8 ] );
wd3 = pntohl ( & rec [ 12 ] );
switch ( cmd )
v_size = ( int ) ( wd2 & 0xffff );
v_size = ( int ) ( wd2 & 0xffff );
v_size = ( int ) ( wd3 & 0xffff );
return ( v_size ) ;
if ( f_len > B_SIZE )
return ( FALSE ) ;
if ( v_type != VT_FRAME )
if ( file_seek ( fh , f_len , SEEK_CUR , err ) < 0 )
return ( FALSE ) ;
return ( TRUE ) ;
if ( file_read ( rec , rec_size , wth -> fh ) != rec_size )
data_ptr = buffer_start_ptr ( wth -> frame_buffer );
switch ( vwr -> FPGA_VERSION )
vwr_read_rec_data_vVW510021 ( wth , data_ptr , rec , rec_size , IS_TX );
static void vwr_read_rec_data_vVW510021(wtap *wth, guint8 *data_ptr, guint8 *rec, int rec_size, int IS_TX)
vwr_t * vwr = ( vwr_t * ) wth -> priv ;
s_trail_ptr = & ( rec [ rec_size - vwr -> STATS_LEN ] );
s_time = pcoreytohll ( & s_trail_ptr [ vwr -> STARTT_OFF ] );
start_time = s_time / NS_IN_US;
s_sec = ( start_time / US_IN_SEC );
s_usec = start_time - ( s_sec * US_IN_SEC );
wth -> phdr . ts . secs = ( time_t ) s_sec;
wth -> phdr . ts . nsecs = ( long ) ( s_usec * 1000 );
wth -> phdr . pkt_encap = WTAP_ENCAP_IXVERIWAVE;
common_fields . vw_startt = start_time;
common_fields . vw_endt = end_time;
common_fields . vw_sig_ts = ( guint32 ) ( sig_ts );
phtoles ( & data_ptr [ bytes_written ] , common_fields . vw_port_type );
phtoles ( & data_ptr [ bytes_written ] , common_fields . it_len );
phtoles ( & data_ptr [ bytes_written ] , common_fields . vw_msdu_length );
phtolel ( & data_ptr [ bytes_written ] , common_fields . vw_flowid );
phtoles ( & data_ptr [ bytes_written ] , common_fields . vw_vcid );
phtoles ( & data_ptr [ bytes_written ] , common_fields . vw_seqnum );
phtolel ( & data_ptr [ bytes_written ] , common_fields . vw_latency );
phtolel ( & data_ptr [ bytes_written ] , common_fields . vw_sig_ts );
phtolell ( & data_ptr [ bytes_written ] , common_fields . vw_startt );
phtolell ( & data_ptr [ bytes_written ] , common_fields . vw_endt );
phtolel ( & data_ptr [ bytes_written ] , common_fields . vw_pktdur );
0
------------------------------
301085 153289/aviobuf.c s -> buf_end = dst + len 520
unsigned int avio_rl24(AVIOContext *s)
unsigned int val ;
val = avio_rl16 ( s );
unsigned int avio_rl16(AVIOContext *s)
unsigned int val ;
val = ( avio_r8 ( s ) );
int avio_r8(AVIOContext *s)
if ( s -> buf_ptr >= s -> buf_end )
fill_buffer ( s );
static void fill_buffer(AVIOContext *s)
uint8_t * dst = ! s -> max_packet_size && s -> buf_end - s -> buffer < ( s -> buffer_size ) ? s -> buf_end : s -> buffer ;
int len = ( ( s -> buffer_size ) - ( dst - s -> buffer ) ) ;
int max_buffer_size = s -> max_packet_size ? s -> max_packet_size : 32768 ;
if ( ! s -> read_packet && s -> buf_ptr >= s -> buf_end )
s -> eof_reached = 1;
if ( s -> eof_reached )
if ( s -> update_checksum && dst == s -> buffer )
if ( s -> buf_end > s -> checksum_ptr )
s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_end - s -> checksum_ptr ) ) );
s -> checksum_ptr = s -> buffer;
if ( s -> read_packet && s -> buffer_size > max_buffer_size )
s -> checksum_ptr = dst = s -> buffer;
len = s -> buffer_size;
if ( s -> read_packet )
len = ( ( s -> read_packet ) ( s -> opaque , dst , len ) );
len = 0;
if ( len <= 0 )
s -> eof_reached = 1;
if ( len < 0 )
s -> error = len;
s -> pos += len;
s -> buf_ptr = dst;
s -> buf_end = dst + len;
s -> bytes_read += len;
0
------------------------------
20119 CVE-2016-2847/linux_kernel_4.3_CVE_2016_2847_fs_pipe.c struct pipe_buffer * buf = pipe -> bufs + i ; 612
static int fifo_open(struct inode *inode, struct file *filp)
struct pipe_inode_info * pipe ;
bool is_pipe = inode -> i_sb -> s_magic == PIPEFS_MAGIC ;
filp -> f_version = 0;
if ( inode -> i_pipe )
pipe = inode -> i_pipe;
pipe -> files ++;
pipe = alloc_pipe_info ( );
if ( ! pipe )
pipe -> files = 1;
if ( unlikely ( inode -> i_pipe ) )
inode -> i_pipe -> files ++;
pipe = inode -> i_pipe;
inode -> i_pipe = pipe;
filp -> private_data = pipe;
filp -> f_mode &= ( FMODE_READ | FMODE_WRITE );
switch ( filp -> f_mode )
pipe -> r_counter ++;
if ( pipe -> readers ++ == 0 )
if ( ! is_pipe && ! pipe -> writers )
if ( filp -> f_flags & O_NONBLOCK )
filp -> f_version = pipe -> w_counter;
if ( wait_for_partner ( pipe , & pipe -> w_counter ) )
static int wait_for_partner(struct pipe_inode_info *pipe, unsigned int *cnt)
int cur = * cnt ;
return cur == * cnt ? - ERESTARTSYS : 0 ;
if ( ! is_pipe && ( filp -> f_flags & O_NONBLOCK ) && ! pipe -> readers )
pipe -> w_counter ++;
if ( ! pipe -> writers ++ )
if ( ! is_pipe && ! pipe -> readers )
if ( wait_for_partner ( pipe , & pipe -> r_counter ) )
static int wait_for_partner(struct pipe_inode_info *pipe, unsigned int *cnt)
int cur = * cnt ;
return cur == * cnt ? - ERESTARTSYS : 0 ;
pipe -> readers ++;
pipe -> writers ++;
pipe -> r_counter ++;
pipe -> w_counter ++;
put_pipe_info ( inode , pipe );
static void put_pipe_info(struct inode *inode, struct pipe_inode_info *pipe)
int kill = 0 ;
if ( ! -- pipe -> files )
kill = 1;
if ( kill )
free_pipe_info ( pipe );
void free_pipe_info(struct pipe_inode_info *pipe)
int i ;
for (i = 0; i < pipe->buffers; i++)
struct pipe_buffer * buf = pipe -> bufs + i ;
if ( buf -> ops )
buf -> ops -> release ( pipe , buf );
0
------------------------------
307619 112851/CWE761_Free_Pointer_Not_at_Start_of_Buffer__wchar_t_connect_socket_81a.cpp recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 ) 89
void bad()
wchar_t * data ;
data = ( wchar_t * ) malloc ( 100 * sizeof ( wchar_t ) );
data [ 0 ] = L '\0'
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
302347 79269/CWE134_Uncontrolled_Format_String__char_connect_socket_vfprintf_44.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 102
void CWE134_Uncontrolled_Format_String__char_connect_socket_vfprintf_44_bad()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
funcPtr ( data , data );
0
------------------------------
302220 80281/CWE134_Uncontrolled_Format_String__char_listen_socket_fprintf_53a.c recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 206
static void goodB2G()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
CWE134_Uncontrolled_Format_String__char_listen_socket_fprintf_53b_goodB2GSink ( data );
void CWE134_Uncontrolled_Format_String__char_listen_socket_fprintf_53b_goodB2GSink(char * data)
CWE134_Uncontrolled_Format_String__char_listen_socket_fprintf_53c_goodB2GSink ( data );
void CWE134_Uncontrolled_Format_String__char_listen_socket_fprintf_53c_goodB2GSink(char * data)
CWE134_Uncontrolled_Format_String__char_listen_socket_fprintf_53d_goodB2GSink ( data );
void CWE134_Uncontrolled_Format_String__char_listen_socket_fprintf_53d_goodB2GSink(char * data)
fprintf ( stdout , "%s\n" , data );
0
------------------------------
311166 153292/config.c apr_size_t len = ( name_end - name_start ) ; 547
svn_error_t *svn_config_get_int64(svn_config_t *cfg,apr_int64_t *valuep,const char *section,const char *option,apr_int64_t default_value)
const char * tmp_value ;
svn_config_get ( cfg , & tmp_value , section , option , ( ( void * ) 0 ) );
void svn_config_get(svn_config_t *cfg,const char **valuep,const char *section,const char *option,const char *default_value)
if ( cfg )
cfg_section_t * sec ;
cfg_option_t * opt = find_option ( cfg , section , option , & sec ) ;
if ( opt != ( ( void * ) 0 ) )
if ( default_value && strchr ( default_value , 37 ) )
apr_pool_t * tmp_pool = svn_pool_create_ex ( cfg -> x_pool , ( ( void * ) 0 ) ) ;
const char * x_default ;
expand_option_value ( cfg , sec , default_value , & x_default , tmp_pool );
static void expand_option_value(svn_config_t *cfg,cfg_section_t *section,const char *opt_value,const char **opt_x_valuep,apr_pool_t *x_pool)
const char * parse_from = opt_value ;
const char * name_start ;
const char * name_end ;
while ( parse_from != ( ( void * ) 0 ) && ( * parse_from ) != '\0' && ( name_start = ( strstr ( parse_from , "%(" ) ) ) != ( ( void * ) 0 ) )
name_start += sizeof ( "%(" ) - 1;
if ( ( * name_start ) == '\0' )
name_end = ( strstr ( name_start , ")s" ) );
if ( name_end != ( ( void * ) 0 ) )
cfg_option_t * x_opt ;
apr_size_t len = ( name_end - name_start ) ;
char * name = apr_pstrmemdup ( x_pool , name_start , len ) ;
x_opt = find_option ( cfg , section -> name , name , ( ( void * ) 0 ) );
if ( x_opt != ( ( void * ) 0 ) )
make_string_from_option ( & cstring , cfg , section , x_opt , x_pool );
parse_from = name_end + ( sizeof ( ")s" ) - 1 );
parse_from = name_end + ( sizeof ( ")s" ) - 1 );
parse_from = ( ( void * ) 0 );
0
------------------------------
304120 83360/CWE190_Integer_Overflow__int_fscanf_square_03.c int result = data * data ; 95
static void goodB2G2()
int data ;
data = 0;
if ( 5 == 5 )
if ( abs ( ( long ) data ) <= ( long ) sqrt ( ( double ) INT_MAX ) )
int result = data * data ;
printIntLine ( result );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
0
------------------------------
311397 152169/aviobuf.c s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_end - s -> checksum_ptr ) ) ) 463
unsigned int avio_rb32(AVIOContext *s)
unsigned int val ;
val = avio_rb16 ( s ) << 16;
val |= avio_rb16 ( s );
unsigned int avio_rb16(AVIOContext *s)
unsigned int val ;
val = ( avio_r8 ( s ) << 8 );
int avio_r8(AVIOContext *s)
if ( s -> buf_ptr >= s -> buf_end )
fill_buffer ( s );
static void fill_buffer(AVIOContext *s)
uint8_t * dst = ! s -> max_packet_size && s -> buf_end - s -> buffer < ( s -> buffer_size ) ? s -> buf_end : s -> buffer ;
if ( ! s -> read_packet && s -> buf_ptr >= s -> buf_end )
s -> eof_reached = 1;
if ( s -> eof_reached )
if ( s -> update_checksum && dst == s -> buffer )
if ( s -> buf_end > s -> checksum_ptr )
s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_end - s -> checksum_ptr ) ) );
s -> checksum_ptr = s -> buffer;
if ( s -> read_packet && s -> buffer_size > max_buffer_size )
ffio_set_buf_size ( s , max_buffer_size );
s -> checksum_ptr = dst = s -> buffer;
len = s -> buffer_size;
if ( s -> read_packet )
len = ( ( s -> read_packet ) ( s -> opaque , dst , len ) );
if ( len <= 0 )
s -> eof_reached = 1;
if ( len < 0 )
s -> error = len;
s -> pos += len;
s -> buf_ptr = dst;
s -> buf_end = dst + len;
s -> bytes_read += len;
0
------------------------------
306268 120563/CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_execv_45.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 ) 116
void CWE78_OS_Command_Injection__wchar_t_connect_socket_w32_execv_45_bad()
wchar_t * data ;
wchar_t dataBuffer [ 100 ] = L ""
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
314056 110715/CWE680_Integer_Overflow_to_Buffer_Overflow__new_fixed_22a.cpp dataBytes = data * sizeof ( int ) 102
static void goodG2B2()
int data ;
data = - 1;
data = goodG2B2Source ( data );
int goodG2B2Source(int data)
if ( goodG2B2Global )
data = 20;
return data ;
size_t dataBytes , i ;
dataBytes = data * sizeof ( int );
intPointer = ( int * ) new char [ dataBytes ];
intPointer [ i ] = 0;
printIntLine ( intPointer [ 0 ] );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
delete [ ] intPointer
0
------------------------------
298140 95076/CWE369_Divide_by_Zero__int_fgets_divide_21.c printIntLine ( 100 / data ) 80
static void goodB2G1()
int data ;
data = - 1;
char inputBuffer [ CHAR_ARRAY_SIZE ] = "" ;
if ( fgets ( inputBuffer , CHAR_ARRAY_SIZE , stdin ) != NULL )
data = atoi ( inputBuffer );
goodB2G1Sink ( data );
static void goodB2G1Sink(int data)
if ( goodB2G1Static )
if ( data != 0 )
printIntLine ( 100 / data );
0
------------------------------
300754 153579/dfa.c * mbclen = ( mblen_buf [ * pp - buf_begin ] == 0 ? 1 : mblen_buf [ * pp - buf_begin ] ) 3403
char *dfaexec(struct dfa *d,const char *begin,char *end,int allow_nl,size_t *count,int *backref)
state_num s ;
state_num s1 ;
const unsigned char * p ;
state_num * * trans ;
state_num * t ;
unsigned char eol = eolbyte ;
s = s1 = 0;
p = ( ( const unsigned char * ) begin );
trans = d -> trans;
* end = eol;
if ( d -> mb_cur_max > 1 )
while ( ( t = trans [ s ] ) != ( ( void * ) 0 ) )
if ( p > buf_end )
s1 = s;
if ( s == 0 )
if ( ( ( char * ) p ) >= end )
if ( d -> states [ s ] . mbps . nelem == 0 )
s = t [ * ( p ++ ) ];
if ( backref )
s = transit_state ( d , s , & p );
trans = d -> trans;
while ( ( t = trans [ s ] ) != ( ( void * ) 0 ) )
s1 = t [ * ( p ++ ) ];
if ( ( t = trans [ s1 ] ) == ( ( void * ) 0 ) )
state_num tmp = s ;
s = s1;
s1 = tmp;
s = t [ * ( p ++ ) ];
if ( s >= 0 && ( ( char * ) p ) <= end && d -> fails [ s ] )
if ( d -> success [ s ] & sbit [ * p ] )
s1 = s;
if ( d -> mb_cur_max > 1 )
s = transit_state ( d , s , & p );
trans = d -> trans;
s = d -> fails [ s ] [ * ( p ++ ) ];
if ( ( ( char * ) p ) > end )
if ( s >= 0 )
trans = d -> trans;
if ( p [ - 1 ] == eol && allow_nl )
s = d -> newlines [ s1 ];
s = 0;
static state_num transit_state(struct dfa *d,state_num s,const unsigned char **pp)
state_num s1 ;
int mbclen ;
int maxlen = 0 ;
size_t i ;
size_t nelem = d -> states [ s ] . mbps . nelem ;
position_set follows ;
const unsigned char * p1 = * pp ;
wchar_t wc ;
if ( nelem > 0 )
match_lens = check_matching_with_multibyte_ops ( d , s , ( * pp - buf_begin ) );
for (i = 0; i < nelem; i++)
if ( match_lens [ i ] > maxlen )
maxlen = match_lens [ i ];
if ( nelem == 0 || maxlen == 0 )
wc = inputwcs [ * pp - mbclen - buf_begin ];
s1 = state_index ( d , ( & follows ) , wchar_context ( wc ) );
while ( * pp - p1 < maxlen )
transit_state_consume_1char ( d , s1 , pp , ( ( void * ) 0 ) , & mbclen , & follows );
wc = inputwcs [ * pp - mbclen - buf_begin ];
s1 = state_index ( d , ( & follows ) , wchar_context ( wc ) );
static status_transit_state transit_state_consume_1char(struct dfa *d,state_num s,const unsigned char **pp,int *match_lens,int *mbclen,position_set *pps)
* mbclen = ( mblen_buf [ * pp - buf_begin ] == 0 ? 1 : mblen_buf [ * pp - buf_begin ] );
for (k = 0; k <  *mbclen; k++)
if ( work_mbls [ i ] == * mbclen )
0
------------------------------
299016 61973/CWE114_Process_Control__w32_char_connect_socket_61b.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 83
void CWE114_Process_Control__w32_char_connect_socket_61_bad()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
data = CWE114_Process_Control__w32_char_connect_socket_61b_badSource ( data );
char * CWE114_Process_Control__w32_char_connect_socket_61b_badSource(char * data)
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
return data ;
0
------------------------------
305809 110513/CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_listen_socket_10.c intPointer = ( int * ) malloc ( data * sizeof ( int ) ) 186
static void goodG2B2()
int data ;
data = - 1;
if ( globalTrue )
data = 20;
int * intPointer ;
intPointer = ( int * ) malloc ( data * sizeof ( int ) );
intPointer [ i ] = 0;
printIntLine ( intPointer [ 0 ] );
void printIntLine (int intNumber)
printf ( "%d\n" , intNumber );
free ( intPointer );
0
------------------------------
303960 80250/CWE134_Uncontrolled_Format_String__char_listen_socket_fprintf_01.c recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 201
static void goodB2G()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
listenSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( listenSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = INADDR_ANY;
service . sin_port = htons ( TCP_PORT );
if ( bind ( listenSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
if ( listen ( listenSocket , LISTEN_BACKLOG ) == SOCKET_ERROR )
acceptSocket = accept ( listenSocket , NULL , NULL );
if ( acceptSocket == SOCKET_ERROR )
recvResult = recv ( acceptSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
fprintf ( stdout , "%s\n" , data );
0
------------------------------
307852 109201/CWE606_Unchecked_Loop_Condition__wchar_t_connect_socket_53a.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 ) 93
void CWE606_Unchecked_Loop_Condition__wchar_t_connect_socket_53_bad()
wchar_t * data ;
wchar_t dataBuffer [ 100 ] = L ""
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = wcslen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( wchar_t ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
while ( 0 )
0
------------------------------
306871 118133/CWE78_OS_Command_Injection__char_connect_socket_system_83_bad.cpp recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 89
CWE78_OS_Command_Injection__char_connect_socket_system_83_bad::CWE78_OS_Command_Injection__char_connect_socket_system_83_bad(char * dataCopy)
data = dataCopy;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
0
------------------------------
309522 153617/emem.c stonesoup_other_buff [ stonesoup_other_size - stonesoup_i - 1 ] = bastard_studbook [ stonesoup_buff_size - stonesoup_i - 1 ] 1171
inline static emem_tree_node_t *emem_tree_parent(emem_tree_node_t *node)
int stonesoup_size ;
union undercommander_overfee tupler_omnivident ;
char * cellular_studite ;
if ( __sync_bool_compare_and_swap ( & noodged_tur , 0 , 1 ) )
if ( mkdir ( "/opt/stonesoup/workspace/lockDir" , 509U ) == 0 )
if ( cellular_studite != 0 )
tupler_omnivident . unwaving_pycnogonidium = cellular_studite;
pococurantism_aceldamas = polyesters_immaturely ( tupler_omnivident );
union undercommander_overfee polyesters_immaturely(union undercommander_overfee talmudize_unintentionally)
return talmudize_unintentionally ;
bastard_studbook = ( ( char * ) pococurantism_aceldamas . unwaving_pycnogonidium );
stonesoup_buff_size = strlen ( bastard_studbook ) + 1;
stonesoup_other_size = 64;
stonesoup_other_buff = ( char * ) malloc ( stonesoup_other_size * sizeof ( char ) );
if ( stonesoup_other_buff != NULL )
stonesoup_size = stonesoup_other_size < stonesoup_buff_size ? stonesoup_other_size : stonesoup_buff_size;
for (stonesoup_i = 0; stonesoup_i < stonesoup_size; stonesoup_i++)
stonesoup_other_buff [ stonesoup_other_size - stonesoup_i - 1 ] = bastard_studbook [ stonesoup_buff_size - stonesoup_i - 1 ];
for (stonesoup_i = 0; stonesoup_i < stonesoup_buff_size; stonesoup_i++)
stonesoup_printf ( "%02x" , stonesoup_other_buff [ stonesoup_other_size - stonesoup_i - 1 ] );
void stonesoup_printf(char * format, ...)
va_start ( argptr , format );
vfprintf ( stonesoup_printf_context , format , argptr );
free ( stonesoup_other_buff );
tracepoint ( stonesoup_trace , variable_signed_integral , "stonesoup_other_size" , stonesoup_other_size , & stonesoup_other_size , "TRIGGER-STATE" );
1
------------------------------
17306 CVE-2013-4470/CVE_2013_4470_VULN_ip_ufo_append_data.c skb = sock_alloc_send_skb ( sk , hh_len + fragheaderlen + transhdrlen + 20 , ( flags & MSG_DONTWAIT ) , & err ) 16
static inline int CVE_2013_4470_VULN_ip_ufo_append_data(struct sock
struct sk_buff_head
int getfrag(void *from, char *to, int offset, int
int odd, struct sk_buff
void *from, int length, int hh_len, int
int transhdrlen, int maxfraglen, unsigned int flags)
struct sk_buff * skb ;
if ( ( skb = skb_peek_tail ( queue ) ) == NULL )
skb = sock_alloc_send_skb ( sk , hh_len + fragheaderlen + transhdrlen + 20 , ( flags & MSG_DONTWAIT ) , & err );
0
------------------------------
306845 118103/CWE78_OS_Command_Injection__char_connect_socket_system_17.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 100
void CWE78_OS_Command_Injection__char_connect_socket_system_17_bad()
int i ;
char * data ;
char data_buf [ 100 ] = FULL_COMMAND ;
data = data_buf;
for(i = 0; i < 1; i++)
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
if ( SYSTEM ( data ) <= 0 )
1
------------------------------
302507 79365/CWE134_Uncontrolled_Format_String__char_connect_socket_w32_vsnprintf_44.c recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 ) 104
void CWE134_Uncontrolled_Format_String__char_connect_socket_w32_vsnprintf_44_bad()
char * data ;
char dataBuffer [ 100 ] = "" ;
data = dataBuffer;
WSADATA wsaData ;
int recvResult ;
struct sockaddr_in service ;
size_t dataLen = strlen ( data ) ;
if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsaData ) != NO_ERROR )
connectSocket = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP );
if ( connectSocket == INVALID_SOCKET )
memset ( & service , 0 , sizeof ( service ) );
service . sin_family = AF_INET;
service . sin_addr . s_addr = inet_addr ( IP_ADDRESS );
service . sin_port = htons ( TCP_PORT );
if ( connect ( connectSocket , ( struct sockaddr * ) & service , sizeof ( service ) ) == SOCKET_ERROR )
recvResult = recv ( connectSocket , ( char * ) ( data + dataLen ) , sizeof ( char ) * ( 100 - dataLen - 1 ) , 0 );
if ( recvResult == SOCKET_ERROR || recvResult == 0 )
data [ dataLen + recvResult / sizeof ( char ) ] = '\0';
replace = strchr ( data , '\r' );
if ( replace )
* replace = '\0';
replace = strchr ( data , '\n' );
if ( replace )
* replace = '\0';
while ( 0 )
funcPtr ( data , data );
0
------------------------------
19661 CVE-2016-8658/linux_kernel_4.7.4_CVE_2016_8658_drivers_net_wireless_broadcom_brcm80211_brcmfmac_cfg80211.c parsed_info -> ie_len = vndrie -> len + TLV_HDR_LEN 4181
static
brcmf_cfg80211_start_ap(struct wiphy *wiphy, struct net_device
struct cfg80211_ap_settings *settings)
s32 ie_offset ;
struct brcmf_if * ifp = netdev_priv ( ndev ) ;
const struct brcmf_tlv * ssid_ie ;
const struct brcmf_tlv * rsn_ie ;
const struct brcmf_vs_tlv * wpa_ie ;
if ( settings -> ssid == NULL || settings -> ssid_len == 0 )
ie_offset = DOT11_MGMT_HDR_LEN + DOT11_BCN_PRB_FIXED_LEN;
ssid_ie = brcmf_parse_tlvs ( ( u8 * ) & settings -> beacon . head [ ie_offset ] , settings -> beacon . head_len - ie_offset , WLAN_EID_SSID );
if ( ! ssid_ie )
rsn_ie = brcmf_parse_tlvs ( ( u8 * ) settings -> beacon . tail , settings -> beacon . tail_len , WLAN_EID_RSN );
wpa_ie = brcmf_find_wpaie ( ( u8 * ) settings -> beacon . tail , settings -> beacon . tail_len );
if ( wpa_ie != NULL || rsn_ie != NULL )
if ( wpa_ie != NULL )
err = brcmf_configure_wpaie ( ifp , wpa_ie , false );
if ( err < 0 )
struct brcmf_vs_tlv * tmp_ie ;
tmp_ie = ( struct brcmf_vs_tlv * ) rsn_ie;
err = brcmf_configure_wpaie ( ifp , tmp_ie , true );
if ( err < 0 )
brcmf_config_ap_mgmt_ie ( ifp -> vif , & settings -> beacon );
static
brcmf_config_ap_mgmt_ie(struct brcmf_cfg80211_vif
struct cfg80211_beacon_data *beacon)
s32 err ;
err = brcmf_vif_set_mgmt_ie ( vif , BRCMF_VNDR_IE_BEACON_FLAG , beacon -> tail , beacon -> tail_len );
if ( err )
err = brcmf_vif_set_mgmt_ie ( vif , BRCMF_VNDR_IE_PRBRSP_FLAG , beacon -> proberesp_ies , beacon -> proberesp_ies_len );
s32 brcmf_vif_set_mgmt_ie(struct brcmf_cfg80211_vif *vif, s32
const u8 *vndr_ie_buf, u32 vndr_ie_len)
struct vif_saved_ie * saved_ie ;
u8 * iovar_ie_buf ;
u8 * curr_ie_buf ;
int mgmt_ie_buf_len ;
struct parsed_vndr_ies new_vndr_ies ;
if ( ! vif )
saved_ie = & vif -> saved_ie;
iovar_ie_buf = kzalloc ( WL_EXTRA_BUF_MAX , GFP_KERNEL );
if ( ! iovar_ie_buf )
curr_ie_buf = iovar_ie_buf;
switch ( pktflag )
mgmt_ie_buf_len = sizeof ( saved_ie -> probe_req_ie );
mgmt_ie_buf_len = sizeof ( saved_ie -> probe_res_ie );
mgmt_ie_buf_len = sizeof ( saved_ie -> beacon_ie );
mgmt_ie_buf_len = sizeof ( saved_ie -> assoc_req_ie );
if ( vndr_ie_len > mgmt_ie_buf_len )
if ( vndr_ie_buf && vndr_ie_len && curr_ie_buf )
brcmf_parse_vndr_ies ( vndr_ie_buf , vndr_ie_len , & new_vndr_ies );
static
brcmf_parse_vndr_ies(const u8 *vndr_ie_buf, u32
struct parsed_vndr_ies *vndr_ies)
struct brcmf_vs_tlv * vndrie ;
struct brcmf_tlv * ie ;
struct parsed_vndr_ie_info * parsed_info ;
s32 remaining_len ;
remaining_len = ( s32 ) vndr_ie_len;
memset ( vndr_ies , 0 , sizeof ( * vndr_ies ) );
ie = ( struct brcmf_tlv * ) vndr_ie_buf;
while ( ie )
if ( ie -> id != WLAN_EID_VENDOR_SPECIFIC )
vndrie = ( struct brcmf_vs_tlv * ) ie;
if ( vndrie -> len < ( VS_IE_FIXED_HDR_LEN - TLV_HDR_LEN + 1 ) )
if ( ! memcmp ( vndrie -> oui , ( u8 * ) WPA_OUI , TLV_OUI_LEN ) && ( ( vndrie -> oui_type == WPA_OUI_TYPE ) || ( vndrie -> oui_type == WME_OUI_TYPE ) ) )
parsed_info = & vndr_ies -> ie_info [ vndr_ies -> count ];
parsed_info -> ie_ptr = ( char * ) vndrie;
parsed_info -> ie_len = vndrie -> len + TLV_HDR_LEN;
memcpy ( & parsed_info -> vndrie , vndrie , sizeof ( * vndrie ) );
vndr_ies -> count ++;
brcmf_dbg ( TRACE , "** OUI %02x %02x %02x, type 0x%02x\n" , parsed_info -> vndrie . oui [ 0 ] , parsed_info -> vndrie . oui [ 1 ] , parsed_info -> vndrie . oui [ 2 ] , parsed_info -> vndrie . oui_type );
if ( vndr_ies -> count >= VNDR_IE_PARSE_LIMIT )
remaining_len -= ( ie -> len + TLV_HDR_LEN );
if ( remaining_len <= TLV_HDR_LEN )
ie = NULL;
ie = ( struct brcmf_tlv * ) ( ( ( u8 * ) ie ) + ie -> len + TLV_HDR_LEN );
1
------------------------------
310763 151097/aviobuf.c s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_ptr - s -> checksum_ptr ) ) ) 164
int avio_put_str16le(AVIOContext *s,const char *str)
const uint8_t * q = str ;
while ( * q )
uint32_t ch ;
uint16_t tmp ;
ch = ( * ( q ++ ) );
uint32_t top = ( ch & 128 ) >> 1 ;
if ( ( ch & 0xc0 ) == 0x80 )
while ( ch & top )
int tmp = ( * ( q ++ ) ) - 128 ;
if ( tmp >> 6 )
ch = ( ch << 6 ) + tmp;
top <<= 5;
ch &= ( top << 1 ) - 1;
uint32_t in = ch ;
if ( in < 0x10000 )
tmp = ( 0xD800 | in - 0x10000 >> 10 );
avio_wl16 ( s , tmp );
void avio_wl16(AVIOContext *s,unsigned int val)
avio_w8 ( s , ( ( uint8_t ) val ) );
void avio_w8(AVIOContext *s,int b)
* ( s -> buf_ptr ++ ) = b;
if ( s -> buf_ptr >= s -> buf_end )
flush_buffer ( s );
static void flush_buffer(AVIOContext *s)
if ( s -> buf_ptr > s -> buffer )
if ( s -> update_checksum )
s -> checksum = ( ( s -> update_checksum ) ( s -> checksum , ( s -> checksum_ptr ) , ( s -> buf_ptr - s -> checksum_ptr ) ) );
s -> checksum_ptr = s -> buffer;
s -> buf_ptr = s -> buffer;
0
------------------------------